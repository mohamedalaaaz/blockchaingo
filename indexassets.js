function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["assets/AccountSettingsModalContent-CnhZp-9U.js", "assets/assets/vendor.js-DHDwnJDe.js", "assets/assets/vendor-D221JFGu.css", "assets/assets/json-bundle.js-Q9als3UY.js", "assets/assets/svg.js-CCgjGHdO.js", "assets/PortfolioPageContent-Dx_ktPlj.js", "assets/DecorativeGradientLine-DS3DfRaJ.js", "assets/RewardsPageContent-Caflerbq.js"]
    }
    return indexes.map( (i) => __vite__mapDeps.viteFileDeps[i])
}
var e = Object.defineProperty
  , t = (t, n, r) => (( (t, n, r) => {
    n in t ? e(t, n, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[n] = r
}
)(t, "symbol" != typeof n ? n + "" : n, r),
r);
!function() {
    try {
        var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
          , t = (new Error).stack;
        t && (e._sentryDebugIds = e._sentryDebugIds || {},
        e._sentryDebugIds[t] = "f5463fc8-f249-480c-b4e5-c79e11e4129a",
        e._sentryDebugIdIdentifier = "sentry-dbid-f5463fc8-f249-480c-b4e5-c79e11e4129a")
    } catch (n) {}
}();
import {i as n, B as r, a, b as s, c as o, _ as l, d as i, l as c, f as d, e as u, k as p, v as h, g as m, h as g, j as x, s as b, m as f, n as v, S, r as y, T as k, o as C, p as A, q as w, t as j, u as T, w as I, R as E, x as M, y as N, z as P, A as O, C as L, D as R, E as D, F as B, G as _, H as U, I as W, J as F, K as V, L as H, M as z, N as $, O as G, P as q, Q as K, U as Y, V as X, W as Q, X as Z, Y as J, Z as ee, $ as te, a0 as ne, a1 as re, a2 as ae, a3 as se, a4 as oe, a5 as le, a6 as ie, a7 as ce, a8 as de, a9 as ue, aa as pe, ab as he, ac as me, ad as ge, ae as xe, af as be, ag as fe, ah as ve, ai as Se, aj as ye, ak as ke, al as Ce, am as Ae, an as we, ao as je, ap as Te, aq as Ie, ar as Ee, as as Me, at as Ne, au as Pe, av as Oe, aw as Le, ax as Re, ay as De, az as Be, aA as _e, aB as Ue, aC as We, aD as Fe, aE as Ve, aF as He, aG as ze, aH as $e, aI as Ge, aJ as qe, aK as Ke, aL as Ye, aM as Xe, aN as Qe, aO as Ze, aP as Je, aQ as et, aR as tt, aS as nt, aT as rt, aU as at, aV as st, aW as ot, aX as lt, aY as it, aZ as ct, a_ as dt, a$ as ut, b0 as pt, b1 as ht, b2 as mt, b3 as gt, b4 as xt, b5 as bt, b6 as ft, b7 as vt, b8 as St, b9 as yt, ba as kt, bb as Ct, bc as At, bd as wt, be as jt, bf as Tt, bg as It, bh as Et, bi as Mt, bj as Nt, bk as Pt, bl as Ot, bm as Lt, bn as Rt, bo as Dt, bp as Bt, bq as _t, br as Ut, bs as Wt, bt as Ft, bu as Vt, bv as Ht, bw as zt, bx as $t, by as Gt, bz as qt, bA as Kt, bB as Yt, bC as Xt, bD as Qt, bE as Zt, bF as Jt, bG as en, bH as tn, bI as nn, bJ as rn, bK as an, bL as sn, bM as on, bN as ln, bO as cn, bP as dn, bQ as un, bR as pn, bS as hn, bT as mn, bU as gn, bV as xn, bW as bn, bX as fn, bY as vn, bZ as Sn, b_ as yn, b$ as kn, c0 as Cn, c1 as An, c2 as wn, c3 as jn, c4 as Tn, c5 as In, c6 as En, c7 as Mn, c8 as Nn, c9 as Pn, ca as On, cb as Ln, cc as Rn, cd as Dn, ce as Bn, cf as _n, cg as Un, ch as Wn, ci as Fn, cj as Vn, ck as Hn, cl as zn, cm as $n, cn as Gn, co as qn, cp as Kn, cq as Yn, cr as Xn, cs as Qn, ct as Zn, cu as Jn, cv as er, cw as tr, cx as nr, cy as rr, cz as ar, cA as sr, cB as or, cC as lr, cD as ir, cE as cr, cF as dr, cG as ur, cH as pr, cI as hr, cJ as mr, cK as gr, cL as xr, cM as br, cN as fr, cO as vr, cP as Sr, cQ as yr, cR as kr, cS as Cr, cT as Ar, cU as wr, cV as jr, cW as Tr} from "./assets/vendor.js-DHDwnJDe.js";
import {p as Ir, d as Er} from "./assets/json-bundle.js-Q9als3UY.js";
import {S as Mr, a as Nr, b as Pr, c as Or, d as Lr, e as Rr, f as Dr, g as Br, h as _r, i as Ur, j as Wr, k as Fr, l as Vr, m as Hr, n as zr, o as $r, p as Gr, q as qr, r as Kr, s as Yr, t as Xr, u as Qr, v as Zr, w as Jr, x as ea, y as ta, z as na, A as ra, B as aa, C as sa, D as oa, E as la, F as ia, G as ca, H as da, I as ua, J as pa, K as ha, L as ma, M as ga, N as xa, O as ba, P as fa, Q as va, R as Sa, T as ya, U as ka, V as Ca, W as Aa, X as wa, Y as ja, Z as Ta, _ as Ia, $ as Ea, a0 as Ma, a1 as Na, a2 as Pa, a3 as Oa, a4 as La, a5 as Ra, a6 as Da, a7 as Ba, a8 as _a, a9 as Ua, aa as Wa, ab as Fa, ac as Va, ad as Ha, ae as za, af as $a, ag as Ga, ah as qa, ai as Ka, aj as Ya, ak as Xa, al as Qa, am as Za, an as Ja, ao as es, ap as ts, aq as ns, ar as rs, as, at as ss, au as os, av as ls, aw as is, ax as cs, ay as ds, az as us, aA as ps, aB as hs, aC as ms, aD as gs, aE as xs, aF as bs, aG as fs, aH as vs, aI as Ss, aJ as ys, aK as ks, aL as Cs, aM as As, aN as ws, aO as js, aP as Ts, aQ as Is, aR as Es, aS as Ms, aT as Ns, aU as Ps, aV as Os, aW as Ls, aX as Rs, aY as Ds, aZ as Bs, a_ as _s, a$ as Us, b0 as Ws, b1 as Fs, b2 as Vs, b3 as Hs, b4 as zs, b5 as $s, b6 as Gs, b7 as qs, b8 as Ks, b9 as Ys, ba as Xs, bb as Qs, bc as Zs, bd as Js, be as eo, bf as to, bg as no, bh as ro, bi as ao, bj as so, bk as oo, bl as lo, bm as io, bn as co, bo as uo, bp as po, bq as ho, br as mo, bs as go, bt as xo, bu as bo, bv as fo, bw as vo, bx as So, by as yo, bz as ko, bA as Co, bB as Ao, bC as wo, bD as jo, bE as To, bF as Io, bG as Eo, bH as Mo, bI as No, bJ as Po, bK as Oo, bL as Lo, bM as Ro, bN as Do, bO as Bo, bP as _o, bQ as Uo, bR as Wo, bS as Fo, bT as Vo, bU as Ho, bV as zo, bW as $o, bX as Go, bY as qo, bZ as Ko, b_ as Yo, b$ as Xo, c0 as Qo, c1 as Zo, c2 as Jo, c3 as el, c4 as tl, c5 as nl, c6 as rl, c7 as al, c8 as sl, c9 as ol, ca as ll, cb as il, cc as cl, cd as dl, ce as ul, cf as pl, cg as hl, ch as ml, ci as gl, cj as xl, ck as bl, cl as fl, cm as vl, cn as Sl, co as yl, cp as kl, cq as Cl, cr as Al, cs as wl, ct as jl, cu as Tl, cv as Il, cw as El, cx as Ml, cy as Nl, cz as Pl, cA as Ol, cB as Ll, cC as Rl, cD as Dl, cE as Bl, cF as _l, cG as Ul, cH as Wl, cI as Fl, cJ as Vl, cK as Hl, cL as zl, cM as $l, cN as Gl, cO as ql, cP as Kl, cQ as Yl, cR as Xl, cS as Ql, cT as Zl, cU as Jl, cV as ei, cW as ti, cX as ni, cY as ri, cZ as ai, c_ as si, c$ as oi, d0 as li, d1 as ii, d2 as ci, d3 as di, d4 as ui, d5 as pi, d6 as hi, d7 as mi, d8 as gi, d9 as xi, da as bi, db as fi, dc as vi, dd as Si, de as yi, df as ki, dg as Ci, dh as Ai, di as wi, dj as ji, dk as Ti, dl as Ii, dm as Ei, dn as Mi, dp as Ni, dq as Pi, dr as Oi, ds as Li, dt as Ri, du as Di, dv as Bi, dw as _i, dx as Ui, dy as Wi, dz as Fi, dA as Vi, dB as Hi, dC as zi, dD as $i, dE as Gi, dF as qi, dG as Ki, dH as Yi} from "./assets/svg.js-CCgjGHdO.js";
!function() {
    const e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
            t(e);
        new MutationObserver((e => {
            for (const n of e)
                if ("childList" === n.type)
                    for (const e of n.addedNodes)
                        "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
        }
        )).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function t(e) {
        if (e.ep)
            return;
        e.ep = !0;
        const t = function(e) {
            const t = {};
            return e.integrity && (t.integrity = e.integrity),
            e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
            "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin",
            t
        }(e);
        fetch(e.href, t)
    }
}();
var Xi = (e => (e[e.GOING_AWAY = 1001] = "GOING_AWAY",
e[e.INVALID_ARGUMENT = 1002] = "INVALID_ARGUMENT",
e[e.CLOSED_ON_REQUEST = 1005] = "CLOSED_ON_REQUEST",
e[e.NETWORK_DISCONNECT = 1006] = "NETWORK_DISCONNECT",
e[e.NOT_AUTHORIZED = 1008] = "NOT_AUTHORIZED",
e[e.INTERNAL_ERROR = 1011] = "INTERNAL_ERROR",
e))(Xi || {});
function Qi(e) {
    return !e.path.startsWith("ws ")
}
function Zi(e) {
    return "httpBody" === e
}
const Ji = e => ({
    name: e,
    converter: e => e ? Number(e) : null
})
  , ec = (e, t) => {
    let n = {
        unsubscribe: () => {}
    }
      , r = 0
      , a = !1;
    const s = () => {
        if (a)
            return void e.close(Xi.CLOSED_ON_REQUEST);
        const o = r;
        n = t({
            onMessage: e.onMessage,
            close: t => {
                o === r && (r += 1,
                t === Xi.NETWORK_DISCONNECT ? setTimeout(s, 1e3) : e.close(t))
            }
        })
    }
    ;
    return s(),
    {
        unsubscribe: () => {
            a = !0,
            n.unsubscribe()
        }
    }
}
  , tc = () => ({
    unsubscribe: () => {}
});
var nc = (e => (e.GREATER = "greater",
e.LOWER = "lower",
e))(nc || {})
  , rc = (e => (e.MARKET = "MARKET",
e.STOP = "STOP",
e.TRAILING_STOP = "TRAILING_STOP",
e.DEV_SOLD = "DEV_SOLD",
e))(rc || {});
function ac(e) {
    return "MARKET" === e.type
}
var sc = (e => (e.WAITING = "WAITING",
e.EXECUTING = "EXECUTING",
e.FILLED = "FILLED",
e.EXECUTION_FAILED = "EXECUTION_FAILED",
e.CANCELED = "CANCELED",
e))(sc || {});
const oc = {
    subscribeTrailingPrices: {
        path: "ws /users/:uid/chain/:chain/base-currency/:baseCurrency/subscribe-trailing-prices",
        params: [":uid", ":chain", ":baseCurrency", "?walletAddress"]
    },
    subscribeOrdersSmart: {
        path: "ws /users/:uid/query-type/:queryType/subscribe-orders-smart",
        params: [":uid", ":queryType", "?walletAddress", "?chain", "?baseCurrency", "?quoteCurrency"]
    },
    createOrder: {
        path: "POST /users/:uid/chains/:chain/wallets/:walletAddress/create",
        params: [":uid", ":chain", ":walletAddress", "httpBody"],
        auth: {
            session: !0
        }
    },
    subscribeOrders: {
        path: "ws /users/:uid/subscribe-orders",
        params: [":uid", "?baseCurrency", "?quoteCurrency", Ji("?limit")]
    },
    subscribeOrdersV2: {
        path: "ws /users/:uid/subscribe-orders-v2",
        params: [":uid", "?baseCurrency", "?quoteCurrency", "?walletAddress", "?skipCancelled", Ji("?limit")]
    },
    subscribeSlimOrderStatus: {
        path: "ws /orders/:orderId/subscribe-slim-status",
        params: [":orderId"]
    },
    subscribeOrder: {
        path: "ws /orders/:orderId/subscribe-order",
        params: [":orderId"]
    },
    getOrderDetails: {
        path: "GET /orders/:orderId/details",
        params: [":orderId"]
    },
    getOrderStateHistory: {
        path: "GET /state/orders/:orderId/history",
        params: [":orderId"]
    },
    cancelOrder: {
        path: "POST /state/orders/:orderId/cancel",
        params: [":orderId"]
    },
    getSlimOrderStatus: {
        path: "GET /orders/:orderId/slim-status",
        params: [":orderId"]
    },
    warmUpCache: {
        path: "POST /orders/warm-up-cache",
        params: ["httpBody"]
    }
};
n.use(r).use(a).use(s).init({
    debug: !1,
    fallbackLng: "en",
    supportedLngs: ["en", "es", "zh", "id", "pt", "ja"],
    ns: ["common"],
    defaultNS: "common",
    interpolation: {
        escapeValue: !1
    },
    detection: {
        order: ["path", "querystring", "localStorage", "navigator"]
    },
    backend: {
        loadPath: "/locales/{{lng}}/{{ns}}.json"
    }
}).catch((e => {
    o(e)
}
));
const lc = async e => {
    try {
        const t = {
            zh: "zh-cn",
            ja: "ja",
            es: "es",
            pt: "pt",
            id: "id",
            en: "en"
        }[e] ?? "en";
        "en" !== t && await l(( () => import(`dayjs/locale/${t}`)), __vite__mapDeps([])),
        i.locale(t)
    } catch (fNe) {
        o(fNe)
    }
}
;
lc(n.resolvedLanguage || n.language || "en").catch((e => {
    o(e)
}
)),
n.on("languageChanged", (e => {
    lc(e)
}
));
var ic = (e => (e.MARKET_BUY = "MARKET_BUY",
e.MARKET_SELL = "MARKET_SELL",
e.STOP_LOSS = "STOP_LOSS",
e.TAKE_PROFIT = "TAKE_PROFIT",
e.BUY_DIP = "BUY_DIP",
e.TRAILING_STOP_LOSS = "TRAILING_STOP_LOSS",
e.DEV_SELL_BUY = "DEV_SELL_BUY",
e.DEV_SELL_SELL = "DEV_SELL_SELL",
e))(ic || {});
const cc = ["MARKET_BUY", "MARKET_SELL", "STOP_LOSS", "TAKE_PROFIT", "BUY_DIP", "TRAILING_STOP_LOSS", "DEV_SELL_BUY", "DEV_SELL_SELL"]
  , dc = {
    MARKET_BUY: "Market",
    MARKET_SELL: "Market",
    STOP_LOSS: "Stop Loss",
    TAKE_PROFIT: "Take Profit",
    BUY_DIP: "Dip",
    TRAILING_STOP_LOSS: "Trailing Stop Loss",
    DEV_SELL_BUY: "Dev sell",
    DEV_SELL_SELL: "Dev sell"
}
  , uc = ["MARKET_BUY", "BUY_DIP"];
var pc = (e => (e.ETH = "ETH",
e.SOL = "SOL",
e))(pc || {})
  , hc = (e => (e.INVALID_NAME = "INVALID_NAME",
e.ALREADY_IMPORTED = "ALREADY_IMPORTED",
e.UNKNOWN = "UNKNOWN",
e))(hc || {});
const mc = [pc.ETH, pc.SOL]
  , gc = e => {
    switch (e) {
    case pc.ETH:
        return 4;
    case pc.SOL:
        return 30
    }
}
;
var xc = (e => (e.BUY = "BUY",
e.SELL = "SELL",
e))(xc || {})
  , bc = (e => (e.BASE = "base",
e.QUOTE = "quote",
e))(bc || {});
const fc = e => "string" == typeof e;
var vc = (e => (e[e.SOLANA_SPL = 1] = "SOLANA_SPL",
e[e.SOLANA_SPL_2022 = 2] = "SOLANA_SPL_2022",
e[e.EVM_ERC20 = 3] = "EVM_ERC20",
e))(vc || {})
  , Sc = (e => (e[e.PHOTON = 0] = "PHOTON",
e[e.BULLX = 1] = "BULLX",
e[e.GMGN = 2] = "GMGN",
e[e.BANANA = 3] = "BANANA",
e[e.MAESTRO = 4] = "MAESTRO",
e[e.BONK = 5] = "BONK",
e[e.SOL_TRADING_BOT = 6] = "SOL_TRADING_BOT",
e[e.PEPEBOOST = 7] = "PEPEBOOST",
e[e.PADRE = 8] = "PADRE",
e[e.TROJAN = 9] = "TROJAN",
e[e.AXIOM = 10] = "AXIOM",
e[e.NOVA = 11] = "NOVA",
e[e.MEVX = 12] = "MEVX",
e[e.VECTOR_FUN = 13] = "VECTOR_FUN",
e[e.DEXCELERATE = 14] = "DEXCELERATE",
e[e.BLOOM = 15] = "BLOOM",
e[e.CIPHER = 16] = "CIPHER",
e[e.TRADE_WIZ = 17] = "TRADE_WIZ",
e[e.FASOL = 18] = "FASOL",
e[e.PHANTOM = 19] = "PHANTOM",
e[e.AQUABOT = 20] = "AQUABOT",
e[e.MONKEY_KING = 21] = "MONKEY_KING",
e[e.FOMO = 22] = "FOMO",
e))(Sc || {});
const yc = [bc.BASE, bc.QUOTE]
  , kc = new Map([[bc.BASE, "amount"], [bc.QUOTE, "total"]])
  , Cc = (e, t, n) => {
    switch (e) {
    case rc.MARKET:
        return t === xc.BUY ? ic.MARKET_BUY : ic.MARKET_SELL;
    case rc.STOP:
        return t === xc.BUY ? n === nc.LOWER ? ic.BUY_DIP : null : n === nc.LOWER ? ic.STOP_LOSS : ic.TAKE_PROFIT;
    case rc.TRAILING_STOP:
        return ic.TRAILING_STOP_LOSS;
    case rc.DEV_SOLD:
        return t === xc.BUY ? ic.DEV_SELL_BUY : ic.DEV_SELL_SELL;
    default:
        throw new Error(`Unsupported order type type: ${e}`)
    }
}
  , Ac = e => {
    switch (e) {
    case ic.MARKET_BUY:
    case ic.MARKET_SELL:
        return rc.MARKET;
    case ic.BUY_DIP:
    case ic.TAKE_PROFIT:
    case ic.STOP_LOSS:
        return rc.STOP;
    case ic.TRAILING_STOP_LOSS:
        return rc.TRAILING_STOP;
    case ic.DEV_SELL_BUY:
    case ic.DEV_SELL_SELL:
        return rc.DEV_SOLD;
    default:
        throw new Error(`Unsupported order specific type: ${e}`)
    }
}
  , wc = e => {
    switch (e) {
    case ic.MARKET_BUY:
    case ic.MARKET_SELL:
    case ic.DEV_SELL_BUY:
    case ic.DEV_SELL_SELL:
    case ic.TRAILING_STOP_LOSS:
        return null;
    case ic.STOP_LOSS:
    case ic.BUY_DIP:
        return nc.LOWER;
    case ic.TAKE_PROFIT:
        return nc.GREATER;
    default:
        throw new Error(`Unsupported order specific type: ${e}`)
    }
}
  , jc = e => {
    switch (e) {
    case ic.MARKET_BUY:
    case ic.BUY_DIP:
    case ic.DEV_SELL_BUY:
        return xc.BUY;
    case ic.MARKET_SELL:
    case ic.STOP_LOSS:
    case ic.TAKE_PROFIT:
    case ic.TRAILING_STOP_LOSS:
    case ic.DEV_SELL_SELL:
        return xc.SELL;
    default:
        throw new Error(`Unsupported order specific type: ${e}`)
    }
}
  , Tc = e => {
    switch (e) {
    case ic.MARKET_BUY:
    case ic.BUY_DIP:
    case ic.DEV_SELL_BUY:
        return bc.QUOTE;
    case ic.MARKET_SELL:
    case ic.STOP_LOSS:
    case ic.TAKE_PROFIT:
    case ic.TRAILING_STOP_LOSS:
    case ic.DEV_SELL_SELL:
        return bc.BASE;
    default:
        throw new Error(`Unsupported order specific type: ${e}`)
    }
}
  , Ic = (e, t=!1) => {
    switch (e) {
    case ic.MARKET_BUY:
        return "Market" + (t ? "" : " Buy");
    case ic.MARKET_SELL:
        return "Market" + (t ? "" : " Sell");
    case ic.STOP_LOSS:
        return "Stop Loss";
    case ic.TAKE_PROFIT:
        return "Take Profit";
    case ic.BUY_DIP:
        return "Buy Dip";
    case ic.TRAILING_STOP_LOSS:
        return "Trailing " + (t ? "SL" : "Stop Loss");
    case ic.DEV_SELL_BUY:
    case ic.DEV_SELL_SELL:
        return "Dev sell";
    default:
        throw new Error(`Unsupported order specific type: ${e}`)
    }
}
;
function Ec(e) {
    return null === e ? null : Nc.test(e) ? e.toLowerCase() : e
}
function Mc(e) {
    return e
}
const Nc = /^0x[a-fA-F0-9]{40}$/
  , Pc = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/
  , Oc = e => Pc.test(e);
var Lc = (e => (e.UNISWAP_V2 = "UNISWAP_V2",
e.UNISWAP_V3 = "UNISWAP_V3",
e.PANCAKE_V3 = "PANCAKE_V3",
e.AERODROME_V2 = "AERODROME_V2",
e.AERODROME_V3 = "AERODROME_V3",
e.VISTA = "VISTA",
e.FOUR_MEME = "FOUR_MEME",
e))(Lc || {})
  , Rc = (e => (e.RAYDIUM = "RAYDIUM",
e.RAYDIUM_CLMM = "RAYDIUM_CLMM",
e.RAYDIUM_CP = "RAYDIUM_CP",
e.WHIRLPOOL = "WHIRLPOOL",
e.METEORA_OLD = "METEORA_OLD",
e.METEORA_DLMM = "METEORA_DLMM",
e.PUMP_FUN = "PUMP_FUN",
e.PUMP_SWAP = "PUMP_SWAP",
e.LAUNCH_LAB = "LAUNCH_LAB",
e.BOOP = "BOOP",
e.METEORA_CURVE = "METEORA_CURVE",
e.METEORA_DAMM_V2 = "METEORA_DAMM_V2",
e.MOONIT = "MOONIT",
e.HEAVEN = "HEAVEN",
e.TOKEN_MILL = "TOKEN_MILL",
e.SUGAR = "SUGAR",
e.SUGAR_TEST = "SUGAR_TEST",
e))(Rc || {});
const Dc = {
    UNISWAP_V2: !0,
    UNISWAP_V3: !0,
    PANCAKE_V3: !0,
    AERODROME_V2: !0,
    AERODROME_V3: !0,
    VISTA: !0,
    FOUR_MEME: !0
}
  , Bc = {
    RAYDIUM: !0,
    RAYDIUM_CLMM: !0,
    RAYDIUM_CP: !0,
    WHIRLPOOL: !0,
    METEORA_DLMM: !0,
    METEORA_OLD: !0,
    PUMP_FUN: !0,
    PUMP_SWAP: !0,
    LAUNCH_LAB: !0,
    BOOP: !0,
    METEORA_CURVE: !0,
    METEORA_DAMM_V2: !0,
    MOONIT: !0,
    HEAVEN: !0,
    TOKEN_MILL: !0,
    SUGAR: !0,
    SUGAR_TEST: !1
};
var _c = (e => (e[e.CONSTANT = 0] = "CONSTANT",
e[e.FIXED = 1] = "FIXED",
e[e.LINEAR = 2] = "LINEAR",
e))(_c || {})
  , Uc = (e => (e[e.LINEAR_V1 = 0] = "LINEAR_V1",
e[e.CONSTANT_PRODUCT_V1 = 1] = "CONSTANT_PRODUCT_V1",
e[e.CONSTANT_PRODUCT_V2 = 2] = "CONSTANT_PRODUCT_V2",
e[e.FLAT_CURVE_V1 = 3] = "FLAT_CURVE_V1",
e[e.FLAT_CURVE_V1_ANTI_SNIPE = 4] = "FLAT_CURVE_V1_ANTI_SNIPE",
e))(Uc || {});
const Wc = {
    [Rc.RAYDIUM]: 1,
    [Rc.RAYDIUM_CP]: 1,
    [Rc.METEORA_OLD]: 1,
    [Rc.PUMP_FUN]: 1,
    [Rc.PUMP_SWAP]: 1,
    [Rc.BOOP]: 1,
    [Rc.LAUNCH_LAB]: 1,
    [Rc.MOONIT]: 1,
    [Rc.HEAVEN]: 1,
    [Rc.SUGAR]: 1,
    [Rc.SUGAR_TEST]: 1
};
var Fc = (e => (e.NEXTBLOCK_DO_NOT_USE = "NEXTBLOCK",
e.TEMPORAL = "TEMPORAL",
e.ZERO_SLOT = "ZERO_SLOT",
e.JITO = "JITO",
e.AUGUR = "AUGUR",
e.CUSTOM_RPC = "CUSTOM_RPC",
e))(Fc || {});
const Vc = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
  , Hc = "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d"
  , zc = "0x55d398326f99059ff775485246999027b3197955"
  , $c = "0x8d0d000ee44948fc98c9b98a4fa4921476f08b0d"
  , Gc = "11111111111111111111111111111111"
  , qc = "So11111111111111111111111111111111111111112"
  , Kc = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  , Yc = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
  , Xc = "USD1ttGY1N17NEEHLmELoaybftRBUSErhqYiQzvEmuB"
  , Qc = "ComputeBudget111111111111111111111111111111"
  , Zc = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
  , Jc = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
  , ed = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
  , td = "SysvarRent111111111111111111111111111111111"
  , nd = "term9YPb9mzAsABaqN71A4xdbxHmpBNZavpBiQKZzN3"
  , rd = "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"
  , ad = "FJsZbftBqRLfF7uqUKpm4s2goDr6xsQ5Q3mN7AFJB6hK"
  , sd = "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"
  , od = "pfeeUxB6jkeY1Hxd7CsFCAjcbHA9rWtchMGdZ6VojVZ"
  , ld = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
  , id = "CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"
  , cd = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"
  , dd = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
  , ud = "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1"
  , pd = "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
  , hd = "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG"
  , md = "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"
  , gd = "boop8hVGQGqehUK2iVEMEnMrL5RbjywRzHKBmBE7ry4"
  , xd = "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN"
  , bd = "CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"
  , fd = "LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"
  , vd = "MoonCVVNZFSYkqNXP6bxHLPL6QQJiMagDL3qcqUQTrG"
  , Sd = "HEAVENoP2qxoeuF8Dj2oT1GHEnu49U5mJYkdeC8BAX2o"
  , yd = "JoeGXemoPqPeGPEXA3Z3UbjoPoGqqfbg8PD58M7Rqj2"
  , kd = "2pbhpVLBKvqKXNbV6V2cvYME1dE9KCb39jZczsZnoTfu"
  , Cd = "deus4Bvftd5QKcEkE5muQaWGWDoma8GrySvPFrBPjhS"
  , Ad = ["NextbLoCkVtMGcV47JzewQdvBpLqT9TxQFozQkN98pE", "NexTbLoCkWykbLuB1NkjXgFWkX9oAtcoagQegygXXA2", "NeXTBLoCKs9F1y5PJS9CKrFNNLU1keHW71rfh7KgA1X", "NexTBLockJYZ7QD7p2byrUa6df8ndV2WSd8GkbWqfbb", "neXtBLock1LeC67jYd1QdAa32kbVeubsfPNTJC1V5At", "nEXTBLockYgngeRmRrjDV31mGSekVPqZoMGhQEZtPVG", "NEXTbLoCkB51HpLBLojQfpyVAMorm3zzKg7w9NFdqid", "nextBLoCkPMgmG8ZgJtABeScP35qLa2AMCNKntAP7Xc"].map((e => e))
  , wd = ["TEMPaMeCRFAS9EKF53Jd6KpHxgL47uWLcpFArU1Fanq", "noz3jAjPiHuBPqiSPkkugaJDkJscPuRhYnSpbi8UvC4", "noz3str9KXfpKknefHji8L1mPgimezaiUyCHYMDv1GE", "noz6uoYCDijhu1V7cutCpwxNiSovEwLdRHPwmgCGDNo", "noz9EPNcT7WH6Sou3sr3GGjHQYVkN3DNirpbvDkv9YJ", "nozc5yT15LazbLTFVZzoNZCwjh3yUtW86LoUyqsBu4L", "nozFrhfnNGoyqwVuwPAW4aaGqempx4PU6g6D9CJMv7Z", "nozievPk7HyK1Rqy1MPJwVQ7qQg2QoJGyP71oeDwbsu", "noznbgwYnBLDHu8wcQVCEw6kDrXkPdKkydGJGNXGvL7", "nozNVWs5N8mgzuD3qigrCG2UoKxZttxzZ85pvAQVrbP", "nozpEGbwx4BcGp6pvEdAh1JoC2CQGZdU6HbNP1v2p6P", "nozrhjhkCr3zXT3BiT4WCodYCUFeQvcdUkM7MqhKqge", "nozrwQtWhEdrA6W8dkbt9gnUaMs52PdAv5byipnadq3", "nozUacTVWub3cL4mJmGCYjKZTnE9RbdY5AP46iQgbPJ", "nozWCyTPppJjRuw2fpzDhhWbW355fzosWSzrrMYB1Qk", "nozWNju6dY353eMkMqURqwQEoM3SFgEKC6psLCSfUne", "nozxNBgWohjR75vdspfxR5H9ceC7XXH99xpxhVGt3Bb"].map((e => e))
  , jd = ["4HiwLEP2Bzqj3hM2ENxJuzhcPCdsafwiet3oGkMkuQY4", "7toBU3inhmrARGngC7z6SjyP85HgGMmCTEwGNRAcYnEK", "8mR3wB1nh4D6J9RUCugxUpc6ya8w38LPxZ3ZjcBhgzws", "6SiVU5WEwqfFapRuYCndomztEwDjvS5xgtEof3PLEGm9", "TpdxgNJBWZRL8UXF5mrEsyWxDWx9HQexA9P1eTWQ42p", "D8f3WkQu6dCF33cZxuAsrKHrGsqGP2yvAHf8mX6RXnwf", "GQPFicsy3P3NXxB5piJohoxACqTvWE9fKpLgdsMduoHE", "Ey2JEr8hDkgN8qKJGrLf2yFjRhW7rab99HVxwi5rcvJE", "4iUgjMT8q2hNZnLuhpqZ1QtiV8deFPy2ajvvjEpKKgsS", "3Rz8uD83QsU8wKvZbgWAPvCNDU6Fy8TSZTMcPm3RB6zt"].map((e => e))
  , Td = ["96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5", "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe", "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY", "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49", "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh", "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt", "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL", "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT"].map((e => e))
  , Id = ["52RdBhQRd2QNUJ8uNCXnAZF2ndpLZNXRuDcUxD7mAdPX"].map((e => e))
  , Ed = {
    [Fc.TEMPORAL]: 1000000n,
    [Fc.ZERO_SLOT]: 100000n,
    [Fc.JITO]: 1000n,
    [Fc.NEXTBLOCK_DO_NOT_USE]: 2n ** 256n,
    [Fc.AUGUR]: 0n
}
  , Md = {
    poolAddr: "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
    protocolType: Rc.RAYDIUM,
    token0: qc,
    token1: Kc,
    token0Vault: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz",
    token1Vault: "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz",
    lpMint: null
};
Rc.RAYDIUM,
Rc.RAYDIUM_CP,
Rc.RAYDIUM_CLMM,
Rc.METEORA_OLD,
Rc.METEORA_DLMM,
Rc.PUMP_FUN,
Rc.PUMP_SWAP,
Rc.WHIRLPOOL,
Rc.LAUNCH_LAB,
Rc.BOOP,
Rc.METEORA_CURVE,
Rc.METEORA_DAMM_V2,
Rc.MOONIT,
Rc.HEAVEN,
Rc.TOKEN_MILL,
Rc.SUGAR,
Rc.SUGAR_TEST;
var Nd = (e => (e.USDC = "USDC",
e.USDT = "USDT",
e.DAI = "DAI",
e.ETH = "ETH",
e.SOL = "SOL",
e.BNB = "BNB",
e.ARB = "ARB",
e.MATIC = "MATIC",
e.USD1 = "USD1",
e))(Nd || {});
var Pd = (e => (e.BSC = "BSC",
e.ETH_MAINNET = "ETH_MAINNET",
e.ETH_SEPOLIA = "ETH_SEPOLIA",
e.BASE = "BASE",
e.ARBITRUM = "ARBITRUM",
e.ARBITRUM_SEPOLIA = "ARBITRUM_SEPOLIA",
e.SOLANA = "SOLANA",
e))(Pd || {});
const Od = [Pd.SOLANA]
  , Ld = [Pd.BSC]
  , Rd = [Pd.ETH_MAINNET, Pd.ETH_SEPOLIA, Pd.BASE, Pd.BSC, Pd.SOLANA]
  , Dd = [Pd.ETH_MAINNET, Pd.SOLANA, Pd.BSC]
  , Bd = [Pd.SOLANA]
  , _d = [Pd.SOLANA]
  , Ud = "-"
  , Wd = "0x0000000000000000000000000000000000000000"
  , Fd = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
  , Vd = "0x000000000000000000000000000000000000dead"
  , Hd = "BofA2ViUSudPBTUms2KRuG6AHNeMawjNfwqTJDgx5BKW"
  , zd = "0xafb979d9afad1ad27c5eff4e27226e3ab9e5dcc9"
  , $d = "GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"
  , Gd = "GVVUi6DaocSEAp8ATnXFAPNF5irCWjCvmPCzoaGAf5eJ"
  , qd = "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
  , Kd = "WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"
  , Yd = "42mepa9xLCtuerAEnnDY43KLRN5dgkrkKvoCT6nDZsyj"
  , Xd = "KpXrCt3pjJYFind2kgk7nQ3dS6bqjC2Ze3zzE5MQ78v"
  , Qd = "0xa82685520c463a752d5319e6616e4e5fd0215e33"
  , Zd = [...[Wd, Gc], qc]
  , Jd = e => {
    return (t = e.toLowerCase()) ? t.replace(/^\w/, (e => e.toUpperCase())) : "";
    var t
}
  , eu = {
    [Pd.ETH_MAINNET]: {
        [Wd]: Nd.ETH,
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2": Nd.ETH,
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48": Nd.USDC,
        "0xdac17f958d2ee523a2206206994597c13d831ec7": Nd.USDT
    },
    [Pd.ARBITRUM]: {
        [Wd]: Nd.ETH,
        "0x82af49447d8a07e3bd95bd0d56f35241523fbab1": Nd.ETH,
        "0xaf88d065e77c8cc2239327c5edb3a432268e5831": Nd.USDC,
        "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9": Nd.USDT
    },
    [Pd.ETH_SEPOLIA]: {
        [Wd]: Nd.ETH,
        "0xfff9976782d46cc05630d1f6ebab18b2324d6b14": Nd.ETH,
        "0x1c7d4b196cb0c7b01d743fbc6116a902379c7238": Nd.USDC
    },
    [Pd.BASE]: {
        [Wd]: Nd.ETH,
        "0x4200000000000000000000000000000000000006": Nd.ETH,
        "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913": Nd.USDC,
        "0x50c5725949a6f0c72e6c4a641f24049a917db0cb": Nd.DAI
    },
    [Pd.BSC]: {
        [Wd]: Nd.BNB,
        "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c": Nd.BNB,
        "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d": Nd.USDC,
        "0x55d398326f99059ff775485246999027b3197955": Nd.USDT
    },
    [Pd.ARBITRUM_SEPOLIA]: {},
    [Pd.SOLANA]: {
        [Gc]: Nd.SOL,
        [qc]: Nd.SOL,
        [Kc]: Nd.USDC,
        [Yc]: Nd.USDT,
        [Xc]: Nd.USD1
    }
}
  , tu = (e, t) => !!eu[t][e]
  , nu = c.uniq(Object.values(eu).flatMap((e => Object.keys(e))))
  , ru = e => Zd.includes(e)
  , au = /^0x[a-fA-F0-9]{40}$/
  , su = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/
  , ou = /^(https?:\/\/|wss?:\/\/)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(:\d{1,5})?(\/.*)?$/
  , lu = new Set(["CGsqR7CTqTwbmAUTPnfg9Bj9GLJgkrUD9rhjh3vHEYvh", "BAGSB9TpGrZxQbEsrEznv5jXXdwyP6AXerN8aVRiAmcv", "5qWya6UjwWnGVhdSBL3hyZ7B45jbk6Byt1hwd7ohEGXE", "7rtiKSUDLBm59b1SBmD9oajcP8xE64vAGSMbAN5CXy1q"])
  , iu = (e, t=cu, n=du) => e.length > t ? `${e.slice(0, t - n)}${".".repeat(n)}` : e
  , cu = 9
  , du = 3
  , uu = {
    balanceTooLowToCreateOrder: n.t("Balance is too low"),
    quickBuyIsZero: n.t("Buy amount is required"),
    quickBuyNoWalletsSelected: n.t("No wallets selected"),
    insufficientBalance: n.t("Insufficient balance"),
    accountAlreadyPasswordProtected: n.t("Your account is already password protected"),
    selectSolWallet: n.t("Please select a SOL wallet"),
    unknownError: n.t("Something went wrong"),
    tryAgainLater: n.t("Try again later"),
    orderFailedToCancel: n.t("Failed to cancel the order"),
    approveFailedFundsTooLow: n.t("Wallet funds too low to send approval transaction"),
    walletImportFailed: n.t("Wallet import has failed"),
    walletImportSuccess: n.t("Your wallet is ready to use."),
    rejected: n.t("Transaction has been rejected"),
    missingMetamask: n.t("Missing MetaMask extension"),
    missingChain: n.t("MetaMask is not connected to any chain"),
    wrongChain: n.t("MetaMask is not connected to Mainnet"),
    resourceUnavailable: n.t("Other action already pending in MetaMask"),
    metamaskFailed: n.t("MetaMask extension failed to open"),
    unlockFailed: n.t("We were unable to unlock trading session"),
    unlockTrading: n.t("Please unlock trading"),
    passkeyUnsupported: n.t("Please use a different passkey provider, e.g. Face ID or a password manager."),
    incorrectPassword: n.t("Incorrect password"),
    approvePasskeySuccess: n.t("Approved pending passkey. You can now use it with your wallets."),
    deletePasskeySuccess: n.t("Deleted pending passkey."),
    createPasskeySuccess: n.t("Created new passkey. You can approve it using existing one."),
    approvePasskeyFailed: n.t("Failed to approve pending passkey."),
    deletePasskeyFailed: n.t("Failed to delete pending passkey."),
    createPasskeyFailed: n.t("Failed to create new passkey."),
    withdrawalWalletDeleteFail: n.t("Failed to remove withdrawal wallet"),
    withdrawalWalletDeleteSuccess: n.t("Withdrawal wallet has been successfully deleted"),
    withdrawalWalletAddFail: n.t("Failed to add withdrawal wallet"),
    withdrawalWalletAddSuccess: n.t("Withdrawal wallet has been successfully added"),
    transferFail: n.t("Failed to transfer funds"),
    transferEnterValidAmount: n.t("Please enter valid amount"),
    filterSaveSuccess: n.t("Filter saved"),
    unableToArchiveWallet: n.t("Unable to archive wallet"),
    unableToUnarchiveWallet: n.t("Unable to unarchive wallet"),
    clipboardWalletsSaved: n.t("Wallet addresses have been saved to clipboard"),
    nativeMarketClick: n.t("No markets for native currencies"),
    createWalletGroupSuccess: n.t("Wallet group has been created"),
    updateWalletGroupSuccess: n.t("Wallet group has been updated"),
    removeWalletGroupSuccess: n.t("Wallet group has been removed"),
    ordersCancelFailed: n.t("Failed to cancel orders"),
    trailingStopLossCreated: n.t("Trailing Stop Loss order has been created"),
    devSellCreated: n.t("Dev Sell order has been created"),
    clipboardExportWalletsSuccess: n.t("Wallets saved to clipboard"),
    clipboardExportThemeSuccess: n.t("Theme saved to clipboard"),
    clipboardExportTrackedAccountsSuccess: n.t("Tracked accounts saved to clipboard"),
    noTokenToSellInit: n.t("You don't have enough tokens"),
    unsupportedInputMode: n.t("Unsupported input mode, refresh page"),
    minClaimNotMet: n.t("Minimum claim amount is 0.02 SOL"),
    minClaimUsdNotMet: n.t("Minimum claim amount is 5 USD"),
    backgroundExceedsSize: n.t("File exceeds 2 MB limit"),
    soundExceedsSize: n.t("File exceeds 1 MB limit"),
    unsupportedFileType: n.t("Unsupported file type"),
    backgroundClipboardSaved: n.t("Image saved in clipabord"),
    backgroundUnsupportedType: n.t("Unsupported file type"),
    devBlacklisted: n.t("Dev has been blacklisted"),
    devProtectedBlacklist: n.t("Cannot blacklist official dev"),
    devBlacklistRemove: n.t("Dev has been removed from blacklist"),
    devBlacklistLimitReached: n.t("Reached dev blacklist limit"),
    handleBlacklisted: n.t("Handle has been blacklisted"),
    handleBlacklistRemove: n.t("Handle has been removed from blacklist"),
    handlesBlacklistLimitReached: n.t("Reached handles blacklist limit"),
    transferSuccess: n.t("Transfer success"),
    backgroundRemovalSuccess: n.t("Background removed"),
    clipboardEnableAccess: n.t("Please enable clipboard access"),
    priceAlertUpdateSuccess: n.t("Price alert has been updated"),
    priceAlertUpdateFailed: n.t("Failed to update price alert"),
    handleNotFound: n.t("Twitter account not found"),
    startedTracking: n.t("Started tracking twitter account"),
    startedTrackingMulti: n.t("Started tracking twitter accounts"),
    trackingCustomHandle: n.t("Custom handles may take 1 min to activate"),
    stoppedTracking: n.t("Stopped tracking twitter account"),
    stoppedTrackingAll: n.t("Stopped tracking all twitter accounts"),
    stoppedTrackingAllFailed: n.t("Failed to stop tracking twitter accounts"),
    selectOneWallet: n.t("Please select one wallet"),
    selectAtLeastTwoWallets: n.t("Select at least 2 wallets"),
    noTokenToConsolidate: n.t("No other wallets with token to consolidate"),
    noTokenToSplit: n.t("No token to split"),
    alreadyDispersed: n.t("Already dispersed"),
    notEnoughFundsForTransfer: "Insufficient balance for transfer",
    quickBuyNotAvailable: n.t("This pair doesn't support Quick Buy")
}
  , pu = {
    referralCodeSet: n.t("Referral code set"),
    claimFailed: "Claim failed",
    tooManyWallets: n.t("Too many wallets"),
    unableToScanQrCode: "Unable to scan QR Code",
    unknownError: n.t("Unknown error"),
    approvalSuccess: "Approved successfully",
    approvalFailed: "Approval failed",
    cancelSuccess: "Cancel success",
    cancelFailed: "Cancel failed",
    createSuccess: "Created successfully",
    createFailed: "Failed to create",
    createFail: "Failed to create",
    loginFail: "Failed to login",
    createPasswordFail: "Failed to create password",
    missingValue: "Missing value",
    importSuccess: "Import success",
    importFailed: "Import failed",
    updateSuccess: "Updated successfully",
    updateFailed: "Failed to update",
    deleteSuccess: "Deleted successfully",
    deleteFailed: "Failed to delete",
    priceMismatch: "Incorrect price",
    internalError: "Internal error",
    rejected: "Rejected on MetaMask",
    missingMetamask: "MetaMask missing",
    unauthorized: "Unauthorized",
    missingChain: "Missing chain",
    wrongChain: "Wrong chain",
    resourceUnavailable: "MetaMask busy",
    limitExceeded: "Limit exceeded",
    limitReached: "Limit reached",
    passkeyUnsupported: "Unsupported passkey provider",
    somethingWentWrong: n.t("Something went wrong"),
    raySnipeCreated: n.t("Migration Snipe created"),
    ordersCanceled: n.t("Orders Canceled"),
    ordersCancelFailed: n.t("Orders Cancel Failed"),
    orderCancel: n.t("Order Cancelled"),
    orderCreate: n.t("Order Created"),
    orderCreationFailed: n.t("Order Creation Failed"),
    phantomNotInstalled: "Phantom not installed",
    addSuccess: n.t("Added successfully"),
    addFailed: n.t("Add failed"),
    transferFailed: n.t("Transfer failed"),
    transferInvalidAmount: n.t("Invalid amount"),
    clipboardUnavailable: n.t("Clipboard unavailable"),
    clipboardCouldntDetermine: n.t("Couldn't find a valid blockchain address in your clipboard"),
    clipboardCouldntDetermineFilters: n.t("Couldn't find valid filters in your clipboard"),
    walletDeleted: n.t("Wallet deleted"),
    walletArchived: n.t("Wallet Archived"),
    walletUnarchived: n.t("Wallet Unarchived"),
    noWalletSelected: n.t("No wallet selected"),
    moonshotBuysNotSupportedInThisWidget: n.t("Moonshot buys are not supported in this widget yet"),
    removeFailed: n.t("Failed to remove"),
    removeSuccess: n.t("Removed successfully"),
    bulkAddFailed: n.t("Failed to bulk add addresses"),
    bulkCustomNamesUpdateFailed: n.t("Failed to add custom labels"),
    noteSaveSuccess: n.t("Personal note has been saved"),
    noteSaveFailed: n.t("Failed to save personal note"),
    noteDeleteSuccess: n.t("Personal note has been removed"),
    noteDeleteFailed: n.t("Failed to remove personal note"),
    hiddenTokenSuccess: n.t("Token has been hidden"),
    hiddenTokensDeletedSuccess: n.t("Hidden tokens list has been emptied"),
    devBlacklistDeletedSuccess: n.t("Dev blacklist has been emptied"),
    handlesBlacklistDeletedSuccess: n.t("Handles blacklist has been emptied"),
    youDontHaveToken: n.t("You don't have this token"),
    sellInitialFailed: n.t("Unable to sell initials"),
    backgroundUploadSuccess: n.t("Background saved"),
    customSoundUploadSuccess: n.t("Custom sound saved"),
    backgroundUploadFailed: n.t("Background upload failed"),
    customSoundUploadFailed: n.t("Custom sound upload failed"),
    splitFailed: n.t("Split failed"),
    consolidationFailed: n.t("Consolidation failed"),
    priceAlertCreationSuccess: n.t("Price alert created"),
    priceAlertDeleteSuccess: n.t("Price alert removed"),
    priceAlertCreationFailed: n.t("Failed to create price alert"),
    priceAlertDeleteFailed: n.t("Failed to remove price alert")
}
  , hu = e => {
    if (Ac(e) === rc.MARKET)
        return uu.unknownError;
    return `${dc[e]} price must be ${e === ic.TAKE_PROFIT ? "greater" : "lower"} than current price`
}
  , mu = e => `${e} copied to clipboard`
  , gu = e => n.t("You can choose at most {{maxWallets}} wallets at once", {
    maxWallets: gc(e)
})
  , xu = 8;
var bu = (e => (e[e.XXSMALL = 28] = "XXSMALL",
e[e.XSMALL = 32] = "XSMALL",
e[e.SMALL = 36] = "SMALL",
e[e.MEDIUM = 40] = "MEDIUM",
e[e.LARGE = 44] = "LARGE",
e[e.XLARGE = 48] = "XLARGE",
e))(bu || {});
const fu = 2
  , vu = "data-1p-ignore"
  , Su = {
    [vu]: "true"
}
  , yu = {
    autoComplete: "off",
    inputProps: Su
};
var ku = (e => (e.PADRE_PLEX = "PADRE_PLEX",
e.GEIST = "GEIST",
e.INTER = "INTER",
e))(ku || {})
  , Cu = (e => (e.REGULAR = "Padre Plex, sans-serif",
e.GEIST = "Geist, sans-serif",
e.INTER = "Inter, sans-serif",
e))(Cu || {})
  , Au = (e => (e[e.SMALL = 11] = "SMALL",
e[e.REGULAR = 12] = "REGULAR",
e[e.LARGE = 13] = "LARGE",
e))(Au || {})
  , wu = (e => (e[e.REGULAR = 400] = "REGULAR",
e[e.MEDIUM = 500] = "MEDIUM",
e[e.SEMIBOLD = 600] = "SEMIBOLD",
e[e.EXTRA_LARGE = 800] = "EXTRA_LARGE",
e))(wu || {});
const ju = 600
  , Tu = ({fontSize: e=12, fontWeight: t=400, lineHeight: n=1, fontFamily: r="Padre Plex, sans-serif", fontFeatureSettings: a="'calt' off", color: s}) => ({
    fontSize: e,
    fontWeight: t,
    lineHeight: n,
    fontFamily: r,
    fontFeatureSettings: a,
    color: s
})
  , Iu = e => {
    switch (e) {
    case ku.PADRE_PLEX:
        return "Padre Plex, sans-serif";
    case ku.GEIST:
        return "Geist, sans-serif";
    case ku.INTER:
        return "Inter, sans-serif";
    default:
        return "Padre Plex, sans-serif"
    }
}
  , Eu = e => ({
    h1: e.h1,
    h2: e.h2,
    h3: e.h2,
    h4: e.h2,
    h5: e.h2,
    h6: e.h2,
    bodyXLarge: e.display1,
    bodyLarge: e.paragraph1,
    bodyRegular: e.paragraph3,
    bodySmall: e.paragraph3,
    bodyMediumLarge: e.paragraph1,
    bodyMediumRegular: e.paragraph3,
    bodyMediumSmall: e.paragraph3,
    labelLarge: e.paragraph1,
    labelRegular: e.paragraph3,
    labelSmall: e.paragraph3,
    monoLarge: e.monospace1,
    monoRegular: e.monospace1,
    monoSmall: e.monospace3
})
  , Mu = e => {
    const t = (e => {
        const t = Iu(e);
        return {
            display1: Tu({
                fontSize: 32,
                fontWeight: 600,
                lineHeight: 1,
                fontFamily: t
            }),
            display2: Tu({
                fontSize: 24,
                fontWeight: 600,
                lineHeight: 1,
                fontFamily: t
            }),
            display3: Tu({
                fontSize: 20,
                fontWeight: 600,
                lineHeight: 1,
                fontFamily: t
            }),
            h1: Tu({
                fontSize: 15,
                fontWeight: 600,
                lineHeight: 1,
                fontFamily: t
            }),
            h2: Tu({
                fontSize: 14,
                fontWeight: 500,
                lineHeight: 1,
                fontFamily: t
            }),
            h3: Tu({
                fontSize: 15,
                fontWeight: 400,
                lineHeight: 1,
                fontFamily: t
            }),
            paragraph1: Tu({
                fontSize: 13,
                fontWeight: 500,
                lineHeight: 1,
                fontFamily: t
            }),
            paragraph2: Tu({
                fontSize: 13,
                fontWeight: 400,
                lineHeight: 1,
                fontFamily: t
            }),
            paragraph3: Tu({
                fontSize: 12,
                fontWeight: 500,
                lineHeight: 1,
                fontFamily: t
            }),
            monospace1: Tu({
                fontSize: 13,
                fontWeight: 500,
                lineHeight: 1,
                fontFamily: t
            }),
            monospace2: Tu({
                fontSize: 13,
                fontWeight: 400,
                lineHeight: 1,
                fontFamily: t
            }),
            monospace3: Tu({
                fontSize: 11,
                fontWeight: 500,
                lineHeight: 1,
                fontFamily: t
            })
        }
    }
    )(e);
    return {
        ...t,
        ...Eu(t)
    }
}
  , Nu = {
    translate: "no",
    className: "notranslate"
};
let Pu = null;
const Ou = e => {
    Pu = e
}
  , Lu = async () => {
    for (; null === Pu; )
        await new Promise((e => setTimeout(e, 200)));
    return (await Pu.getIdTokenResult()).token
}
  , Ru = async () => {
    for (; null === Pu; )
        await new Promise((e => setTimeout(e, 200)));
    return Pu.uid
}
  , Du = {
    NODE_ENV: "production",
    PADRE_BACKEND: "https://backend.padre.gg".endsWith(".padre.gg") ? "https://backend.padre.gg" : "https://localhost:5173/vite-proxy-backend-api",
    PADRE_BACKEND_HEAVY: "https://backend.padre.gg".endsWith(".padre.gg") ? "https://backend.padre.gg" : "https://localhost:5173/vite-proxy-backend-heavy-api",
    PADRE_TURNKEY_RP_ID: "padre.gg",
    PADRE_TURNKEY_ORGANIZATION_ID: "d2da2313-75ea-4ce1-829d-dbbe05359878",
    SENTRY_RELEASE_HASH: "0e04a225fc16f98c3e2f580697bbfcfa901cc963",
    TELEGRAM_BOT_ID: "7455121876"
};
function Bu(e, t, n, r, a) {
    const s = {};
    return d(t, ( (t, o) => {
        if (!Qi(t))
            return;
        const [l,i] = t.path.split(" ");
        s[o] = async (...s) => {
            const [o,c] = _u(`${e.host}${e.path}`, i, t.params, s)
              , d = n ? {
                headers: {
                    Authorization: `Bearer ${await n()}`,
                    "X-Padre-Session": r ? r() : ""
                }
            } : {
                headers: {}
            };
            if (a && (null == d ? void 0 : d.headers.Authorization))
                return a.request(o.slice(e.host.length), c, r ? r() : null);
            switch (l) {
            case "GET":
                return (await u.get(o, d)).data;
            case "POST":
                return (await u.post(o, c, d)).data;
            case "PUT":
                return (await u.put(o, c, d)).data;
            case "DELETE":
                return (await u.delete(o, d)).data;
            default:
                throw new Error("Unknown http method")
            }
        }
    }
    )),
    d(t, ( (t, n) => {
        if (Qi(t))
            return;
        const [,r] = t.path.split(" ");
        s[n] = (...n) => {
            if (!n.length)
                throw new Error("Ws methods must have at least one argument");
            const s = n[n.length - 1];
            if (a) {
                const o = a.registerListener(`${e.path}${r}`, n.slice(0, n.length - 1), t, s)
                  , l = {};
                return p(t.incoming).forEach((e => {
                    l[e] = (...e) => {}
                }
                )),
                {
                    ...l,
                    unsubscribe: o
                }
            }
            {
                const [a] = _u(`${e.host}${e.path}`, r, t.params, n)
                  , o = new WebSocket(a.replace("http://", "ws://").replace("https://", "wss://"));
                o.onmessage = e => {
                    const t = JSON.parse(e.data.toString("utf-8"));
                    s.onMessage(t)
                }
                ,
                o.onclose = e => {
                    s.close(e.code)
                }
                ,
                o.onerror = e => {
                    s.close(Xi.INTERNAL_ERROR),
                    o.close()
                }
                ;
                const l = () => {
                    o.close()
                }
                  , i = {};
                return p(t.incoming).forEach((e => {
                    i[e] = (...t) => {
                        const n = {
                            method: e,
                            args: t
                        };
                        o.send(JSON.stringify(n))
                    }
                }
                )),
                {
                    ...i,
                    unsubscribe: l
                }
            }
        }
    }
    )),
    s
}
function _u(e, t, n, r) {
    let a, s = t;
    const o = [];
    n.forEach(( (e, t) => {
        const n = function(e) {
            if (Zi(e))
                return {
                    placement: "body",
                    paramName: ""
                };
            if (function(e) {
                return !Zi(e) && "string" == typeof e
            }(e))
                return {
                    placement: e.startsWith(":") ? "path" : "query",
                    paramName: e.slice(1)
                };
            return {
                placement: e.name.startsWith(":") ? "path" : "query",
                paramName: e.name.slice(1)
            }
        }(e);
        switch (n.placement) {
        case "body":
            a = r[t];
            break;
        case "path":
            s = s.replace(`/:${n.paramName}`, `/${encodeURIComponent(String(r[t]))}`);
            break;
        case "query":
            null !== r[t] && o.push(`${n.paramName}=${encodeURIComponent(String(r[t]))}`)
        }
    }
    ));
    return [`${e}${s}${o.length ? "?" : ""}${o.join("&")}`, a]
}
Object.entries(Du).forEach(( ([e,t]) => {}
));
var Uu = (e => (e[e.ALREADY_KOL = 1] = "ALREADY_KOL",
e[e.NAME_ALREADY_TOKEN = 2] = "NAME_ALREADY_TOKEN",
e[e.TOO_LONG = 3] = "TOO_LONG",
e[e.TOO_SHORT = 4] = "TOO_SHORT",
e[e.CHARACTER_NOT_ALLOWED = 5] = "CHARACTER_NOT_ALLOWED",
e))(Uu || {});
var Wu = (e => (e.DISCORD = "discord",
e.TELEGRAM = "telegram",
e.TWITTER = "twitter",
e))(Wu || {});
const Fu = {
    ...{
        subscribeUserOverrides: {
            path: "ws /mentions/users/:uid/config/groups-info-v2/overrides",
            params: [":uid"]
        },
        subscribeGroupsInfo: {
            path: "ws /mentions/users/:uid/config/groups-info",
            params: [":uid"]
        },
        subscribeGroupsInfoV2: {
            path: "ws /mentions/users/:uid/config/groups-info-v2",
            params: [":uid"]
        },
        subscribeAddressGroupMentions: {
            path: "ws /mentions/subscribe-feed/v2/:address",
            params: [":address"]
        },
        subscribeAddressGroupMentionsV3: {
            path: "ws /mentions/subscribe-feed/v3/:address",
            params: [":address"]
        },
        subscribeTrackerGroupMentions: {
            path: "ws /mentions/subscribe-feed/tracker",
            params: [Ji("?minPublicMentions"), Ji("?maxTokenAgeInSeconds"), Ji("?onlyFirstMentionPerGroup"), "?onlyChannelIdsPacked", "?onlyChainsPacked", "?onlyUiGroupIdsPacked"]
        }
    },
    updateAlphaMentionsUiGroupHideChartMarks: {
        path: "POST /mentions/users/:uid/config/groups-info-v2/overrides/hide-chart-marks",
        params: [":uid", "httpBody"]
    },
    updateAlphaMentionsUiGroupHideInTracker: {
        path: "POST /mentions/users/:uid/config/groups-info-v2/overrides/hide-in-tracker",
        params: [":uid", "httpBody"]
    },
    updateAlphaMentionsUiGroupHideNotifications: {
        path: "POST /mentions/users/:uid/config/groups-info-v2/overrides/hide-notifications",
        params: [":uid", "httpBody"]
    }
}
  , Vu = {
    getPhantomSignInInputMobile: {
        path: "POST /pubkey/:dappPublicKey/get-phantom-sign-in-input-mobile",
        params: [":dappPublicKey"]
    },
    signInWithPhantomMobile: {
        path: "POST /sign-in-with-phantom-mobile",
        params: ["httpBody"]
    },
    createPhantomPublicKey: {
        path: "POST /create-phantom-public-key",
        params: []
    },
    handlePhantomConnectResponse: {
        path: "POST /handle-phantom-connect-response",
        params: ["httpBody"]
    },
    assignToKol: {
        path: "POST /assign-to-kol",
        params: ["httpBody"]
    },
    assignToRefCode: {
        path: "POST /assign-to-ref-code",
        params: ["httpBody"]
    },
    getRefCodeType: {
        path: "GET /code/:code/get-ref-code-type",
        params: [":code"]
    },
    whoami: {
        path: "GET /whoami",
        params: []
    },
    onNewAuthEvent: {
        path: "ws /auth/:uid",
        params: [":uid"]
    },
    getTelegramToken: {
        path: "POST /get-telegram-token",
        params: ["httpBody"]
    },
    getSolanaSignInInput: {
        path: "GET /get-solana-sign-in-input",
        params: []
    },
    getMetaMaskSignInInput: {
        path: "GET /get-meta-mask-sign-in-input",
        params: []
    },
    signInWithMetaMask: {
        path: "POST /sign-in-with-metamask",
        params: ["httpBody"]
    },
    signInWithPhantom: {
        path: "POST /sign-in-with-phantom",
        params: ["httpBody"]
    },
    generateOtp: {
        path: "POST /generate-otp",
        params: ["httpBody"]
    },
    signInWithOtp: {
        path: "POST /sign-in-with-otp",
        params: ["httpBody"]
    },
    getServerTime: {
        path: "GET /time",
        params: []
    }
}
  , Hu = e => new Promise((t => {
    setTimeout(t, e)
}
))
  , zu = h().slice(0, 13);
let $u = 1;
const Gu = () => {
    let e = $u++;
    return e > Number.MAX_SAFE_INTEGER && ($u = 1,
    e = 1),
    e
}
  , qu = "padre_multiplex_last1006";
class Ku {
    constructor(e, n, r) {
        t(this, "fullRemoteUri"),
        t(this, "relevantKeepAliveTs"),
        t(this, "multiplexWs"),
        t(this, "isWsAuthed"),
        t(this, "tokenProvider"),
        t(this, "reqs", {}),
        t(this, "subs"),
        t(this, "logCallback", ( () => {}
        )),
        this.multiplexWorker = n,
        this.multiplexWs = null,
        this.isWsAuthed = !1,
        this.fullRemoteUri = e,
        this.relevantKeepAliveTs = null,
        this.subs = {},
        this.reqs = {},
        this.tokenProvider = r,
        this.setupSocket().catch((e => {}
        ))
    }
    getSubs() {
        return m.mapValues(this.subs, (e => ({
            isPending: e.isPending
        })))
    }
    registerLogCallback(e) {
        this.logCallback = e
    }
    async setupSocket() {
        const e = +i();
        let t = !1;
        this.relevantKeepAliveTs = i().unix();
        const n = await this.tokenProvider()
          , r = setInterval(( () => {
            t ? clearInterval(r) : !document.hidden && this.multiplexWs && this.relevantKeepAliveTs && this.relevantKeepAliveTs + 10 < i().unix() && (this.logCallback("KeepAlive interval closing multiplex socket", {
                socketId: e,
                relTs: this.relevantKeepAliveTs,
                now: i().unix()
            }),
            this.multiplexWs.close())
        }
        ), 250);
        this.multiplexWs = new Xu(this.fullRemoteUri,n,this.multiplexWorker,( () => {
            t || (this.logCallback("Auth response received", {
                socketId: e,
                subs: this.getSubs(),
                wsExists: !!this.multiplexWs
            }),
            this.isWsAuthed = !0,
            Object.entries(this.reqs).forEach(( ([t,n]) => {
                if (n.isPending && this.multiplexWs) {
                    this.logCallback("Resuming request", {
                        socketId: e,
                        reqId: t
                    });
                    try {
                        n.send(),
                        n.isPending = !1
                    } catch (r) {
                        null == this || this.logCallback("Error while resuming request", {
                            socketId: e,
                            reqId: t,
                            err: r
                        })
                    }
                }
            }
            )),
            Object.entries(this.subs).forEach(( ([t,n]) => {
                if (n.isPending && this.multiplexWs) {
                    this.logCallback("Resuming connection", {
                        socketId: e,
                        connId: t
                    });
                    try {
                        this.multiplexWs.openConnection(Number(t), n.path, n.listener),
                        n.isPending = !1
                    } catch (r) {
                        null == this || this.logCallback("Error while resuming connection", {
                            socketId: e,
                            connId: t,
                            err: r
                        })
                    }
                }
            }
            )),
            f({
                message: "Multiplex onAuth completed"
            }))
        }
        ),(t => {
            var n;
            const r = i();
            this.relevantKeepAliveTs = r.unix(),
            window._padre_lastMxMsgMs = +r;
            const a = t[1];
            if (!this.subs[a])
                return this.logCallback("Listener for connId not found", {
                    socketId: e,
                    connId: a,
                    msgType: t[0]
                }),
                void (6 !== t[0] && (this.logCallback("Listener for connId not found, sending close to the server", {
                    socketId: e,
                    connId: a,
                    msgType: t[0]
                }),
                null == (n = this.multiplexWs) || n.send([6, a, Xi.CLOSED_ON_REQUEST])));
            const {listener: s} = this.subs[a];
            switch (t[0]) {
            case 5:
                s.onMessage(t[2]);
                break;
            case 6:
                this.logCallback("Received close msg", {
                    socketId: e,
                    connId: a
                }),
                delete this.subs[a],
                s.close(Xi.GOING_AWAY);
                break;
            case 7:
                this.logCallback("Received error msg", {
                    socketId: e,
                    connId: a
                }),
                delete this.subs[a],
                s.close(t[2])
            }
        }
        ),(e => {
            this.relevantKeepAliveTs = i().unix();
            const [,t,n,r] = e
              , a = this.reqs[Number(t)];
            a && (delete this.reqs[Number(t)],
            200 !== n ? a.reject(new Error(`Request failed with status code ${n}`)) : a.resolve(r))
        }
        ),(n => {
            if (t)
                return;
            this.logCallback("onClose called", {
                socketId: e,
                info: n
            }),
            t = !0,
            this.multiplexWs = null,
            this.isWsAuthed = !1,
            Object.values(this.subs).forEach((e => {
                e.isPending = !0
            }
            ));
            const r = (null == n ? void 0 : n.exitCode) === Xi.GOING_AWAY ? 1 : 1e3;
            Hu(r).then(( () => this.setupSocket().catch((e => {
                this.logCallback("Failed to setup multiplex websocket", {
                    error: e
                })
            }
            ))))
        }
        ),( () => {
            const e = i();
            this.relevantKeepAliveTs = e.unix(),
            window._padre_lastMxMsgMs = +e
        }
        ),this.logCallback.bind(this))
    }
    request(e, t, n) {
        const r = Gu();
        let a = !1;
        const s = () => {
            if (!this.multiplexWs || !this.isWsAuthed)
                throw new Error("MultiplexManager.request trying to send, but multiplex is not ready or not authenticated");
            if (a)
                throw new Error("MultiplexManager.request trying to send, but this request has already been sent");
            {
                const s = [8, r, e, n];
                void 0 !== t && s.push(t);
                this.multiplexWs.send(s) && (a = !0,
                this.reqs[r].isPending = !1)
            }
        }
          , o = new Promise(( (e, t) => {
            this.reqs[r] = {
                isPending: !0,
                send: s,
                reject: t,
                resolve: e
            }
        }
        ));
        return this.multiplexWs && this.isWsAuthed && s(),
        o
    }
    registerListener(e, t, n, r) {
        const a = Gu()
          , [s] = _u("", e, n.params, t);
        if (this.logCallback("Subscribe called", {
            connId: a,
            path: s
        }),
        this.subs[a] = {
            path: s,
            listener: r,
            isPending: !0
        },
        this.multiplexWs && this.isWsAuthed) {
            this.multiplexWs.openConnection(a, s, r) && (this.subs[a].isPending = !1)
        }
        return () => {
            this.logCallback("Unsubscribe called", {
                connId: a
            }),
            this.subs[a] && (!this.subs[a].isPending && this.multiplexWs && (this.logCallback("Sending close to the server", {
                connId: a
            }),
            this.multiplexWs.send([6, a, Xi.CLOSED_ON_REQUEST])),
            delete this.subs[a])
        }
    }
}
const Yu = {};
class Xu {
    constructor(e, n, r, a, s, l, i, c, d) {
        var u, p;
        t(this, "socket"),
        t(this, "isOpen"),
        t(this, "isDead"),
        t(this, "listeners"),
        this.multiplexWorker = r,
        this.onAuth = a,
        this.onMsg = s,
        this.onResponse = l,
        this.onClose = i,
        this.onPing = c,
        this.logCallback = d,
        this.isOpen = !1,
        this.isDead = !1,
        this.listeners = {};
        let h = "";
        const m = !Yu[e]
          , x = (null == (u = window.socketPreloaded) ? void 0 : u[e]) ?? null
          , v = (null == (p = window.replacedWithPreloaded) ? void 0 : p[e]) ?? null;
        if (m && x && v && [0, 1].includes(x.readyState))
            this.socket = x,
            h = v;
        else {
            const [t,n] = (e => {
                const t = localStorage.getItem(qu) ?? "";
                if (t && e.includes(".padre.gg") && e.includes("//backend")) {
                    const n = b(["backend.padre.gg", "backend1.padre.gg", "backend2.padre.gg", "backend3.padre.gg"].filter((e => e !== t)));
                    return [e.replace("backend.padre.gg", n), n]
                }
                return [e, "backend.padre.gg"]
            }
            )(e.replace("http://", "ws://").replace("https://", "wss://"));
            h = n,
            this.socket = new WebSocket(t),
            this.socket.binaryType = "arraybuffer"
        }
        this.multiplexWorker.worker && (this.multiplexWorker.worker.onmessage = e => {
            try {
                if (83719402391 === e.data)
                    return void (this.multiplexWorker.isHealthy = !1);
                this.onRawMessage(e.data)
            } catch (t) {
                this.multiplexWorker.isHealthy = !1
            }
        }
        ,
        this.multiplexWorker.worker.onerror = e => {
            this.multiplexWorker.isHealthy = !1
        }
        ),
        this.socket.onmessage = e => {
            if (!this.isDead) {
                if (this.multiplexWorker.worker && this.multiplexWorker.isHealthy)
                    try {
                        return void this.multiplexWorker.worker.postMessage(e.data, [e.data])
                    } catch (t) {
                        this.multiplexWorker.isHealthy = !1
                    }
                this.onRawMessage(g(new Uint8Array(e.data)))
            }
        }
        ;
        const S = () => {
            var e;
            if (this.isOpen)
                throw null == (e = this.logCallback) || e.call(this, "ERROR: duplicate onOpen invokation"),
                new Error("MultiplexWeboscket is already open");
            this.isOpen = !0,
            f({
                message: "Multiplex sending auth request"
            }),
            this.send([1, n, zu])
        }
        ;
        this.socket.readyState === WebSocket.OPEN ? S() : this.socket.onopen = () => {
            S()
        }
        ,
        this.socket.onclose = e => {
            var t;
            null == (t = this.logCallback) || t.call(this, "MultiplexWebsocket.onclose", e),
            1006 === e.code && (localStorage.setItem(qu, h),
            1 === Math.floor(1e3 * Math.random()) && o(new Error(`Received 1006 on multiplex. ReplacedWith: ${h}`))),
            this.isDead || (this.isDead = !0,
            i({
                exitCode: e.code
            }))
        }
        ,
        this.socket.onerror = e => {
            var t;
            null == (t = this.logCallback) || t.call(this, "Socket error", {
                err: e
            }),
            1 === Math.floor(100 * Math.random()) && o(e, {
                level: "warning"
            }),
            this.isDead || (this.isDead = !0,
            i({
                err: e
            }),
            this.socket.close())
        }
        ,
        Yu[e] = !0
    }
    close() {
        this.isDead || (this.isDead = !0,
        this.onClose({
            exitCode: -1
        }),
        this.socket.close())
    }
    send(e) {
        var t, n, r, a;
        if (!this.isOpen)
            return null == (t = this.logCallback) || t.call(this, "MultiplexWebsocket.send failed. Socket is not open. Ignoring msg", {
                state: this.socket.readyState,
                msgType: e[0]
            }),
            !1;
        if (this.isDead)
            return null == (n = this.logCallback) || n.call(this, "MultiplexWebsocket.send failed. Socket is dead. Ignoring msg", {
                state: this.socket.readyState,
                msgType: e[0]
            }),
            !1;
        if (this.socket.readyState !== WebSocket.OPEN)
            return null == (r = this.logCallback) || r.call(this, "Trying to send msg when readyState is not OPEN", {
                state: this.socket.readyState,
                msgType: e[0]
            }),
            !1;
        try {
            this.socket.send(x(e))
        } catch (s) {
            return null == (a = this.logCallback) || a.call(this, "Error when calling socket.send", {
                state: this.socket.readyState,
                err: s,
                msgType: e[0]
            }),
            !1
        }
        return !0
    }
    onRawMessage(e) {
        var t;
        if (4 !== e[0] && 1 !== e[0])
            if (2 !== e[0]) {
                if (8 !== e[0])
                    if (3 !== e[0])
                        if (9 !== e[0])
                            if (6 === e[0] || 7 === e[0] || 5 === e[0])
                                this.onMsg(e);
                            else {
                                const n = e;
                                null == (t = this.logCallback) || t.call(this, "Received unspported msg type", {
                                    guard: n
                                })
                            }
                        else
                            this.onResponse(e);
                    else
                        this.onPing()
            } else
                this.onAuth()
    }
    openConnection(e, t, n) {
        var r, a;
        if (!this.isOpen)
            throw null == (r = this.logCallback) || r.call(this, "Can't open multiplex socket connection. Socket is not open", {
                connId: e
            }),
            new Error(`Can't open multiplex socket connection. Socket is not open. Path: ${t}`);
        if (this.isDead)
            throw null == (a = this.logCallback) || a.call(this, "Can't open multiplex socket connection. Socket is dead", {
                connId: e
            }),
            new Error(`Can't open multiplex socket connection. Socket is dead. Path: ${t}`);
        return this.listeners[e] = n,
        this.send([4, e, t])
    }
}
const Qu = {
    isHealthy: !0,
    worker: null
}
  , Zu = {
    isHealthy: !0,
    worker: null
};
if ("undefined" != typeof Worker)
    try {
        Qu.worker = new Worker(new URL("/assets/decoder.worker-DpLffzur.js",import.meta.url),{
            type: "module"
        }),
        Zu.worker = new Worker(new URL("/assets/decoder-heavy.worker-DpLffzur.js",import.meta.url),{
            type: "module"
        })
    } catch (W$e) {
        Zu.worker = null,
        Zu.isHealthy = !1,
        Qu.worker = null,
        Qu.isHealthy = !1
    }
const Ju = new Ku(`${Du.PADRE_BACKEND}/_multiplex`,Qu,Lu)
  , ep = new Ku(`${Du.PADRE_BACKEND_HEAVY}/_heavy_multiplex`,Zu,Lu);
class tp {
    constructor(e, n) {
        t(this, "creditsUsed", 0),
        this.opts = e,
        this.onThrottled = n
    }
    call(e) {
        var t;
        this.creditsUsed >= this.opts.perMinuteLimit ? null == (t = this.onThrottled) || t.call(this) : (this.creditsUsed += 1,
        setTimeout(( () => {
            this.creditsUsed -= 1
        }
        ), 6e4),
        e())
    }
}
const np = new class {
    constructor() {
        t(this, "appInfo"),
        t(this, "throttledCount", 0),
        t(this, "limit", new tp({
            perMinuteLimit: 300
        },( () => {
            this.throttledCount += 1
        }
        ))),
        this.appInfo = {
            appName: "padre-client-v2",
            rev: Du.SENTRY_RELEASE_HASH,
            sessionId: zu
        }
    }
    postLog(e, t, n) {
        const r = rp(e, t, n)
          , a = this.throttledCount ? {
            ...r.appContext,
            _throttled: this.throttledCount
        } : r.appContext;
        this.limit.call(( () => Bm.postLines({
            ...this.appInfo,
            lines: [{
                severity: r.severity,
                data: {
                    message: r.message,
                    appContext: a
                }
            }]
        }).catch((e => {}
        ))))
    }
    debug(e, t) {}
    info(e, t) {
        this.postLog("INFO", e, t)
    }
    warn(e, t) {
        this.postLog("WARN", e, t)
    }
    error(e, t) {
        this.postLog("ERROR", e, t)
    }
}
  , rp = (e, t, n) => {
    t.length > op && (t = t.substring(0, op) + "...(truncated)",
    e = "ERROR");
    let[r,a] = n ? ap(n) : [{}, 0]
      , s = 14;
    for (; n && s > 0 && a > sp; )
        [r,a] = ap(n, s),
        s -= 1;
    return a > sp && (r = {
        info: "Payload too large"
    },
    e = "ERROR"),
    {
        severity: e,
        message: t,
        appContext: r
    }
}
  , ap = (e, t=5) => {
    const n = new WeakMap;
    let r = 0;
    const a = (e, s) => {
        if (s >= t)
            return r += 10,
            `[${typeof e}]`;
        if ("function" == typeof e)
            return r += 4,
            "[fn]";
        if ("bigint" == typeof e) {
            const t = e.toString();
            return r += t.length,
            t
        }
        if ("string" == typeof e)
            return r += e.length,
            e;
        if (!e || "object" != typeof e)
            return r += 4,
            e;
        if (n.has(e))
            return r += 10,
            "[Circular]";
        if (n.set(e, !0),
        r += 4,
        Array.isArray(e))
            return e.map((e => a(e, s + 1)));
        if (!e.constructor)
            return r += 10,
            `[${typeof e}]`;
        const o = "Object" === e.constructor.name ? {} : {
            class: e.constructor.name
        };
        return Reflect.ownKeys(e).reduce(( (t, n) => (t[n] = a(e[n], s + 1),
        t)), o)
    }
    ;
    return [a(e, 0), r]
}
  , sp = 1e4
  , op = 200;
function lp(e, t="utf8") {
    return Buffer.isBuffer(e) ? cp(e.toString("base64")) : cp(Buffer.from(e, t).toString("base64"))
}
function ip(e) {
    return function(e) {
        const t = e.length
          , n = t % 4;
        if (!n)
            return e;
        let r = t
          , a = 4 - n;
        const s = t + a
          , o = Buffer.alloc(s);
        for (o.write(e); a--; )
            o.write("=", r++);
        return o.toString()
    }(e = e.toString()).replace(/\-/g, "+").replace(/_/g, "/")
}
function cp(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}
setInterval(( () => {
    const e = Ju.getSubs();
    np.info("MultiplexManager tracking subs", {
        manager: "server",
        subs: e
    });
    const t = ep.getSubs();
    np.info("MultiplexManager tracking subs", {
        manager: "heavy",
        subs: t
    })
}
), 1e4),
ep.registerLogCallback(( (e, t) => setTimeout(( () => {
    np.info(`[MultiplexDebug][heavy] ${e}`, t)
}
), 5e3)));
const dp = lp;
dp.encode = lp,
dp.decode = function(e, t="utf8") {
    return Buffer.from(ip(e), "base64").toString(t)
}
,
dp.toBase64 = ip,
dp.fromBase64 = cp,
dp.toBuffer = function(e) {
    return Buffer.from(ip(e), "base64")
}
;
const up = 0
  , pp = 1
  , hp = 2
  , mp = 3
  , gp = 4
  , xp = 5
  , bp = {
    getTime: {
        path: "GET /time",
        params: []
    },
    getSearch: {
        path: "GET /search",
        params: ["?query", "?type", "?exchange", Ji("?limit")]
    },
    getHistory: {
        path: "GET /history",
        params: ["?symbol", Ji("?from"), Ji("?to"), "?resolution", Ji("?countback")]
    },
    subscribeMigrationAwareSmartFeed: {
        path: "ws /subscribe-migration-aware-smart-feed",
        params: ["?symbol", "?resolution"]
    },
    subscribeSmartFeed: {
        path: "ws /subscribe-smart-feed",
        params: ["?symbol", "?resolution", Ji("?skipUpdates")]
    },
    getTradesForMayhemMarks: {
        path: "GET /get-trades-for-mayhem-marks",
        params: ["?symbol", Ji("?from"), Ji("?to")]
    },
    getTradesForSniperMarks: {
        path: "GET /get-trades-for-sniper-marks",
        params: ["?symbol", Ji("?from"), Ji("?to"), "?encodedWallets"]
    },
    getTradesForMarks: {
        path: "GET /get-trades-for-marks",
        params: ["?symbol", "?type", Ji("?from"), Ji("?to"), "?wallet", "?walletGroupId"]
    },
    getTrackedKolsTradesForMarks: {
        path: "GET /get-tracked-kols-trades-for-marks",
        params: ["?symbol", Ji("?from"), Ji("?to")]
    },
    getSettings: {
        path: "GET /settings",
        params: []
    },
    setSetting: {
        path: "PUT /settings/:key",
        params: [":key", "httpBody"]
    },
    deleteSetting: {
        path: "DELETE /settings/:key",
        params: [":key"]
    },
    getAllCharts: {
        path: "GET /charts",
        params: []
    },
    getAllStudyTemplates: {
        path: "GET /study-templates",
        params: []
    },
    getChartContent: {
        path: "GET /charts/:chartId",
        params: [":chartId"]
    },
    getStudyTemplateContent: {
        path: "GET /study-templates/:templateName",
        params: [":templateName"]
    },
    getDrawingTemplates: {
        path: "GET /drawing-templates/tools/:toolName/templates",
        params: [":toolName"]
    },
    getChartTemplateContent: {
        path: "GET /chart-templates/:templateName",
        params: [":templateName"]
    },
    getAllChartTemplates: {
        path: "GET /chart-templates",
        params: []
    },
    loadDrawingTemplate: {
        path: "GET /drawing-templates/tools/:toolName/templates/:templateName",
        params: [":toolName", ":templateName"]
    },
    saveChart: {
        path: "POST /charts",
        params: ["httpBody"]
    },
    saveStudyTemplate: {
        path: "POST /study-templates",
        params: ["httpBody"]
    },
    saveDrawingTemplate: {
        path: "POST /drawing-templates",
        params: ["httpBody"]
    },
    saveChartTemplate: {
        path: "POST /chart-templates",
        params: ["httpBody"]
    },
    removeChart: {
        path: "DELETE /charts/:chartId",
        params: [":chartId"]
    },
    removeStudyTemplate: {
        path: "DELETE /study-templates/:templateName",
        params: [":templateName"]
    },
    removeDrawingTemplate: {
        path: "DELETE /drawing-templates/tools/:toolName/templates/:templateName",
        params: [":toolName", ":templateName"]
    },
    removeChartTemplate: {
        path: "DELETE /chart-templates/:templateName",
        params: [":templateName"]
    }
};
var fp = (e => (e.UNCX = "UNCX",
e.TEAM_FINANCE = "TEAM_FINANCE",
e.PINK_LOCK = "PINK_LOCK",
e))(fp || {});
const vp = e => e.pancakeSwapCreatedAt ?? null
  , Sp = e => "heaven" === e.type || "token-mill" === e.type ? e.bondedAt : e.meteoraCreatedAt ?? e.raydiumCreatedAt ?? e.pumpSwapCreatedAt ?? null
  , yp = e => {
    if (e.postMigrationProtocol)
        return e.postMigrationProtocol;
    if ("fourmeme" === e.type)
        return {
            type: Lc.FOUR_MEME
        };
    {
        const t = e.type;
        throw new Error(`Unknown protocol ${t}`)
    }
}
  , kp = e => {
    if (e.postMigrationProtocol)
        return e.postMigrationProtocol;
    if ("sugar" === e.type)
        return {
            type: Rc.SUGAR
        };
    if ("heaven" === e.type)
        return {
            type: Rc.HEAVEN
        };
    if ("token-mill" === e.type)
        return {
            type: Rc.TOKEN_MILL
        };
    if ("boop" === e.type && !e.raydiumAddress)
        return {
            type: Rc.BOOP
        };
    if ("meteora-curve" === e.type && !e.meteoraAddress)
        return {
            type: Rc.METEORA_CURVE
        };
    if ("launchlab" === e.type && !e.raydiumAddress)
        return {
            type: Rc.LAUNCH_LAB,
            curveType: _c.CONSTANT
        };
    if ("moonit" === e.type && !e.raydiumAddress && !e.meteoraAddress)
        return {
            type: Rc.MOONIT
        };
    if (e.meteoraAddress)
        return {
            type: Rc.METEORA_OLD
        };
    if (e.pumpSwapAddress)
        return {
            type: Rc.PUMP_SWAP
        };
    if (e.raydiumAddress)
        return {
            type: Rc.RAYDIUM
        };
    if (e.pumpfunAddress)
        return {
            type: Rc.PUMP_FUN
        };
    switch (e.type) {
    case "pumpfun":
    case "launchlab":
    case "boop":
    case "meteora-curve":
    case "moonit":
        throw new Error("No protocol found");
    default:
        {
            const t = e.type;
            throw new Error(`Unknown protocol ${t}`)
        }
    }
}
;
let Cp = null;
const Ap = e => {
    Cp = e
}
  , wp = () => Cp ? Cp.sessionSecret : null
  , jp = e => e[1]
  , Tp = {
    fetchJeetGrid: {
        path: "GET /jeet-grid/:chain/:tokenAddress",
        params: [":chain", ":tokenAddress", "?backfillIfMissing"]
    },
    subscribeRecentJeetGrids: {
        path: "ws /recent-jeet-grids/chain/:chain/tokenAddress/:tokenAddress",
        params: [":chain", ":tokenAddress", Ji("?limit")]
    },
    subscribeJeetGridStats: {
        path: "ws /jeet-grid-stats/chain/:chain/tokenAddress/:tokenAddress/subscribe",
        params: [":chain", ":tokenAddress"]
    },
    subscribeTopHoldersV2: {
        path: "ws /v2/chains/:chain/tokenAddress/:tokenAddress/top-holders-v2",
        params: [":chain", ":tokenAddress"]
    },
    subscribeRichHolding: {
        path: "ws /v2/chains/:chain/tokenAddress/:tokenAddress/walletAddress/:walletAddress/subscribe-rich-holding",
        params: [":chain", ":tokenAddress", ":walletAddress"]
    },
    subscribeRecentHolders: {
        path: "ws /chains/:chain/tokenAddress/:tokenAddress/subscribe-recent-holders",
        params: [":chain", ":tokenAddress"]
    },
    subscribeTopTraders: {
        path: "ws /chains/:chain/tokenAddress/:tokenAddress/subscribe-top-traders",
        params: [":chain", ":tokenAddress"]
    },
    subscribeTopHoldersV3: {
        path: "ws /chains/:chain/tokenAddress/:tokenAddress/subscribe-top-holders-v3",
        params: [":chain", ":tokenAddress"]
    },
    fetchHoldingMulti: {
        path: "POST /users/:uid/fetch-holding-multi",
        params: [":uid", "httpBody"]
    },
    subscribeSolTokenBalancesV2: {
        path: "ws /wallets/:encodedWallets/tokens/:encodedTokens/subscribe-sol-token-balances-v2",
        params: [":encodedWallets", ":encodedTokens"]
    }
}
  , Ip = {
    subscribeLiquidityEvents: {
        path: "ws /liquidity-events/market/:marketId",
        params: [":marketId", "?providerAddress", Ji("?limit")]
    },
    subscribeLiquidityProviders: {
        path: "ws /liquidity-providers/market/:marketId",
        params: [":marketId", Ji("?limit")]
    }
}
  , Ep = {
    getRollStatus: {
        path: "GET /users/:uid/rolls/:orderId/status",
        params: [":uid", ":orderId"]
    },
    roll: {
        path: "POST /users/:uid/rolls/:orderId",
        params: [":uid", ":orderId"]
    },
    claimMarketingOffer: {
        path: "POST /users/:uid/claim-marketing-offer/:offerId",
        params: [":uid", ":offerId"]
    },
    subscribeTradingRanking: {
        path: "ws /users/:uid/trading-ranking/subscribe",
        params: [":uid"]
    }
}
  , Mp = {
    [Rc.PUMP_FUN]: !0,
    [Rc.LAUNCH_LAB]: !0,
    [Rc.BOOP]: !0,
    [Rc.MOONIT]: !0,
    [Rc.HEAVEN]: !0,
    [Rc.METEORA_CURVE]: !0,
    [Rc.SUGAR]: !0,
    [Rc.TOKEN_MILL]: !0,
    [Rc.SUGAR_TEST]: !0,
    [Rc.RAYDIUM]: !1,
    [Rc.RAYDIUM_CLMM]: !1,
    [Rc.RAYDIUM_CP]: !1,
    [Rc.WHIRLPOOL]: !1,
    [Rc.METEORA_DLMM]: !1,
    [Rc.METEORA_OLD]: !1,
    [Rc.PUMP_SWAP]: !1,
    [Rc.METEORA_DAMM_V2]: !1
}
  , Np = Object.keys(Mp).filter((e => Mp[e]))
  , Pp = [Lc.FOUR_MEME]
  , Op = e => Lp(e.protocol.type)
  , Lp = e => Pp.includes(e) || Np.includes(e)
  , Rp = {
    [Rc.PUMP_FUN]: !0,
    [Rc.BOOP]: !0,
    [Rc.MOONIT]: !0,
    [Rc.SUGAR]: !0,
    [Rc.LAUNCH_LAB]: !0,
    [Rc.HEAVEN]: !0,
    [Rc.TOKEN_MILL]: !0,
    [Rc.METEORA_CURVE]: !1,
    [Rc.SUGAR_TEST]: !1,
    [Rc.METEORA_DLMM]: !1,
    [Rc.METEORA_OLD]: !1,
    [Rc.PUMP_SWAP]: !1,
    [Rc.METEORA_DAMM_V2]: !1,
    [Rc.RAYDIUM]: !1,
    [Rc.RAYDIUM_CLMM]: !1,
    [Rc.RAYDIUM_CP]: !1,
    [Rc.WHIRLPOOL]: !1
};
var Dp = (e => (e.WIDGET = "WIDGET",
e.INSTA_MOUSE = "INSTA_MOUSE",
e.INSTA_HOTKEY = "INSTA_HOTKEY",
e.TRENCHES = "TRENCHES",
e.WALLET_TRACKER = "WALLET_TRACKER",
e.PASTE_CA = "PASTE_CA",
e.SEARCH = "SEARCH",
e.TRENDING = "TRENDING",
e.PUMP_LIVE = "PUMP_LIVE",
e.WATCHLIST = "WATCHLIST",
e))(Dp || {});
const Bp = e => e[0]
  , _p = e => e[1]
  , Up = e => e[3]
  , Wp = e => e[4]
  , Fp = e => e[5]
  , Vp = e => e[7]
  , Hp = {
    batchGetTokenBalances: {
        path: "POST /token-balances/batch-get",
        params: ["httpBody", "?wrapNative"]
    },
    setPurchasePrice: {
        path: "PUT /users/:uid/chains/:chain/wallets/:walletAddress/tokens/:tokenAddress/set-purchase-price",
        params: ["httpBody", ":uid", ":chain", ":walletAddress", ":tokenAddress"]
    },
    fetchFullPortfolio: {
        path: "GET /users/:uid/fetch-full-portfolio",
        params: [":uid"]
    },
    subscribeWalletPortfolio: {
        path: "ws /users/:uid/wallets/:walletAddress/subscribe-wallet-portfolio",
        params: [":uid", ":walletAddress"]
    },
    subscribeSolTokenBalances: {
        path: "ws /wallets/:encodedWallets/tokens/:encodedTokens/subscribe-sol-token-balances",
        params: [":encodedWallets", ":encodedTokens"]
    },
    subscribeUserPortfolio: {
        path: "ws /users/:uid/subscribe-user-portfolio",
        params: [":uid"]
    },
    subscribeUserOpenPortfolio: {
        path: "ws /users/:uid/subscribe-user-open-portfolio",
        params: [":uid"]
    },
    subscribeUserSinglePosition: {
        path: "ws /users/:uid/wallets/:encodedWallets/tokens/:tokenId/",
        params: [":uid", ":encodedWallets", ":tokenId"]
    },
    subscribeUserOpenPortfolioStats: {
        path: "ws /users/:uid/order/:orderBy/user-open-portfolio-stats/subscribe",
        params: [":uid", ":orderBy"]
    }
};
var zp = (e => (e.DEFAULT = "DEFAULT",
e.LIQUIDITY = "LIQUIDITY",
e.VOLUME_H1 = "VOLUME_H1",
e.MARKET_CAP = "MARKET_CAP",
e))(zp || {});
const $p = new Set([Pd.BSC, Pd.SOLANA]);
var Gp = (e => (e[e.MEV_TXN = 0] = "MEV_TXN",
e[e.BUNDLER = 1] = "BUNDLER",
e))(Gp || {});
const qp = 0
  , Kp = 1
  , Yp = 2
  , Xp = 3
  , Qp = 4
  , Zp = 5
  , Jp = 6
  , eh = 7
  , th = 8
  , nh = 9
  , rh = 10
  , ah = 11
  , sh = 12
  , oh = 13
  , lh = 14
  , ih = 17
  , ch = 18
  , dh = e => dp.encode(JSON.stringify(e))
  , uh = {
    getHistoryV4: {
        path: "GET /recent/:marketId/history-v4",
        params: [":marketId", "?tradersEncoded", Ji("?to"), Ji("?docLimit"), "?walletGroupId", Ji("?minSizeInUsd"), "?oldest"]
    },
    getHistoryV5: {
        path: "GET /recent/:marketId/history-v5",
        params: [":marketId", "?tradersEncoded", Ji("?to"), Ji("?docLimit"), "?walletGroupIdsEncoded", Ji("?minSizeInUsd"), "?oldest"]
    },
    getHistoryV6: {
        path: "GET /recent/:marketId/history-v6",
        params: [":marketId", "?tradersEncoded", Ji("?from"), Ji("?to"), Ji("?docLimit"), "?walletGroupIdsEncoded", Ji("?minSizeInUsd"), "?oldest"]
    },
    subscribeSmartFeed: {
        path: "ws /recent/:marketId/smart-feed",
        params: [":marketId", "?trader"]
    },
    getDailyPnl: {
        path: "GET /wallet-address/:walletAddress/pnl",
        params: [":walletAddress", Ji("?lastDaysNumber")]
    },
    getDailyPnlV2: {
        path: "GET /wallet-address/:walletAddress/pnl-v2",
        params: [":walletAddress", Ji("?startTs"), Ji("?endTs")]
    },
    subscribeSnipers: {
        path: "ws /snipers/:chain/:tokenAddress/subscribe",
        params: [":chain", ":tokenAddress"]
    }
};
var ph = (e => (e[e.BUY_FIRST = 0] = "BUY_FIRST",
e[e.BUY_MORE = 1] = "BUY_MORE",
e[e.SELL_ALL = 2] = "SELL_ALL",
e[e.SELL_PART = 3] = "SELL_PART",
e))(ph || {});
const hh = 0
  , mh = 1
  , gh = 2
  , xh = 3
  , bh = 4
  , fh = 5
  , vh = 6
  , Sh = 7
  , yh = 8
  , kh = 9
  , Ch = 10
  , Ah = 11
  , wh = 12
  , jh = 13
  , Th = 14
  , Ih = 15
  , Eh = 16
  , Mh = 17
  , Nh = 18
  , Ph = 19
  , Oh = 20
  , Lh = 21
  , Rh = 22
  , Dh = e => ({
    txnHash: e[hh],
    timestamp: e[mh],
    tradeIndex: e[gh],
    maker: e[xh],
    amountInUsd: e[bh],
    amountInNative: e[fh],
    tokenAge: e[vh],
    tradeType: e[Sh],
    priceInUsd: e[yh],
    priceInNative: e[kh],
    basePctChange: e[Ch],
    marketId: e[Ah],
    baseTokenAddress: e[wh],
    quoteTokenAddress: e[jh],
    baseTokenDecimals: e[Th],
    baseTokenTotalSupply: e[Ih],
    baseTokenSymbol: e[Eh],
    baseTokenName: e[Mh],
    marketProtocolType: e[Nh],
    marketLaunchpad: e[Ph],
    marketLaunchpadAux: e[Oh],
    isMigration: e[Lh],
    baseTokenType: e[Rh]
});
var Bh = (e => (e.POPULAR = "POPULAR",
e.CUSTOM = "CUSTOM",
e.CUSTOM_OVER_LIMIT = "CUSTOM_OVER_LIMIT",
e.UNAVAILABLE = "UNAVAILABLE",
e))(Bh || {});
const _h = {
    fetchFullTweet: {
        path: "GET /tweet/full/:id",
        params: [":id"]
    },
    fetchFullTweetTranslation: {
        path: "GET /tweet/full/:id/translation/:languageCode",
        params: [":id", ":languageCode"]
    },
    getAccount: {
        path: "POST /get-account",
        params: ["httpBody"]
    },
    getCommunity: {
        path: "POST /get-community",
        params: ["httpBody"]
    },
    getUserSubscribedAccounts: {
        path: "GET /users/:uid/watched/subscribed",
        params: [":uid"]
    },
    updateUserSubscribedAccounts: {
        path: "POST /watched/subscribed",
        params: ["httpBody"]
    },
    getUserSubscribedAccountsV2: {
        path: "GET /users/:uid/watched/v2/subscribed",
        params: [":uid"]
    },
    setUserSubscribedAccountsV2: {
        path: "POST /watched/v2/subscribed",
        params: ["httpBody"]
    },
    subscribeTweetFeedV2: {
        path: "ws /tweet/subscribe-feed/v2/:uid",
        params: [":uid", "?encodedCategoryFilters", "?onlySubscribedAccounts", "?contractAddress"]
    },
    subscribeTweetFeedV3: {
        path: "ws /tweet/subscribe-feed/v3/:uid",
        params: [":uid", "?encodedCategoryFilters", "?onlySubscribedAccounts", "?contractAddress"]
    },
    subscribeWatchedAccountsDocumentChange: {
        path: "ws /tweet/subscribe-watched-document/change",
        params: []
    }
};
var Uh = (e => (e.CUSTOM_SOUND = "custom-sound",
e.CUSTOM_PNL_BACKGROUND = "custom-pnl-background",
e))(Uh || {});
const Wh = {
    "custom-sound": {
        maxNameLength: 200,
        maxSize: 204800,
        allowedContentTypes: new Set(["audio/mpeg", "audio/mp3", "audio/wav", "audio/x-wav", "audio/ogg", "audio/webm", "audio/m4a", "audio/x-m4a", "audio/aac", "audio/flac"])
    },
    "custom-pnl-background": {
        maxNameLength: 200,
        maxSize: 2097152,
        allowedContentTypes: new Set(["image/gif", "image/jpeg", "image/jpg", "image/png", "image/webp", "image/apng", "image/avif", "image/svg+xml"])
    }
};
var Fh = (e => (e.BUTTONS = "BUTTONS",
e.SLIDER = "SLIDER",
e))(Fh || {})
  , Vh = (e => (e.PRICE = "PRICE",
e.MCAP = "MCAP",
e.NONE = "NONE",
e))(Vh || {})
  , Hh = (e => (e.TOP = "TOP",
e.BELOW_NAV = "BELOW_NAV",
e))(Hh || {})
  , zh = (e => (e.NORMAL = "Normal",
e.FAST = "Fast",
e.ULTRA = "Ultra",
e))(zh || {})
  , $h = (e => (e.CORK = "CORK",
e.RING = "RING",
e.BELL = "BELL",
e.NICE = "NICE",
e.YEAH_BOY = "YEAH BOY",
e.KACHING = "KACHING",
e.UGH = "UGH",
e.CUSTOM = "CUSTOM",
e))($h || {})
  , Gh = (e => (e.TXN_TIME = "TXN_TIME",
e.CURRENT = "CURRENT",
e))(Gh || {})
  , qh = (e => (e.MARKET_VALUE = "MARKET_VALUE",
e.EXIT_VALUE = "EXIT_VALUE",
e))(qh || {})
  , Kh = (e => (e.TRENDING = "TRENDING",
e.PORTFOLIO = "PORTFOLIO",
e.AUTOMATIONS = "AUTOMATIONS",
e.TRACK = "TRACK",
e.REWARDS = "REWARDS",
e.TRENCHES = "TRENCHES",
e))(Kh || {})
  , Yh = (e => (e.SMALL = "SMALL",
e.BIG = "BIG",
e))(Yh || {})
  , Xh = (e => (e.DARK = "DARK",
e.GREY = "GREY",
e.GREEN = "GREEN",
e.PURPLE = "PURPLE",
e.MONOKAI = "MONOKAI",
e.VIOLET = "VIOLET",
e.INDIGO = "INDIGO",
e.NOIR = "NOIR",
e.TERMINAL = "TERMINAL",
e))(Xh || {})
  , Qh = (e => (e.TICKERS = "TICKERS",
e.EXCLUDE_KEYWORDS = "EXCLUDE KEYWORDS",
e.NO_SOCIALS_REUSE = "NO SOCIALS REUSE",
e.NO_PERMISSIONED = "NO_PERMISSIONED",
e.HAS_SOCIALS = "HAS SOCIALS",
e.DEV_HOLDING = "DEV HOLDING",
e.CURVE_PROGRESS = "CURVE_PROGRESS",
e.TOP_10_HOLDERS_PCNT = "TOP 10 HOLDERS PCNT",
e.TOP_INSIDERS_HOLDING_PCNT = "TOP INSIDER HOLDING PCNT",
e.SNIPERS_HOLDINGS_PCNT = "SNIPERS HOLDINGS PCNT",
e.VOLUME = "VOLUME",
e.MARKET_CAP = "MARKET CAP",
e.BUYS = "BUYS",
e.SELLS = "SELLS",
e.TOTAL_SOL_FEES = "TOTAL_SOL_FEES",
e.TOKEN_AGE_IN_MINUTES = "TOKEN AGE IN SECONDS",
e.HOLDERS_COUNT = "HOLDERS COUNT",
e.BUNDLES_HOLDING_PCNT = "BUNDLES HOLDING PCNT",
e.HAS_ORIGINAL_AVATAR = "HAS ORIGINAL AVATAR",
e.PERCENTAGE_DEV_HOLDING = "PERCENTAGE DEV HOLDING",
e.DEXSCREENER_BOOSTED = "DEXSCREENER BOOSTED",
e.DEV_BONDED = "DEV BONDED",
e.LAUNCHPADS = "LAUNCHPADS",
e.LIQUIDITY = "LIQUIDITY",
e.FRESH_WALLETS_BUYS = "FRESH_WALLETS_BUYS",
e.ALPHA_GROUP_MENTIONS = "ALPHA_GROUP_MENTIONS",
e.PRO_HOLDERS_COUNT = "PRO_HOLDERS_COUNT",
e.PUMP_LIVE = "PUMP LIVE",
e.NO_CONFIRMED_BOTS = "NO_CONFIRMED_BOTS",
e.IS_ACTIVE_MAYHEM = "IS_ACTIVE_MAYHEM",
e))(Qh || {})
  , Zh = (e => (e.NEW = "NEW",
e.ALMOST_BONDED = "ALMOST_BONDED",
e.RECENTLY_BONDED = "RECENTLY_BONDED",
e))(Zh || {});
var Jh = (e => (e.SUCCESS = "success",
e.DOMAIN_NOT_FOUND = "domain_not_found",
e))(Jh || {});
const em = Bu({
    host: Du.PADRE_BACKEND,
    path: "/auth"
}, Vu, void 0, wp)
  , tm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/auth"
}, Vu, Lu, wp, Ju)
  , nm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/ping"
}, {
    ping: {
        path: "GET /ping",
        params: []
    }
}, Lu, wp, Ju);
Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/approvals"
}, {
    hybridApprove: {
        path: "PUT /chains/:chain/wallets/:walletAddress/tokens/:token/hybrid-approve",
        params: [":chain", ":walletAddress", ":token", "httpBody"]
    },
    isHybridApproveNeeded: {
        path: "GET /chains/:chain/wallets/:walletAddress/tokens/:token/is-hybrid-approve-needed",
        params: [":chain", ":walletAddress", ":token"]
    },
    isHybridApproveNeededV2: {
        path: "GET /markets/:marketId/wallets/:walletAddress/tokens/:token/is-hybrid-approve-needed-v2",
        params: [":marketId", ":walletAddress", ":token"]
    },
    isHybridApproveNeededV3: {
        path: "GET /markets/:marketId/wallets/:encodedWallets/tokens/:token/is-hybrid-approve-needed-v3",
        params: [":marketId", ":encodedWallets", ":token"]
    },
    onApprovalStateChange: {
        path: "ws /state/approvals/:approvalId/subscribe",
        params: [":approvalId"]
    },
    onTokenApprovalStateChange: {
        path: "ws /state/chains/:chain/wallets/:walletAddress/tokens/:token/subscribe",
        params: [":chain", ":walletAddress", ":token"]
    }
}, Lu, wp, ep),
Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/essence"
}, {
    claimEssence: {
        path: "PUT /claim-essence",
        params: ["httpBody"]
    },
    onEssenceSummaryChange: {
        path: "ws /users/:uid/on-essence-summary-change",
        params: [":uid"]
    }
}, Lu, wp, ep);
const rm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/prices"
}, {
    getMarketsWithPrices: {
        path: "POST /prices/markets-per-token",
        params: ["httpBody"]
    },
    subscribeChainStats: {
        path: "ws /subscribe-chain-stats",
        params: []
    },
    getMarketSmart: {
        path: "GET /query/:query/get-market-smart",
        params: [":query"]
    },
    getMarketSmartWithWarm: {
        path: "GET /query/:query/get-market-smart-with-warm",
        params: [":query"]
    }
}, Lu, wp, Ju)
  , am = Bu({
    host: Du.PADRE_BACKEND,
    path: "/wallets"
}, {
    ackWallets: {
        path: "PUT /ack-wallets",
        params: ["httpBody"]
    },
    addWithdrawalWallet: {
        path: "PUT /add-withdrawal-wallet",
        params: ["httpBody"]
    },
    removeWithdrawalWallet: {
        path: "PUT /remove-withdrawal-wallet",
        params: ["httpBody"]
    },
    onResourceUpdate: {
        path: "ws /resource/:uid/listen",
        params: [":uid"]
    },
    createWallet: {
        path: "POST /create-wallet",
        params: ["httpBody"]
    },
    renameWallet: {
        path: "POST /rename-wallet",
        params: ["httpBody"]
    },
    deleteWallet: {
        path: "POST /delete-wallet",
        params: ["httpBody"]
    },
    deletePrivateKey: {
        path: "POST /delete-private-key",
        params: ["httpBody"]
    },
    setWalletVisibility: {
        path: "POST /set-wallet-visibility",
        params: ["httpBody"]
    },
    createPolicy: {
        path: "POST /policies/users/:uid/create",
        params: [":uid", "httpBody"]
    },
    finalizeWalletImport: {
        path: "POST /finalize-wallet-import",
        params: ["httpBody"]
    },
    finalizeWalletImportv2: {
        path: "POST /v2/finalize-wallet-import",
        params: ["httpBody"]
    },
    initializeUser: {
        path: "POST /initialize-user",
        params: ["httpBody"]
    },
    startSession: {
        path: "POST /start-session",
        params: ["httpBody"]
    },
    signSession: {
        path: "POST /sessions/:sessionId/sign",
        params: [":sessionId", "httpBody"]
    }
}, Lu, wp, Ju)
  , sm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/orders"
}, oc, Lu, wp, ep)
  , om = Bu({
    host: Du.PADRE_BACKEND,
    path: "/order-data"
}, {
    subscribeShortLivedBlockhash: {
        path: "ws /sol/short-lived-blockhash/subscribe",
        params: []
    },
    subscribePadreLutData: {
        path: "ws /sol/padre-lut/subscribe",
        params: []
    },
    subscribeMarketOrderContextInternal: {
        path: "ws /markets/:marketId/order-context/subscribe",
        params: [":marketId"]
    },
    subscribeAuxOrderContextInternal: {
        path: "ws /markets/:marketId/aux-order-context/subscribe",
        params: [":marketId"]
    },
    subscribeWalletsOrderContext: {
        path: "ws /sol/wallets/:encodedWalletAddresses/order-context/subscribe",
        params: [":encodedWalletAddresses"]
    },
    subscribeAtaOrderContext: {
        path: "ws /markets/:marketId/wallets/:encodedWalletAddresses/ata-context/subscribe",
        params: [":marketId", ":encodedWalletAddresses", "?subQuote"]
    },
    subscribeMarketOrderContextV2: {
        path: "ws /v2/markets/:marketId/order-context/subscribe",
        params: [":marketId"]
    },
    subscribeAuxOrderContextV2: {
        path: "ws /v2/markets/:marketId/aux-order-context/subscribe",
        params: [":marketId"]
    },
    keepMarketContextAlive: {
        path: "POST /markets/keep-alive",
        params: ["httpBody"]
    },
    getMarketContext: {
        path: "GET /markets/:marketId/market-context",
        params: [":marketId"]
    },
    debugGetManagerStats: {
        path: "GET /debug/manager-stats",
        params: []
    }
}, Lu, wp, Ju);
Bu({
    host: Du.PADRE_BACKEND,
    path: "/orders"
}, oc, Lu, wp);
const lm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/search"
}, {
    getMarkets: {
        path: "POST /markets",
        params: ["httpBody"]
    },
    getMarketsV2: {
        path: "POST /markets-v2",
        params: ["httpBody"]
    },
    searchSimilarTokens: {
        path: "POST /similar-tokens",
        params: ["httpBody"]
    }
}, Lu, wp, Ju)
  , im = Bu({
    host: Du.PADRE_BACKEND,
    path: "/markets"
}, {
    getTaxes: {
        path: "GET /markets/:marketId/get-taxes",
        params: [":marketId"]
    },
    getTokenAudit: {
        path: "GET /chains/:chain/tokens/:tokenAddress/get-token-audit",
        params: [":chain", ":tokenAddress"]
    },
    batchGetBasicTokenInfo: {
        path: "POST /info/batch-get-basic",
        params: ["httpBody"]
    },
    batchGetStaticMarketInfo: {
        path: "POST /info/batch-get-static-market-info",
        params: ["httpBody"]
    }
}, Lu, wp, Ju)
  , cm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/quoter"
}, {
    getQuote: {
        path: "POST /quote",
        params: ["httpBody"]
    },
    getQuoteV2: {
        path: "POST /quote-v2",
        params: ["httpBody"]
    }
}, Lu, wp, Ju)
  , dm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/portfolio"
}, Hp, Lu, wp, Ju)
  , um = Bu({
    host: Du.PADRE_BACKEND,
    path: "/fast-stats"
}, {
    onAutoMigratingMarketStatsUpdate: {
        path: "ws /encoded-markets/:marketId/on-auto-migrating-market-stats-update",
        params: [":marketId"]
    },
    onMarketStatsUpdateV2: {
        path: "ws /encoded-markets/:marketId/on-market-stats-update-v2",
        params: [":marketId"]
    },
    onFastStatsUpdate: {
        path: "ws /encoded-tokens/:encodedTokens/on-fast-stats-update",
        params: [":encodedTokens"]
    }
}, Lu, wp, Ju)
  , pm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/candles"
}, bp, Lu)
  , hm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/candles"
}, bp, Lu, wp, Ju)
  , mm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/trending"
}, {
    subscribeV5: {
        path: "ws /subscribe-v5",
        params: ["?params"]
    },
    subscribeNewMarketsV5: {
        path: "ws /subscribe-new-markets-v5",
        params: ["?params"]
    },
    subscribeMarketsV2: {
        path: "ws /markets/subscribe-v2",
        params: ["?markets"]
    },
    subscribeMigrationAwareMarketStats: {
        path: "ws /subscribe-migration-aware-market-stats",
        params: ["?marketId"]
    }
}, Lu, wp, ep)
  , gm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/watchlist"
}, {
    addToken: {
        path: "POST /users/:uid/add-token",
        params: [":uid", "httpBody"]
    },
    removeToken: {
        path: "DELETE /users/:uid/chains/:chain/tokens/:tokenAddress/remove-token",
        params: [":uid", ":chain", ":tokenAddress"]
    },
    onWatchlistUpdate: {
        path: "ws /users/:uid/on-watchlist-update",
        params: [":uid"]
    }
}, Lu, wp, ep)
  , xm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/trades"
}, uh, Lu, wp, Ju)
  , bm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/trades"
}, uh, Lu, wp, ep)
  , fm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/tracked-trades"
}, {
    subscribeWalletGroup: {
        path: "ws /wallet-groups/:walletGroupId/subscribe",
        params: [":walletGroupId", "?encodedFilter"]
    },
    subscribeWallet: {
        path: "ws /wallets/:walletAddress/subscribe",
        params: [":walletAddress", "?encodedFilter"]
    }
}, Lu, wp, ep)
  , vm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/telegram"
}, {
    subscribe: {
        path: "POST /users/:uid/subscribe",
        params: [":uid", "httpBody"]
    },
    unsubscribe: {
        path: "DELETE /users/:uid/unsubscribe",
        params: [":uid"]
    },
    getSettings: {
        path: "GET /users/:uid/get-settings",
        params: [":uid"]
    },
    setSetting: {
        path: "PUT /users/:uid/settings/:key",
        params: [":uid", ":key", "httpBody"]
    }
}, Lu, wp, ep)
  , Sm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/kols"
}, {
    decodeV1Migration: {
        path: "GET /v1-migrate/:code",
        params: [":code"]
    },
    isValid: {
        path: "GET /kols/:kolName/is-valid",
        params: [":kolName"]
    }
})
  , ym = Bu({
    host: Du.PADRE_BACKEND,
    path: "/users"
}, {
    getReferredByInfo: {
        path: "GET /users/:uid/referred-by-info",
        params: [":uid"]
    },
    onSettingsUpdated: {
        path: "ws /users/:uid/on-settings-updated",
        params: [":uid"]
    },
    updateSettings: {
        path: "PUT /users/:uid/update-settings",
        params: [":uid", "httpBody"]
    },
    onTrenchesSettingsUpdated: {
        path: "ws /users/:uid/trenches/on-settings-updated",
        params: [":uid"]
    },
    updateTrenchesSettings: {
        path: "PUT /users/:uid/trenches/update-settings",
        params: [":uid", "httpBody"]
    },
    getEarlyAccessScope: {
        path: "GET /users/:uid/early-access-scope",
        params: [":uid"]
    },
    createWalletGroup: {
        path: "PUT /users/:uid/wallet-groups/create",
        params: [":uid", "httpBody"]
    },
    updateWalletGroup: {
        path: "PUT /users/:uid/wallet-groups/:groupId/update",
        params: [":uid", ":groupId", "httpBody"]
    },
    deleteWalletGroup: {
        path: "DELETE /users/:uid/wallet-groups/:groupId/delete",
        params: [":uid", ":groupId"]
    },
    subscribeWalletGroups: {
        path: "ws /users/:uid/wallet-groups/subscribe",
        params: [":uid"]
    },
    updateCustomWalletEmojis: {
        path: "PUT /users/:uid/custom-wallet-emojis/update",
        params: [":uid", "httpBody"]
    },
    updateCustomWalletNames: {
        path: "PUT /users/:uid/custom-wallet-names/update",
        params: [":uid", "httpBody"]
    },
    updateCustomWalletSilenced: {
        path: "PUT /users/:uid/custom-wallet-silenced/update",
        params: [":uid", "httpBody"]
    },
    updateCustomWalletOnLiveTrades: {
        path: "PUT /users/:uid/custom-wallet-on-live-trades/update",
        params: [":uid", "httpBody"]
    },
    updateCustomWalletOnChart: {
        path: "PUT /users/:uid/custom-wallet-on-chart/update",
        params: [":uid", "httpBody"]
    },
    subscribeCustomWalletNames: {
        path: "ws /users/:uid/custom-wallet-names/subscribe",
        params: [":uid"]
    },
    updatePersonalNote: {
        path: "PUT /users/:uid/personal-notes/:chain/:tokenAddress/update",
        params: [":uid", ":chain", ":tokenAddress", "httpBody"]
    },
    getPersonalNote: {
        path: "DELETE /users/:uid/personal-notes/:chain/:tokenAddress/get",
        params: [":uid", ":chain", ":tokenAddress"]
    }
}, Lu, void 0, Ju)
  , km = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/accounting"
}, {
    getKolsPerf: {
        path: "POST /get-kols-perf",
        params: ["httpBody"]
    },
    getUserStats: {
        path: "GET /users/:uid/get-user-stats",
        params: [":uid"]
    },
    getRefStats: {
        path: "GET /users/:uid/get-ref-stats",
        params: [":uid"]
    },
    subscribeCashbackStats: {
        path: "ws /users/:uid/subscribe-cashback-stats",
        params: [":uid"]
    },
    subscribeRefStats: {
        path: "ws /users/:uid/subscribe-ref-stats",
        params: [":uid"]
    },
    getWalletDesignationMessage: {
        path: "GET /users/:uid/walletAddress/:walletAddress/get-wallet-designation-message",
        params: [":uid", ":walletAddress"]
    },
    subscribePartnerStats: {
        path: "ws /accounting/user/:uid",
        params: [":uid"]
    },
    designateSolRewardsWallet: {
        path: "PUT /designate-sol-rewards-wallet",
        params: ["httpBody"],
        auth: {
            session: !0
        }
    },
    claimCashback: {
        path: "POST /claim-cashback",
        params: ["httpBody"],
        auth: {
            session: !0
        }
    },
    claimKolRewardsInSol: {
        path: "POST /claim-kol-rewards-in-sol",
        params: ["httpBody"],
        auth: {
            session: !0
        }
    },
    subscribeRecentClaims: {
        path: "ws /users/:uid/subscribe-recent-claims",
        params: [":uid"]
    },
    setKolName: {
        path: "POST /set-kol-name",
        params: ["httpBody"]
    },
    bumpKolKickback: {
        path: "POST /bump-kol-kickback",
        params: ["httpBody"]
    },
    bumpCashback: {
        path: "POST /bump-cashback",
        params: ["httpBody"]
    },
    bumpKolRef: {
        path: "POST /bump-kol-ref",
        params: ["httpBody"]
    },
    checkVol: {
        path: "POST /check-vol",
        params: ["httpBody"]
    },
    assignToKolSupport: {
        path: "POST /assign-to-kol-support",
        params: ["httpBody"]
    },
    subscribeUserVolumes: {
        path: "ws /accounting/user/:uid/volumes",
        params: [":uid"]
    },
    getUsersOfInterest: {
        path: "GET /users/of-interest/stats",
        params: []
    },
    getDailyFees: {
        path: "GET /get-daily-fees",
        params: ["?cursor"]
    }
}, Lu, wp, ep)
  , Cm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/marketing"
}, Ep, Lu, wp, ep)
  , Am = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/ens"
}, {
    getEns: {
        path: "POST /ens",
        params: ["httpBody"]
    }
}, Lu, wp, ep)
  , wm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/dev-tokens"
}, {
    subscribeDevTokensSmartFeed: {
        path: "ws /chain/:chain/dev/:devAddress/subscribe-dev-tokens-smart-feed",
        params: [":chain", ":devAddress"]
    },
    subscribeDevTokensSmartFeedV2: {
        path: "ws /chain/:chain/dev/:devAddress/sorting/:sorting/direction/:direction/subscribe-dev-tokens-smart-feed-v2",
        params: [":chain", ":devAddress", ":sorting", ":direction"]
    },
    getDevStats: {
        path: "GET /chain/:chain/dev/:devAddress/get-dev-stats",
        params: [":chain", ":devAddress"]
    }
}, Lu, wp, ep)
  , jm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/tokens"
}, {
    subscribeTokenSocials: {
        path: "ws /chains/:chain/tokens/:tokenAddress/subscribe-token-socials",
        params: [":chain", ":tokenAddress"]
    },
    getTokensWithSimilarAvatar: {
        path: "GET /chains/:chain/tokens/:tokenAddress/similar-avatar-tokens",
        params: [":chain", ":tokenAddress"]
    },
    getBagsTokenRoyalties: {
        path: "GET /chains/SOLANA/tokens/:tokenAddress/bags-token-royalties",
        params: [":tokenAddress"]
    },
    subscribeCurrentlyLivePumpFuns: {
        path: "ws /chains/SOLANA/subscribe-currently-live-pump-funs",
        params: []
    },
    getCurrentlyLivePumpFunMetadata: {
        path: "GET /chains/SOLANA/tokens/:tokenAddress/currently-live-pump-fun-metadata",
        params: [":tokenAddress"]
    }
}, Lu, wp, Ju)
  , Tm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/holders"
}, Tp, Lu, wp, Ju)
  , Im = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/user-content"
}, {
    upload: {
        path: "POST /users/:uid/upload",
        params: [":uid", "httpBody"]
    },
    remove: {
        path: "POST /users/:uid/remove",
        params: [":uid", "httpBody"]
    },
    getSingle: {
        path: "GET /users/:uid/categories/:category/get-single",
        params: [":uid", ":category"]
    }
}, Lu, void 0, ep)
  , Em = Bu({
    host: Du.PADRE_BACKEND,
    path: "/velvet"
}, {
    hasApiAuthenticator: {
        path: "GET /users/:uid/has-api-authenticator",
        params: [":uid"]
    },
    createVelvetBundle: {
        path: "PUT /users/:uid/create-velvet",
        params: [":uid", "httpBody"]
    },
    createAndEnableVelvetBundle: {
        path: "PUT /users/:uid/create-and-enable-velvet",
        params: [":uid", "httpBody"]
    },
    getVelvetBundles: {
        path: "GET /users/:uid/get-velvet-bundles",
        params: [":uid"]
    },
    getVelvetBundle: {
        path: "GET /users/:uid/get-velvet",
        params: [":uid"]
    },
    runVelvetMigration: {
        path: "PUT /users/:uid/run-velvet-migration",
        params: [":uid", "httpBody"]
    },
    runVelvetSolMigration: {
        path: "PUT /users/:uid/run-velvet-sol-migration",
        params: [":uid", "httpBody"]
    }
}, Lu, wp, Ju);
Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/notifications"
}, {
    subscribe: {
        path: "ws /users/:uid/subscribe",
        params: [":uid"]
    },
    markAsRead: {
        path: "POST /users/:uid/mark-as-read",
        params: [":uid", "httpBody"]
    }
}, Lu, wp, ep),
Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/liquidity"
}, Ip, Lu, wp, ep);
const Mm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/transfers"
}, {
    makeNativeTransfer: {
        path: "POST /users/:uid/make-native-transfer",
        params: [":uid", "httpBody"]
    },
    onNativeTransferStateChange: {
        path: "ws /native-transfer-ids/:nativeTransferId/subscribe",
        params: [":nativeTransferId"]
    }
}, Lu, wp, Ju)
  , Nm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/twitter"
}, _h, Lu, wp, ep)
  , Pm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/pnl-custom-backgrounds"
}, {
    uploadImage: {
        path: "POST /users/:uid/custom-backgrounds/upload",
        params: [":uid", "httpBody"]
    },
    getUserCustomBackgrounds: {
        path: "GET /users/:uid/custom-backgrounds",
        params: [":uid"]
    },
    deleteCustomBackground: {
        path: "POST /users/:uid/custom-backgrounds/delete",
        params: [":uid", "httpBody"]
    }
}, Lu, void 0, ep)
  , Om = Bu({
    host: Du.PADRE_BACKEND,
    path: "/app-info"
}, {
    subscribeGlobalMessage: {
        path: "ws /global-message",
        params: []
    },
    subscribeAppVersion: {
        path: "ws /app-version",
        params: []
    }
}, Lu, void 0, Ju)
  , Lm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/gaze"
}, {
    subscribe: {
        path: "ws /gaze/type/:gazeType/params/:encodedParams/subscribe",
        params: [":gazeType", ":encodedParams"]
    },
    subscribeV2: {
        path: "ws /user/:uid/gaze/type/:gazeType/params/:encodedParams/subscribe",
        params: [":uid", ":gazeType", ":encodedParams"]
    },
    subscribeBsc: {
        path: "ws /gaze/type/:gazeType/params/:encodedParams/subscribe-bsc",
        params: [":gazeType", ":encodedParams"]
    },
    subscribePopularSymbolSubstrings: {
        path: "ws /gaze/popular-symbol-substrings/subscribe",
        params: []
    },
    subscribeNewPumpFunImages: {
        path: "ws /gaze/pump-fun-images/subscribe",
        params: []
    },
    subscribeNewFourMemeImages: {
        path: "ws /gaze/four-meme-images/four-meme/subscribe",
        params: []
    }
}, Lu, void 0, ep)
  , Rm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/wallet-overview"
}, {
    subscribeWalletOverview: {
        path: "ws /wallet/:walletAddress/subscribe-wallet-overview",
        params: [":walletAddress"]
    },
    subscribeActivePositions: {
        path: "ws /wallet/:walletAddress/subscribe-active-positions",
        params: [":walletAddress"]
    },
    subscribeMostProfitable: {
        path: "ws /wallet/:walletAddress/subscribe-most-profitable",
        params: [":walletAddress"]
    },
    getWalletBasicInfo: {
        path: "GET /wallet/:walletAddress/get-wallet-basic-info",
        params: [":walletAddress"]
    }
}, Lu, void 0, ep)
  , Dm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/client-metrics"
}, {
    sendOrderLatency: {
        path: "PUT /order-latency",
        params: ["httpBody"]
    },
    sendOrderStatusTs: {
        path: "PUT /order-status-ts",
        params: ["httpBody"]
    }
}, Lu, void 0, Ju)
  , Bm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/frontend-logs"
}, {
    postLines: {
        path: "POST /lines",
        params: ["httpBody"]
    }
}, Lu, wp, ep)
  , _m = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/discord"
}, Fu, Lu, wp, ep)
  , Um = Bu({
    host: Du.PADRE_BACKEND,
    path: "/ad-hoc-txn"
}, {
    submitAndAwaitResolution: {
        path: "POST /ad-hoc-txn/submit",
        params: ["httpBody"]
    }
}, Lu, wp, Ju)
  , Wm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/alerts"
}, {
    createTokenAlert: {
        path: "POST /token-alert/create",
        params: ["httpBody"]
    },
    updateTokenAlert: {
        path: "POST /token-alert/update",
        params: ["httpBody"]
    },
    pauseTokenAlert: {
        path: "POST /alert/:alertId/pause",
        params: [":alertId"]
    },
    unpauseTokenAlert: {
        path: "POST /alert/:alertId/unpause",
        params: [":alertId"]
    },
    deleteTokenAlert: {
        path: "DELETE /alert/:alertId/delete",
        params: [":alertId"]
    },
    subscribeTokenAlerts: {
        path: "ws /token-alerts/:uid/subscribe",
        params: [":uid"]
    },
    subscribeRecentNotifications: {
        path: "ws /token-alerts/:uid/notifications/subscribe",
        params: [":uid"]
    }
}, Lu, wp, Ju)
  , Fm = Bu({
    host: Du.PADRE_BACKEND,
    path: "/whois"
}, {
    getDomainRegistration: {
        path: "POST /whois/get-domain-registration",
        params: ["httpBody"]
    }
}, Lu, wp, ep)
  , Vm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/padre-http-only-news"
}, {
    getAllNews: {
        path: "GET /news/all",
        params: ["?lang"]
    }
}, Lu, wp)
  , Hm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/tracked-kols"
}, {
    getTrackedKols: {
        path: "GET /chains/:chain/get-all",
        params: [":chain"]
    }
}, Lu, wp)
  , zm = Bu({
    host: Du.PADRE_BACKEND_HEAVY,
    path: "/padre-news"
}, {
    subscribeAllNewsCurrentVersion: {
        path: "ws /news/all/current-version",
        params: []
    }
}, Lu, wp, ep)
  , $m = Bu({
    host: Du.PADRE_BACKEND,
    path: "/pump-news"
}, {
    subscribeAllNews: {
        path: "ws /pump-news/subscribe",
        params: []
    },
    getArticles: {
        path: "POST /get-articles",
        params: ["httpBody"]
    }
}, Lu, wp, Ju)
  , Gm = Bu({
    host: Du.PADRE_BACKEND, 
    path: "/time"
}, {
    getServerTime: {
        path: "GET /get-server-time",
        params: []
    }
}, void 0, void 0)
  , qm = e => v.jsx(S, {
    "data-testid": "loading-animation",
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    gap: 2,
    ...e
})
  , Km = y.memo(( ({text: e}) => v.jsxs(qm, {
    children: [v.jsx("img", {
        src: "/padre-loading.gif",
        height: 26
    }), e && v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        textAlign: "center",
        children: e
    })]
})))
  , Ym = () => v.jsx(qm, {
    children: v.jsx(C, {
        flexShrink: 0
    })
})
  , Xm = w(A({
    apiKey: "AIzaSyDytD3neNMfkCmjm7Ll24bJuAzZIaERw8Q",
    authDomain: "auth.padre.gg",
    projectId: "padre-417020",
    storageBucket: "padre-417020.appspot.com",
    messagingSenderId: "678231832583",
    appId: "1:678231832583:web:81243a9bc65c3c19ac92a2"
}))
  , Qm = {
    api_host: "https://mp-proxy-qa6saklotq-uc.a.run.app"
}
  , Zm = {
    appVersion: Ir.version,
    epochName: "v2"
}
  , Jm = {
    mixpanel: null,
    identified: !1,
    trackSignedUp: c.noop,
    trackLoggedIn: c.noop,
    trackCreatedOrder: c.noop,
    trackCanceledOrder: c.noop,
    trackCreatedPasskey: c.noop,
    trackCreatedPassword: c.noop,
    trackStartedWalletImport: c.noop,
    setUid: c.noop,
    setReferredBy: () => {}
    ,
    setCreatedPasskey: () => {}
    ,
    registerReferralCode: c.noop,
    trackPageview: c.noop
}
  , eg = e => {
    switch (e) {
    case Pd.BASE:
        return "base";
    case Pd.BSC:
        return "bsc";
    case Pd.ETH_MAINNET:
        return "eth";
    case Pd.ARBITRUM:
        return "arbitrum";
    case Pd.ETH_SEPOLIA:
        return "sepolia";
    case Pd.ARBITRUM_SEPOLIA:
        return "arbitrum_sepolia";
    case Pd.SOLANA:
        return "solana"
    }
}
  , tg = e => {
    switch (e) {
    case "base":
        return Pd.BASE;
    case "bsc":
        return Pd.BSC;
    case "eth":
        return Pd.ETH_MAINNET;
    case "arbitrum":
        return Pd.ARBITRUM;
    case "sepolia":
        return Pd.ETH_SEPOLIA;
    case "arbitrum_sepolia":
        return Pd.ARBITRUM_SEPOLIA;
    case "solana":
        return Pd.SOLANA;
    default:
        return null
    }
}
;
function ng(e) {
    return e && e.startsWith("0x") ? e.toLowerCase() : e
}
var rg = (e => (e.DARK = "dark",
e.GREY = "medium",
e.GREEN = "green",
e.PURPLE = "purple",
e.VIOLET = "violet",
e.MONOKAI = "monokai",
e.INDIGO = "indigo",
e.CUSTOM = "custom",
e.NOIR = "noir",
e.CUSTOM_2 = "custom2",
e.TERMINAL = "terminal",
e))(rg || {});
const ag = Au.REGULAR
  , sg = "77";
var og = (e => (e[e.MINUTE = 0] = "MINUTE",
e[e.HOUR = 1] = "HOUR",
e[e.DAY = 2] = "DAY",
e[e.SECOND = 3] = "SECOND",
e))(og || {})
  , lg = (e => (e[e.S15 = 10] = "S15",
e[e.M5 = 12] = "M5",
e[e.H4 = 13] = "H4",
e))(lg || {})
  , ig = (e => (e[e.S3 = 100] = "S3",
e[e.S5 = 130] = "S5",
e))(ig || {});
const cg = {
    3: 1,
    0: 60,
    1: 3600,
    2: 86400,
    10: 15,
    12: 300,
    13: 14400,
    100: 3,
    130: 5
}
  , dg = (e, t) => {
    switch (t) {
    case 3:
        return e;
    case 0:
        return e - e % 60;
    case 1:
        return e - e % 3600;
    case 2:
        return e - e % 86400;
    case 10:
        return e - e % 15;
    case 12:
        return e - e % 300;
    case 13:
        return e - e % 14400;
    case 100:
        return e - e % 3;
    case 130:
        return e - e % 5
    }
}
  , ug = (e, t, n) => {
    const r = new Map
      , a = async n => {
        try {
            return await t(n)
        } catch (fNe) {
            throw r.delete(e(n)),
            fNe
        }
    }
    ;
    return t => {
        const s = e(t)
          , o = r.get(s)
          , l = +i();
        return (void 0 === o || o.cachedAtMs + 1e3 * n < l) && r.set(s, {
            result: a(t),
            cachedAtMs: l
        }),
        r.get(s).result
    }
}
  , pg = (e, t, n) => {
    const r = new hg(n);
    return n => {
        const a = e(n);
        return null === r.get(a) && r.set(a, (n => {
            try {
                return t(n)
            } catch (fNe) {
                throw r.delete(e(n)),
                fNe
            }
        }
        )(n)),
        r.get(a)
    }
}
;
class hg {
    constructor(e, n) {
        t(this, "cache", new Map),
        this.maxSize = e,
        n && n.forEach((e => {
            this.cache.set(e.key, e.value)
        }
        ))
    }
    size() {
        return this.cache.size
    }
    get(e) {
        const t = this.cache.get(e);
        return t ? (this.cache.delete(e),
        this.cache.set(e, t),
        t) : null
    }
    set(e, t) {
        if (this.cache.has(e))
            this.cache.delete(e);
        else if (this.cache.size >= this.maxSize) {
            const e = this.cache.keys().next().value;
            this.cache.delete(e)
        }
        this.cache.set(e, t)
    }
    delete(e) {
        this.cache.delete(e)
    }
    has(e) {
        return this.cache.has(e)
    }
    clear() {
        this.cache.clear()
    }
}
const mg = e => {
    const [t,n] = e.trim().split("-", 2)
      , r = tg(t);
    if (!r)
        throw new Error(`Unknown chain name: ${t}`);
    switch (r) {
    case Pd.ARBITRUM:
    case Pd.ARBITRUM_SEPOLIA:
    case Pd.BASE:
    case Pd.BSC:
    case Pd.ETH_MAINNET:
    case Pd.ETH_SEPOLIA:
        return ( (e, t) => {
            let n = null
              , r = t;
            const a = t.split("_");
            return a.length > 1 && ("as" === a[0] ? (r = ng(a[1]),
            n = {
                type: "apestore",
                tokenAddress: ng(a[2])
            }) : "fm" === a[0] && (r = ng(a[1]),
            n = {
                type: "fourmeme",
                tokenAddress: ng(a[2])
            })),
            {
                type: "eth-like",
                chain: e,
                marketAddress: ng(r ?? ""),
                opts: n
            }
        }
        )(r, n);
    case Pd.SOLANA:
        return (e => {
            const t = e;
            if (!t)
                throw new Error("Missing market address");
            return {
                type: "sol",
                chain: Pd.SOLANA,
                marketAddress: ng(t),
                opts: null
            }
        }
        )(n)
    }
}
  , gg = e => [Pd.ETH_MAINNET, Pd.ETH_SEPOLIA, Pd.BASE, Pd.BSC, Pd.ARBITRUM, Pd.ARBITRUM_SEPOLIA].includes(e)
  , xg = (e, t, n) => `${eg(e)}-${ng(t)}-${ng(n)}`
  , bg = (e, t) => `${eg(e)}-${ng(t)}`
  , fg = (e, t, n) => {
    if (n) {
        if ("fourmeme" === n.type)
            return `${eg(e)}-fm_${ng(t)}_${ng(n.tokenAddress)}`;
        if ("apestore" === n.type)
            return `${eg(e)}-as_${ng(t)}_${ng(n.tokenAddress)}`
    }
    return gg(e) ? `${eg(e)}-${t.toLowerCase()}` : `${eg(e)}-${ng(t)}`
}
  , vg = e => e.protocol.type === Lc.FOUR_MEME ? fg(e.chain, e.marketAddress, {
    type: "fourmeme",
    tokenAddress: ng(e.baseToken.address)
}) : fg(e.chain, e.marketAddress, null)
  , Sg = {
    maxAttempts: 5,
    minBackoffMs: 500,
    maxBackoffMs: 1e4
}
  , yg = (e, t) => async (...n) => {
    let r = null;
    const a = {
        ...Sg,
        ...t
    };
    for (let t = 0; t < a.maxAttempts; ++t)
        try {
            return await e(...n)
        } catch (W$e) {
            r = W$e,
            np.warn("withRetry error", {
                error: W$e
            }),
            await Hu(Math.min(a.maxBackoffMs, a.minBackoffMs * 2 ** t))
        }
    throw r
}
  , kg = async () => {
    {
        const {unixTs: e} = await yg(( () => Gm.getServerTime()), {
            maxAttempts: 5,
            minBackoffMs: 1e3,
            maxBackoffMs: 4e3
        })();
        return i.unix(e)
    }
}
  , Cg = () => new Ag("image-base64",{});
class Ag {
    constructor(e, n) {
        t(this, "isClosed", !1),
        t(this, "hasRecordedFirstMsg", !1),
        t(this, "observations", []),
        t(this, "lastFlushHrts", 0),
        t(this, "initAtHrts", performance.now()),
        this.type = e,
        this.ctx = n
    }
    close() {
        this.isClosed = !0,
        this.observations.length = 0
    }
    recordInit(e) {
        if (!this.isClosed && !this.hasRecordedFirstMsg) {
            this.hasRecordedFirstMsg = !0;
            const t = "number" == typeof e ? e : performance.now() - this.initAtHrts;
            if (t < 5)
                return;
            if (t > 1e4)
                return;
            np.info("First msg delay", {
                type: this.type,
                delayMs: t,
                ...this.getCtx()
            })
        }
    }
    recordUpdate(e) {
        const {serverSideMs: t} = e
          , n = Ig();
        if (!n)
            return;
        const r = n.diff(t);
        Math.abs(r) > 1e4 || (this.observations.push(r),
        this.flush())
    }
    flush() {
        if (this.isClosed || 0 === this.observations.length || performance.now() - this.lastFlushHrts < Mg)
            return;
        let e = 1 / 0
          , t = 0
          , n = 0;
        for (const a of this.observations)
            e = Math.min(a, e),
            t = Math.max(a, t),
            n += a;
        const r = n / this.observations.length;
        np.info("Msg ts diff", {
            type: this.type,
            minMs: e,
            avgMs: r,
            maxMs: t,
            count: this.observations.length,
            ...this.getCtx()
        }),
        this.lastFlushHrts = performance.now(),
        this.observations.length = 0
    }
    getCtx() {
        return {
            ...this.ctx,
            driftRttMs: wg,
            driftMs: jg
        }
    }
}
let wg = 1 / 0
  , jg = null;
const Tg = async () => {
    try {
        const e = Date.now()
          , t = await (async () => {
            try {
                const {unixMs: e} = await yg(( () => Gm.getServerTime()), {
                    maxAttempts: 5,
                    minBackoffMs: 1e3,
                    maxBackoffMs: 4e3
                })();
                return i(e)
            } catch (W$e) {
                return o(W$e),
                null
            }
        }
        )();
        if (!t)
            return;
        const n = Date.now()
          , r = n - e;
        if (r > Math.min(Ng, wg))
            return;
        wg = r;
        jg = (e + n) / 2 - t.valueOf()
    } catch (W$e) {}
}
;
Tg(),
setInterval(( () => {
    Tg()
}
), 3e4);
const Ig = () => "number" == typeof jg ? i(Date.now() - jg) : null;
class Eg {
    recordInit() {}
    recordUpdate() {}
    close() {}
}
const Mg = 5e3
  , Ng = 500
  , Pg = (e, t) => `${e}-${t}`;
window._recentSnapshot = null;
const Og = e => {
    switch (e.at(-1)) {
    case "T":
    case "W":
        throw new Error(`Unsupported resolution ${e}`);
    case "D":
        return "1D";
    case "H":
        return Number(e.slice(0, -1)) >= 4 ? "240" : "60";
    case "M":
        return Number(e.slice(0, -1)) >= 5 ? "5" : "1";
    case "S":
        return Number(e.slice(0, -1)) >= 15 ? "15S" : 5 === Number(e.slice(0, -1)) ? "5S" : 3 === Number(e.slice(0, -1)) ? "3S" : "1S";
    default:
        {
            if (!/^\d+$/.test(e))
                throw new Error(`Unexpected resolution string: ${e}`);
            const t = Number(e);
            return t % 240 == 0 ? "240" : t % 60 == 0 ? "60" : t % 5 == 0 ? "5" : "1"
        }
    }
}
  , Lg = e => {
    switch (e.at(-1)) {
    case "T":
    case "W":
        throw new Error(`Unsupported resolution ${e}`);
    case "D":
        return og.DAY;
    case "H":
        return Number(e.slice(0, -1)) >= 4 ? lg.H4 : og.HOUR;
    case "M":
        return Number(e.slice(0, -1)) >= 5 ? lg.M5 : og.MINUTE;
    case "S":
        return Number(e.slice(0, -1)) >= 15 ? lg.S15 : 5 === Number(e.slice(0, -1)) ? ig.S5 : 3 === Number(e.slice(0, -1)) ? ig.S3 : og.SECOND;
    default:
        {
            if (!/^\d+$/.test(e))
                throw new Error(`Unexpected resolution string: ${e}`);
            const t = Number(e);
            return t % 240 == 0 ? lg.H4 : t % 60 == 0 ? og.HOUR : t % 5 == 0 ? lg.M5 : og.MINUTE
        }
    }
}
;
class Rg {
    constructor(e, n, r) {
        t(this, "isReady", !1),
        t(this, "resolveIsReady", null),
        t(this, "awaitIsReady"),
        t(this, "isClosed", !1),
        t(this, "snapshot", null),
        t(this, "subscribers", new Map),
        t(this, "unsub"),
        t(this, "tradesCallback"),
        t(this, "seenTradesCache", new hg(Dg)),
        t(this, "liveTradesInitialized", !1),
        this.marketId = e,
        this.resolution = n,
        this.tradesProxy = r,
        this.awaitIsReady = new Promise((e => {
            this.isReady ? e() : this.resolveIsReady = e
        }
        )),
        this.tradesCallback = e => {
            if ("init" === e.type && !e.snapshot.some((e => {
                const t = Pg(e[qp], e[Zp]);
                return this.seenTradesCache.has(t)
            }
            )) && this.liveTradesInitialized) {
                if (!this.isReady)
                    return;
                return this.unsub(),
                this.isReady = !1,
                this.awaitIsReady = new Promise((e => {
                    this.isReady ? e() : this.resolveIsReady = e
                }
                )),
                this.snapshot = null,
                window._recentSnapshot = this.snapshot,
                this.seenTradesCache = new hg(Dg),
                this.unsub = this.openConnection(),
                void this.subscribers.forEach((e => e.resetCacheData()))
            }
            const t = "init" === e.type ? e.snapshot : e.update
              , n = T(t, [Qp, Yp], ["asc", "asc"]);
            this.liveTradesInitialized = !0,
            this.isReady && n.forEach((e => {
                this.insertTrade({
                    amountInQuote: e[th],
                    timestamp: e[Qp],
                    priceInUsd: e[Zp],
                    amountInUsd: e[Jp],
                    tradeKey: Pg(e[qp], e[Zp])
                }, {
                    skipNotify: !1
                })
            }
            ))
        }
        ,
        r.smartFeedCallbacks.add(this.tradesCallback),
        this.unsub = this.openConnection()
    }
    openConnection() {
        "1S" !== this.resolution && "3S" !== this.resolution && pm.getHistory(this.marketId, 0, 0, this.resolution, null).catch((e => {}
        ));
        const e = (t = this.marketId,
        n = this.resolution,
        mg(t).chain === Pd.SOLANA ? new Ag("candles",{
            marketId: t,
            resolution: n
        }) : new Eg);
        var t, n;
        const r = hm.subscribeMigrationAwareSmartFeed(this.marketId, this.resolution, {
            onMessage: t => {
                e.recordInit(),
                this.onMessage(t)
            }
            ,
            close: () => {
                setTimeout(( () => {
                    this.isClosed || this.openConnection()
                }
                ), 500)
            }
        });
        return () => {
            r.unsubscribe(),
            e.close()
        }
    }
    insertTrade(e, t) {
        var n;
        if (!this.snapshot)
            return;
        if (this.seenTradesCache.has(e.tradeKey))
            return;
        if (this.seenTradesCache.set(e.tradeKey, !0),
        e.amountInQuote < 1e-7)
            return;
        const r = Lg(this.resolution)
          , a = dg(e.timestamp, r)
          , s = this.snapshot.candles.at(-1)
          , o = Number(e.priceInUsd);
        if (s && s[xp] === a)
            s[hp] = o,
            s[pp] = Math.max(s[pp], o),
            s[mp] = Math.min(s[mp], o),
            s[gp] += Number(e.amountInUsd),
            this.subscribers.forEach(( ({onMsg: e}) => {
                !t.skipNotify && s && e(s)
            }
            ));
        else if (!s || s[xp] < a) {
            const r = (null == s ? void 0 : s[hp]) ?? .9 * o
              , l = [r, Math.max(r, o), o, Math.min(r, o), Number(e.amountInUsd), a];
            this.snapshot.candles.push(l),
            this.subscribers.forEach(( ({onMsg: e}) => {
                !t.skipNotify && l && e(l)
            }
            )),
            (null == (n = this.snapshot) ? void 0 : n.candles.length) > 5e3 && (this.snapshot = {
                hasOldest: !1,
                candles: this.snapshot.candles.slice(1e3)
            }),
            window._recentSnapshot = this.snapshot
        }
    }
    onMessage(e) {
        if ("init" === e.type) {
            if (this.snapshot) {
                const t = e.snapshot.candles[0] ?? null
                  , n = this.snapshot.candles.at(-1) ?? null;
                if (e.snapshot.hasOldest || t && n && t[xp] <= n[xp])
                    return void e.snapshot.candles.forEach((e => {
                        const t = e[xp];
                        (!n || t >= n[xp]) && (this.snapshot.candles.push(e),
                        window._recentSnapshot = this.snapshot,
                        this.subscribers.forEach(( ({onMsg: t}) => {
                            t(e)
                        }
                        )))
                    }
                    ))
            }
            if (this.snapshot = e.snapshot,
            window._recentSnapshot = this.snapshot,
            this.tradesProxy.trades) {
                T(this.tradesProxy.trades, ["timestamp", "tradeIndex"], ["asc", "asc"]).forEach((e => {
                    this.insertTrade({
                        amountInQuote: Number(e.amountInQuote),
                        timestamp: e.timestamp,
                        priceInUsd: Number(e.priceInUsd),
                        amountInUsd: Number(e.amountInUsd),
                        tradeKey: Pg(e.txnHash, Number(e.priceInUsd))
                    }, {
                        skipNotify: !0
                    })
                }
                ))
            }
            this.isReady ? this.subscribers.forEach(( ({resetCacheData: e}) => {
                e()
            }
            )) : (this.isReady = !0,
            setTimeout(( () => {
                this.resolveIsReady && this.resolveIsReady()
            }
            ), 0))
        }
    }
    async getBars(e) {
        if (await this.awaitIsReady,
        !this.snapshot)
            return o("CandlesSmartFeed.query ready but no snapshot"),
            {
                type: "fetch-from-server",
                partial: []
            };
        const t = this.snapshot.candles.filter((t => t[xp] <= e.to));
        return !this.snapshot.hasOldest && t.length < (e.countBack ?? 1e3) ? {
            partial: t,
            type: "fetch-from-server"
        } : 0 === t.length ? {
            type: "no-data"
        } : {
            type: "data",
            candles: t
        }
    }
    subscribe(e, t) {
        const n = I();
        if (e.symbolInfo.name !== this.marketId)
            throw new Error(`Unexpected symbolInfo ${e.symbolInfo}`);
        return this.subscribers.set(n, {
            resetCacheData: e.resetCacheData,
            onMsg: t
        }),
        () => {
            this.subscribers.delete(n)
        }
    }
    close() {
        this.isClosed = !0,
        this.tradesProxy.smartFeedCallbacks.delete(this.tradesCallback),
        this.unsub && this.unsub()
    }
}
const Dg = 1e3
  , Bg = ["config", "symbols"]
  , _g = [Pd.BASE, Pd.BSC, Pd.ETH_MAINNET, Pd.ETH_SEPOLIA, Pd.SOLANA]
  , Ug = {
    currency_codes: ["USD"],
    exchanges: [],
    supported_resolutions: ["1S", "3S", "5S", "15S", "30S", "1", "5", "15", "30", "60", "120", "240", "720", "1D"],
    supports_marks: !0,
    supports_time: !1,
    supports_search: !0,
    supports_timescale_marks: !1,
    symbols_types: []
}
  , Wg = "padreV2-candlesUserSettingsStorageKey-v2"
  , Fg = "padreV2-candlesChartsStorageKey"
  , Vg = "padreV2-candlesStudyTemplatesStorageKey"
  , Hg = "padreV2-candlesDrawingTemplatesStorageKey"
  , zg = "padreV2-candlesChartTemplatesStorageKey"
  , $g = "#FFFFFFFF"
  , Gg = "#3CC5AAFF"
  , qg = "#D84C4CFF"
  , Kg = {
    dev: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    mayhem: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    sniper: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    mine: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    specific: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    group: {
        text: $g,
        buy: Gg,
        sell: qg
    },
    kol: {
        text: $g,
        buy: Gg,
        sell: qg
    }
}
  , Yg = "11px Inter, sans-serif"
  , Xg = {
    [rg.DARK]: {},
    [rg.GREY]: {},
    [rg.GREEN]: {},
    [rg.PURPLE]: {},
    [rg.VIOLET]: {},
    [rg.MONOKAI]: {},
    [rg.INDIGO]: {},
    [rg.CUSTOM]: {},
    [rg.NOIR]: {},
    [rg.CUSTOM_2]: {},
    [rg.TERMINAL]: {}
}
  , Qg = (e, t) => {
    const n = JSON.parse(e);
    return !n || "object" != typeof n || "dark"in n && "medium"in n ? n && "object" == typeof n && !("green"in n) ? {
        dark: n.dark,
        medium: n.medium,
        green: t,
        monokai: t,
        purple: t,
        violet: t,
        indigo: t,
        custom: t,
        noir: t,
        custom2: t,
        terminal: t
    } : {
        ...Xg,
        ...n
    } : {
        dark: n,
        medium: n,
        green: n,
        monokai: n,
        purple: n,
        violet: n,
        indigo: n ?? {},
        custom: n ?? {},
        noir: n ?? {},
        custom2: n ?? {},
        terminal: n ?? {}
    }
}
  , Zg = (e, t) => {
    var n;
    const r = Fg
      , a = localStorage.getItem(r);
    if (null === a)
        return (null == e ? void 0 : e["chart.lastUsedTimeBasedResolution"]) || "1";
    const s = null == (n = JSON.parse(a)) ? void 0 : n[t];
    return (null == e ? void 0 : e["chart.lastUsedTimeBasedResolution"]) || (e => {
        var t;
        try {
            const n = null == (t = Object.values(e)[0]) ? void 0 : t.resolution;
            return "string" == typeof n && Og(n) ? n : null
        } catch (W$e) {
            return null
        }
    }
    )(s) || "1"
}
  , Jg = {
    m_barSpacing: 6,
    m_rightOffset: 10,
    rightOffsetPercentage: 5,
    usePercentageRightOffset: !1
}
  , ex = e => {
    try {
        const t = JSON.parse(e)
          , n = JSON.parse(t.content);
        if ((null == n ? void 0 : n.charts) && "object" == typeof n.charts)
            for (const e in n.charts) {
                const t = n.charts[e];
                (null == t ? void 0 : t.timeScale) && (t.timeScale = {
                    ...t.timeScale,
                    ...Jg
                })
            }
        return JSON.stringify({
            ...t,
            content: JSON.stringify(n)
        })
    } catch (t) {
        return e
    }
}
;
class tx {
    constructor(e) {
        this.colorSkin = e
    }
    async saveLineToolsAndGroups(e, t, n) {
        throw new Error("Method not implemented.")
    }
    async loadLineToolsAndGroups(e, t, n, r) {
        throw new Error("Method not implemented.")
    }
    getAllCharts() {
        return this.handleError("getAllCharts", (async () => {
            const e = Fg
              , t = localStorage.getItem(e);
            return null === t ? [] : Object.values(Qg(t, {})[this.colorSkin] ?? {})
        }
        ))
    }
    removeChart(e) {
        return this.handleError("removeChart", ( () => {
            const t = Fg
              , n = localStorage.getItem(t);
            if (null === n)
                return;
            const r = Qg(n, {});
            delete r[this.colorSkin][e.toString()],
            localStorage.setItem(t, JSON.stringify(r))
        }
        ))
    }
    saveChart(e) {
        return this.handleError("saveChart", ( () => {
            const t = Fg
              , n = localStorage.getItem(t)
              , r = String(e.id) ?? crypto.randomUUID()
              , a = {
                ...e,
                content: ex(e.content),
                id: r
            }
              , s = n ? Qg(n, {}) : Xg;
            return s[this.colorSkin][r] = a,
            localStorage.setItem(t, JSON.stringify(s)),
            r
        }
        ))
    }
    getChartContent(e) {
        return this.handleError("getChartContent", ( () => {
            const t = Fg
              , n = localStorage.getItem(t);
            if (null === n)
                return "";
            const r = Qg(n, {})[this.colorSkin][e];
            return r && r.content ? ex(r.content) : ""
        }
        ))
    }
    getAllStudyTemplates() {
        return this.handleError("getAllStudyTemplates", (async () => {
            const e = Vg
              , t = localStorage.getItem(e);
            return null === t ? [] : Object.values(Qg(t, {})[this.colorSkin])
        }
        ))
    }
    removeStudyTemplate(e) {
        return this.handleError("removeStudyTemplate", ( () => {
            const t = Vg
              , n = localStorage.getItem(t);
            if (null === n)
                return;
            const r = Qg(n, {});
            delete r[this.colorSkin][e.name],
            localStorage.setItem(t, JSON.stringify(r))
        }
        ))
    }
    saveStudyTemplate(e) {
        return this.handleError("saveStudyTemplate", ( () => {
            const t = Vg
              , n = localStorage.getItem(t)
              , r = n ? Qg(n, {}) : Xg;
            r[this.colorSkin][e.name] = e,
            localStorage.setItem(t, JSON.stringify(r))
        }
        ))
    }
    getStudyTemplateContent(e) {
        return this.handleError("getStudyTemplateContent", ( () => {
            var t;
            const n = Vg
              , r = localStorage.getItem(n);
            if (null === r)
                return "";
            return (null == (t = Qg(r, {})[this.colorSkin][e.name]) ? void 0 : t.content) ?? ""
        }
        ))
    }
    getDrawingTemplates(e) {
        return this.handleError("getDrawingTemplates", (async () => {
            const t = Hg
              , n = localStorage.getItem(t);
            if (null === n)
                return [];
            {
                const t = Qg(n, {});
                return Object.keys(t[this.colorSkin][e])
            }
        }
        ))
    }
    loadDrawingTemplate(e, t) {
        return this.handleError("loadDrawingTemplate", ( () => {
            var n;
            const r = Hg
              , a = localStorage.getItem(r);
            if (null === a)
                return "";
            return (null == (n = Qg(a, {})[this.colorSkin][e]) ? void 0 : n[t]) ?? ""
        }
        ))
    }
    removeDrawingTemplate(e, t) {
        return this.handleError("removeDrawingTemplate", ( () => {
            const n = Hg
              , r = localStorage.getItem(n);
            if (null === r)
                return;
            const a = Qg(r, {});
            try {
                delete a[this.colorSkin][e][t],
                localStorage.setItem(n, JSON.stringify(a))
            } catch (s) {}
        }
        ))
    }
    saveDrawingTemplate(e, t, n) {
        return this.handleError("saveDrawingTemplate", ( () => {
            const r = Hg
              , a = localStorage.getItem(r)
              , s = a ? Qg(a, {}) : {
                dark: {},
                medium: {},
                green: {},
                purple: {},
                violet: {},
                monokai: {},
                indigo: {},
                custom: {},
                noir: {},
                custom2: {},
                terminal: {}
            };
            s[this.colorSkin][e] || (s[this.colorSkin][e] = {}),
            s[this.colorSkin][e][t] = n,
            localStorage.setItem(r, JSON.stringify(s))
        }
        ))
    }
    getAllChartTemplates() {
        return this.handleError("getAllChartTemplates", (async () => {
            const e = zg
              , t = localStorage.getItem(e);
            return null === t ? [] : Object.keys(Qg(t, [])[this.colorSkin])
        }
        ))
    }
    getChartTemplateContent(e) {
        return this.handleError("getChartTemplateContent", ( () => {
            const t = zg
              , n = localStorage.getItem(t);
            if (null === n)
                return {};
            return Qg(n, {})[this.colorSkin][e] ?? {}
        }
        ))
    }
    saveChartTemplate(e, t) {
        return this.handleError("saveChartTemplate", ( () => {
            const n = zg
              , r = localStorage.getItem(n)
              , a = r ? Qg(r, {}) : {
                dark: {},
                medium: {},
                green: {},
                purple: {},
                violet: {},
                monokai: {},
                indigo: {},
                custom: {},
                noir: {},
                custom2: {},
                terminal: {}
            };
            a[this.colorSkin][e] = {
                content: t
            },
            localStorage.setItem(n, JSON.stringify(a))
        }
        ))
    }
    removeChartTemplate(e) {
        return this.handleError("removeChartTemplate", (async () => {
            const t = zg
              , n = localStorage.getItem(t);
            if (null === n)
                return;
            const r = Qg(n, {});
            delete r[this.colorSkin][e],
            localStorage.setItem(t, JSON.stringify(r))
        }
        ))
    }
    async handleError(e, t) {
        try {
            return await t()
        } catch (fNe) {
            throw fNe
        }
    }
}
const nx = e => {
    const t = Fg
      , n = localStorage.getItem(t)
      , r = n ? Qg(n, {}) : Xg;
    localStorage.setItem(t, JSON.stringify({
        ...r,
        [e]: {}
    }))
}
  , rx = () => {
    nx(rg.CUSTOM)
}
  , ax = () => {
    nx(rg.CUSTOM_2)
}
  , sx = (e, t) => {
    var n, r;
    const a = Fg
      , s = localStorage.getItem(a)
      , o = s ? Qg(s, {}) : Xg
      , l = null == (r = null == (n = null == o ? void 0 : o[e]) ? void 0 : n.null) ? void 0 : r.content;
    if (!l)
        return;
    t.some((e => {
        const t = e.toLowerCase();
        return l.includes(e) || l.includes(t)
    }
    )) && localStorage.setItem(a, JSON.stringify({
        ...o,
        [e]: {}
    }))
}
;
var ox = (e => (e.INITIAL = "INITIAL",
e.LOADING = "LOADING",
e.READY = "READY",
e.ERROR = "ERROR",
e))(ox || {});
const lx = e => /^#([0-9A-F]{3}){1,2}$/i.test(e)
  , ix = e => /^#(?:[0-9A-F]{4}|[0-9A-F]{8})$/i.test(e)
  , cx = (e, t) => (n, r) => {
    const [a,s] = y.useState(( () => {
        if (!n)
            return r;
        const a = e.getItem(n)
          , s = null == t ? void 0 : t.getItem(n);
        return a ? JSON.parse(a) : s ? JSON.parse(s) : r
    }
    ));
    return y.useEffect(( () => {
        if (n)
            try {
                e.setItem(n, JSON.stringify(a))
            } catch (fNe) {
                try {
                    null == t || t.setItem(n, JSON.stringify(a))
                } catch (r) {}
            }
    }
    ), [n, a]),
    [a, s]
}
  , dx = cx(localStorage, sessionStorage)
  , ux = cx(sessionStorage)
  , px = (e, t=hx) => {
    const n = Object.entries(e);
    if (n.length <= t)
        return e;
    const r = n.length - t
      , a = n.sort(( (e, t) => e[1].cacheTimestamp - t[1].cacheTimestamp));
    for (let s = 0; s < r; s++) {
        delete e[a[s][0]]
    }
    return e
}
  , hx = 100
  , mx = e => {
    const t = y.useRef(e);
    return t.current === e || c.isEqual(t.current, e) || (t.current = e),
    t.current
}
  , gx = "visibilitychange"
  , xx = (e, {skipInitialCall: t=!0}={}) => {
    y.useEffect(( () => {
        const n = () => {
            const t = "visible" === document.visibilityState;
            e(t)
        }
        ;
        return document.addEventListener(gx, n, !1),
        t || e("visible" === document.visibilityState),
        () => document.removeEventListener(gx, n)
    }
    ), [e, t])
}
  , bx = () => {
    const [e,t] = y.useState("visible" === document.visibilityState);
    return xx(t),
    e
}
  , fx = (e, t, n) => {
    const [r,a] = E.useState(0)
      , s = E.useRef(null)
      , o = E.useRef(0);
    return E.useEffect(( () => {
        let l = !1
          , i = null;
        const c = ec({
            onMessage: a => {
                var c, d;
                if (l)
                    return;
                o.current = 0,
                i = t.extractPageCursor(a);
                const u = {
                    event: a,
                    source: e,
                    sessionBump: r
                }
                  , p = null == (c = s.current) ? void 0 : c.lastAppliedEvent
                  , h = t.transition((null == p ? void 0 : p.sessionBump) === r && p.source === e ? (null == (d = s.current) ? void 0 : d.state) ?? null : null, u.event);
                s.current = {
                    state: h,
                    lastAppliedEvent: u
                },
                n && n(h)
            }
            ,
            close: e => {
                if (!l && (l = !0,
                e !== Xi.CLOSED_ON_REQUEST)) {
                    const e = Sx(o.current);
                    setTimeout(( () => a((e => e + 1))), e),
                    o.current += 1
                }
            }
        }, (t => e(i, t)));
        return () => {
            l = !0,
            c.unsubscribe()
        }
    }
    ), [e, t, r, n]),
    y.useCallback(( () => {
        var t;
        return (null == (t = s.current) ? void 0 : t.lastAppliedEvent.source) === e ? null == s ? void 0 : s.current.state : null
    }
    ), [e])
}
  , vx = (e, t, n, r) => {
    const [a,s] = E.useState(0)
      , [o,l] = E.useState(null)
      , c = E.useRef(o)
      , d = E.useRef("visible" === document.visibilityState)
      , u = E.useRef(0);
    return xx((e => {
        d.current = e,
        e && l(c.current)
    }
    )),
    E.useEffect(( () => {
        let o = !1
          , p = null;
        const h = (null == n ? void 0 : n.debounceDuration) ?? 25
          , m = M(( () => {
            l(c.current)
        }
        ), h, {
            maxWait: 2 * h
        })
          , g = ec({
            onMessage: n => {
                var s, l;
                if (r && !r.current.hasReceivedAnyEvent && (r.current.hasReceivedAnyEvent = !0,
                r.current.firstEventTs = i().unix()),
                o)
                    return;
                u.current = 0,
                r && (r.current.reconnectCount = 0),
                p = t.extractPageCursor(n);
                const h = {
                    event: n,
                    source: e,
                    sessionBump: a
                }
                  , g = null == (s = c.current) ? void 0 : s.lastAppliedEvent
                  , x = t.transition((null == g ? void 0 : g.sessionBump) === a ? (null == (l = c.current) ? void 0 : l.state) ?? null : null, h.event);
                c.current = {
                    state: x,
                    lastAppliedEvent: h
                },
                d.current && m()
            }
            ,
            close: e => {
                if (!o && (o = !0,
                e !== Xi.CLOSED_ON_REQUEST)) {
                    const e = Sx(u.current);
                    setTimeout(( () => s((e => e + 1))), e),
                    u.current += 1,
                    r && (r.current.reconnectCount = u.current + 1)
                }
            }
        }, (t => e(p, t)));
        return () => {
            o = !0,
            g.unsubscribe()
        }
    }
    ), [e, t, a, l, null == n ? void 0 : n.debounceDuration, r]),
    E.useEffect(( () => {
        o && o.lastAppliedEvent.source !== e && (l(null),
        c.current = null)
    }
    ), [o, e]),
    (null == o ? void 0 : o.lastAppliedEvent.source) === e ? o.state : null
}
;
function Sx(e) {
    return 1e3 * (Math.min(1.5 ** e, 11) - 1)
}
const yx = (e, t, n) => {
    const r = E.useCallback(( (t, n) => e(n)), [e])
      , a = E.useMemo(( () => ({
        transition: (e, t) => t,
        extractPageCursor: () => ""
    })), []);
    return vx(r, a, t, n)
}
  , kx = (e, t, n) => {
    const r = E.useCallback(( (t, n) => e(n)), [e])
      , a = E.useMemo(( () => ({
        transition: (e, n) => t(e, n),
        extractPageCursor: () => ""
    })), [t]);
    return vx(r, a, n)
}
  , Cx = (e, t, n) => {
    const r = E.useCallback(( (t, n) => e(n)), [e])
      , a = E.useMemo(( () => ({
        transition: (e, n) => t(e, n),
        extractPageCursor: () => ""
    })), [t]);
    return fx(r, a, n)
}
  , Ax = () => {
    const {user: e} = VK();
    return (null == e ? void 0 : e.uid) ?? null
}
  , wx = N()(( (e, t) => ({
    isSynced: !1,
    values: {},
    lastSyncedValues: {},
    setValues: t => e((e => ({
        values: {
            ...e.values,
            ...t
        }
    }))),
    setSingleValue: (t, n) => e((e => ({
        values: {
            ...e.values,
            [t]: n
        }
    }))),
    setIsSynced: t => e(( () => ({
        isSynced: t
    }))),
    markSynced: () => {
        const {values: n} = t();
        e({
            lastSyncedValues: {
                ...n
            }
        })
    }
    ,
    setLastSyncedValues: t => e(( () => ({
        lastSyncedValues: t
    })))
})))
  , jx = () => wx((e => e.isSynced))
  , Tx = e => {
    const t = Ax();
    Ix(t, e);
    const n = wx((e => e.setIsSynced))
      , r = wx((e => e.setValues))
      , a = wx((e => e.setLastSyncedValues))
      , [s,o] = y.useState(null);
    y.useEffect(( () => {
        s && s !== t && (o(null),
        n(!1))
    }
    ), [n, s, t]),
    y.useEffect(( () => {
        e && t && s !== t && (o(t),
        r(e),
        a(e),
        n(!0))
    }
    ), [n, r, a, s, t, e])
}
  , Ix = (e, t) => {
    const n = wx((e => e.markSynced))
      , r = wx((e => e.values))
      , a = wx((e => e.lastSyncedValues))
      , s = jx()
      , o = y.useMemo(( () => c.debounce((async (e, r) => {
        if (t && r)
            try {
                await ym.updateSettings(r, {
                    syncedLocalStorage: {
                        ...t,
                        ...e
                    }
                }),
                n()
            } catch (fNe) {}
    }
    ), 1e3)), [n, t]);
    y.useEffect(( () => {
        if (!e || !s)
            return;
        const t = Object.entries(r);
        (t.length !== Object.entries(a).length || 0 !== t.length) && t.some(( ([e,t]) => a[e] !== t)) && o(r, e)
    }
    ), [r, e, a, o, s])
}
  , Ex = (e, t) => {
    if ("string" != typeof e)
        return t;
    try {
        return JSON.parse(e)
    } catch (n) {
        return t
    }
}
  , Mx = (e, t, n) => {
    const [r,a] = y.useState(!1)
      , s = jx()
      , o = wx((e => e.setSingleValue))
      , l = (e => wx((t => t.isSynced ? t.values[e] ?? void 0 : void 0)))(e)
      , [i,c] = y.useState(( () => {
        if (!e)
            return t;
        const n = localStorage.getItem(e)
          , r = sessionStorage.getItem(e);
        return n ? Ex(n, t) : r ? Ex(r, t) : t
    }
    ))
      , d = y.useCallback((t => {
        try {
            const n = JSON.stringify(t);
            localStorage.setItem(e, n),
            o(e, n)
        } catch (n) {
            try {
                const n = JSON.stringify(t);
                sessionStorage.setItem(e, n),
                o(e, n)
            } catch (r) {}
        }
    }
    ), [e, o]);
    y.useEffect(( () => {
        e && d(i)
    }
    ), [e, d, i]),
    y.useEffect(( () => {
        !s && r && a(!1)
    }
    ), [r, s]),
    y.useEffect(( () => {
        if (r || !s)
            return;
        const t = JSON.stringify(i);
        if (t === l || void 0 === l)
            return void 0 === l && o(e, t),
            void a(!0);
        try {
            const e = JSON.parse(l);
            c(e)
        } catch (fNe) {
            try {
                sessionStorage.setItem(e, JSON.stringify(i))
            } catch (n) {}
        } finally {
            a(!0)
        }
    }
    ), [r, s, e, l, i, o]);
    const [u,p] = y.useState(!n);
    return y.useEffect(( () => {
        if (e && n && !u && r) {
            const e = n(i);
            P(e, i) || (d(e),
            c(e)),
            p(!0)
        }
    }
    ), [n, u, r, i, c, e, o, d]),
    [i, c]
}
;
var Nx = (e => (e.KOLS = "KOLS",
e.TRACKED_GROUPS = "TRACKED_GROUPS",
e))(Nx || {})
  , Px = (e => (e.LEFT = "LEFT",
e.RIGHT = "RIGHT",
e))(Px || {})
  , Ox = (e => (e.NATIVE = "NATIVE",
e.STABLE = "STABLE",
e.PERCENTAGE = "PERCENTAGE",
e.INSTANT_SELL_NATIVE = "INSTANT_SELL_NATIVE",
e))(Ox || {})
  , Lx = (e => (e.FILL = "FILL",
e.SELL = "SELL",
e.TOP_HOLDERS_ENTRY = "TOP_HOLDERS_ENTRY",
e.TOP_HOLDERS_EXIT = "TOP_HOLDERS_EXIT",
e.PRICE_ALERT_ABOVE = "PRICE_ALERT_ABOVE",
e.PRICE_ALERT_BELOW = "PRICE_ALERT_BELOW",
e))(Lx || {})
  , Rx = (e => (e.KOL = "KOL",
e.MIGRATION_PRICE = "MIGRATION_PRICE",
e.MIGRATION_TIME = "MIGRATION_TIME",
e))(Rx || {});
const Dx = {
    native: {
        [Pd.ETH_MAINNET]: [.01, .02, .5, 1],
        [Pd.BASE]: [.01, .02, .5, 1],
        [Pd.BSC]: [.01, .02, .5, 1],
        [Pd.SOLANA]: [.1, .2, .5, 1]
    },
    stable: {
        [Pd.ETH_MAINNET]: [50, 100, 500, 1e3],
        [Pd.BASE]: [50, 100, 500, 1e3],
        [Pd.BSC]: [50, 100, 500, 1e3],
        [Pd.SOLANA]: [50, 100, 500, 1e3]
    },
    percentage: {
        [Pd.ETH_MAINNET]: [25, 50, 75, 100],
        [Pd.BASE]: [25, 50, 75, 100],
        [Pd.BSC]: [25, 50, 75, 100],
        [Pd.SOLANA]: [25, 50, 75, 100]
    },
    instantSellNativeValues: {
        [Pd.ETH_MAINNET]: [.01, .02, .5, 1],
        [Pd.BASE]: [.01, .02, .5, 1],
        [Pd.BSC]: [.01, .02, .5, 1],
        [Pd.SOLANA]: [.1, .2, .5, 1]
    }
}
  , Bx = {
    [Pd.ETH_MAINNET]: {
        [xc.BUY]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "1",
                tip: null,
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !0,
                slippage: "20",
                prio: "3",
                tip: null,
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !0,
                slippage: "20",
                prio: "10",
                tip: null,
                customRpcUrl: null
            }
        },
        [xc.SELL]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "1",
                tip: null,
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !0,
                slippage: "20",
                prio: "3",
                tip: null,
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !0,
                slippage: "20",
                prio: "10",
                tip: null,
                customRpcUrl: null
            }
        }
    },
    [Pd.BASE]: {
        [xc.BUY]: {
            [zh.NORMAL]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.01",
                tip: null,
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.05",
                tip: null,
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.1",
                tip: null,
                customRpcUrl: null
            }
        },
        [xc.SELL]: {
            [zh.NORMAL]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.01",
                tip: null,
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.05",
                tip: null,
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: null,
                slippage: "30",
                prio: "0.1",
                tip: null,
                customRpcUrl: null
            }
        }
    },
    [Pd.SOLANA]: {
        [xc.BUY]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "0.003",
                tip: "0.004",
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !1,
                slippage: "10",
                prio: "0.008",
                tip: "0.012",
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !1,
                slippage: "10",
                prio: "0.012",
                tip: "0.03",
                customRpcUrl: null
            }
        },
        [xc.SELL]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "0.003",
                tip: "0.004",
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !1,
                slippage: "10",
                prio: "0.008",
                tip: "0.012",
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !1,
                slippage: "10",
                prio: "0.012",
                tip: "0.03",
                customRpcUrl: null
            }
        }
    },
    [Pd.BSC]: {
        [xc.BUY]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "1",
                tip: "0",
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !1,
                slippage: "5",
                prio: "2",
                tip: "0",
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !1,
                slippage: "5",
                prio: "3",
                tip: "0",
                customRpcUrl: null
            }
        },
        [xc.SELL]: {
            [zh.NORMAL]: {
                mevProtection: !0,
                slippage: "20",
                prio: "1",
                tip: "0",
                customRpcUrl: null
            },
            [zh.FAST]: {
                mevProtection: !1,
                slippage: "5",
                prio: "2",
                tip: "0",
                customRpcUrl: null
            },
            [zh.ULTRA]: {
                mevProtection: !1,
                slippage: "5",
                prio: "3",
                tip: "0",
                customRpcUrl: null
            }
        }
    }
}
  , _x = Fh.BUTTONS
  , Ux = 0
  , Wx = [Kh.TRENDING, Kh.PORTFOLIO, Kh.TRACK, Kh.REWARDS, Kh.TRENCHES]
  , Fx = [Kh.TRENDING, Kh.TRACK, Kh.TRENCHES, Kh.PORTFOLIO, Kh.REWARDS]
  , Vx = 2
  , Hx = 25
  , zx = 0
  , $x = .5
  , Gx = Px.RIGHT
  , qx = Nx.KOLS
  , Kx = {
    [Lx.FILL]: !0,
    [Lx.SELL]: !0,
    [Lx.TOP_HOLDERS_ENTRY]: !0,
    [Lx.TOP_HOLDERS_EXIT]: !0,
    [Lx.PRICE_ALERT_ABOVE]: !0,
    [Lx.PRICE_ALERT_BELOW]: !0,
    [Rx.KOL]: !0,
    [Rx.MIGRATION_PRICE]: !0,
    [Rx.MIGRATION_TIME]: !0
}
  , Yx = {
    mine: !0,
    dev: !0,
    kol: !0,
    sniper: !0,
    specific: !0,
    group: !0,
    mayhem: !0
}
  , Xx = y.createContext({
    settings: null,
    earlyAccess: null,
    updateHiddenPairs: O,
    updateBooleanSetting: O,
    updateSidebarVisibleSections: O,
    updateAmountInputPreset: O,
    updateExtraAmountInputPreset: O,
    updateOrderPreset: O,
    updateQuickInputMode: O,
    updatePageTitleModeSetting: O,
    updateAirdropWallet: O,
    updateLastSeenNewsId: O,
    updateSolanaMaxRevertRetry: O,
    updateMultiWalletsSpread: O,
    updateMultiWalletsDelay: O,
    addToDevBlacklist: O,
    removeFromDevBlacklist: O,
    clearBlacklist: O,
    addToHandlesBlacklist: O,
    removeFromHandlesBlacklist: O,
    clearHandlesBalcklist: O,
    updatePnlTrackerInitialValue: O,
    updatePnlTrackerInitialValueBsc: O,
    updateTradeSound: O,
    updateTradeSoundVolume: O,
    updateTradeNotificationsDuration: O,
    updateMarkPriceMode: O,
    updateLineColor: O,
    updateLinesColors: O,
    updateCustomColors: O,
    updateChartMarkersColors: O,
    updateMultipleChartMarkersColors: O,
    chartMarkersVisibility: Yx,
    setChartMarkersVisibility: O,
    updateRemainingBasisMode: O,
    updateTopBarPosition: O,
    walletGroups: null,
    customWalletNames: {},
    customWalletEmojis: {},
    customWalletSilenced: {},
    customWalletOnChart: {},
    customWalletOnLiveTrades: {},
    extraInputPresets: !1,
    toggleExtraInputPresets: O,
    desktopNavigationOrder: Wx,
    mobileNavigationOrder: Fx,
    updateNavigationOrder: O,
    updateTokenAvatarPreviewSize: O,
    updateTwitterSearchExclusions: O,
    chartForceAutoScale: !1,
    toggleChartForceAutoScale: O,
    chartHoldersLinesPosition: Gx,
    setChartHoldersLinesPosition: O,
    chartHoldersLinesMode: qx,
    setChartHoldersLinesMode: O,
    chartLinesVisibility: Kx,
    setChartLinesVisibility: O,
    hideChartMarkers: !1,
    setHideChartMarkers: O,
    hideChartLines: !1,
    setHideChartLines: O
});
Xx.displayName = "UserSettingsContext";
const Qx = (e, t) => n => {
    const r = Jx(n, e);
    return c.isEqual(r, n) ? n : (Zx(t, n, r),
    r)
}
  , Zx = (e, t, n) => {
    np.info("UserSettings migrated", {
        key: e,
        from: t,
        to: n
    })
}
  , Jx = (e, t) => t.reduce(( (e, [t,n]) => {
    const r = (e => Ex(localStorage.getItem(e) || sessionStorage.getItem(e), null))(t);
    if ((e => {
        localStorage.removeItem(e),
        sessionStorage.removeItem(e)
    }
    )(t),
    c.isNil(r))
        return e;
    const a = "function" == typeof n ? n(r) : {
        [n]: r
    };
    return {
        ...e,
        ...a
    }
}
), {
    ...e
})
  , eb = Qx([["padreV2-tvShowPurchaseLine", Lx.FILL], ["padreV2-tvShowSellLine", Lx.SELL], ["padreV2-tvShowPriceAlertsLines", e => ({
    [Lx.PRICE_ALERT_ABOVE]: e,
    [Lx.PRICE_ALERT_BELOW]: e
})], ["padreV2-tvShowHoldersLines", e => ({
    [Lx.TOP_HOLDERS_ENTRY]: e,
    [Lx.TOP_HOLDERS_EXIT]: e
})], ["padreV2-tvShowTopKolsLines", Rx.KOL], ["padreV2-tvShowMigrationLineKey", Rx.MIGRATION_TIME], ["padreV2-tvShowMigrationHorizontalLineKey", Rx.MIGRATION_PRICE]], "UserSettings migrated: chartLinesVisibility")
  , tb = Qx([["padreV2-tvShowMineTrades", "mine"], ["padreV2-tvSuppressmarks", e => ({
    mine: !e
})], ["padreV2-tvShowDevTrades", "dev"], ["padreV2-tvShowSniperTrades", "sniper"], ["padreV2-tvShowSpecificTrades", "specific"], ["padreV2-tvShowTrackedTrades", "specific"], ["padreV2-tvShowAlphaGroupsKey", "group"], ["padreV2-tvShowKolsTrades", "kol"], ["padreV2-tvShowMayhemTrades", "mayhem"]], "UserSettings migrated: chartMarkersVisibility")
  , nb = e => null === e || "object" != typeof e && "function" != typeof e
  , rb = e => "object" == typeof e && null !== e && !Array.isArray(e)
  , ab = (e, t) => {
    if (e === t)
        return !0;
    if (Array.isArray(e) || Array.isArray(t))
        return ( (e, t) => {
            if (!Array.isArray(e) || !Array.isArray(t))
                return !1;
            if (e.length !== t.length)
                return !1;
            const n = e.every(nb)
              , r = t.every(nb);
            if (n && r) {
                for (let n = 0; n < e.length; n++)
                    if (e[n] !== t[n])
                        return !1;
                return !0
            }
            for (let a = 0; a < e.length; a++)
                if (!ab(e[a], t[a]))
                    return !1;
            return !0
        }
        )(e, t);
    if (rb(e) && rb(t)) {
        const n = Object.keys(e)
          , r = Object.keys(t);
        if (n.length !== r.length)
            return !1;
        for (const a of n)
            if (!ab(e[a], t[a]))
                return !1;
        return !0
    }
    return e === t
}
  , sb = new Set(["uid", "lastSeenNewsId", "hiddenPairs", "hiddenMigratedPairs", "disableAutoApprove", "completedTours", "sidebarVisibleSections", "showTopBar", "topBarPosition", "hideSidebar", "isSidebarRight", "amountInputPresets", "extraAmountInputPresets", "orderPresets", "quickInputMode", "clearOrderAfterSuccessfulTxn", "devSoldSound", "pageTitleMode", "airdropWalletAddress", "solanaStopOrderMaxRevertRetry", "includeFeesInAvgBuyLine", "redirectToRaydiumAutomatically", "solanaCustomRpcUrl", "devBlacklist", "handlesBlacklist", "pnlTrackerInitialValue", "buySuccessSound", "buyFailedSound", "sellSuccessSound", "sellFailedSound", "tradeSoundVolume", "tradeNotificationsDuration", "markPriceMode", "customColors1", "customColors2", "fillLineColor", "exitLineColor", "abovePriceAlertLineColor", "belowPriceAlertLineColor", "top10HoldersEntryLineColor", "top10HoldersExitLineColor", "disableNonNativeWarn", "chartMarkersColors", "remainingBasis", "navigationOrderDesktop", "navigationOrderMobile", "hidePlatformTradeIcon", "multiWalletsTradeSpread", "multiWalletsTradeDelay", "twitterSearchExclusions", "tokenAvatarPreviewSize", "preventDoubleClick"])
  , ob = e => {
    const t = (e => {
        if (!e)
            return e;
        const t = {};
        for (const n of sb)
            t[n] = e[n];
        return t
    }
    )(e)
      , n = y.useRef(t);
    return ( (e, t) => {
        if (e === t)
            return !0;
        if (!e || !t)
            return !1;
        for (const n of sb) {
            const r = e[n]
              , a = t[n];
            if (!ab(r, a))
                return !1
        }
        return !0
    }
    )(n.current, t) || (n.current = t),
    n.current
}
  , lb = (e, t) => Math.max(Math.min(e, t.max), t.min)
  , ib = {
    red: {
        200: "#E25560",
        500: "#CF4D58",
        600: "#6E4245",
        700: "#A13C44",
        900: "#5F2429"
    },
    green: {
        200: "#62DC9B",
        500: "#57C58B",
        600: "#357855",
        700: "#174C3D",
        900: "#285C41"
    },
    grey: {
        50: "#FFFFFF",
        100: "#F5F5F5",
        200: "#676A6D",
        300: "#676A6D",
        400: "#505158",
        500: "#2A2C38",
        600: "#303037",
        700: "#303037",
        800: "#15171A",
        900: "#111214",
        950: "#0D0D11"
    },
    orange: {
        200: "#62DC9B",
        300: "#FF9D6A",
        500: "#62DC9B",
        600: "#3A6F4E",
        700: "#355D40",
        800: "#1C402C"
    }
}
  , cb = {
    yellow: {
        200: "#F9E3A3",
        500: "#F4C20E",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , db = {
    red: {
        200: "#ff4b92",
        500: "#B53567",
        600: "#FF4B92",
        700: "#FF4B92",
        900: "#712140"
    },
    green: {
        200: "#857CEC",
        500: "#4C44A5",
        600: "#3D3783",
        700: "#4C44A5",
        900: "#302B67"
    },
    grey: {
        50: "#FFFFFF",
        100: "#F5F5F5",
        200: "#777C9A",
        300: "#777C9A",
        400: "#505158",
        500: "#28282e",
        600: "#303037",
        700: "#2d2861",
        800: "#1d1f33",
        900: "#101118",
        950: "#0f0f18"
    },
    orange: {
        200: "#857CEC",
        300: "#7971D9",
        500: "#857CEC",
        600: "#6556C1",
        700: "#4B3E97",
        800: "#2D2861"
    }
}
  , ub = {
    yellow: {
        200: "#F9E3A3",
        500: "#F4C20E",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , pb = {
    red: {
        200: "#FFB2B2",
        500: "#E73A44",
        600: "#572E30",
        700: "#53272D",
        900: "#2E1C1D"
    },
    green: {
        200: "#7EFFC1",
        500: "#17C671",
        600: "#23513B",
        700: "#17472F",
        900: "#193326"
    },
    grey: {
        50: "#FFFFFF",
        100: "#E6E6E6",
        200: "#9D9EA2",
        300: "#3E3E3E",
        400: "#303030",
        500: "#2A2A2A",
        600: "#222222",
        700: "#242424",
        800: "#1F1F1F",
        900: "#1A1A1A",
        950: "#171717"
    },
    orange: {
        200: "#FFA06A",
        300: "#FF8845",
        500: "#FF7324",
        600: "#493328",
        700: "#4F2E1C",
        800: "#30221A"
    }
}
  , hb = {
    yellow: {
        200: "#F7DC85",
        500: "#F0B90B",
        700: "#5A4D22",
        800: "#3B3827"
    },
    purple: {
        200: "#C7A4F9",
        500: "#8E49F4",
        600: "#41315C",
        800: "#312C3E"
    },
    blue: {
        200: "#90A8FA",
        500: "#2151F5",
        600: "#25335C",
        800: "#262D3F"
    },
    lavender: {
        200: "#B3BDF1",
        500: "#677CE2",
        600: "#373E58",
        800: "#2D313D"
    },
    black: {
        700: "#161616BF "
    },
    gold: {
        500: "#EDCA07"
    },
    silver: {
        500: "#D1D1D6"
    },
    bronze: {
        500: "#D19849"
    }
}
  , mb = {
    red: {
        200: "#FFCBCB",
        500: "#E75A61",
        600: "#6E4245",
        700: "#64393D",
        900: "#3F2A2C"
    },
    green: {
        200: "#95FFCD",
        500: "#28BA7D",
        600: "#3D654B",
        700: "#315941",
        900: "#2F443C"
    },
    grey: {
        50: "#FFFFFF",
        100: "#F5F5F5",
        200: "#C0C0C0",
        300: "#666666",
        400: "#505050",
        500: "#404040",
        600: "#373737",
        700: "#333333",
        800: "#292929",
        900: "#262626",
        950: "#212121"
    },
    orange: {
        200: "#FFC4A0",
        300: "#FF9D6A",
        500: "#FF8A49",
        600: "#604135",
        700: "#6A3A2A",
        800: "#453128"
    }
}
  , gb = {
    yellow: {
        200: "#F9E3A3",
        500: "#F4C20E",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , xb = {
    red: {
        200: "#FFCAD6",
        500: "#EC397A",
        600: "#F8649A",
        700: "#F23546",
        900: "#F23546"
    },
    green: {
        200: "#06070B",
        500: "#2FE3AC",
        600: "#5BE7BD",
        700: "#0B9981",
        900: "#0B9981"
    },
    grey: {
        50: "#FCFCFC",
        100: "#F5EEEE",
        200: "#777A8C",
        300: "#2E303A",
        400: "#505158",
        500: "#21242D",
        600: "#303037",
        700: "#2A2B34",
        800: "#18181A",
        900: "#101114",
        950: "#101114"
    },
    orange: {
        200: "#8E9DFF",
        300: "#FF9D6A",
        500: "#526FFF",
        600: "#6F7DD8",
        700: "#545EB3",
        800: "#3B448A"
    }
}
  , bb = {
    yellow: {
        200: "#F9E3A3",
        500: "#DCC13C",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , fb = {
    red: {
        200: "#FF6188",
        500: "#FF6188",
        600: "#913740",
        700: "#A43B44",
        900: "#732C33"
    },
    green: {
        200: "#A9DC76",
        500: "#A9DC76",
        600: "#357855",
        700: "#174C3D",
        900: "#285C41"
    },
    grey: {
        50: "#FFFFFF",
        100: "#F8F8F2",
        200: "#A6A6A6",
        300: "#505158",
        400: "#3E3D42",
        500: "#2C2A2E",
        600: "#302F36",
        700: "#303037",
        800: "#1c1c1c",
        900: "#1E1E1E",
        950: "#19181A"
    },
    orange: {
        200: "#FD971F",
        300: "#E67E22",
        500: "#FF7324",
        600: "#BF5B04",
        700: "#8F4603",
        800: "#662D01"
    }
}
  , vb = {
    yellow: {
        200: "#E6DB74",
        500: "#F4C20E",
        700: "#9A8700",
        800: "#7D6D00"
    },
    purple: {
        200: "#AE81FF",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#66D9EF",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#B3BDF1",
        500: "#677CE2",
        600: "#373E58",
        800: "#2D313D"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , Sb = {
    red: {
        200: "#4e4a99",
        500: "#545456",
        600: "#8b8ba6",
        700: "#bebfc8",
        900: "#d4d4d8"
    },
    green: {
        200: "#c7e2c2",
        500: "#9a9e99",
        600: "#e4e9e2",
        700: "#eaece9",
        900: "#d5d8d4"
    },
    grey: {
        50: "#FFFFFF",
        100: "#ffffff",
        200: "#dadada",
        300: "#363636",
        400: "#292929",
        500: "#212121",
        600: "#1a1a1a",
        700: "#1c1c1c",
        800: "#171717",
        900: "#121212",
        950: "#101010"
    },
    orange: {
        200: "#645a5a",
        300: "#5a5151",
        500: "#504848",
        600: "#261515",
        700: "#290e0e",
        800: "#1a0e0e"
    }
}
  , yb = {
    yellow: {
        200: "#F7DC85",
        500: "#F0B90B",
        700: "#5A4D22",
        800: "#3B3827"
    },
    purple: {
        200: "#C7A4F9",
        500: "#8E49F4",
        600: "#41315C",
        800: "#312C3E"
    },
    blue: {
        200: "#90A8FA",
        500: "#2151F5",
        600: "#25335C",
        800: "#262D3F"
    },
    lavender: {
        200: "#B3BDF1",
        500: "#677CE2",
        600: "#373E58",
        800: "#2D313D"
    },
    black: {
        700: "#161616BF"
    },
    gold: {
        500: "#EDCA07"
    },
    silver: {
        500: "#D1D1D6"
    },
    bronze: {
        500: "#D19849"
    }
}
  , kb = {
    red: {
        200: "#FFCAD6",
        500: "#FF4B92",
        600: "#B43F67",
        700: "#9B375A",
        900: "#4A1D2E"
    },
    green: {
        200: "#3ED6CB",
        500: "#3ED6CB",
        600: "#28A891",
        700: "#174C3D",
        900: "#106E5A"
    },
    grey: {
        50: "#FFFFFF",
        100: "#F5F5F5",
        200: "#B3B6D9",
        300: "#2E303A",
        400: "#505158",
        500: "#25262E",
        600: "#303037",
        700: "#2A2B34",
        800: "#23242C",
        900: "#1F2028",
        950: "#181921"
    },
    orange: {
        200: "#8E9DFF",
        300: "#FF9D6A",
        500: "#8E9DFF",
        600: "#6F7DD8",
        700: "#545EB3",
        800: "#3B448A"
    }
}
  , Cb = {
    yellow: {
        200: "#F9E3A3",
        500: "#F4C20E",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , Ab = {
    red: {
        200: "#F87171",
        500: "#F87171",
        600: "#6E4246",
        700: "#A13C43",
        900: "#5F2428"
    },
    green: {
        200: "#62DC5D",
        500: "#5DDF6C",
        600: "#357856",
        700: "#174C3E",
        900: "#285C42"
    },
    grey: {
        50: "#FAFAFA",
        100: "#F5F5F5",
        200: "#A1A1AA",
        300: "#303336",
        400: "#505157",
        500: "#2A2C39",
        600: "#303038",
        700: "#303036",
        800: "#222225",
        900: "#18181B",
        950: "#0F0F12"
    },
    orange: {
        200: "#62DC9C",
        300: "#86EFAC",
        500: "#86EFAC",
        600: "#3A6F4F",
        700: "#355D41",
        800: "#1C402D"
    }
}
  , wb = {
    yellow: {
        200: "#F9E3A3",
        500: "#F4C20E",
        700: "#6C5B30",
        800: "#4A4530"
    },
    purple: {
        200: "#D3B9FA",
        500: "#A262F7",
        600: "#554072",
        800: "#423A4D"
    },
    blue: {
        200: "#A6B9FC",
        500: "#3A6EF7",
        600: "#3C4A70",
        800: "#353D52"
    },
    lavender: {
        200: "#C7CCE6",
        500: "#8094E8",
        600: "#464E6A",
        800: "#3B3F50"
    },
    black: {
        700: "#1A1A1AC0"
    },
    gold: {
        500: "#F2D10A"
    },
    silver: {
        500: "#E0E0E5"
    },
    bronze: {
        500: "#E1A860"
    }
}
  , jb = e => Object.fromEntries(Object.entries(e).filter((e => null !== e[1])))
  , Tb = e => {
    const [,t,n] = Mb(e);
    return t < 30 && n > 25
}
  , Ib = e => {
    const [,,t] = Mb(e);
    return t >= 30
}
  , Eb = e => {
    const [,,t] = Mb(e);
    return t > 65
}
  , Mb = e => {
    const t = parseInt(e.substring(1, 3), 16) / 255
      , n = parseInt(e.substring(3, 5), 16) / 255
      , r = parseInt(e.substring(5, 7), 16) / 255
      , a = Math.max(t, n, r)
      , s = Math.min(t, n, r);
    let o = 0
      , l = 0;
    const i = (a + s) / 2;
    if (a !== s) {
        const e = a - s;
        switch (l = i > .5 ? e / (2 - a - s) : e / (a + s),
        a) {
        case t:
            o = (n - r) / e + (n < r ? 6 : 0);
            break;
        case n:
            o = (r - t) / e + 2;
            break;
        case r:
            o = (t - n) / e + 4
        }
        o /= 6
    }
    return [Math.round(360 * o), Math.round(100 * l), Math.round(100 * i)]
}
  , Nb = (e, t, n) => {
    const r = lb(t, {
        min: 0,
        max: 100
    }) / 100
      , a = lb(n, {
        min: 0,
        max: 100
    }) / 100
      , s = t => (t + lb(e % 360, {
        min: 0,
        max: 360
    }) / 30) % 12
      , o = r * Math.min(a, 1 - a)
      , l = e => Math.round(255 * (a - o * Math.max(-1, Math.min(s(e) - 3, Math.min(9 - s(e), 1)))));
    return `#${l(0).toString(16).padStart(2, "0")}${l(8).toString(16).padStart(2, "0")}${l(4).toString(16).padStart(2, "0")}`
}
  , Pb = e => {
    if (e.useSpecific && e.specific && e.defaultSkin) {
        const t = Rb[e.defaultSkin];
        return {
            ...t,
            red: {
                ...t.red,
                ...jb(e.specific.red)
            },
            green: {
                ...t.green,
                ...jb(e.specific.green)
            },
            grey: {
                ...t.grey,
                ...jb(e.specific.grey)
            },
            orange: {
                ...t.orange,
                ...jb(e.specific.orange)
            }
        }
    }
    const t = e.useSpecific ? e.specific : null
      , n = lx(e.customRed) ? e.customRed : Bb.customRed
      , r = lx(e.customGreen) ? e.customGreen : Bb.customGreen
      , a = lx(e.customPrimary) ? e.customPrimary : Bb.customPrimary
      , s = lx(e.customGray) ? e.customGray : Bb.customGray
      , [o,l,i] = Mb(s)
      , c = Ib(s)
      , d = lx(e.customBg) ? e.customBg : Bb.customBg
      , [u,p,h] = Mb(d)
      , m = Eb(d);
    return {
        red: {
            ...Lb(n),
            ...t ? jb(t.red) : {}
        },
        green: {
            ...Lb(r),
            ...t ? jb(t.green) : {}
        },
        grey: {
            50: Nb(o, l, c ? 1.59 * i : .63 * i),
            100: Nb(o, l, c ? 1.42 * i : .7 * i),
            200: s,
            300: Nb(u, p, m ? h - 15 : h + 15),
            400: Nb(u, p, m ? h - 10 : h + 10),
            500: Nb(u, p, m ? h - 7 : h + 7),
            600: Nb(u, p, m ? h - 4 : h + 4),
            700: Nb(u, p, m ? h - 5 : h + 5),
            800: Nb(u, p, m ? h - 3 : h + 3),
            900: Nb(u, p, m ? h - 1 : h + 1),
            950: d,
            ...t ? jb(t.grey) : {}
        },
        orange: {
            ...Ob(a),
            ...t ? jb(t.orange) : {}
        }
    }
}
  , Ob = e => {
    const [t,n,r] = Mb(e);
    return {
        200: Nb(t, n, 1.245 * r),
        300: Nb(t, n, 1.12 * r),
        500: e,
        600: Nb(t - 2, 29, .39 * r),
        700: Nb(t - 1, 48, .36 * r),
        800: Nb(t, 30, .26 * r)
    }
}
  , Lb = e => {
    const [t,n,r] = Mb(e)
      , a = Tb(e);
    return {
        200: Nb(t + 3, lb(a ? .87 * n : .79 * n, {
            min: 35,
            max: 97
        }), lb(a ? 1.35 * r : 1.48 * r, {
            min: 35,
            max: 86
        })),
        500: e,
        600: Nb(t, lb(a ? .41 * n : 2.41 * n, {
            min: 13,
            max: 86
        }), lb(a ? 1.81 * r : .47 * r, {
            min: 13,
            max: 90
        })),
        700: Nb(t - 5, lb(a ? .46 * n : 2.17 * n, {
            min: 8,
            max: 90
        }), lb(a ? 2.32 * r : .43 * r, {
            min: 8,
            max: 92
        })),
        900: Nb(t, lb(a ? .32 * n : 3.12 * n, {
            min: 5,
            max: 94
        }), lb(a ? 3.7 * r : .27 * r, {
            min: 5,
            max: 84
        }))
    }
}
  , Rb = {
    [Xh.DARK]: pb,
    [Xh.GREY]: mb,
    [Xh.GREEN]: ib,
    [Xh.PURPLE]: db,
    [Xh.MONOKAI]: fb,
    [Xh.VIOLET]: kb,
    [Xh.INDIGO]: xb,
    [Xh.NOIR]: Sb,
    [Xh.TERMINAL]: Ab
}
  , Db = {
    red: {
        200: null,
        500: null,
        600: null,
        700: null,
        900: null
    },
    green: {
        200: null,
        500: null,
        600: null,
        700: null,
        900: null
    },
    grey: {
        50: null,
        100: null,
        200: null,
        300: null,
        400: null,
        500: null,
        600: null,
        700: null,
        800: null,
        900: null,
        950: null
    },
    orange: {
        200: null,
        300: null,
        500: null,
        600: null,
        700: null,
        800: null
    },
    yellow: {
        200: null,
        500: null,
        700: null,
        800: null
    },
    purple: {
        200: null,
        500: null,
        600: null,
        800: null
    },
    blue: {
        200: null,
        500: null,
        600: null,
        800: null
    },
    lavender: {
        200: null,
        500: null,
        600: null,
        800: null
    },
    gold: {
        500: null
    },
    silver: {
        500: null
    },
    bronze: {
        500: null
    }
}
  , Bb = {
    customPrimary: "#FF7324",
    customRed: "#E73A44",
    customGreen: "#17C671",
    customGray: "#A0A0A0",
    customBg: "#171717",
    useSpecific: !1,
    specific: Db,
    defaultSkin: null
}
  , _b = rg.TERMINAL
  , Ub = ku.GEIST
  , Wb = y.createContext({
    setColorSkin: c.noop,
    colorSkin: _b,
    customStyleConfig: Bb,
    customStyleConfig2: Bb,
    updateCustomStyleConfig: c.noop,
    updateCustomStyleConfig2: c.noop,
    isCustomRedLight: !1,
    isCustomGreenLight: !1,
    isCustomTextLight: !1,
    isCustomBgLight: !1,
    font: ku.PADRE_PLEX,
    setFont: c.noop,
    defaultThemeSkin: null
})
  , Fb = y.memo(( ({children: e}) => {
    const [t,n] = Mx("padreV2-userThemeType", _b)
      , [r,a] = Mx("padreV2-userThemeFont", Ub)
      , [s,o] = Mx("padreV2-userThemeCustomConfig", Bb)
      , l = y.useCallback((e => {
        o(e)
    }
    ), [o])
      , [i,c] = Mx("padreV2-userThemeCustomConfig2", Bb)
      , d = y.useCallback((e => {
        c(e)
    }
    ), [c])
      , [u,p,h,m] = y.useMemo(( () => {
        if (![rg.CUSTOM, rg.CUSTOM_2].includes(t))
            return [!1, !1, !1, !1];
        const e = t === rg.CUSTOM ? s : i;
        return [!!e.customRed && Tb(e.customRed), !!e.customGreen && Tb(e.customGreen), !!e.customGreen && Ib(e.customGray), !!e.customGreen && Eb(e.customBg)]
    }
    ), [t, s, i])
      , g = y.useMemo(( () => t === rg.CUSTOM ? s.defaultSkin ?? null : t === rg.CUSTOM_2 ? i.defaultSkin ?? null : null), [t, s.defaultSkin, i.defaultSkin])
      , x = y.useMemo(( () => ({
        setColorSkin: n,
        colorSkin: t,
        customStyleConfig: s,
        customStyleConfig2: i,
        updateCustomStyleConfig: l,
        updateCustomStyleConfig2: d,
        isCustomRedLight: u,
        isCustomGreenLight: p,
        isCustomTextLight: h,
        isCustomBgLight: m,
        font: r,
        setFont: a,
        defaultThemeSkin: g
    })), [t, s, i, p, u, h, m, n, l, d, r, a, g]);
    return v.jsx(Wb.Provider, {
        value: x,
        children: e
    })
}
))
  , Vb = () => y.useContext(Wb)
  , Hb = () => {
    var e;
    const t = (null == (e = VK().user) ? void 0 : e.uid) ?? null
      , n = y.useCallback((e => t ? ym.subscribeWalletGroups(t, e) : {
        unsubscribe: () => {}
    }), [t]);
    return yx(n)
}
  , zb = e => "Inferno" === e
  , $b = [Pd.SOLANA]
  , Gb = (e, t, n, r) => {
    if (r >= 4)
        return 0;
    const a = qb(t, e ?? Dx)[n] ?? qb(t, Dx)[n];
    return a.length > r ? a[r] : 0
}
  , qb = (e, t) => {
    switch (e) {
    case Ox.NATIVE:
        return t.native ?? Dx.native;
    case Ox.STABLE:
        return t.stable ?? Dx.stable;
    case Ox.PERCENTAGE:
        return t.percentage ?? Dx.percentage;
    case Ox.INSTANT_SELL_NATIVE:
        return t.instantSellNativeValues ?? Dx.instantSellNativeValues
    }
}
  , Kb = (e, t, n, r) => {
    if (zb(t))
        return null;
    return (((e || Bx)[n] || Bx[n])[r] || Bx[n][r])[t] || Bx[n][r][t]
}
  , Yb = (e, t) => {
    switch (e) {
    case Lx.FILL:
        return {
            fillLineColor: t
        };
    case Lx.SELL:
        return {
            exitLineColor: t
        };
    case Lx.TOP_HOLDERS_ENTRY:
        return {
            top10HoldersEntryLineColor: t
        };
    case Lx.TOP_HOLDERS_EXIT:
        return {
            top10HoldersExitLineColor: t
        };
    case Lx.PRICE_ALERT_ABOVE:
        return {
            abovePriceAlertLineColor: t
        };
    case Lx.PRICE_ALERT_BELOW:
        return {
            belowPriceAlertLineColor: t
        }
    }
}
  , Xb = ({children: e}) => {
    const {user: t} = VK()
      , n = (null == t ? void 0 : t.uid) ?? null
      , r = y.useCallback((e => t ? ym.onSettingsUpdated(t.uid, e) : {
        unsubscribe: () => {}
    }), [t])
      , a = yx(r)
      , s = ob(a)
      , [o,l] = y.useState({
        status: ox.INITIAL
    })
      , i = mx(Hb())
      , d = mx(y.useMemo(( () => i ? null == i ? void 0 : i.sort(( (e, t) => e.createdAt - t.createdAt)) : null), [i]))
      , u = mx(( () => {
        var e;
        const t = (null == (e = VK().user) ? void 0 : e.uid) ?? null
          , n = y.useCallback((e => t ? ym.subscribeCustomWalletNames(t, e) : {
            unsubscribe: () => {}
        }), [t]);
        return yx(n)
    }
    )())
      , [p,h] = dx("padreV2-extraInputButtons", !1)
      , m = y.useCallback(( () => {
        h((e => !e))
    }
    ), [h])
      , g = y.useCallback(( (e, t) => {
        if (!n || !s)
            return;
        const r = null !== e && !c.isEqual(s.hiddenPairs, e)
          , a = null !== t && !c.isEqual(s.hiddenMigratedPairs, t);
        (r || a) && ym.updateSettings(n, {
            ...r && e ? {
                hiddenPairs: e
            } : {},
            ...a && t ? {
                hiddenMigratedPairs: t
            } : {}
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , x = y.useCallback(( (e, t) => {
        if (!n)
            return;
        const r = {
            [e]: t
        };
        "disableAutoApprove" === e && (r[e] = !t),
        ym.updateSettings(n, r).catch((e => {}
        ))
    }
    ), [n])
      , b = y.useCallback((e => {
        n && ym.updateSettings(n, {
            sidebarVisibleSections: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , f = y.useCallback(( (e, t, r, a, o=!1) => {
        if (!n)
            return;
        if (e < 0)
            return;
        if (a >= 4)
            return;
        const l = o ? (null == s ? void 0 : s.extraAmountInputPresets) ? {
            native: s.extraAmountInputPresets.native ?? Dx.native,
            stable: s.extraAmountInputPresets.stable ?? Dx.stable,
            percentage: s.extraAmountInputPresets.percentage ?? Dx.percentage,
            instantSellNativeValues: s.extraAmountInputPresets.instantSellNativeValues ?? Dx.instantSellNativeValues
        } : Dx : (null == s ? void 0 : s.amountInputPresets) ? {
            native: s.amountInputPresets.native ?? Dx.native,
            stable: s.amountInputPresets.stable ?? Dx.stable,
            percentage: s.amountInputPresets.percentage ?? Dx.percentage,
            instantSellNativeValues: s.amountInputPresets.instantSellNativeValues ?? Dx.instantSellNativeValues
        } : Dx
          , i = t === Ox.NATIVE ? l.native : t === Ox.PERCENTAGE ? l.percentage : t === Ox.STABLE ? l.stable : l.instantSellNativeValues
          , c = i ? i[r] ?? (t === Ox.NATIVE ? Dx.native : t === Ox.PERCENTAGE ? Dx.percentage : t === Ox.STABLE ? Dx.stable : Dx.instantSellNativeValues)[r] : [];
        if (c.length > a && e === c[a])
            return;
        const d = ( (e, t, n) => {
            if (t < 0)
                return e;
            if (t >= e.length) {
                const r = [...e];
                for (let n = e.length; n <= t; n++)
                    r.push(0);
                return r[t] = n,
                r
            }
            {
                const r = [...e];
                return r[t] = n,
                r
            }
        }
        )(c, a, e)
          , u = {
            [t === Ox.NATIVE ? "native" : t === Ox.PERCENTAGE ? "percentage" : t === Ox.STABLE ? "stable" : "instantSellNativeValues"]: {
                ...i ?? {},
                [r]: d
            }
        }
          , p = {
            ...l,
            ...u
        };
        ym.updateSettings(n, o ? {
            extraAmountInputPresets: p
        } : {
            amountInputPresets: p
        }).catch((e => {}
        ))
    }
    ), [null == s ? void 0 : s.amountInputPresets, null == s ? void 0 : s.extraAmountInputPresets, n])
      , S = y.useCallback(( (e, t, n, r) => {
        f(e, t, n, r)
    }
    ), [f])
      , k = y.useCallback(( (e, t, n, r) => {
        f(e, t, n, r, !0)
    }
    ), [f])
      , C = y.useCallback(( (e, t, r, a) => {
        if (!n || !Object.keys(e).length)
            return;
        const o = (null == s ? void 0 : s.orderPresets) ?? Bx
          , l = o[t] ?? Bx[t]
          , i = l[r] ?? Bx[t][r]
          , c = i[a] ?? Bx[t][r][a]
          , d = {
            ...o,
            [t]: {
                ...l,
                [r]: {
                    ...i,
                    [a]: {
                        ...c,
                        ...e
                    }
                }
            }
        };
        ym.updateSettings(n, {
            orderPresets: d
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , A = y.useCallback((e => {
        n && ym.updateSettings(n, {
            quickInputMode: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , w = y.useCallback((e => {
        n && ym.updateSettings(n, {
            lastSeenNewsId: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , j = y.useCallback((e => {
        n && ym.updateSettings(n, {
            pageTitleMode: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , T = y.useCallback((e => {
        n && ym.updateSettings(n, {
            airdropWalletAddress: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , I = y.useCallback((e => {
        n && ym.updateSettings(n, {
            solanaStopOrderMaxRevertRetry: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , E = y.useCallback((e => {
        n && ym.updateSettings(n, {
            multiWalletsTradeSpread: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , M = y.useCallback((e => {
        n && ym.updateSettings(n, {
            multiWalletsTradeDelay: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , N = y.useCallback((e => {
        var t;
        if (!n)
            return;
        const r = ng(e);
        if (lu.has(r))
            return;
        if (null == (t = null == s ? void 0 : s.devBlacklist) ? void 0 : t.includes(r))
            return;
        const a = [e, ...(null == s ? void 0 : s.devBlacklist) ?? []];
        ym.updateSettings(n, {
            devBlacklist: a
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , P = y.useCallback((e => {
        if (!n)
            return;
        const t = ng(e);
        if (!(null == s ? void 0 : s.devBlacklist) || !s.devBlacklist.includes(t))
            return;
        const r = s.devBlacklist.filter((e => e !== t));
        ym.updateSettings(n, {
            devBlacklist: r
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , O = y.useCallback(( () => {
        n && ym.updateSettings(n, {
            devBlacklist: []
        }).catch((e => {}
        ))
    }
    ), [n])
      , L = y.useCallback((e => {
        var t;
        if (!n)
            return;
        if (null == (t = null == s ? void 0 : s.handlesBlacklist) ? void 0 : t.includes(e))
            return;
        const r = [e, ...(null == s ? void 0 : s.handlesBlacklist) ?? []];
        ym.updateSettings(n, {
            handlesBlacklist: r
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , R = y.useCallback((e => {
        if (!n)
            return;
        if (!(null == s ? void 0 : s.handlesBlacklist) || !s.handlesBlacklist.includes(e))
            return;
        const t = s.handlesBlacklist.filter((t => t !== e));
        ym.updateSettings(n, {
            handlesBlacklist: t
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , D = y.useCallback(( () => {
        n && ym.updateSettings(n, {
            handlesBlacklist: []
        }).catch((e => {}
        ))
    }
    ), [n])
      , B = y.useCallback((e => {
        n && ym.updateSettings(n, {
            pnlTrackerInitialValue: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , _ = y.useCallback((e => {
        n && ym.updateSettings(n, {
            pnlTrackerInitialValueBsc: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , U = y.useCallback(( (e, t, r) => {
        n && ym.updateSettings(n, t === xc.BUY ? r ? {
            buySuccessSound: e
        } : {
            buyFailedSound: e
        } : r ? {
            sellSuccessSound: e
        } : {
            sellFailedSound: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , W = y.useCallback((e => {
        n && ym.updateSettings(n, {
            tradeSoundVolume: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , F = y.useCallback((e => {
        n && ym.updateSettings(n, {
            tradeNotificationsDuration: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , V = y.useCallback((e => {
        n && ym.updateSettings(n, {
            markPriceMode: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , H = y.useCallback(( (e, t) => {
        n && ix(e) && ym.updateSettings(n, Yb(t, e)).catch((e => {}
        ))
    }
    ), [n])
      , z = y.useCallback((e => {
        if (!n)
            return;
        const t = Object.entries(e).reduce(( (e, [t,n]) => {
            if (!ix(n))
                return e;
            const r = Yb(t, n);
            return {
                ...e,
                ...r
            }
        }
        ), {});
        ym.updateSettings(n, t).catch((e => {}
        ))
    }
    ), [n])
      , $ = y.useCallback(( (e, t) => {
        n && ym.updateSettings(n, 1 === t ? {
            customColors1: e
        } : {
            customColors2: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , G = y.useCallback((e => {
        if (!n || !s)
            return;
        const t = {
            ...s.chartMarkersColors ? {
                ...s.chartMarkersColors
            } : {},
            ...e
        };
        ym.updateSettings(n, {
            chartMarkersColors: t
        }).catch((e => {}
        ))
    }
    ), [n, s])
      , q = y.useCallback(( (e, t) => {
        G({
            [t]: e
        })
    }
    ), [G])
      , K = y.useCallback((e => {
        n && ym.updateSettings(n, {
            remainingBasis: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , Y = y.useCallback((e => {
        n && ym.updateSettings(n, {
            topBarPosition: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , {customStyleConfig: X, customStyleConfig2: Q, updateCustomStyleConfig: Z, updateCustomStyleConfig2: J} = Vb()
      , ee = !!s
      , [te,ne] = y.useState(!1);
    y.useEffect(( () => {
        ee && !te && n && (s.customColors1 && !c.isEqual(X, s.customColors1) && (Z(s.customColors1),
        rx()),
        s.customColors2 && !c.isEqual(Q, s.customColors2) && (J(s.customColors2),
        rx()),
        (async () => {
            try {
                const e = s.customColors1 && s.customColors2 ? null : {
                    ...s.customColors1 ? {} : {
                        customColors1: X
                    },
                    ...s.customColors2 ? {} : {
                        customColors2: Q
                    }
                };
                e && await ym.updateSettings(n, e)
            } catch (fNe) {} finally {
                ne(!0)
            }
        }
        )())
    }
    ), [te, X, Q, ee, null == s ? void 0 : s.customColors1, null == s ? void 0 : s.customColors2, n, Z, J]);
    const [re,ae] = dx("padreV2-chartVioletColorsResynced", !1);
    y.useEffect(( () => {
        ee && !re && (sx(rg.VIOLET, ["#181921"]),
        ae(!0))
    }
    ), [ee, ae, re]);
    const [se,oe] = dx("padreV2-chartIndigoColorsResyncedV2", !1);
    y.useEffect(( () => {
        ee && !se && (sx(rg.INDIGO, ["#06070B", "#2FE3AC"]),
        oe(!0))
    }
    ), [ee, oe, se]),
    y.useEffect(( () => {
        let e = !1;
        if (n) {
            if (o.status !== ox.READY)
                return (async () => {
                    try {
                        const t = await ym.getEarlyAccessScope(n);
                        if (e)
                            return;
                        l({
                            status: ox.READY,
                            data: t.canAccess
                        })
                    } catch (fNe) {
                        if (await Hu(Qb),
                        e)
                            return;
                        l({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    e = !0
                }
        } else
            l({
                status: ox.INITIAL
            })
    }
    ), [o.status, n]);
    const [le,ie] = dx("padreV2-desktopNavigationOrder", Wx)
      , [ce,de] = dx("padreV2-mobileNavigationOrder", Fx);
    y.useEffect(( () => {}
    ), [s]);
    const [ue,pe] = y.useState(!1);
    y.useEffect(( () => {
        ee && !ue && n && (s.navigationOrderDesktop && !c.isEqual(le, s.navigationOrderDesktop) && ie(s.navigationOrderDesktop),
        s.navigationOrderMobile && !c.isEqual(ce, s.navigationOrderMobile) && de(s.navigationOrderMobile),
        (async () => {
            try {
                const e = s.navigationOrderDesktop && s.navigationOrderMobile ? null : {
                    ...s.navigationOrderDesktop ? {} : {
                        navigationOrderDesktop: le
                    },
                    ...s.navigationOrderMobile ? {} : {
                        navigationOrderMobile: ce
                    }
                };
                e && await ym.updateSettings(n, e)
            } catch (fNe) {} finally {
                pe(!0)
            }
        }
        )())
    }
    ), [ee, le, ce, ue, ie, de, s, n]);
    const he = y.useCallback(( (e, t) => {
        n && (t ? de(e) : ie(e),
        ym.updateSettings(n, t ? {
            navigationOrderMobile: e
        } : {
            navigationOrderDesktop: e
        }).catch((e => {}
        )))
    }
    ), [ie, de, n])
      , me = y.useCallback((e => {
        n && ym.updateSettings(n, {
            tokenAvatarPreviewSize: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , ge = y.useCallback((e => {
        n && ym.updateSettings(n, {
            twitterSearchExclusions: e
        }).catch((e => {}
        ))
    }
    ), [n])
      , xe = y.useMemo(( () => (ue ? le ?? (null == s ? void 0 : s.navigationOrderDesktop) ?? Wx : le).filter((e => e !== Kh.AUTOMATIONS))), [le, null == s ? void 0 : s.navigationOrderDesktop, ue])
      , be = y.useMemo(( () => (ue ? ce ?? (null == s ? void 0 : s.navigationOrderMobile) ?? Fx : ce).filter((e => e !== Kh.AUTOMATIONS))), [ce, null == s ? void 0 : s.navigationOrderMobile, ue])
      , fe = y.useMemo(( () => a ? a.syncedLocalStorage ? {
        ...a.syncedLocalStorage
    } : {} : null), [a]);
    Tx(fe);
    const [ve,Se] = Mx("padreV2-chartForceAutoScale", !1)
      , ye = y.useCallback(( () => {
        Se((e => !e))
    }
    ), [Se])
      , [ke,Ce] = Mx("padreV2-chartHoldersLinePosition", Gx)
      , [Ae,we] = Mx("padreV2-chartHoldersLineMode", qx)
      , [je,Te] = Mx("padreV2-chartLinesVisibility", Kx, eb)
      , [Ie,Ee] = Mx("padreV2-hideLines", !1)
      , [Me,Ne] = Mx("padreV2-chartMarkersVisibility", Yx, tb)
      , [Pe,Oe] = Mx("padreV2-hideMarkers", !1);
    y.useEffect(( () => {}
    ), [ee, n]);
    const Le = y.useMemo(( () => ({
        settings: s,
        earlyAccess: o.status === ox.READY ? o.data : null,
        updateHiddenPairs: g,
        updateBooleanSetting: x,
        updateSidebarVisibleSections: b,
        updateAmountInputPreset: S,
        updateExtraAmountInputPreset: k,
        updateOrderPreset: C,
        updateQuickInputMode: A,
        updateLastSeenNewsId: w,
        updatePageTitleModeSetting: j,
        updateAirdropWallet: T,
        updateSolanaMaxRevertRetry: I,
        updateMultiWalletsSpread: E,
        updateMultiWalletsDelay: M,
        addToDevBlacklist: N,
        removeFromDevBlacklist: P,
        clearBlacklist: O,
        addToHandlesBlacklist: L,
        removeFromHandlesBlacklist: R,
        clearHandlesBalcklist: D,
        updatePnlTrackerInitialValue: B,
        updatePnlTrackerInitialValueBsc: _,
        updateTradeSound: U,
        updateTradeSoundVolume: W,
        updateTradeNotificationsDuration: F,
        updateMarkPriceMode: V,
        updateLineColor: H,
        updateLinesColors: z,
        updateCustomColors: $,
        updateChartMarkersColors: q,
        updateMultipleChartMarkersColors: G,
        chartMarkersVisibility: Me,
        setChartMarkersVisibility: Ne,
        updateRemainingBasisMode: K,
        updateTopBarPosition: Y,
        walletGroups: d,
        customWalletNames: (null == u ? void 0 : u.names) ?? Zb,
        customWalletEmojis: (null == u ? void 0 : u.emojis) ?? Jb,
        customWalletSilenced: (null == u ? void 0 : u.silenced) ?? ef,
        customWalletOnChart: (null == u ? void 0 : u.onChart) ?? tf,
        customWalletOnLiveTrades: (null == u ? void 0 : u.onLiveTrades) ?? nf,
        extraInputPresets: p,
        toggleExtraInputPresets: m,
        desktopNavigationOrder: xe,
        mobileNavigationOrder: be,
        updateNavigationOrder: he,
        updateTokenAvatarPreviewSize: me,
        updateTwitterSearchExclusions: ge,
        chartForceAutoScale: ve,
        toggleChartForceAutoScale: ye,
        chartHoldersLinesPosition: ke,
        setChartHoldersLinesPosition: Ce,
        chartHoldersLinesMode: Ae,
        setChartHoldersLinesMode: we,
        chartLinesVisibility: je,
        setChartLinesVisibility: Te,
        hideChartLines: Ie,
        setHideChartLines: Ee,
        hideChartMarkers: Pe,
        setHideChartMarkers: Oe
    })), [s, o, g, x, b, S, k, C, A, w, j, T, I, E, M, N, P, O, L, R, D, B, _, U, W, F, V, H, z, $, q, G, Me, Ne, K, Y, d, null == u ? void 0 : u.names, null == u ? void 0 : u.emojis, null == u ? void 0 : u.silenced, null == u ? void 0 : u.onChart, null == u ? void 0 : u.onLiveTrades, p, m, xe, be, he, me, ge, ve, ye, ke, Ce, Ae, we, je, Te, Ie, Ee, Pe, Oe]);
    return v.jsx(Xx.Provider, {
        value: Le,
        children: e
    })
}
  , Qb = 5e3
  , Zb = {}
  , Jb = {}
  , ef = {}
  , tf = {}
  , nf = {}
  , rf = () => y.useContext(Xx)
  , af = new Set(["0dd1b971a01a17852e4fcbf04eef1367e2e0e3dab39b64463007b7ed5691931d", "13702a493bb22157de3979f84fc434def6c90cb6f08f2578a9e925db4fb847da", "142727523303d192c26b96c83a76be35f8055fe9b3aaf3c5a662be57594c7198", "1be74af1fba67e610f71f454ba112efbc3431029d2951ef09674a6f859e9b207", "26f54f3175e40a4ee4c1967c85c0c613f7d26a72f61ab819aabef6dd09477fd0", "29152c04c93f84be771c053543384153829ab3b291bc37b0df20ead4f6ca62a6", "329bda1210a3c49fe2cc78a69edd6d39a9587728541b7d8988ddd47c24ce842d", "36854b4ef83251becdeeb3b8641712fd45e4b5d15748b2f96456835fe8941339", "487a54202350ceb7b704af804ccdb57779dd08296e1c9c21e768aa874952eb23", "4a1203081ee5540d672ad20408a1196e48b5014e3243cacc6277f3b8087acdb0", "4dc363e53e4d3513c1263684b98b022119c790db0c10abda1772c31942c0e932", "4e87efd2566f18579f323f324be63ccd74859bcd49eb872b4e2c5aeb2e8012b6", "538139fc9a9faa4e4937233bb006fea9c0eed988fb80b790b1812eace91ec4eb", "5df395f63382d508a2280059264b4ed70940a70db2b0fbf9fbb1ea10cdbb4eb3", "642a1e25a7ed93e028cb7f30916f253f49f26a950e5d5a147ac7bfd32c7f652c", "7089ee41e7d3a4006e11b12c82ba982f2b628bd46e4d79b8bb660dd0b459452b", "9476a20f3c88533cd94fc6b2861fbfde189eabb97239968dd7a8b01bf03e8f54", "993fe745dce591c7e393972382830d1d1ce1b8f9c37897944a957f1ef6669c48", "9cdbc9562e771907e053e3a59e829e96363cfe986df54bde3ccf9994eb70c95f", "9ff7776de5be8866810c4f694f65d471f1e22d8916547dc2ac9ab4a316c1c4c8", "a0b6c8cc861350897eba995fff60c27167f6b5f98c4a85d0092b164720aa53db", "ac98e81a3fdc70a9c44839b803108541fc7db93aaa09201805522ade4f01c21e", "c1dc3339784d8251a1995c0d359e8b5d1c01b5f03213c2bbbb74190c0482086e", "c9ba7472d81013b64e0c8a630c506ead0c1b17c4be7ea641c3dd0433db9e6fe0", "cdb84d601bd7195c86b790f88b9e44acd4ccc63a7a6aea20f9de277f06618865", "ce1290364ae0e51a526dec1a0f63e27a96756d57a6a7b3ebfa88d94f73d6c368", "ceceeeb6db7c74f75a38b09ccb9aa0bb7123d576759c37f6a30fb6ea48594387", "d18ac9c2541357d764bd1ab747e9bfbe4d6c2dcaae7f7a92b96d38e19972ed3a", "e2f07082fef6b7a8f1cc89cfdc4c8674431b64aaf55bec4691f7e3eefc49b7b6", "ec1c513eede1eefdfe47dfcce9f8cf9a7ff87924a41b9c60295130f099b3e454", "ec9e11920b2e4e1b89072b2affd8a3ed70e518b3f5818cce8207e64d3137b029", "fdb301b358118c1fb6a5a4bfb31b536e7ae14078d831ce51af240c32c0abc909", "8cbbedfc459b6bb2e3c267b92a641bef8b63d2e6d03fd291c0cbc6bea9ee00de", "fa42cb192fca4e8bcaa53fddd90a5cc23becc1e7e352f7a3ee7be1f5f26d730b", "93f91fb987cdda7b90d938c1f8cfb652d328f75493bf03896ad93f5fd9f64cdb", "ab652d90114d17e443a4fd48e388b4ec9965e8a9f2f3997a51cc08c8e3b4d193", "f3c4495094277e06c5b5a68c46b710c3f5fbb1e44759bb90a3562357d53560a0", "cf356b395184c7c8b5552fc291152df00a583c8275781e1f8cb3d9ffac17361f", "dcee43904b3b6fccd50ee617036ee97011a2e4899c02afe349124371484aaf96", "e58d138f2a6fefce85464d2c1a5bbc7897918e6fe1c25ba2d25af852841fa49d"])
  , sf = async (e, t) => {
    try {
        const n = (new TextEncoder).encode(e)
          , r = await crypto.subtle.digest("SHA-256", n)
          , a = Array.from(new Uint8Array(r)).map((e => e.toString(16).padStart(2, "0"))).join("");
        return t.has(a)
    } catch (W$e) {
        return !1
    }
}
  , of = (e, t=0) => {
    let n = 3735928559 ^ t
      , r = 1103547991 ^ t;
    for (let a, s = 0; s < e.length; s++)
        a = e.charCodeAt(s),
        n = Math.imul(n ^ a, 2654435761),
        r = Math.imul(r ^ a, 1597334677);
    n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(r ^ r >>> 13, 3266489909),
    r = Math.imul(r ^ r >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909);
    return Number(4294967296 * (2097151 & r) + (n >>> 0)).toString(36)
}
;
window._padre_cyrb53 = of;
const lf = e => {
    if (!e)
        return "unknown";
    switch (e) {
    case ic.MARKET_BUY:
    case ic.MARKET_SELL:
        return "market";
    case ic.BUY_DIP:
        return "buy_dip";
    case ic.STOP_LOSS:
        return "stop_loss";
    case ic.TAKE_PROFIT:
        return "take_profit";
    case ic.TRAILING_STOP_LOSS:
        return "trailing_stop_loss";
    case ic.DEV_SELL_BUY:
    case ic.DEV_SELL_SELL:
        return "dev_sell";
    case "SELL_INIT":
        return "sell_init"
    }
}
  , cf = "f259317776e8d4d722cf5f6de613d9b5"
  , df = e => "SELL_INIT" === e ? xc.SELL : jc(e)
  , uf = y.createContext(Jm);
uf.displayName = "MixpanelContext";
const pf = y.memo(( ({children: e}) => {
    const [t,n] = y.useState()
      , [r,a] = y.useState(!1)
      , [s,o] = y.useState(null)
      , [l,i] = y.useState(!1)
      , [c,d] = y.useState(!1)
      , {colorSkin: u} = Vb();
    y.useEffect(( () => {
        s && s.register({
            colorSkin: u
        })
    }
    ), [s, u]),
    y.useEffect(( () => {
        if (s)
            return;
        const e = L.init(cf, Qm, "padre-mixpanel-v2");
        e.register(Zm),
        o(e)
    }
    ), [s, t, o]),
    y.useEffect(( () => {
        if (s) {
            if (!t)
                return s.reset(),
                s.register({
                    colorSkin: u
                }),
                a(!1),
                i(!1),
                void d(!1);
            s.identify(t),
            (async () => {
                try {
                    null == window || window.hj("identify", t, {
                        uid: t,
                        isTeam: await sf(t, af)
                    })
                } catch (W$e) {}
            }
            )(),
            a(!0)
        }
    }
    ), [s, u, t, a]);
    const p = y.useCallback(( (e, t) => {
        s && (!r && t && (s.identify(t),
        a(!0)),
        s.track("SignedUp", e ? {
            authType: e,
            ...Zm
        } : Zm))
    }
    ), [r, s])
      , h = y.useCallback(( (e, t) => {
        s && (!r && t && (s.identify(t),
        a(!0)),
        s.track("LoggedIn", e ? {
            authType: e,
            ...Zm
        } : Zm))
    }
    ), [r, s])
      , m = y.useCallback(( ({chain: e, specificType: t, originWidget: n, isMultiWallet: r, estimatedUsd: a, tradePageOrigin: o}) => {
        if (!s)
            return;
        const l = {
            isMobile: R,
            originWidget: n,
            isMultiWallet: r,
            ...a ? {
                estimatedUsd: a
            } : {},
            ...o ? {
                tradePageOrigin: o
            } : {}
        };
        s.track("CreatedOrder", {
            chain: e,
            type: lf(t),
            side: df(t),
            ...l,
            ...Zm
        })
    }
    ), [s])
      , g = y.useCallback((e => {
        s && s.track("CanceledOrder", {
            chain: e,
            ...Zm
        })
    }
    ), [s])
      , x = y.useCallback(( () => {
        s && s.track("CreatedPasskey", {
            ...Zm
        })
    }
    ), [s])
      , b = y.useCallback(( () => {
        s && s.track("StartedWalletImport", {
            ...Zm
        })
    }
    ), [s])
      , f = y.useCallback(( () => {
        s && s.track("CreatedPassword", {
            ...Zm
        })
    }
    ), [s])
      , S = y.useCallback((e => {
        n(e)
    }
    ), [n])
      , k = y.useCallback((e => {
        !l && s && (s.people.set_once("referralCode", e),
        s.register_once({
            referralCode: e
        }),
        i(!0))
    }
    ), [s, l])
      , C = y.useCallback(( () => {
        !c && s && (null == s || s.people.set_once("createdPasskey", !0),
        d(!0))
    }
    ), [c, s])
      , A = y.useCallback((e => {
        e && s && s.register_once({
            referralCode: e
        })
    }
    ), [s])
      , w = y.useCallback((e => {
        s && s.track("PageView", {
            path: e,
            ...Zm
        })
    }
    ), [s])
      , j = y.useMemo(( () => ({
        mixpanel: s,
        identified: r,
        trackSignedUp: p,
        trackLoggedIn: h,
        trackCreatedOrder: m,
        trackCanceledOrder: g,
        trackCreatedPasskey: x,
        trackCreatedPassword: f,
        trackStartedWalletImport: b,
        setUid: S,
        setReferredBy: k,
        setCreatedPasskey: C,
        registerReferralCode: A,
        trackPageview: w
    })), [s, r, p, h, m, g, x, f, b, S, k, C, A, w]);
    return v.jsx(uf.Provider, {
        value: j,
        children: e
    })
}
))
  , hf = () => y.useContext(uf)
  , mf = y.memo(( ({icon: e, isFill: t, isStroke: n, isCircular: r, color: a, colors: s, size: o, width: l, height: i, animateColor: c=!1, shadow: d, ...u}) => {
    const p = D()
      , h = y.useMemo(( () => "inherit" === a ? "currentColor" : ( (e, t) => {
        var n;
        return (null == (n = t.palette[e || ""]) ? void 0 : n.main) ?? e
    }
    )(a, p)), [p, a])
      , m = y.useMemo(( () => s || []), [s])
      , g = y.useMemo(( () => B(e)(( () => {
        const e = xf({
            animateColor: c,
            isFill: t,
            isStroke: n
        });
        return m.reduce(( (r, a, s) => {
            const o = gf({
                color: a,
                isFill: t,
                isStroke: n,
                theme: p
            });
            return a && !_(o) && (r[`& .color-${s}`] = {
                ...o,
                ...e
            }),
            r
        }
        ), {
            ...gf({
                color: h,
                isFill: t,
                isStroke: n,
                theme: p
            }),
            ...e,
            ...r ? {
                borderRadius: "50%"
            } : {},
            ...d ? {
                overflow: "visible",
                filter: `drop-shadow(${d})`
            } : {}
        })
    }
    ))), [e, c, t, n, r, p, m, h, d]);
    return v.jsx(g, {
        ...u,
        height: i ?? o ?? 16,
        width: l ?? o ?? 16
    })
}
))
  , gf = ({color: e, isFill: t, isStroke: n, theme: r}) => ({
    fill: t ? e ?? r.palette.grey[200] : void 0,
    stroke: n ? e || r.palette.grey[200] : void 0,
    ".no-fill": {
        fill: "transparent"
    },
    ".no-stroke": {
        transparent: "transparent"
    }
})
  , xf = ({animateColor: e, isFill: t, isStroke: n}) => {
    if (!e)
        return {};
    return {
        transition: "150ms ease-in-out",
        transitionProperty: [t ? "fill" : "", n ? "stroke" : ""].filter(Boolean).join(", ")
    }
}
  , bf = y.memo(( ({icon: e, size: t=16}) => v.jsx(C, {
    component: "img",
    src: e,
    sx: {
        width: t,
        height: t
    }
})))
  , ff = e => v.jsx(bf, {
    icon: "/assets/cielo-0IemN11J.png",
    ...e
})
  , vf = e => v.jsx(mf, {
    icon: Mr,
    isFill: !0,
    ...e
})
  , Sf = e => v.jsx(mf, {
    icon: Nr,
    isFill: !0,
    ...e
})
  , yf = e => v.jsx(mf, {
    icon: Pr,
    isFill: !0,
    ...e
})
  , kf = e => v.jsx(mf, {
    icon: Or,
    isFill: !0,
    ...e
})
  , Cf = e => v.jsx(mf, {
    icon: Lr,
    ...e
})
  , Af = e => v.jsx(mf, {
    icon: Ko,
    isFill: !0,
    ...e
})
  , wf = e => v.jsx(mf, {
    icon: Rr,
    isFill: !0,
    ...e
})
  , jf = e => v.jsx(mf, {
    icon: Dr,
    isStroke: !0,
    ...e
})
  , Tf = e => v.jsx(mf, {
    icon: Br,
    isFill: !0,
    ...e
})
  , If = e => v.jsx(mf, {
    icon: _r,
    isFill: !0,
    ...e
})
  , Ef = e => v.jsx(mf, {
    icon: Ur,
    isFill: !0,
    ...e
})
  , Mf = e => v.jsx(mf, {
    icon: Wr,
    isFill: !0,
    ...e
})
  , Nf = e => v.jsx(mf, {
    icon: Fr,
    isStroke: !0,
    ...e
})
  , Pf = e => v.jsx(mf, {
    icon: Yo,
    ...e
})
  , Of = e => v.jsx(mf, {
    icon: Xo,
    ...e
})
  , Lf = e => v.jsx(mf, {
    icon: Qo,
    ...e
})
  , Rf = e => v.jsx(mf, {
    icon: Vr,
    isStroke: !0,
    ...e
})
  , Df = e => v.jsx(mf, {
    icon: Hr,
    isFill: !0,
    ...e
})
  , Bf = e => v.jsx(mf, {
    icon: zr,
    isFill: !0,
    ...e
})
  , _f = e => v.jsx(mf, {
    icon: $r,
    isStroke: !0,
    ...e
})
  , Uf = e => v.jsx(mf, {
    icon: Gr,
    isStroke: !0,
    ...e
})
  , Wf = e => v.jsx(mf, {
    icon: qr,
    isFill: !0,
    ...e
})
  , Ff = e => v.jsx(mf, {
    icon: Zo,
    ...e
})
  , Vf = e => v.jsx(mf, {
    icon: Kr,
    ...e
})
  , Hf = e => v.jsx(mf, {
    icon: Jo,
    ...e
})
  , zf = e => v.jsx(mf, {
    icon: el,
    ...e
})
  , $f = e => v.jsx(mf, {
    icon: tl,
    ...e
})
  , Gf = e => v.jsx(mf, {
    icon: nl,
    ...e
})
  , qf = e => v.jsx(mf, {
    icon: rl,
    ...e
})
  , Kf = e => v.jsx(mf, {
    icon: al,
    ...e
})
  , Yf = e => v.jsx(mf, {
    icon: sl,
    ...e
})
  , Xf = e => v.jsx(mf, {
    icon: ol,
    ...e
})
  , Qf = e => v.jsx(mf, {
    icon: ll,
    ...e
})
  , Zf = e => v.jsx(mf, {
    icon: il,
    ...e
})
  , Jf = e => v.jsx(mf, {
    icon: cl,
    ...e
})
  , ev = e => v.jsx(mf, {
    icon: dl,
    ...e
})
  , tv = e => v.jsx(mf, {
    icon: ul,
    ...e
})
  , nv = e => v.jsx(mf, {
    icon: pl,
    ...e
})
  , rv = e => v.jsx(mf, {
    icon: hl,
    ...e
})
  , av = e => v.jsx(mf, {
    icon: ml,
    ...e
})
  , sv = e => v.jsx(mf, {
    icon: gl,
    ...e
})
  , ov = e => v.jsx(mf, {
    icon: xl,
    ...e
})
  , lv = e => v.jsx(mf, {
    icon: bl,
    ...e
})
  , iv = e => v.jsx(mf, {
    icon: fl,
    ...e
})
  , cv = e => v.jsx(mf, {
    icon: vl,
    ...e
})
  , dv = e => v.jsx(mf, {
    icon: Sl,
    ...e
})
  , uv = e => v.jsx(mf, {
    icon: yl,
    ...e
})
  , pv = e => v.jsx(mf, {
    icon: kl,
    ...e
})
  , hv = e => v.jsx(mf, {
    icon: Cl,
    ...e
})
  , mv = e => v.jsx(mf, {
    icon: Al,
    ...e
})
  , gv = e => v.jsx(mf, {
    icon: wl,
    ...e
})
  , xv = e => v.jsx(mf, {
    icon: jl,
    ...e
})
  , bv = e => v.jsx(mf, {
    icon: Tl,
    ...e
})
  , fv = e => v.jsx(mf, {
    icon: Il,
    ...e
})
  , vv = e => v.jsx(mf, {
    icon: El,
    ...e
})
  , Sv = e => v.jsx(mf, {
    icon: Ml,
    ...e
})
  , yv = e => v.jsx(mf, {
    icon: Nl,
    ...e
})
  , kv = e => v.jsx(mf, {
    icon: Pl,
    ...e
})
  , Cv = e => v.jsx(mf, {
    icon: Ol,
    ...e
})
  , Av = e => v.jsx(mf, {
    icon: Ll,
    ...e
})
  , wv = e => v.jsx(mf, {
    icon: Rl,
    ...e
})
  , jv = e => v.jsx(mf, {
    icon: Dl,
    ...e
})
  , Tv = e => v.jsx(mf, {
    icon: Bl,
    ...e
})
  , Iv = e => v.jsx(mf, {
    icon: _l,
    ...e
})
  , Ev = e => v.jsx(mf, {
    icon: Ul,
    ...e
})
  , Mv = e => v.jsx(mf, {
    icon: Wl,
    ...e
})
  , Nv = e => v.jsx(mf, {
    icon: Fl,
    ...e
})
  , Pv = e => v.jsx(mf, {
    icon: Vl,
    ...e
})
  , Ov = e => v.jsx(mf, {
    icon: Yr,
    isStroke: !0,
    ...e
})
  , Lv = e => v.jsx(mf, {
    icon: Xr,
    isFill: !0,
    ...e
})
  , Rv = e => v.jsx(mf, {
    icon: Qr,
    isStroke: !0,
    ...e
})
  , Dv = e => v.jsx(mf, {
    icon: Zr,
    isFill: !0,
    ...e
})
  , Bv = e => v.jsx(mf, {
    icon: Jr,
    isFill: !0,
    ...e
})
  , _v = e => v.jsx(mf, {
    icon: ea,
    isFill: !0,
    ...e
})
  , Uv = e => v.jsx(mf, {
    icon: ta,
    isFill: !0,
    ...e
})
  , Wv = e => v.jsx(mf, {
    icon: Wi,
    isFill: !0,
    isStroke: !0,
    ...e
})
  , Fv = e => v.jsx(mf, {
    icon: Hl,
    isFill: !0,
    ...e
})
  , Vv = e => v.jsx(mf, {
    icon: na,
    ...e,
    isStroke: !0
})
  , Hv = e => v.jsx(mf, {
    icon: ra,
    isFill: !0,
    ...e
})
  , zv = e => v.jsx(mf, {
    icon: aa,
    isStroke: !0,
    ...e
})
  , $v = e => v.jsx(mf, {
    icon: sa,
    isStroke: !0,
    ...e
})
  , Gv = e => v.jsx(mf, {
    icon: oa,
    isStroke: !0,
    ...e
})
  , qv = e => v.jsx(mf, {
    icon: la,
    isStroke: !0,
    ...e
})
  , Kv = e => v.jsx(mf, {
    icon: ia,
    isFill: !0,
    ...e
})
  , Yv = e => v.jsx(mf, {
    icon: ca,
    ...e
})
  , Xv = e => v.jsx(mf, {
    icon: da,
    ...e
})
  , Qv = e => v.jsx(mf, {
    icon: zl,
    ...e
})
  , Zv = e => v.jsx(mf, {
    icon: $l,
    ...e
})
  , Jv = e => v.jsx(mf, {
    icon: ua,
    isFill: !0,
    ...e
})
  , eS = e => v.jsx(mf, {
    icon: Gl,
    ...e
})
  , tS = e => v.jsx(mf, {
    icon: pa,
    ...e
})
  , nS = e => v.jsx(mf, {
    icon: ql,
    ...e
})
  , rS = e => v.jsx(mf, {
    icon: Kl,
    ...e
})
  , aS = e => v.jsx(mf, {
    icon: ha,
    ...e,
    isStroke: !0
})
  , sS = e => v.jsx(mf, {
    icon: ma,
    isStroke: !0,
    ...e
})
  , oS = e => v.jsx(mf, {
    icon: ga,
    ...e
})
  , lS = e => v.jsx(mf, {
    icon: Yl,
    ...e
})
  , iS = e => v.jsx(mf, {
    icon: Xl,
    ...e
})
  , cS = e => v.jsx(mf, {
    icon: xa,
    isFill: !0,
    ...e
})
  , dS = e => v.jsx(mf, {
    icon: ba,
    ...e
})
  , uS = e => v.jsx(mf, {
    icon: fa,
    isFill: !0,
    ...e
})
  , pS = e => v.jsx(mf, {
    icon: va,
    isStroke: !0,
    ...e
})
  , hS = e => v.jsx(mf, {
    icon: Sa,
    isFill: !0,
    ...e
})
  , mS = e => v.jsx(mf, {
    icon: ya,
    isFill: !0,
    ...e
})
  , gS = e => v.jsx(mf, {
    icon: ka,
    isFill: !0,
    ...e
})
  , xS = e => v.jsx(mf, {
    icon: Ca,
    isStroke: !0,
    ...e
})
  , bS = e => v.jsx(mf, {
    icon: Ql,
    isFill: !0,
    ...e
})
  , fS = e => v.jsx(mf, {
    icon: Aa,
    isStroke: !0,
    ...e
})
  , vS = e => v.jsx(mf, {
    icon: wa,
    isFill: !0,
    ...e
})
  , SS = e => v.jsx(mf, {
    icon: ja,
    isFill: !0,
    ...e
})
  , yS = e => v.jsx(mf, {
    icon: Ta,
    isFill: !0,
    ...e
})
  , kS = e => v.jsx(mf, {
    icon: Ia,
    isStroke: !0,
    ...e
})
  , CS = e => v.jsx(mf, {
    icon: Ea,
    isFill: !0,
    ...e
})
  , AS = e => v.jsx(mf, {
    icon: Ma,
    isStroke: !0,
    ...e
})
  , wS = e => v.jsx(mf, {
    icon: Na,
    isStroke: !0,
    ...e
})
  , jS = e => v.jsx(mf, {
    icon: Pa,
    isFill: !0,
    ...e
})
  , TS = e => v.jsx(mf, {
    icon: Oa,
    isFill: !0,
    ...e
})
  , IS = e => v.jsx(mf, {
    icon: Zl,
    isStroke: !0,
    ...e
})
  , ES = e => v.jsx(mf, {
    icon: Ra,
    isFill: !0,
    ...e
})
  , MS = e => v.jsx(mf, {
    icon: Da,
    isStroke: !0,
    ...e
})
  , NS = e => v.jsx(mf, {
    icon: Ba,
    isFill: !0,
    ...e
})
  , PS = e => v.jsx(mf, {
    icon: _a,
    isFill: !0,
    ...e
})
  , OS = e => v.jsx(mf, {
    icon: Ua,
    isFill: !0,
    ...e
})
  , LS = e => v.jsx(mf, {
    icon: Wa,
    isFill: !0,
    ...e
})
  , RS = e => v.jsx(mf, {
    icon: Fa,
    isStroke: !0,
    ...e
})
  , DS = e => v.jsx(mf, {
    icon: Va,
    ...e
})
  , BS = e => v.jsx(mf, {
    icon: Ha,
    ...e
})
  , _S = e => v.jsx(mf, {
    icon: za,
    isStroke: !0,
    ...e
})
  , US = e => v.jsx(mf, {
    icon: $a,
    isFill: !0,
    ...e
})
  , WS = e => v.jsx(mf, {
    icon: Jl,
    ...e
})
  , FS = e => v.jsx(mf, {
    icon: ei,
    isStroke: !0,
    ...e
})
  , VS = e => v.jsx(mf, {
    icon: Ga,
    isFill: !0,
    isStroke: !0,
    ...e
})
  , HS = e => v.jsx(mf, {
    icon: ti,
    isStroke: !0,
    ...e
})
  , zS = e => v.jsx(mf, {
    icon: qa,
    ...e
})
  , $S = e => v.jsx(mf, {
    icon: Ka,
    isStroke: !0,
    ...e
})
  , GS = e => v.jsx(mf, {
    icon: Ya,
    isFill: !0,
    ...e
})
  , qS = e => v.jsx(mf, {
    icon: Xa,
    isFill: !0,
    ...e
})
  , KS = e => v.jsx(mf, {
    icon: ni,
    isFill: !0,
    ...e
})
  , YS = e => v.jsx(mf, {
    icon: Qa,
    isFill: !0,
    ...e
})
  , XS = e => v.jsx(mf, {
    icon: Za,
    isStroke: !0,
    ...e
})
  , QS = e => v.jsx(mf, {
    icon: Ja,
    isFill: !0,
    ...e
})
  , ZS = e => v.jsx(mf, {
    icon: es,
    isStroke: !0,
    ...e
})
  , JS = e => v.jsx(mf, {
    icon: ts,
    isStroke: !0,
    ...e
})
  , ey = e => v.jsx(mf, {
    icon: ns,
    isStroke: !0,
    ...e
})
  , ty = e => v.jsx(mf, {
    icon: rs,
    isStroke: !0,
    ...e
})
  , ny = e => v.jsx(mf, {
    icon: as,
    isStroke: !0,
    ...e
})
  , ry = e => v.jsx(mf, {
    icon: ss,
    ...e
})
  , ay = e => v.jsx(mf, {
    icon: os,
    isFill: !0,
    ...e
})
  , sy = e => v.jsx(mf, {
    icon: ls,
    isStroke: !0,
    ...e
})
  , oy = e => v.jsx(mf, {
    icon: is,
    isStroke: !0,
    ...e
})
  , ly = e => v.jsx(mf, {
    icon: cs,
    isFill: !0,
    ...e
})
  , iy = e => v.jsx(mf, {
    icon: ds,
    isFill: !0,
    isStroke: !0,
    ...e
})
  , cy = e => v.jsx(mf, {
    icon: us,
    isStroke: !0,
    ...e
})
  , dy = e => v.jsx(mf, {
    icon: ps,
    isStroke: !0,
    ...e
})
  , uy = e => v.jsx(mf, {
    icon: hs,
    isFill: !0,
    ...e
})
  , py = e => v.jsx(mf, {
    icon: ms,
    isFill: !0,
    isStroke: !0,
    ...e
})
  , hy = e => v.jsx(mf, {
    icon: gs,
    ...e
})
  , my = e => v.jsx(mf, {
    icon: xs,
    isStroke: !0,
    ...e
})
  , gy = e => v.jsx(mf, {
    icon: bs,
    isStroke: !0,
    ...e
})
  , xy = e => v.jsx(mf, {
    icon: fs,
    isStroke: !0,
    ...e
})
  , by = e => v.jsx(mf, {
    icon: Yi,
    isStroke: !0,
    ...e
})
  , fy = e => v.jsx(mf, {
    icon: vs,
    isFill: !0,
    ...e
})
  , vy = e => v.jsx(mf, {
    icon: Ss,
    isStroke: !0,
    ...e
})
  , Sy = e => v.jsx(mf, {
    icon: ys,
    isStroke: !0,
    ...e
})
  , yy = e => v.jsx(mf, {
    icon: ks,
    isStroke: !0,
    ...e
})
  , ky = e => v.jsx(mf, {
    icon: Cs,
    isStroke: !0,
    ...e
})
  , Cy = e => v.jsx(mf, {
    icon: As,
    isStroke: !0,
    ...e
})
  , Ay = e => v.jsx(mf, {
    icon: ws,
    isFill: !0,
    ...e
})
  , wy = e => v.jsx(mf, {
    icon: js,
    isFill: !0,
    ...e
})
  , jy = e => v.jsx(mf, {
    icon: Ts,
    isFill: !0,
    ...e
})
  , Ty = e => v.jsx(mf, {
    icon: Is,
    isFill: !0,
    ...e
})
  , Iy = e => v.jsx(mf, {
    icon: Es,
    isFill: !0,
    ...e
})
  , Ey = e => v.jsx(mf, {
    icon: Ms,
    isFill: !0,
    ...e
})
  , My = e => v.jsx(mf, {
    icon: Ns,
    isFill: !0,
    ...e
})
  , Ny = e => v.jsx(mf, {
    icon: Ps,
    isStroke: !0,
    ...e
})
  , Py = e => v.jsx(mf, {
    icon: Os,
    isFill: !0,
    ...e
})
  , Oy = e => v.jsx(mf, {
    icon: Ls,
    isFill: !0,
    ...e
})
  , Ly = e => v.jsx(mf, {
    icon: Rs,
    isFill: !0,
    ...e
})
  , Ry = e => v.jsx(mf, {
    icon: ri,
    ...e
})
  , Dy = e => v.jsx(mf, {
    icon: Ds,
    isStroke: !0,
    ...e
})
  , By = e => v.jsx(mf, {
    icon: Bs,
    isStroke: !0,
    ...e
})
  , _y = e => v.jsx(mf, {
    icon: _s,
    isStroke: !0,
    ...e
})
  , Uy = e => v.jsx(mf, {
    icon: Us,
    isStroke: !0,
    ...e
})
  , Wy = e => v.jsx(mf, {
    icon: Ws,
    isFill: !0,
    ...e
})
  , Fy = e => v.jsx(mf, {
    icon: Fs,
    isFill: !0,
    ...e
})
  , Vy = e => v.jsx(mf, {
    icon: Vs,
    ...e
})
  , Hy = e => v.jsx(mf, {
    icon: ai,
    ...e
})
  , zy = e => v.jsx(mf, {
    icon: si,
    ...e
})
  , $y = e => v.jsx(mf, {
    icon: oi,
    ...e
})
  , Gy = e => v.jsx(mf, {
    icon: Hs,
    isStroke: !0,
    ...e
})
  , qy = e => v.jsx(mf, {
    icon: zs,
    ...e,
    isStroke: !0
})
  , Ky = e => v.jsx(mf, {
    icon: $s,
    isStroke: !0,
    ...e
})
  , Yy = e => v.jsx(mf, {
    icon: li,
    ...e
})
  , Xy = e => v.jsx(mf, {
    icon: ii,
    ...e
})
  , Qy = e => v.jsx(mf, {
    icon: ci,
    ...e
})
  , Zy = e => v.jsx(mf, {
    icon: di,
    isFill: !0,
    ...e
})
  , Jy = e => v.jsx(mf, {
    icon: ui,
    ...e
})
  , ek = e => v.jsx(mf, {
    icon: Gs,
    isStroke: !0,
    ...e
})
  , tk = e => v.jsx(mf, {
    icon: qs,
    isStroke: !0,
    ...e
})
  , nk = e => v.jsx(mf, {
    icon: Ks,
    isCircular: !0,
    ...e
})
  , rk = e => v.jsx(mf, {
    icon: Ys,
    isFill: !0,
    ...e
})
  , ak = e => v.jsx(mf, {
    icon: Xs,
    ...e
})
  , sk = e => v.jsx(mf, {
    icon: Qs,
    ...e
})
  , ok = e => v.jsx(mf, {
    icon: Zs,
    isFill: !0,
    ...e
})
  , lk = e => v.jsx(mf, {
    icon: pi,
    ...e
})
  , ik = e => v.jsx(mf, {
    icon: Js,
    ...e
})
  , ck = e => v.jsx(mf, {
    icon: hi,
    ...e
})
  , dk = e => v.jsx(mf, {
    icon: eo,
    ...e
})
  , uk = e => v.jsx(mf, {
    icon: mi,
    ...e
})
  , pk = e => v.jsx(mf, {
    icon: to,
    ...e
})
  , hk = e => v.jsx(mf, {
    icon: gi,
    ...e
})
  , mk = e => v.jsx(mf, {
    icon: no,
    ...e
})
  , gk = e => v.jsx(mf, {
    icon: ro,
    isFill: !0,
    ...e
})
  , xk = e => v.jsx(mf, {
    icon: ao,
    isStroke: !0,
    ...e
})
  , bk = e => v.jsx(mf, {
    icon: so,
    isFill: !0,
    ...e
})
  , fk = e => v.jsx(mf, {
    icon: oo,
    isFill: !0,
    ...e
})
  , vk = e => v.jsx(mf, {
    icon: lo,
    isStroke: !0,
    ...e
})
  , Sk = e => v.jsx(mf, {
    icon: xi,
    isStroke: !0,
    ...e
})
  , yk = e => v.jsx(mf, {
    icon: io,
    isStroke: !0,
    ...e
})
  , kk = e => v.jsx(mf, {
    icon: bi,
    isFill: !0,
    ...e
})
  , Ck = e => v.jsx(mf, {
    icon: co,
    isStroke: !0,
    ...e
})
  , Ak = e => v.jsx(mf, {
    icon: uo,
    isStroke: !0,
    ...e
})
  , wk = e => v.jsx(mf, {
    icon: po,
    isStroke: !0,
    ...e
})
  , jk = e => v.jsx(mf, {
    icon: ho,
    isStroke: !0,
    ...e
})
  , Tk = e => v.jsx(mf, {
    icon: mo,
    isStroke: !0,
    ...e
})
  , Ik = e => v.jsx(mf, {
    icon: Fi,
    ...e
})
  , Ek = e => v.jsx(mf, {
    icon: go,
    isStroke: !0,
    ...e
})
  , Mk = e => v.jsx(mf, {
    icon: xo,
    isFill: !0,
    ...e
})
  , Nk = e => v.jsx(mf, {
    icon: bo,
    isFill: !0,
    ...e
})
  , Pk = e => v.jsx(mf, {
    icon: fo,
    isStroke: !0,
    ...e
})
  , Ok = e => v.jsx(mf, {
    icon: vo,
    ...e
})
  , Lk = e => v.jsx(mf, {
    icon: So,
    ...e
})
  , Rk = e => v.jsx(mf, {
    icon: fi,
    ...e
})
  , Dk = e => v.jsx(mf, {
    icon: yo,
    ...e
})
  , Bk = e => v.jsx(mf, {
    icon: ko,
    ...e
})
  , _k = e => v.jsx(mf, {
    icon: Co,
    isFill: !0,
    ...e
})
  , Uk = e => v.jsx(mf, {
    icon: Ao,
    isFill: !0,
    ...e
})
  , Wk = e => v.jsx(mf, {
    icon: wo,
    isFill: !0,
    ...e
})
  , Fk = e => v.jsx(mf, {
    icon: jo,
    isStroke: !0,
    ...e
})
  , Vk = e => v.jsx(mf, {
    icon: To,
    isStroke: !0,
    ...e
})
  , Hk = e => v.jsx(mf, {
    icon: Io,
    ...e
})
  , zk = e => v.jsx(mf, {
    icon: Eo,
    isFill: !0,
    ...e
})
  , $k = e => v.jsx(mf, {
    icon: vi,
    ...e
})
  , Gk = e => v.jsx(mf, {
    icon: Mo,
    isFill: !0,
    ...e
})
  , qk = e => v.jsx(mf, {
    icon: Si,
    ...e
})
  , Kk = e => v.jsx(mf, {
    icon: yi,
    ...e
})
  , Yk = e => v.jsx(mf, {
    icon: ki,
    ...e
})
  , Xk = e => v.jsx(mf, {
    icon: No,
    ...e
})
  , Qk = e => v.jsx(mf, {
    icon: Ci,
    ...e
})
  , Zk = e => v.jsx(mf, {
    icon: Po,
    isFill: !0,
    ...e
})
  , Jk = e => v.jsx(mf, {
    icon: Oo,
    ...e
})
  , eC = e => v.jsx(mf, {
    icon: Ai,
    ...e
})
  , tC = e => v.jsx(mf, {
    icon: wi,
    ...e
})
  , nC = e => v.jsx(mf, {
    icon: Lo,
    isFill: !0,
    ...e
})
  , rC = e => v.jsx(mf, {
    icon: ji,
    ...e
})
  , aC = e => v.jsx(mf, {
    icon: Ti,
    ...e
})
  , sC = e => v.jsx(mf, {
    icon: Ro,
    ...e
})
  , oC = e => v.jsx(mf, {
    icon: Ii,
    ...e
})
  , lC = e => v.jsx(mf, {
    icon: Ei,
    ...e
})
  , iC = e => v.jsx(mf, {
    icon: Mi,
    ...e
})
  , cC = e => v.jsx(mf, {
    icon: Ni,
    ...e
})
  , dC = e => v.jsx(mf, {
    icon: Pi,
    ...e
})
  , uC = e => v.jsx(mf, {
    icon: Oi,
    ...e
})
  , pC = e => v.jsx(mf, {
    icon: Li,
    ...e
})
  , hC = e => v.jsx(mf, {
    icon: Ri,
    ...e
})
  , mC = e => v.jsx(mf, {
    icon: Di,
    ...e
})
  , gC = e => v.jsx(mf, {
    icon: Do,
    isFill: !0,
    ...e
})
  , xC = e => v.jsx(mf, {
    icon: Bo,
    ...e
})
  , bC = e => v.jsx(mf, {
    icon: Bi,
    ...e
})
  , fC = e => v.jsx(mf, {
    icon: _i,
    ...e
})
  , vC = e => v.jsx(mf, {
    icon: Ui,
    ...e
})
  , SC = e => v.jsx(mf, {
    icon: _o,
    ...e
})
  , yC = e => v.jsx(mf, {
    icon: Uo,
    isFill: !0,
    ...e
})
  , kC = e => v.jsx(mf, {
    icon: Wo,
    isFill: !0,
    ...e
})
  , CC = e => v.jsx(mf, {
    icon: Fo,
    isFill: !0,
    ...e
})
  , AC = e => v.jsx(mf, {
    icon: Vo,
    isFill: !0,
    ...e
})
  , wC = e => v.jsx(mf, {
    icon: $o,
    isStroke: !0,
    ...e
})
  , jC = e => v.jsx(mf, {
    icon: Go,
    isStroke: !0,
    ...e
})
  , TC = e => v.jsx(mf, {
    icon: qo,
    ...e
})
  , IC = 1.21
  , EC = 400
  , MC = 450
  , NC = y.forwardRef(( ({message: e, snackName: t, onClose: n, actionLabel: r, onAction: a, type: s="default"}, o) => {
    const l = D()
      , i = y.useCallback((e => {
        switch (e) {
        case "success":
            return v.jsx(vy, {
                color: l.palette.success.main
            });
        case "warning":
            return v.jsx(wk, {
                color: l.palette.warning.main
            });
        case "error":
            return v.jsx(Uy, {
                color: l.palette.error.main
            });
        default:
            return null
        }
    }
    ), [l])
      , c = r && v.jsx(S, {
        ml: 2,
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: v.jsx(V, {
            color: "primary",
            size: "small",
            onClick: a,
            children: r
        })
    })
      , d = i(s);
    return v.jsx(U, {
        ref: o,
        children: v.jsx(W, {
            icon: !1,
            sx: PC,
            action: c,
            className: "padre-no-scroll",
            children: v.jsxs(C, {
                display: "flex",
                flexDirection: "column",
                gap: 2,
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "flex-start",
                    gap: 1,
                    children: [d, v.jsx(k, {
                        variant: "labelLarge",
                        lineHeight: IC,
                        color: "text.label",
                        children: t || e
                    }), v.jsx(F, {
                        size: "small",
                        "aria-label": "close",
                        onClick: n,
                        sx: {
                            p: 0,
                            ml: "auto"
                        },
                        children: v.jsx(gy, {})
                    })]
                }), t && v.jsx(k, {
                    variant: "bodyRegular",
                    lineHeight: IC,
                    color: "text.primary",
                    children: e
                })]
            })
        })
    })
}
))
  , PC = {
    flexWrap: "wrap",
    backgroundColor: "background.tertiary",
    borderRadius: 1,
    p: 2,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0,
        overflow: "hidden"
    },
    maxWidth: {
        xs: EC,
        md: MC
    }
};
var OC = (e => (e.GAS_PRICE_TOO_LOW = "GAS_PRICE_TOO_LOW",
e.NOT_ENOUGH_FUNDS = "NOT_ENOUGH_FUNDS",
e.NOT_ENOUGH_FUNDS_FOR_GAS = "NOT_ENOUGH_FUNDS_FOR_GAS",
e.TOO_LITTLE_RECEIVED = "TOO_LITTLE_RECEIVED",
e.TRANSACTION_DEADLINE_PASSED = "TRANSACTION_DEADLINE_PASSED",
e.ORDER_AMOUNT_EXCEEDS_BALANCE = "ORDER_AMOUNT_EXCEEDS_BALANCE",
e.SLIPPAGE_TOLERANCE_EXCEEDED = "SLIPPAGE_TOLERANCE_EXCEEDED",
e.UNKNOWN_EXECUTION_ERROR = "UNKNOWN_EXECUTION_ERROR",
e.OUT_OF_GAS = "OUT_OF_GAS",
e.LIKELY_EXCEEDS_MAX = "LIKELY_EXCEEDS_MAX",
e.FROZEN_ACCOUNT = "FROZEN_ACCOUNT",
e.CURRENT_APPROVAL_SUFFICIENT = "CURRENT_APPROVAL_SUFFICIENT",
e.LIKELY_HONEYPOT = "LIKELY_HONEYPOT",
e.REPLACEMENT_TRANSACTION_UNDERPRICED = "REPLACEMENT_TRANSACTION_UNDERPRICED",
e.POOL_CLOSED = "POOL_CLOSED",
e.INSUFFICIENT_LIQUIDITY = "INSUFFICIENT_LIQUIDITY",
e.ORDER_LOGIC_INVALID = "ORDER_LOGIC_INVALID",
e.BONDING_CURVE_EMPTY = "BONDING_CURVE_EMPTY",
e.PADRE_NONCE = "PADRE_NONCE",
e.PADRE_NONCE_HISTORY_FULL = "PADRE_NONCE_HISTORY_FULL",
e))(OC || {});
const LC = "https://discord.gg/h6ZH2BaYJu"
  , RC = "https://trade.padre.gg"
  , DC = "https://padre.gg/privacy-policy"
  , BC = "https://padre.gg"
  , _C = `${BC}/tos`
  , UC = "https://docs.padre.gg/app-guide/trading/exit-strategies#unable-to-sell-initial"
  , WC = "https://pump.fun/docs/mayhem-mode"
  , FC = {
    slippageTooLowTitle: "Slippage Too Low",
    slippageTooLow: "Your slippage tolerance is too low to account for your trade's \n  price impact. \n  Consider retrying with higher slippage.",
    notEnoughFundsForGasTitle: "Not Enough Funds",
    notEnoughFundsForGas: "The transaction could not be completed due to insufficient funds in your trading wallet to cover both the transaction and gas fee.",
    notEnoughFundsTitle: "Not Enough Funds",
    notEnoughFunds: "The transaction could not be completed due to insufficient funds in your trading wallet.",
    gasPriceTooLowTitle: "Gas Too Low",
    gasPriceTooLow: "Your gas limit is insufficient to process this transaction. Consider increasing its value.",
    transactionDeadlinePassedTitle: "Transaction Timed Out",
    transactionDeadlinePassed: "The transaction has failed to complete due to time out.",
    unknownErrorTitle: "Unknown Execution Error",
    outOfGasTitle: "Out of Gas",
    outOfGas: "Transaction ran out of gas during on-chain execution.",
    likelyExceedsMax: "Your trade is likely too big. Check Data & Security for max buy and max sell amounts and adjust your trade size.",
    likelyExceedsMaxTitle: "Trade Limit Exceeded",
    frozenAccountTitle: "Account Frozen",
    likelyHoneypot: "Token might be a honeypot. Always do your research before buying and check the Data & Security section.",
    likelyHoneypotTitle: "Likely Honeypot",
    exceedsBalanceTitle: "Exceeds balance",
    exceedsBalance: "Order exceeds current balance",
    exceedsBalanceSellInit: "You're not in profit",
    poolMigratedTitle: "Pool Bonded",
    poolMigrated: "Trading on this pool is no longer possible."
}
  , VC = e => `The developer of ${e ? iu(e, 16) : "token"} froze your account, preventing you from trading this token.`;
var HC = (e => (e.QUEUED = "QUEUED",
e.EXECUTING = "EXECUTING",
e.DONE = "DONE",
e.FAILED = "FAILED",
e.REVERTED = "REVERTED",
e.TIMED_OUT = "TIMED_OUT",
e))(HC || {});
const zC = y.forwardRef(( ({href: e, children: t, nofollow: n=!0, ...r}, a) => v.jsx(H, {
    ref: a,
    component: "a",
    href: e,
    target: "_blank",
    rel: "noopener" + (n ? " nofollow" : ""),
    fontWeight: "inherit",
    underline: "always",
    ...r,
    children: t
})))
  , $C = ({label: e, href: t, nofollow: n=!0, sx: r, ...a}) => v.jsx(zC, {
    href: t,
    nofollow: n,
    whiteSpace: "nowrap",
    sx: r,
    ...a,
    children: e
})
  , GC = y.memo(( ({allowOnMobile: e=!1, maxWidth: t=YC, children: n, title: r, noTooltipBackground: a, noPadding: s=!1, link: o, offset: l=0, noEnterDelay: i=!0, ...c}) => {
    const d = D()
      , u = y.useMemo(( () => ({
        tooltip: a ? {
            sx: {
                p: 0,
                border: "none",
                maxWidth: t,
                backgroundColor: "transparent"
            }
        } : {
            sx: {
                py: s ? 0 : .5,
                px: s ? 0 : .75,
                border: `1px solid ${d.palette.background.borderActive}${KC}`,
                maxWidth: t
            }
        }
    })), [a, t, s, d.palette.background.borderActive])
      , p = y.useMemo(( () => ({
        popper: {
            modifiers: [{
                name: "offset",
                options: {
                    offset: [0, l]
                }
            }]
        }
    })), [l]);
    return v.jsx(z, {
        ...c,
        TransitionProps: qC,
        componentsProps: u,
        slotProps: p,
        title: !R || e || c.open ? r : "",
        "aria-label": o,
        enterDelay: c.enterDelay ?? (i ? 0 : XC),
        enterNextDelay: c.enterNextDelay ?? (i ? 0 : XC),
        children: n
    })
}
))
  , qC = {
    timeout: 0
}
  , KC = "60"
  , YC = 400
  , XC = 200
  , QC = !!navigator.clipboard
  , ZC = e => {
    navigator.clipboard.writeText(e).then(( () => (e => {
        const t = new CustomEvent("copyButtonClick",{
            detail: e
        });
        document.dispatchEvent(t)
    }
    )(e))).catch((e => {}
    ))
}
  , JC = (e, t=eA, n=e) => {
    const [r,a] = y.useState(e)
      , s = y.useRef(null)
      , o = y.useCallback((e => {
        s.current && clearTimeout(s.current),
        a(e),
        s.current = e !== n ? setTimeout(( () => {
            a(n)
        }
        ), t) : null
    }
    ), [t, n]);
    return y.useEffect(( () => {
        e !== n && o(e)
    }
    ), [o, n, e]),
    [r, o]
}
  , eA = 1e3
  , tA = ({label: e, disabled: t=!1, tooltipTitle: n="Copy", stopPropagation: r=!1, preventDefault: a=!1, isInTooltip: s=!1, ellipsis: o=!1, ariaLabel: l, textToCopy: i=e, labelSx: c={}, containerSx: d={}, hideTooltip: u=!1, labelVariant: p="paragraph3", labelWrapper: h=nA, copyIconSize: m=rA, hideIcon: g=!1, customLabelComponent: x}) => {
    const b = D()
      , [f,A] = JC(!1, aA)
      , w = y.useCallback((async t => {
        r && t.stopPropagation(),
        a && t.preventDefault(),
        QC && (await ZC(i ?? e),
        A(!0))
    }
    ), [r, a, i, e, A])
      , j = y.useCallback((e => {
        s && e.preventDefault()
    }
    ), [s])
      , T = y.useCallback(( () => {
        A(!1)
    }
    ), [A])
      , I = QC && o
      , E = QC ? l : i
      , M = QC ? e : i
      , N = v.jsxs($, {
        disabled: t,
        "aria-label": E,
        onClick: w,
        onMouseDown: j,
        sx: e => ({
            maxWidth: I ? "100%" : void 0,
            display: "inline-flex",
            alignItems: "center",
            p: .5,
            gap: .5,
            borderRadius: 1,
            whiteSpace: "nowrap",
            transition: "background-color 0.2s ease-in-out, color 0.2s ease-in-out",
            color: e.palette.text.label,
            ":hover": {
                color: e.palette.text.value
            },
            ..."function" == typeof d ? d(e) : d
        }),
        style: {
            backgroundColor: "transparent"
        },
        children: [x || (M ? v.jsx(h, {
            children: v.jsx(k, {
                "aria-hidden": !!E,
                maxWidth: I ? "100%" : void 0,
                noWrap: I,
                variant: p,
                color: "inherit",
                sx: {
                    ...QC ? {} : {
                        userSelect: "text",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                        overflow: "hidden"
                    },
                    ..."function" == typeof c ? c(b) : c
                },
                ...Nu,
                children: M
            })
        }) : null), QC && !g && v.jsx(S, {
            justifyContent: "center",
            alignItems: "center",
            mt: sA,
            flex: "0 0 auto",
            children: v.jsx(gk, {
                color: "inherit",
                size: m
            })
        })]
    })
      , P = y.useMemo(( () => f ? v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        ...Nu,
        children: ["Copied", v.jsx(G, {
            sx: {
                fontSize: "1.5em"
            },
            color: "success"
        })]
    }) : v.jsx("div", {
        ...Nu,
        children: n
    })), [f, n]);
    return !QC || u ? N : v.jsx(GC, {
        title: P,
        TransitionProps: {
            onExited: T
        },
        maxWidth: 425,
        children: v.jsx(C, {
            component: "span",
            display: "flex",
            children: N
        })
    })
}
  , nA = ({children: e}) => v.jsx(v.Fragment, {
    children: e
})
  , rA = 16
  , aA = 6e3
  , sA = -.25
  , oA = (e, {firstPartLength: t=5, finalPartLength: n=4, checksummed: r=!1}={}) => {
    const a = r && q(e) ? j(e) : e;
    if (0 === a.length)
        return "";
    if (a.length <= t + n)
        return a;
    const s = a.slice(0, t)
      , o = a.slice(a.length - n);
    return `${s}${s && o ? "" : ""}${o}`
}
  , lA = ({showContent: e=!1, children: t, blurRadius: n=iA, bgColor: r, ...a}) => {
    const s = y.useMemo(( () => n + 1), [n]);
    return v.jsx(S, {
        m: -s + "px",
        ...a,
        children: v.jsx(S, {
            p: `${s}px`,
            bgcolor: r,
            sx: t => {
                const r = `${t.transitions.duration.short}ms`;
                return {
                    ...e ? {} : {
                        position: "relative",
                        "&:after": {
                            pointerEvents: "none",
                            position: "absolute",
                            inset: 0,
                            content: '""',
                            backgroundColor: "transparent",
                            backdropFilter: `blur(${n}px)`,
                            opacity: 1,
                            visibility: "visible",
                            transition: `opacity ${r} ease-in-out, visibility ${r} 0ms ease-in-out`
                        }
                    }
                }
            }
            ,
            children: t
        })
    })
}
  , iA = 3
  , cA = y.memo(( ({address: e, disabled: t, firstPartLength: n=5, finalPartLength: r=4, stopPropagation: a, preventDefault: s, isInTooltip: o, customName: l, maxWidth: i, labelSx: c={}, hideTooltip: d=!1, tooltipTitle: u, omitAriaLabel: p, anonimize: h=!1, ...m}) => {
    const g = y.useMemo(( () => ({
        firstPartLength: n,
        finalPartLength: r
    })), [n, r])
      , x = y.useMemo(( () => void 0 !== l ? l : oA(e || "", g)), [l, e, g]);
    return e ? v.jsx(tA, {
        disabled: t,
        label: x,
        textToCopy: e,
        ariaLabel: p ? void 0 : "Copy address",
        tooltipTitle: u ?? (h ? "Copy" : `Copy ${oA(e)}`),
        stopPropagation: a,
        preventDefault: s,
        isInTooltip: o,
        ellipsis: !!l,
        labelSx: {
            maxWidth: i || `${n + r + 3}ch`,
            ...c
        },
        hideTooltip: d,
        labelWrapper: h ? dA : uA,
        ...m
    }) : null
}
))
  , dA = ({children: e}) => v.jsx(lA, {
    showContent: !1,
    children: e
})
  , uA = ({children: e}) => v.jsx(v.Fragment, {
    children: e
});
var pA = (e => (e.SECOND = "SECOND",
e.MINUTE = "MINUTE",
e.HOUR = "HOUR",
e))(pA || {});
const hA = [{
    value: 1e5,
    color: "#17C671"
}, {
    value: 2e4,
    color: "#EDCA07"
}, {
    value: 1e3,
    color: "#51C0FF"
}]
  , mA = [{
    value: 30,
    color: "#E73A44",
    timeUnit: pA.MINUTE
}, {
    value: 10,
    color: "#FF7324",
    timeUnit: pA.MINUTE
}, {
    value: 2,
    color: "#36D8FF",
    timeUnit: pA.MINUTE
}]
  , gA = {}
  , xA = y.createContext({
    marketCapThresholds: hA,
    setMarketCapThresholds: c.noop,
    tweetCreationThresholds: mA,
    setTweetCreationThresholds: c.noop,
    protocolsRowColors: gA,
    setProtocolsRowColors: c.noop
})
  , bA = () => y.useContext(xA)
  , fA = ({children: e}) => {
    const [t,n] = Mx("padreV2-trenchesMarketCapThresholds", hA)
      , [r,a] = Mx("padreV2-tweetCreationColorThresholds", mA)
      , [s,o] = Mx("padreV2-protocolsRowColors", gA)
      , l = y.useMemo(( () => ({
        marketCapThresholds: t,
        setMarketCapThresholds: n,
        tweetCreationThresholds: r,
        setTweetCreationThresholds: a,
        protocolsRowColors: s,
        setProtocolsRowColors: o
    })), [t, n, a, r, s, o]);
    return v.jsx(xA.Provider, {
        value: l,
        children: e
    })
}
  , vA = y.createContext({
    livePumpfuns: new Set([])
})
  , SA = ({children: e}) => {
    const t = mx(( () => {
        const e = Ax()
          , t = y.useCallback((t => e ? jm.subscribeCurrentlyLivePumpFuns(t) : {
            unsubscribe: () => {}
        }), [e]);
        return yx(t)
    }
    )())
      , n = y.useMemo(( () => new Set((null == t ? void 0 : t.addresses) ?? [])), [t])
      , r = y.useMemo(( () => ({
        livePumpfuns: n
    })), [n]);
    return v.jsx(vA.Provider, {
        value: r,
        children: e
    })
}
  , yA = "https://honeypot.is/"
  , kA = (e, t) => {
    switch (e) {
    case Pd.BSC:
        return t ? `${yA}?address=${t}` : null;
    case Pd.ETH_MAINNET:
        return t ? `${yA}ethereum?address=${t}` : null;
    case Pd.BASE:
        return t ? `${yA}base?address=${t}` : null;
    default:
        return null
    }
}
  , CA = e => {
    switch (e) {
    case Pd.ARBITRUM:
        return "https://arbiscan.io/";
    case Pd.ARBITRUM_SEPOLIA:
        return "https://sepolia.arbiscan.io/";
    case Pd.ETH_MAINNET:
        return "https://etherscan.io/";
    case Pd.ETH_SEPOLIA:
        return "https://sepolia.etherscan.io/";
    case Pd.BASE:
        return "https://basescan.org/";
    case Pd.BSC:
        return "https://bscscan.com/";
    case Pd.SOLANA:
        return "https://solscan.io/"
    }
}
  , AA = (e, t) => e ? `${CA(t)}${(e => {
    switch (e) {
    case Pd.ARBITRUM:
    case Pd.ARBITRUM_SEPOLIA:
    case Pd.ETH_MAINNET:
    case Pd.ETH_SEPOLIA:
    case Pd.BASE:
    case Pd.BSC:
    case Pd.SOLANA:
        return "tx/"
    }
}
)(t)}${e}` : null
  , wA = (e, t) => e ? `${CA(t)}${(e => {
    switch (e) {
    case Pd.ARBITRUM:
    case Pd.ARBITRUM_SEPOLIA:
    case Pd.ETH_MAINNET:
    case Pd.ETH_SEPOLIA:
    case Pd.BASE:
    case Pd.BSC:
    case Pd.SOLANA:
        return "token/"
    }
}
)(t)}${e}` : null
  , jA = (e, t) => e ? `${CA(t)}${(e => {
    switch (e) {
    case Pd.ARBITRUM:
    case Pd.ARBITRUM_SEPOLIA:
    case Pd.ETH_MAINNET:
    case Pd.ETH_SEPOLIA:
    case Pd.BASE:
    case Pd.BSC:
        return "address/";
    case Pd.SOLANA:
        return "account/"
    }
}
)(t)}${e}` : null
  , TA = (e, t) => {
    const n = (e => {
        switch (e) {
        case Pd.ARBITRUM:
            return "arbitrum";
        case Pd.ETH_MAINNET:
            return "ethereum";
        case Pd.BASE:
            return "base";
        case Pd.BSC:
            return "bsc";
        case Pd.SOLANA:
            return "solana";
        default:
            return null
        }
    }
    )(e);
    return n && t ? `https://dexscreener.com/${n}/${t}` : null
}
  , IA = (e, t, n) => {
    var r;
    return (null == (r = t.find((t => e >= t.value))) ? void 0 : r.color) ?? n
}
  , EA = {
    [pA.SECOND]: 1,
    [pA.MINUTE]: 60,
    [pA.HOUR]: 3600
}
  , MA = (e, t) => {
    var n;
    const r = t[t.length - 1];
    return (null == (n = t.slice(0, -1).find((t => e >= t.value * EA[t.timeUnit ?? pA.SECOND]))) ? void 0 : n.color) ?? r.color
}
;
function NA(e, t=!1, n) {
    const r = y.useRef(n ?? e);
    return y.useEffect(( () => {
        t && null === e || (r.current = e)
    }
    ), [e, t]),
    r.current
}
const PA = e => {
    const [t,n] = y.useState(i());
    return ( (e, t) => {
        const {delay: n, immediateExecution: r, forceStop: a=!1} = t
          , s = bx()
          , o = NA(s)
          , l = a || !s
          , i = !o && s && t.immediateRunAfterPageBecomesVisible
          , c = y.useRef(e);
        c.current = e,
        y.useEffect(( () => {
            if (l)
                return;
            const e = () => {
                c.current()
            }
            ;
            (r || i) && setTimeout(e, 0);
            const t = setInterval(e, n);
            return () => clearInterval(t)
        }
        ), [n, i, l, r])
    }
    )(( () => n(i())), {
        delay: e.refreshRate,
        immediateRunAfterPageBecomesVisible: (null == e ? void 0 : e.immediateRunAfterPageBecomesVisible) ?? !0,
        immediateExecution: !1,
        forceStop: (null == e ? void 0 : e.skip) ?? !1
    }),
    t
}
  , OA = y.createContext({
    nowTs: 0
})
  , LA = ({children: e}) => {
    const t = PA({
        refreshRate: 1e3,
        immediateRunAfterPageBecomesVisible: !0
    })
      , n = y.useMemo(( () => ({
        nowTs: t.unix()
    })), [t]);
    return v.jsx(OA.Provider, {
        value: n,
        children: e
    })
}
;
var RA = (e => (e[e.ONE_SECOND = 1] = "ONE_SECOND",
e[e.ONE_MINUTE = 60] = "ONE_MINUTE",
e[e.FIVE_MINUTES = 300] = "FIVE_MINUTES",
e[e.FIFTEEN_MINUTES = 900] = "FIFTEEN_MINUTES",
e[e.THIRTY_MINUTES = 1800] = "THIRTY_MINUTES",
e[e.ONE_HOUR = 3600] = "ONE_HOUR",
e[e.FOUR_HOURS = 14400] = "FOUR_HOURS",
e[e.ONE_DAY = 86400] = "ONE_DAY",
e[e.ONE_WEEK = 604800] = "ONE_WEEK",
e[e.ONE_MONTH = 2592e3] = "ONE_MONTH",
e[e.ONE_YEAR = 31536e3] = "ONE_YEAR",
e))(RA || {});
RA.ONE_MINUTE,
RA.FIVE_MINUTES,
RA.FIFTEEN_MINUTES,
RA.THIRTY_MINUTES,
RA.ONE_HOUR,
RA.FOUR_HOURS,
RA.ONE_DAY;
const DA = new Set;
let BA = i().unix();
setInterval(( () => {
    const e = i();
    BA = e.unix(),
    DA.forEach((t => {
        try {
            t(e)
        } catch (W$e) {}
    }
    ))
}
), 1e3);
const _A = e => {
    y.useEffect(( () => (DA.add(e),
    () => {
        DA.delete(e)
    }
    )), [e])
}
  , UA = (e, t=!1) => {
    const {nowTs: n} = y.useContext(OA)
      , r = y.useMemo(( () => null === e ? null : Math.max(n - e, 0)), [n, e]);
    return y.useMemo(( () => WA(r, t)), [r, t])
}
  , WA = (e, t) => {
    if (null === e)
        return null;
    const n = Math.floor(e);
    if (n < 0) {
        const e = -1 * n;
        if (e < 2 * RA.ONE_MINUTE)
            return t ? "in 1m" : "in 1 minute";
        if (e < 1 * RA.ONE_HOUR) {
            const n = Math.floor(e / RA.ONE_MINUTE);
            return t ? `in ${n}m` : `in ${n} minutes`
        }
        if (e < 2 * RA.ONE_HOUR)
            return t ? "in 1h" : "in 1 hour";
        if (e < RA.ONE_DAY) {
            const n = Math.floor(e / RA.ONE_HOUR);
            return t ? `in ${n}h` : `in ${n} hours`
        }
        if (e < 2 * RA.ONE_DAY) {
            const n = Math.floor(e / RA.ONE_DAY);
            return t ? `in ${n}d` : "in 1 day"
        }
        if (e < RA.ONE_MONTH) {
            const n = Math.floor(e / RA.ONE_DAY);
            return t ? `in ${n}d` : `in ${n} days`
        }
        if (e < 2 * RA.ONE_MONTH)
            return t ? "in 1mo" : "in 1 month";
        if (e < RA.ONE_YEAR) {
            const n = Math.floor(e / RA.ONE_MONTH);
            return t ? `in ${n}mo` : `in ${n} months`
        }
        if (e < 2 * RA.ONE_YEAR)
            return t ? "in 1yr" : "in 1 year";
        const r = Math.floor(e / RA.ONE_YEAR);
        return t ? `in ${r}yr` : `in ${r} years`
    }
    if (0 === n)
        return t ? `${n}s` : `${n} seconds ago`;
    if (1 === n)
        return t ? `${n}s` : `${n} second ago`;
    if (n < 60)
        return t ? `${n}s` : `${n} seconds ago`;
    if (n < 2 * RA.ONE_MINUTE)
        return t ? "1m" : "a minute ago";
    if (n < RA.ONE_HOUR) {
        const e = Math.floor(n / RA.ONE_MINUTE);
        return t ? `${e}m` : `${e} minutes ago`
    }
    if (n < 2 * RA.ONE_HOUR)
        return t ? "1h" : "an hour ago";
    if (n < RA.ONE_DAY) {
        const e = Math.floor(n / RA.ONE_HOUR);
        return t ? `${e}h` : `${e} hours ago`
    }
    if (n < 2 * RA.ONE_DAY) {
        const e = Math.floor(n / RA.ONE_DAY);
        return t ? `${e}d` : "a day ago"
    }
    if (n < RA.ONE_MONTH) {
        const e = Math.floor(n / RA.ONE_DAY);
        return t ? `${e}d` : `${e} days ago`
    }
    if (n < 2 * RA.ONE_MONTH)
        return t ? "1mo" : "a month ago";
    if (n < RA.ONE_YEAR) {
        const e = Math.floor(n / RA.ONE_MONTH);
        return t ? `${e}mo` : `${e} months ago`
    }
    if (n < 2 * RA.ONE_YEAR)
        return t ? "1yr" : "a year ago";
    const r = Math.floor(n / RA.ONE_YEAR);
    return t ? `${r}yr` : `${r} years ago`
}
;
var FA = (e => (e.TWEET = "TWEET",
e.RETWEET = "RETWEET",
e.REPLY = "REPLY",
e.QUOTE = "QUOTE",
e.FOLLOW = "FOLLOW",
e.PROFILE_UPDATE = "PROFILE_UPDATE",
e))(FA || {})
  , VA = (e => (e.TRUTHSOCIAL = "TRUTHSOCIAL",
e.TWITTER = "TWITTER",
e))(VA || {})
  , HA = (e => (e.TWEET = "TWEET",
e.FOLLOW = "FOLLOW",
e.PROFILE_UPDATE = "PROFILE_UPDATE",
e.PROFILE_UPDATE_V2 = "PROFILE_UPDATE_V2",
e))(HA || {});
const zA = {
    content: null,
    address: null
}
  , $A = [FA.TWEET, FA.RETWEET, FA.QUOTE, FA.REPLY, FA.FOLLOW, FA.PROFILE_UPDATE]
  , GA = $h.CORK
  , qA = y.createContext({
    allWatchedAccounts: null,
    trackedMessages: null,
    trackedAccounts: null,
    subscribeHandle: async () => !1,
    subscribeUser: async () => !1,
    unsubscribeUser: async () => !1,
    multiUpdate: async () => !1,
    removeAll: async () => !1,
    tweetsFilters: zA,
    setTweetsFilters: c.noop,
    soundEffectEnabled: !1,
    setSoundEffectEnabled: c.noop,
    selectedSoundEffect: GA,
    setSelectedSoundEffect: c.noop,
    notificationsVolume: 100,
    setNotificationsVolume: c.noop
})
  , KA = () => y.useContext(qA)
  , YA = e => e.join("-");
let XA = 0;
const QA = async () => {
    try {
        const e = await kg();
        XA = i().unix() - e.unix()
    } catch (fNe) {}
}
;
QA().finally(( () => {
    setInterval(( () => {
        QA()
    }
    ), 6e4)
}
));
const ZA = () => i().unix() - XA
  , JA = 100
  , ew = 10
  , tw = {
    [$h.CORK]: "cork.mp3",
    [$h.RING]: "ring.mp3",
    [$h.BELL]: "bell.mp3",
    [$h.NICE]: "nice.mp3",
    [$h.YEAH_BOY]: "yeah-boy.mp3",
    [$h.KACHING]: "kaching.mp3",
    [$h.UGH]: "ugh.mp3",
    [$h.CUSTOM]: null
};
const nw = new class {
    constructor() {
        t(this, "howlers", {}),
        t(this, "devSoldHowl"),
        t(this, "customSoundBaseVolume", 100),
        this.devSoldHowl = new K.Howl({
            src: ["/sounds/dev-sold.mp3"]
        });
        for (const e of Object.values($h)) {
            const t = tw[e];
            t && (this.howlers[e] = new K.Howl({
                src: [`/sounds/${t}`]
            }))
        }
    }
    loadCustomSound(e) {
        this.howlers[$h.CUSTOM] = new K.Howl({
            src: [e.contentUri],
            format: [e.contentType.split("/")[1]],
            onloaderror: (e, t) => {
                this.howlers[$h.CUSTOM] = null
            }
        })
    }
    unloadCustomSound() {
        this.howlers[$h.CUSTOM] = null
    }
    setCustomSoundBaseVolume(e) {
        this.customSoundBaseVolume = lb(e, {
            min: 10,
            max: 100
        })
    }
    play(e, t=100) {
        const n = this.howlers[e];
        if (!n)
            return;
        const r = e === $h.CUSTOM && this.customSoundBaseVolume ? this.customSoundBaseVolume / 100 : 1
          , a = lb(t, {
            min: ew,
            max: JA
        }) / 100 * r;
        e === $h.CUSTOM && n.once("play", (e => {
            n.volume(a, e)
        }
        ));
        const s = n.play();
        e !== $h.CUSTOM && n.volume(a, s)
    }
    playDevSold() {
        this.devSoldHowl && this.devSoldHowl.play()
    }
}
  , rw = e => {
    const t = (e => {
        switch (e.type) {
        case "QUOTE":
            return FA.QUOTE;
        case "REPLY":
            return FA.REPLY;
        case "RETWEET":
            return FA.RETWEET;
        case "TWEET":
            return FA.TWEET
        }
    }
    )(e);
    return {
        id: e.id,
        userAvatarUrl: e.author.profile.avatar,
        userName: e.author.profile.name,
        isVerified: e.author.verified ?? !1,
        isEdited: !1,
        userId: `@${e.author.handle}`,
        createdTs: Number((e.created_at ? e.created_at / 1e3 : 0).toFixed(0)),
        platform: VA.TWITTER,
        message: e.body.text,
        videoUrl: e.media.videos.length ? e.media.videos[0] : null,
        imageUrl: e.media.images.length ? e.media.images[0] : null,
        tweetType: t,
        mentions: e.body.mentions,
        urls: e.body.urls,
        userAccountId: e.author.id
    }
}
  , aw = e => {
    switch (e.type) {
    case "PROFILE_UPDATE":
        return {
            current: (n = e).author,
            before: n.before,
            id: "feed-profile-update-id",
            createdTs: n.itemCreatedAt,
            variant: HA.PROFILE_UPDATE
        };
    case "FOLLOW":
        return {
            author: (t = e).author,
            following: t.following,
            id: "feed-follow-tweet-id",
            createdTs: t.itemCreatedAt,
            variant: HA.FOLLOW
        };
    case "PROFILE_UPDATE_V2":
        return (e => ({
            author: e.author,
            id: e.itemId,
            createdTs: e.itemCreatedAt,
            variant: HA.PROFILE_UPDATE_V2,
            oldAvatar: e.oldAvatar,
            oldBanner: e.oldBanner,
            oldBio: e.oldBio
        }))(e);
    case "QUOTE":
    case "REPLY":
    case "RETWEET":
    case "TWEET":
        return {
            variant: HA.TWEET,
            ...rw(e.tweet),
            replyTo: null === e.tweet.subtweet ? null : rw(e.tweet.subtweet)
        };
    default:
        return null
    }
    var t, n
}
  , sw = (e, t, n, r, a, s, o) => {
    const l = ( (e, t) => t.filter((t => {
        const n = `${(r = t).itemId}-${r.itemCreatedAt}-${r.type}`;
        var r;
        return !e.current.has(n) && (e.current.set(n, !0),
        !0)
    }
    )))(t, "init" === e.type ? e.snapshot.items : e.update.updates);
    n.current && (null == l ? void 0 : l.length) ? ( (e, t, n, r, a) => {
        c.forEach(e, (e => {
            const {itemCreatedAt: s} = e;
            s < a - ow || t && nw.play(n, r)
        }
        ))
    }
    )(l, s, r, a, o) : null !== l && (n.current = !0)
}
  , ow = 10
  , lw = () => {
    const e = Ax()
      , [t,n] = y.useState({
        status: ox.INITIAL
    });
    return y.useEffect(( () => {
        let r = !1;
        if (e && t.status !== ox.READY)
            return (async () => {
                try {
                    if (t.status === ox.ERROR && (await Hu(iw),
                    r))
                        return;
                    const a = await fetch("https://twitter-public.padre.gg/watched-accounts/singleton");
                    if (!a.ok)
                        throw new Error("Failed to fetch watched accounts");
                    const s = await (async e => {
                        const t = null == e ? void 0 : e.getReader()
                          , n = new TextDecoder;
                        let r = ""
                          , a = !1;
                        for (; !a; ) {
                            const {value: e, done: s} = await t.read();
                            a = s,
                            e && (r += n.decode(e, {
                                stream: !a
                            }))
                        }
                        return r
                    }
                    )(a.body)
                      , o = JSON.parse(s)
                      , l = (e = o.watchedAccountsCompact,
                    c.reduce(Object.entries(e.accountsByCategory), ( (e, [,t]) => (e.push(...c.reduce(t, ( (e, [t,n]) => (e.push({
                        accountId: t,
                        handle: n,
                        type: Bh.POPULAR
                    }),
                    e)), [])),
                    e)), []));
                    if (r)
                        return;
                    n({
                        data: l,
                        status: ox.READY
                    })
                } catch (fNe) {
                    if (r)
                        return;
                    n({
                        status: ox.ERROR
                    })
                }
                var e
            }
            )(),
            () => {
                r = !0
            }
    }
    ), [e, t.status]),
    t
}
  , iw = 3e3
  , cw = 3e3
  , dw = e => e.id
  , uw = e => c.reduce(e, ( (e, t) => {
    const n = aw(t);
    return n && e.push(n),
    e
}
), [])
  , pw = (e, t) => {
    if ("init" === t.type)
        return {
            messages: c.reduce(uw(t.snapshot.items), ( (e, t) => (e[dw(t)] = t,
            e)), {})
        };
    const n = c.reduce(uw(t.update.updates), ( (e, t) => (e[dw(t)] = t,
    e)), (null == e ? void 0 : e.messages) ? {
        ...e.messages
    } : {});
    var r;
    return {
        messages: (r = n,
        Object.keys(r).length < 80 ? r : c.reduce(Object.values(r).sort(( (e, t) => t.createdTs - e.createdTs)).slice(0, 50), ( (e, t) => (e[dw(t)] = t,
        e)), {}))
    }
}
  , hw = ({children: e}) => {
    const t = Ax()
      , n = pK()
      , [r,a] = Mx("padreV2-trackerTweetsFilters", zA)
      , [s,o] = (y.useMemo(( () => r.content ? YA($A.filter((e => {
        var t;
        return !(null == (t = r.content) ? void 0 : t.includes(e))
    }
    )).sort()) : ""), [r]),
    Mx("padreV2-twitterTrackerSoundEnabled", !1))
      , [l,i] = Mx("padreV2-twitterTrackerSoundVolume", 100)
      , [d,u] = Mx("padreV2-twitterTrackerSelectedSound", GA)
      , p = y.useRef(new hg(1e3))
      , h = y.useRef(!1)
      , m = ZA()
      , g = y.useRef(m);
    g.current = m;
    const x = y.useRef(d);
    x.current = d;
    const b = y.useRef(l);
    b.current = l;
    const f = y.useRef(s);
    f.current = s;
    const S = y.useCallback((e => {
        sw(e, p, h, x.current, b.current, f.current, g.current)
    }
    ), [])
      , k = y.useRef(S);
    y.useEffect(( () => {
        k.current = S
    }
    ), [S]);
    const C = ( (e, t, n, r) => {
        const a = Ax()
          , s = y.useCallback((t => a ? Nm.subscribeTweetFeedV3(a, e, "1", n, {
            onMessage: e => {
                r.current && r.current(e),
                t.onMessage(e)
            }
            ,
            close: e => {
                t.close && t.close(e)
            }
        }) : {
            unsubscribe: () => {}
        }), [e, r, n, a]);
        return kx(s, pw)
    }
    )("", 0, r.address, k)
      , A = lw()
      , w = ( () => {
        const e = Ax()
          , [t,n] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let r = !1;
            if (e && t.status !== ox.READY)
                return (async () => {
                    try {
                        if (t.status === ox.ERROR && (await Hu(cw),
                        r))
                            return;
                        const a = await Nm.getUserSubscribedAccountsV2(e);
                        if (r)
                            return;
                        n({
                            data: a.accounts,
                            status: ox.READY
                        })
                    } catch (fNe) {
                        if (r)
                            return;
                        n({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    r = !0
                }
        }
        ), [e, t.status]),
        t
    }
    )()
      , [j,T] = y.useState(null);
    y.useEffect(( () => {
        w.status === ox.READY && T(w.data)
    }
    ), [w]);
    const I = y.useRef(j);
    y.useEffect(( () => {
        I.current = j
    }
    ), [j]);
    const E = y.useCallback((async ({idsAdds: e, handlesAdds: r, idsDeletes: a}) => {
        const s = I.current;
        if (!s || !t)
            return !1;
        if (!e.length && !r.length && !a.length)
            return !1;
        const o = c.reduce([...s.map((e => ({
            refType: "id",
            ref: e.accountId
        }))), ...r.map((e => ({
            refType: "handle",
            ref: e
        }))), ...e.map((e => ({
            refType: "id",
            ref: e
        })))], ( (e, t) => (e[t.ref] = t,
        e)), {})
          , l = c.reduce(a, ( (e, t) => (delete e[t],
        e)), o)
          , i = Object.values(l);
        try {
            const s = await Nm.setUserSubscribedAccountsV2({
                uid: t,
                accounts: i
            });
            return s.handlesNotFound.length ? n({
                message: uu.handleNotFound,
                type: "warning"
            }, "handle-not-found") : a.length ? n({
                message: uu.stoppedTracking,
                type: "error"
            }, "delete-success") : n(r.length > 0 ? {
                message: uu.trackingCustomHandle,
                snackName: e.length + r.length > 1 ? uu.startedTrackingMulti : uu.startedTracking,
                type: "success"
            } : {
                message: e.length + r.length > 1 ? uu.startedTrackingMulti : uu.startedTracking,
                type: "success"
            }, "added-success"),
            I.current = s.accounts,
            T(s.accounts),
            !0
        } catch (fNe) {
            return !1
        }
    }
    ), [t, n])
      , M = y.useRef(!1)
      , N = y.useRef({
        idsAdds: [],
        handlesAdds: [],
        idsDeletes: []
    })
      , P = y.useRef([])
      , O = y.useCallback((async () => {
        if (M.current)
            return;
        const e = {
            ...N.current
        };
        if (N.current = {
            idsAdds: [],
            handlesAdds: [],
            idsDeletes: []
        },
        e.idsAdds.length || e.handlesAdds.length || e.idsDeletes.length) {
            M.current = !0;
            try {
                const t = await E(e);
                P.current.forEach((e => e(t))),
                P.current = []
            } catch (fNe) {
                P.current.forEach((e => e(!1))),
                P.current = []
            } finally {
                M.current = !1,
                (N.current.idsAdds.length > 0 || N.current.handlesAdds.length > 0 || N.current.idsDeletes.length > 0) && O()
            }
        }
    }
    ), [E])
      , L = y.useCallback((e => j && t && !j.some((t => t.accountId === e)) ? new Promise((t => {
        N.current.idsAdds.push(e),
        P.current.push(t),
        O()
    }
    )) : Promise.resolve(!1)), [O, j, t])
      , R = y.useCallback((e => {
        if (!j || !t)
            return Promise.resolve(!1);
        const n = e.toLowerCase()
          , r = j ? j.find((e => e.handle.toLowerCase() === n)) ?? null : null;
        return new Promise((e => {
            r ? L(r.accountId).then(e) : (N.current.handlesAdds.push(n),
            P.current.push(e),
            O())
        }
        ))
    }
    ), [O, L, j, t])
      , D = y.useCallback((e => new Promise((t => {
        N.current.idsDeletes.push(e),
        P.current.push(t),
        O()
    }
    ))), [O])
      , B = y.useCallback((async ({idsAdds: e, handlesAdds: n, idsDeletes: r}) => {
        if (!j || !t)
            return !1;
        N.current.handlesAdds.push(...n),
        N.current.idsAdds.push(...e),
        N.current.idsDeletes.push(...r);
        try {
            return await O(),
            !0
        } catch (fNe) {
            return !1
        }
    }
    ), [O, j, t])
      , _ = y.useCallback((async () => {
        var e;
        if (!t || !(null == (e = I.current) ? void 0 : e.length))
            return !1;
        try {
            const e = await Nm.setUserSubscribedAccountsV2({
                uid: t,
                accounts: []
            });
            return I.current = e.accounts,
            T(e.accounts),
            n({
                message: uu.stoppedTrackingAll,
                type: "error"
            }, "delete-success"),
            !0
        } catch (fNe) {
            return n({
                message: uu.stoppedTrackingAllFailed,
                type: "error"
            }, "delete-success"),
            !1
        }
    }
    ), [n, t])
      , U = y.useMemo(( () => (null == C ? void 0 : C.messages) ? Object.values(C.messages).sort(( (e, t) => t.createdTs - e.createdTs)).slice(0, 20) : null), [null == C ? void 0 : C.messages])
      , W = y.useMemo(( () => ({
        allWatchedAccounts: A.status === ox.READY ? A.data : null,
        trackedMessages: U,
        trackedAccounts: j,
        subscribeHandle: R,
        subscribeUser: L,
        unsubscribeUser: D,
        multiUpdate: B,
        removeAll: _,
        tweetsFilters: r,
        setTweetsFilters: a,
        soundEffectEnabled: s,
        setSoundEffectEnabled: o,
        selectedSoundEffect: d,
        setSelectedSoundEffect: u,
        notificationsVolume: l,
        setNotificationsVolume: i
    })), [A, U, j, R, L, D, B, _, r, a, s, o, d, u, l, i]);
    return v.jsx(qA.Provider, {
        value: W,
        children: e
    })
}
  , mw = y.createContext({
    openModal: c.noop,
    hasCustomSound: !1
})
  , gw = e => () => {
    const t = D();
    return Y(t.breakpoints.up(e))
}
  , xw = gw("sm")
  , bw = gw("md")
  , fw = gw("lg")
  , vw = gw("xl")
  , Sw = ({decorative: e=!1, stackSx: t={}, maxDesktopHeight: n=yw, minDesktopHeight: r, minDesktopWidth: a=kw, desktopWidth: s=kw, maxDesktopWidth: o, disableBackdropClick: l=!1, children: i, ...c}) => {
    const d = D()
      , u = xw()
      , p = y.useCallback(( (e, t) => {
        c.onClose && ("backdropClick" === t && l || c.onClose(e, t))
    }
    ), [c, l])
      , h = y.useMemo(( () => ({
        ...u ? {
            position: "absolute",
            minWidth: a,
            width: o ? "calc(100% - 24px)" : s,
            maxWidth: o,
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            ":focus-visible": {
                outline: "none"
            }
        } : {},
        height: u ? void 0 : "100%",
        minHeight: u ? `max(${r}${"number" == typeof r ? "px" : ""}, 0px)` : "100%",
        maxHeight: u ? `min(${n}${"number" == typeof n ? "px" : ""}, ${ww})` : "100%",
        overflow: "auto",
        border: e ? "none" : `1px solid ${d.palette.background.borderSubtle}`,
        backgroundColor: d.palette.background.secondary,
        borderRadius: {
            xs: 0,
            sm: e ? 6 : 2
        },
        p: e ? Aw : Cw,
        ...t
    })), [e, s, n, o, r, a, u, t, d.palette.background.borderSubtle, d.palette.background.secondary]);
    return v.jsx(X, {
        disableAutoFocus: !0,
        slotProps: {
            backdrop: {
                transitionDuration: d.transitions.duration.shortest,
                sx: {
                    backdropFilter: "blur(1px)"
                }
            }
        },
        ...c,
        onClose: p,
        children: v.jsx(Q, {
            in: c.open,
            timeout: d.transitions.duration.shorter,
            children: v.jsx(S, {
                className: "padre-no-scroll",
                sx: h,
                children: i
            })
        })
    })
}
  , yw = 650
  , kw = 478
  , Cw = 4
  , Aw = 7
  , ww = "calc(100vh - 48px)"
  , jw = y.memo(( ({valueSuffix: e, Icon: t, iconSize: n=Iw, defaultValue: r, min: a, max: s, step: o, saveValue: l, disabled: i=!1, width: d}) => {
    const [u,p] = y.useState(r)
      , h = y.useMemo(( () => c.debounce((e => {
        l(e)
    }
    ), Tw)), [l]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        width: d,
        gap: 1.5,
        children: [t && v.jsx(C, {
            display: "flex",
            minWidth: Math.max(24, n),
            height: n,
            children: v.jsx(t, {
                size: n
            })
        }), v.jsx(Z, {
            size: "small",
            step: o,
            min: a,
            max: s,
            value: u,
            onChange: (e, t) => {
                const n = t;
                p(n),
                h(n)
            }
            ,
            disabled: i,
            sx: Mw
        }), null !== e && v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            noWrap: !0,
            textAlign: "end",
            sx: Ew,
            children: `${u}${e}`
        })]
    })
}
))
  , Tw = 200
  , Iw = 16
  , Ew = {
    width: 60
}
  , Mw = {
    transition: "none",
    "& .MuiSlider-thumb": {
        transition: "none",
        boxShadow: "none",
        "&:hover, &:focus, &.Mui-active, &.Mui-focusVisible": {
            boxShadow: "none"
        }
    },
    "& .MuiSlider-track": {
        transition: "none"
    },
    "& .MuiSlider-rail": {
        transition: "none"
    },
    "&:hover": {
        backgroundColor: "transparent"
    }
}
  , Nw = ["audio/mpeg", "audio/mp3", "audio/mp4", "video/mp4", "audio/wav"];
let Pw = {
    soundSrc: null,
    ts: 0
};
const Ow = ({children: e}) => {
    const t = D()
      , n = Ax()
      , r = pK()
      , [a,s] = y.useState(!1)
      , [o,l] = y.useState(null)
      , c = y.useCallback((e => {
        s(!0),
        l(e)
    }
    ), [])
      , d = y.useCallback(( () => {
        s(!1),
        l(null)
    }
    ), [])
      , {customSoundSrc: u, refreshCustomSoundSrc: p} = ( () => {
        const e = Ax()
          , [t,n] = y.useState(null)
          , [r,a] = y.useState(!1)
          , s = y.useCallback((async (t=!1) => {
            if ((t || r) && e)
                try {
                    const t = await Im.getSingle(e, Uh.CUSTOM_SOUND)
                      , r = t.result ? {
                        contentType: t.result.contentType,
                        contentUri: t.result.contentUri
                    } : null;
                    Pw = {
                        soundSrc: r,
                        ts: i().unix()
                    },
                    n(r)
                } catch (fNe) {}
        }
        ), [r, e]);
        return y.useEffect(( () => {
            !r && e && (Pw.soundSrc && i().unix() - 600 < Pw.ts ? n(Pw.soundSrc) : (a(!0),
            s(!0)))
        }
        ), [r, s, e]),
        {
            customSoundSrc: t,
            refreshCustomSoundSrc: s
        }
    }
    )();
    y.useEffect(( () => {
        u ? (nw.loadCustomSound(u),
        o && (o(),
        l(null))) : nw.unloadCustomSound()
    }
    ), [u, o]);
    const [h,m] = Mx("padreV2-customSoundVolume", 100)
      , g = y.useCallback((e => {
        m(e),
        nw.setCustomSoundBaseVolume(e),
        nw.play($h.CUSTOM)
    }
    ), [m]);
    y.useEffect(( () => {
        nw.setCustomSoundBaseVolume(h)
    }
    ), [h]);
    const x = y.useMemo(( () => !!u), [u])
      , b = y.useRef(null)
      , [f,C] = y.useState(!1)
      , A = y.useCallback((async e => {
        if (!n)
            return;
        if (!Nw.includes(e.type))
            return void r({
                message: uu.unsupportedFileType,
                snackName: pu.customSoundUploadFailed,
                type: "error"
            }, "sound-upload-error-type");
        if (e.size > Wh[Uh.CUSTOM_SOUND].maxSize)
            return void r({
                message: uu.soundExceedsSize,
                snackName: pu.customSoundUploadFailed,
                type: "error"
            }, "sound-upload-error-size");
        try {
            C(!0);
            const [a,s] = await (t = e,
            new Promise(( (e, n) => {
                const r = new FileReader;
                r.onload = () => {
                    const t = r.result
                      , [n,a] = t.split(",")
                      , s = n.match(/^data:([^;]+);/)
                      , o = s ? s[1] : "";
                    e([o, a])
                }
                ,
                r.onerror = n,
                r.readAsDataURL(t)
            }
            )));
            await Im.upload(n, {
                name: e.name.slice(0, 190),
                base64: s,
                contentType: a,
                contentCategory: Uh.CUSTOM_SOUND
            }),
            await p(),
            r({
                message: pu.customSoundUploadSuccess,
                type: "success"
            }, "sound-upload-success")
        } catch (a) {
            r({
                message: uu.unknownError,
                snackName: pu.customSoundUploadFailed,
                type: "error"
            }, "sound-upload-error")
        } finally {
            C(!1)
        }
        var t
    }
    ), [r, p, n])
      , w = y.useCallback((e => {
        var t;
        const n = null == (t = e.target.files) ? void 0 : t[0];
        n && A(n)
    }
    ), [A])
      , j = y.useCallback(( () => {
        var e;
        null == (e = b.current) || e.click()
    }
    ), [])
      , T = y.useCallback(( () => {
        nw.play($h.CUSTOM)
    }
    ), [])
      , I = y.useMemo(( () => ({
        openModal: c,
        hasCustomSound: x
    })), [c, x]);
    return v.jsxs(mw.Provider, {
        value: I,
        children: [e, a && v.jsx(Sw, {
            open: a,
            onClose: d,
            maxDesktopHeight: Lw,
            desktopWidth: Rw,
            minDesktopWidth: Rw,
            disableBackdropClick: !0,
            stackSx: Dw,
            children: v.jsxs(S, {
                gap: 4,
                children: [v.jsx(S, {
                    gap: 1.5,
                    children: v.jsxs(S, {
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        mt: -1,
                        children: [v.jsx(k, {
                            variant: "h1",
                            color: "text.main",
                            children: "Custom sound"
                        }), v.jsx(F, {
                            sx: _w,
                            onClick: d,
                            children: v.jsx(kS, {
                                size: 20
                            })
                        })]
                    })
                }), v.jsx("input", {
                    ref: b,
                    type: "file",
                    accept: Nw.join(","),
                    hidden: !0,
                    onChange: w
                }), v.jsxs(S, {
                    gap: 1.5,
                    children: [v.jsx(V, {
                        disabled: f,
                        onClick: j,
                        children: v.jsxs(S, {
                            direction: "row",
                            gap: 1,
                            alignItems: "center",
                            children: [v.jsx("span", {
                                children: "Upload custom sound, max 0.2 MB"
                            }), f && v.jsx(J, {
                                size: 12
                            })]
                        })
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        gap: 1,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            children: "Custom sound volume"
                        }), v.jsx(jw, {
                            valueSuffix: "%",
                            Icon: x ? hS : mS,
                            iconSize: 22,
                            defaultValue: h,
                            min: ew,
                            max: JA,
                            step: 10,
                            saveValue: g,
                            disabled: !x,
                            width: 200
                        })]
                    }), x && v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        gap: 1,
                        height: Bw,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            children: "Current sound"
                        }), x ? v.jsxs(V, {
                            onClick: T,
                            sx: _w,
                            variant: "primary",
                            size: "xxsmall",
                            children: [v.jsx(k, {
                                variant: "inherit",
                                color: "inherit",
                                children: "Preview"
                            }), v.jsx(kk, {
                                color: t.palette.text.main
                            })]
                        }) : v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: "None"
                        })]
                    })]
                })]
            })
        })]
    })
}
  , Lw = 1e3
  , Rw = 420
  , Dw = {
    px: 2,
    pb: 2,
    pt: 3
}
  , Bw = 20
  , _w = {
    py: 0,
    pr: .25,
    pl: .75,
    height: Bw,
    border: "none"
}
  , Uw = e => {
    e.preventDefault()
}
  , Ww = e => {
    e.stopPropagation()
}
  , Fw = ({id: e, onClose: t=O, onOpen: n=O, stopPropagation: r=!1}={}) => {
    const a = y.useRef(null)
      , s = y.useId()
      , o = y.useMemo(( () => `button-${e ?? s}`), [e, s])
      , l = y.useMemo(( () => `menu-${e ?? s}`), [e, s])
      , [i,c] = y.useState(!1)
      , d = y.useCallback((e => {
        r && e && e.stopPropagation(),
        n(),
        c(!0)
    }
    ), [n, r])
      , u = y.useCallback(( () => {
        c(!1)
    }
    ), [])
      , p = y.useCallback(( () => {
        t(),
        u()
    }
    ), [u, t]);
    return {
        buttonProps: y.useMemo(( () => ({
            ref: a,
            id: o,
            onClick: d,
            "aria-controls": i ? l : void 0,
            "aria-expanded": !!i || void 0,
            "aria-haspopup": !0
        })), [o, d, i, l]),
        popoverProps: y.useMemo(( () => ({
            id: l,
            anchorEl: a.current,
            open: i,
            onClose: p
        })), [l, i, p]),
        callHandlerAndClose: p
    }
}
  , Vw = 1300
  , Hw = 1250
  , zw = 1240
  , $w = 1303
  , Gw = 1304
  , qw = 1306
  , Kw = 1314
  , Yw = [$h.CORK, $h.RING, $h.BELL, $h.NICE, $h.YEAH_BOY, $h.KACHING, $h.UGH]
  , Xw = $h.CORK
  , Qw = {
    [$h.CORK]: "Cork",
    [$h.RING]: "Ring",
    [$h.BELL]: "Bell",
    [$h.NICE]: "Nice",
    [$h.YEAH_BOY]: "Yeah Bwoi",
    [$h.KACHING]: "Kaching",
    [$h.UGH]: "Ugh",
    [$h.CUSTOM]: "Custom"
}
  , Zw = y.memo(( ({soundEffect: e, isSelected: t}) => {
    const n = D();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        gap: .5,
        minWidth: Jw,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: t ? "text.value" : "text.label",
            children: Qw[e]
        }), t && v.jsx(xy, {
            color: n.palette.text.value
        })]
    })
}
))
  , Jw = 85
  , ej = y.memo(( ({idKey: e, soundEffectEnabled: t, setSoundEffectEnabled: n, selectedSoundEffect: r, setSelectedSoundEffect: a, size: s=rj, usePopper: o=!1, volume: l=100, showName: i=!1, useIconButton: c=!1, disabled: d=!1, isInModal: u=!1, isInFloatingWidget: p=!1, iconSize: h=s - 4, tooltipTitle: m, tooltipOffset: g, disableBackground: x=!1}) => {
    const b = D()
      , {openModal: f, hasCustomSound: A} = y.useContext(mw)
      , {buttonProps: w, popoverProps: j} = Fw({
        id: `sound-effect-select-${e}`
    })
      , T = y.useCallback(( () => {
        a($h.CUSTOM),
        n(!0),
        nw.play($h.CUSTOM)
    }
    ), [a, n])
      , I = y.useCallback(( () => {
        A ? T() : (f(T),
        j.onClose())
    }
    ), [A, f, j, T])
      , E = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        f(A ? null : T)
    }
    ), [f, T, A])
      , M = y.useCallback(( () => {
        n(!1),
        j.onClose()
    }
    ), [j, n])
      , N = y.useMemo(( () => e => ({
        py: 0,
        px: i ? .75 : 0,
        height: s,
        width: i ? void 0 : s,
        minWidth: s,
        ...p || x ? {
            border: "none",
            background: "transparent"
        } : {},
        color: !A && t && r === $h.CUSTOM ? e.palette.error.main : e.palette.text.value,
        "&:hover, &:focus": {
            background: e.palette.background.hover,
            borderColor: "transparent"
        }
    })), [i, s, A, t, r, p, x])
      , P = y.useMemo(( () => e => ({
        p: .25,
        width: s,
        height: s,
        "&:hover": {
            background: e.palette.background.buttonHover
        }
    })), [s])
      , O = y.useMemo(( () => ({
        zIndex: u ? 1380 : p ? 1290 : 4
    })), [p, u])
      , L = v.jsx(ee, {
        elevation: 1,
        sx: sj,
        className: "padre-no-scroll, no-drag",
        children: v.jsxs(S, {
            children: [v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "never",
                sx: aj,
                onClick: M,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: t ? "text.label" : "text.value",
                        children: "None"
                    }), !t && v.jsx(xy, {
                        color: b.palette.text.value
                    })]
                })
            }), Object.values(Yw).map((e => {
                const s = t && r === e;
                return v.jsx(te, {
                    tabIndex: -1,
                    onMouseDown: e => e.preventDefault(),
                    disableRipple: !0,
                    disableTouchRipple: !0,
                    value: e,
                    sx: aj,
                    onClick: async () => {
                        a(e),
                        n(!0),
                        nw.play(e, l),
                        j.onClose()
                    }
                    ,
                    children: v.jsx(Zw, {
                        soundEffect: e,
                        isSelected: s
                    })
                }, e)
            }
            )), v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "never",
                sx: aj,
                onClick: I,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: t && r === $h.CUSTOM ? "text.value" : "text.label",
                        children: A ? "Custom" : "Add custom"
                    }), v.jsxs(S, {
                        height: 14,
                        direction: "row",
                        gap: .5,
                        alignItems: "center",
                        children: [t && r === $h.CUSTOM && v.jsx(xy, {
                            color: b.palette.text.value
                        }), A && v.jsx(F, {
                            sx: oj,
                            onClick: E,
                            children: v.jsx(Ky, {
                                size: 14,
                                color: "inherit"
                            })
                        })]
                    })]
                })
            })]
        })
    });
    return v.jsxs(v.Fragment, {
        children: [v.jsx(GC, {
            title: m,
            offset: g,
            children: v.jsx(C, {
                display: "flex",
                children: c ? v.jsx(F, {
                    ...w,
                    tabIndex: -1,
                    sx: P,
                    onClick: j.open ? j.onClose : w.onClick,
                    disabled: d,
                    children: t ? v.jsx(hS, {
                        size: h,
                        color: "inherit"
                    }) : v.jsx(mS, {
                        size: h,
                        color: b.palette.text.label
                    })
                }) : v.jsxs(V, {
                    ...w,
                    tabIndex: -1,
                    onMouseDown: Uw,
                    onClick: j.open ? j.onClose : w.onClick,
                    variant: "tertiary",
                    size: "xxsmall",
                    sx: N,
                    disabled: d,
                    children: [i && v.jsx(S, {
                        direction: "row",
                        mr: .5,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: t ? Qw[r] : "None"
                        })
                    }), t ? v.jsx(hS, {
                        size: h,
                        color: "inherit"
                    }) : v.jsx(mS, {
                        size: h,
                        color: b.palette.text.label
                    })]
                })
            })
        }), o ? v.jsx(ne, {
            ...j,
            disablePortal: !u,
            onClick: Ww,
            sx: O,
            children: v.jsx(re, {
                onClickAway: j.onClose,
                children: L
            })
        }) : v.jsx(ae, {
            ...j,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: tj,
            transformOrigin: nj,
            children: L
        })]
    })
}
))
  , tj = {
    vertical: "bottom",
    horizontal: "center"
}
  , nj = {
    vertical: "top",
    horizontal: "center"
}
  , rj = 24
  , aj = e => ({
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    },
    height: 27
})
  , sj = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , oj = e => ({
    p: 0,
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.value
    }
})
  , lj = (e, t) => new RegExp(t.split("").join(".*"),"i").test(e);
function ij(e, t, n) {
    if (!n[t[e]])
        throw new Error(`Unknown union type ${t[e]}`);
    return n[t[e]](t)
}
function cj(e) {
    return null !== e
}
const dj = (e, t) => e < t ? e : t
  , uj = 1n << 127n
  , pj = (e, t, n) => {
    if (t < 0n || t > uj)
        throw new RangeError("Value must be a non-negative 128-bit integer.");
    for (let r = 0; r < 16; r++)
        e[n + r] = Number(0xffn & t),
        t >>= 8n
}
;
class hj extends Error {
    constructor(e, t) {
        super(e),
        this.args = t,
        np.error(e, t)
    }
}
const mj = e => new se(e)
  , gj = e => ({
    pubkey: mj(e),
    isSigner: !0,
    isWritable: !0
})
  , xj = e => ({
    pubkey: mj(e),
    isSigner: !1,
    isWritable: !0
})
  , bj = e => ({
    pubkey: mj(e),
    isSigner: !1,
    isWritable: !1
})
  , fj = (...e) => {
    var t;
    const n = null == (t = e.at(0)) ? void 0 : t.feePayer;
    if (!n)
        throw new hj("Empty txn array");
    if (new Set(e.map((e => e.feePayer))).size > 1)
        throw new hj("Cannot join txns with different payers");
    const r = e.flatMap((e => e.instructions));
    return {
        feePayer: n,
        instructions: [...r.filter((e => e.programId.toString() === Qc)), ...r.filter((e => e.programId.toString() !== Qc))],
        lookupTableAccounts: e.flatMap((e => e.lookupTableAccounts))
    }
}
  , vj = e => "exact-in" === e.type
  , Sj = {
    [Rc.RAYDIUM]: 18e4,
    [Rc.PUMP_FUN]: 18e4,
    [Rc.PUMP_SWAP]: 24e4,
    [Rc.WHIRLPOOL]: 4e5,
    [Rc.RAYDIUM_CLMM]: 3e5,
    [Rc.RAYDIUM_CP]: 24e4,
    [Rc.METEORA_OLD]: 24e4,
    [Rc.METEORA_DAMM_V2]: 3e5,
    [Rc.METEORA_DLMM]: 3e5,
    [Rc.BOOP]: 24e4,
    [Rc.METEORA_CURVE]: 24e4,
    [Rc.LAUNCH_LAB]: 24e4,
    [Rc.MOONIT]: 24e4,
    [Rc.HEAVEN]: 24e4,
    [Rc.TOKEN_MILL]: 24e4,
    [Rc.SUGAR]: 24e4,
    [Rc.SUGAR_TEST]: 24e4
}
  , yj = e => {
    switch (e) {
    case vc.SOLANA_SPL:
        return Jc;
    case vc.SOLANA_SPL_2022:
        return ed;
    default:
        throw new hj("Unsupported type",{
            type: e
        })
    }
}
  , kj = (e, t, n) => new ie({
    keys: [gj(e), xj(n.address), xj(t), bj(n.mint), bj(Gc), bj(yj(n.tokenType))],
    programId: mj(Zc),
    data: Buffer.from([1])
})
  , Cj = (e, t, n, r, a, s, o) => {
    const l = Buffer.alloc(10);
    l.writeUInt8(12, 0),
    l.writeBigUInt64LE(s, 1),
    l.writeUint8(o, 9);
    const i = yj(a);
    return new ie({
        keys: [xj(e), bj(r), xj(t), gj(n)],
        programId: mj(i),
        data: l
    })
}
  , Aj = e => {
    const t = [];
    for (let n = 0; n < e; ++n)
        t.push("a".charCodeAt(0) + Math.floor(25 * Math.random()));
    return String.fromCharCode(...t)
}
  , wj = (e, t, n) => {
    const r = Buffer.concat([mj(e).toBuffer(), Buffer.from(t), mj(n).toBuffer()])
      , a = Buffer.from(ue.sha256(r), "hex");
    return new se(a).toString()
}
  , jj = (e, t) => {
    if (Ij(e))
        return {
            baseCurrency: t,
            quoteCurrency: e
        };
    if (Ij(t))
        return {
            baseCurrency: e,
            quoteCurrency: t
        };
    if (Ej(e))
        return {
            baseCurrency: t,
            quoteCurrency: e
        };
    if (Ej(t))
        return {
            baseCurrency: e,
            quoteCurrency: t
        };
    throw new hj("Invalid pair",{
        token0: e,
        token1: t
    })
}
  , Tj = (e, t, n) => {
    const r = n === vc.SOLANA_SPL_2022 ? ed : Jc
      , [a] = se.findProgramAddressSync([mj(e).toBuffer(), mj(r).toBuffer(), mj(t).toBuffer()], mj(Zc));
    return a.toString()
}
  , Ij = e => e === Gc || e === qc
  , Ej = e => e === Kc || e === Yc || e === Xc
  , Mj = (e, t) => ij("protocolType", e, {
    RAYDIUM: e => e.poolStatic,
    RAYDIUM_CP: e => e.poolStatic,
    METEORA_DLMM: e => e.poolStatic,
    METEORA_OLD: e => e.poolStatic,
    PUMP_FUN: () => ({
        token0: t,
        token1: qc
    }),
    PUMP_SWAP: e => e.poolStatic,
    BOOP: e => ({
        token0: e.poolStatic.baseMint,
        token1: qc
    }),
    METEORA_CURVE: e => e.poolStatic,
    LAUNCH_LAB: e => e.poolStatic,
    METEORA_DAMM_V2: e => e.poolStatic,
    WHIRLPOOL: e => e.poolStatic,
    RAYDIUM_CLMM: e => e.poolStatic,
    MOONIT: e => ({
        token0: e.poolStatic.baseMint,
        token1: e.poolStatic.collateralCurrency
    }),
    HEAVEN: e => e.poolStatic,
    TOKEN_MILL: e => e.poolStatic,
    SUGAR: () => ({
        token0: t,
        token1: qc
    }),
    SUGAR_TEST: () => ({
        token0: t,
        token1: qc
    })
})
  , Nj = (e, t) => BigInt(e) * t / 10000n
  , Pj = e => BigInt(ce(e).shiftedBy(9).toFixed(0))
  , Oj = e => {
    if (0 === e.unadjustedPrice)
        return {
            baseReserves: 0n,
            quoteReserves: 0n
        };
    const t = ce(e.unadjustedPrice).sqrt();
    return {
        baseReserves: BigInt(ce(e.liquidity).dividedBy(t).toFixed(0)),
        quoteReserves: BigInt(ce(e.liquidity).multipliedBy(t).toFixed(0))
    }
}
  , Lj = e => e.priceInclDecimals * Math.pow(10, e.quoteDecimals - e.baseDecimals)
  , Rj = (e, t) => {
    const n = e ? ce(t.sqrtPriceX64).dividedBy(2 ** 64) : ce(2 ** 64).dividedBy(t.sqrtPriceX64);
    return n.multipliedBy(n)
}
  , Dj = e => e.sqrt().multipliedBy(2 ** 64).toFixed(0)
  , Bj = 2039280n
  , _j = e => BigInt(e.toFixed(0))
  , Uj = (e, t) => e.filter((e => {
    const n = e[xh];
    return (!t || !t.current.has(n)) && !Ej(e[wh])
}
))
  , Wj = e => {
    switch (e) {
    case ph.BUY_MORE:
    case ph.BUY_FIRST:
        return xc.BUY;
    case ph.SELL_ALL:
    case ph.SELL_PART:
        return xc.SELL
    }
}
  , Fj = (e, t) => e.timestamp !== t.timestamp ? e.timestamp - t.timestamp : (e.tradeIndex ?? 0) - (t.tradeIndex ?? 0)
  , Vj = e => [...e].sort(Fj)
  , Hj = e => (t, n) => {
    if ("init" === n.type) {
        const t = Uj(n.snapshot.trades, e);
        return {
            trades: Vj(t.map((e => Dh(e)))),
            richHoldingInfo: {}
        }
    }
    t || (t = {
        trades: [],
        richHoldingInfo: {}
    });
    const r = Vj(Uj(n.update.newTrades ?? [], e).map((e => Dh(e))))
      , a = [...t.trades, ...r]
      , s = r.length && t.trades.length && Fj(r[0], t.trades[t.trades.length - 1]) < 0 ? Vj(a) : a;
    return {
        trades: r.length ? c.uniqBy(s, (e => e.tradeIndex)).slice(-40) : t.trades,
        richHoldingInfo: {}
    }
}
;
var zj = (e => (e[e.STAR = 0] = "STAR",
e[e.HEART = 1] = "HEART",
e[e.GOAT = 2] = "GOAT",
e[e.MONEY = 3] = "MONEY",
e))(zj || {});
const $j = (e, t) => t ?? Gj[e] ?? Gj[zj.STAR]
  , Gj = {
    [zj.STAR]: "",
    [zj.HEART]: "",
    [zj.GOAT]: "",
    [zj.MONEY]: ""
}
  , qj = e => c.reduce(e, ( (e, t) => (e.push([{
    name: t.name,
    emoji: $j(t.icon, t.emoji),
    groupId: t.groupId
}, new Set(t.addresses)]),
e)), [])
  , Kj = (e, t) => c.reduce(e, ( (e, [n,r]) => (r.has(t) && e.push(n),
e)), [])
  , Yj = (e, t) => `${e}-${t ?? "#"}`
  , Xj = e => e ? c.reduce(e, ( (e, t) => {
    const n = {
        name: t.name,
        emoji: $j(t.icon, t.emoji)
    };
    return t.addresses.forEach((t => {
        e[t] = n
    }
    )),
    e
}
), {}) : {}
  , Qj = {
    trades: [],
    richHoldingInfo: {}
}
  , Zj = (e, t) => {
    if (!e.length)
        return Qj;
    const n = c.reduce(e, ( (e, n, r) => {
        const a = t[n];
        return e.isLoading ? e : a ? (0 === r ? (e.richHoldingInfo = a.richHoldingInfo,
        e.trades = (s = a.trades,
        c.reduce(s, ( (e, t) => (e[Yj(t.txnHash, t.tradeIndex)] = t,
        e)), {}))) : (a.trades.forEach((t => {
            const n = Yj(t.txnHash, t.tradeIndex);
            e.trades[n] || (e.trades[n] = t)
        }
        )),
        Object.entries(a.richHoldingInfo).forEach(( ([t,n]) => {
            e.richHoldingInfo[t] || (e.richHoldingInfo[t] = n)
        }
        ))),
        e) : (e.isLoading = !0,
        e);
        var s
    }
    ), {
        trades: {},
        richHoldingInfo: {},
        isLoading: !1
    });
    return n.isLoading ? null : {
        trades: Object.values(n.trades),
        richHoldingInfo: n.richHoldingInfo
    }
}
  , Jj = ({feedState: e, customWalletNames: t, customWalletEmojis: n, walletGroupsLookup: r, search: a}) => {
    const s = a ? a.trim().toLowerCase() : "";
    return c.reduce(e.trades, ( (a, o) => {
        const {txnHash: l, tradeIndex: i, maker: d, tradeType: u, marketId: p, timestamp: h, baseTokenTotalSupply: m, baseTokenAddress: g, baseTokenDecimals: x, baseTokenName: b, baseTokenSymbol: f, baseTokenType: v, amountInNative: S, amountInUsd: y, priceInUsd: k, tokenAge: C, quoteTokenAddress: A, marketProtocolType: w, marketLaunchpad: j, marketLaunchpadAux: T, isMigration: I} = o;
        if (s && !lj(f, s) && !lj(b, s) && !lj(g, s))
            return a;
        const E = Wj(u)
          , {chain: M} = mg(p)
          , N = h - C
          , P = ng(g)
          , O = ng(A)
          , L = ng(d)
          , R = r[L]
          , D = e.richHoldingInfo[xg(M, P, L)] ?? null
          , B = !c.isNil(x) && m ? k * m : null
          , _ = D ? D[7] ?? null : null
          , U = D ? D[8] ?? null : null
          , W = D ? D[5] ?? null : null
          , F = D ? D[6] ?? null : null
          , V = n[L] ?? null
          , H = t[L] ?? null;
        return a.push({
            txnHash: l,
            tradeIndex: i,
            side: E,
            marketId: p,
            timestamp: h,
            makerAddress: L,
            makerCustomEmoji: V,
            makerCustomName: H,
            walletGroupName: (null == R ? void 0 : R.name) ?? null,
            walletGroupEmoji: (null == R ? void 0 : R.emoji) ?? null,
            tokenAddress: P,
            tokenSymbol: f,
            tokenName: b,
            tokenDecimals: x,
            tokenType: v,
            totalBoughtUsd: W,
            totalSoldUsd: F,
            quoteAddress: O,
            totalSupply: null,
            amountBought: null,
            amountSold: null,
            tokenPriceInUsdUi: k,
            chain: M,
            tokenDeployedAt: N,
            padreAvatarUrl: null,
            amountInNative: S,
            amountInUsd: y,
            remaining: null,
            remainingPercentage: null,
            buyTxns: _,
            sellTxns: U,
            pnl: null,
            marketCapInUsd: B,
            marketProtocolType: w,
            marketLaunchpad: j,
            marketLaunchpadAux: T,
            isMigration: I
        }),
        a
    }
    ), [])
}
  , eT = [ph.BUY_FIRST, ph.BUY_MORE, ph.SELL_PART, ph.SELL_ALL];
var tT = (e => (e.HOME = "/",
e.TRADE = "/trade",
e.SIGN_IN = "/sign-in",
e.TRENDING = "/trending",
e.PORTFOLIO = "/portfolio",
e.WALLETS = "/wallets",
e.TRENCHES = "/trenches",
e.RK = "/rk",
e.TRACKER = "/tracker",
e.REWARDS = "/rewards",
e))(tT || {})
  , nT = (e => (e.WATCHLIST = "watchlist",
e.PUMP_LIVE = "pumpLive",
e.TRENDING = "trending",
e.PORTFOLIO = "portfolio",
e.POSITIONS_ON_TRADE_PAGE = "tradePositions",
e.TRENCHES = "trenches",
e.TRENCHES_SIDE_PANEL = "trenchesSidePanel",
e.TRENCHES_POPULAR_SYMBOLS = "trenchesPopularSymbols",
e.TRACHES_POST_BUY = "trenchesPostBuy",
e.PUMP_NEWS = "pumpNews",
e.PUMP_NEWS_INDICATOR = "pumpNewsIndicator",
e.PUMP_NEWS_HISTORICAL = "pumpNewsHistorical",
e.PRICE_ALERTS = "priceAlerts",
e.LIVE_TRADES = "liveTrades",
e.SEARCH = "search",
e.SEARCH_RECENTS = "searchRecents",
e.SIMILAR_TOKENS = "similarTokens",
e.PASTE_CA = "pasteCa",
e.DEV_TOKENS = "devTokens",
e.ORDER_SUMMARY = "orderSummary",
e.WALLETS_LIST = "walletsList",
e.ALPHA_TRACKER = "alphaTracker",
e.SNACK_TRADE = "snackTrade",
e.SNACK_PRICE_ALERT = "snackPriceAlert",
e.SNACK_ALPHA_TRADE = "snackAlphaTrade",
e.SNACK_LIVE_TRADES_TRACKER = "snackLiveTradesTracker",
e.TOP_BAR_RECENTS = "topBarRecents",
e.TOP_BAR_POSITIONS = "topBarPositions",
e.TOP_BAR_WATCHLIST = "topBarWatchlist",
e.SIDEBAR_RECENTS = "sidebarRecents",
e.SIDEBAR_POSITIONS = "sidebarPositions",
e.WALLET_OVERVIEW_POSITIONS = "walletOverviewPositions",
e.OTHER = "other",
e))(nT || {});
const rT = e => [{
    path: tT.TRENDING,
    label: n.t("Trending"),
    Icon: ay,
    showInBottomBar: !0
}, {
    path: "WALLETS" === e ? tT.WALLETS : tT.PORTFOLIO,
    label: n.t("Portfolio"),
    Icon: sy,
    showInBottomBar: !0
}, {
    path: tT.TRACKER,
    label: n.t("Track"),
    Icon: Wv,
    showInBottomBar: !0
}, {
    path: tT.REWARDS,
    label: n.t("Rewards"),
    Icon: ny,
    showInBottomBar: !0
}, {
    path: tT.TRENCHES,
    Icon: MS,
    label: n.t("Trenches"),
    showInBottomBar: !0
}]
  , aT = {
    [Kh.TRENDING]: [tT.TRENDING],
    [Kh.PORTFOLIO]: [tT.PORTFOLIO, tT.WALLETS],
    [Kh.AUTOMATIONS]: [tT.TRENCHES],
    [Kh.TRACK]: [tT.TRACKER],
    [Kh.REWARDS]: [tT.REWARDS],
    [Kh.TRENCHES]: [tT.TRENCHES]
}
  , sT = (e, t) => {
    const n = new Map(t.flatMap((e => aT[e])).map(( (e, t) => [e, t])));
    return [...e].sort(( (e, t) => {
        const r = n.get(e.path)
          , a = n.get(t.path);
        return void 0 === r ? 1 : void 0 === a ? -1 : r - a
    }
    ))
}
  , oT = [tT.TRENDING, tT.TRACKER, tT.TRENCHES, tT.PORTFOLIO, tT.WALLETS, tT.REWARDS]
  , lT = "backToUrl"
  , iT = tT.TRENCHES
  , cT = () => {
    const {pathname: e, search: t, hash: n} = he()
      , r = me()
      , a = y.useMemo(( () => [e, t, n].filter(Boolean).join("")), [e, t, n]);
    return y.useCallback((s => {
        e !== tT.SIGN_IN && r({
            pathname: tT.SIGN_IN,
            search: t.includes(lT) ? `${t}${n}` : `?${ge({
                [lT]: a
            })}`
        }, s)
    }
    ), [a, r, e, t, n])
}
  , dT = () => {
    const e = me()
      , [t] = xe();
    return y.useCallback(( ({navigationOptions: n, keepSearchParams: r}) => {
        e({
            pathname: `${tT.WALLETS}`,
            search: r ? t.toString() : ""
        }, n)
    }
    ), [e, t])
}
  , uT = e => {
    const t = mg(e);
    if (!t.opts)
        return `/${eg(t.chain)}/${t.marketAddress}`;
    switch (t.opts.type) {
    case "fourmeme":
        return `/${eg(t.chain)}/fm_${t.marketAddress}_${t.opts.tokenAddress}`;
    case "apestore":
        return `/${eg(t.chain)}/as_${t.marketAddress}_${t.opts.tokenAddress}`
    }
}
  , pT = () => {
    const e = me()
      , [t] = xe();
    return y.useCallback(( ({marketId: n, navigationOptions: r, keepSearchParams: a, tradePageOrigin: s}) => {
        if (!n)
            return;
        const o = new URLSearchParams(a ? t : void 0);
        e({
            pathname: `${tT.TRADE}${uT(n)}`,
            search: o.toString()
        }, {
            ...r ? {
                ...r
            } : {},
            state: {
                ...(null == r ? void 0 : r.state) ? {
                    ...r.state
                } : {},
                tradePageOrigin: s
            }
        })
    }
    ), [e, t])
}
  , hT = {
    key: `solana-${Hd}`,
    value: {
        realQuoteToken: null,
        preMigrationMarketId: null,
        createdAt: 1757950381,
        chain: Pd.SOLANA,
        protocol: {
            type: Rc.WHIRLPOOL
        },
        launchpad: null,
        launchpadAux: null,
        marketAddress: Hd,
        baseToken: {
            symbol: "PUMP",
            chain: Pd.SOLANA,
            address: "pumpCmXqMfrsAkQ5r49WcJnRayYRqmXz6ae8H7H9Dfn",
            decimals: 6,
            name: "Pump",
            deployer: "ETFtBU2MYFqN3QW4ktKZfR6XH4mJ7yTawK5QqyzrqoGh",
            deployedAt: 1752153028,
            deployedAtBlock: null,
            tokenType: vc.SOLANA_SPL_2022
        },
        quoteToken: {
            symbol: "SOL",
            chain: Pd.SOLANA,
            address: qc,
            decimals: 9,
            name: "Wrapped SOL",
            deployedAt: 0,
            deployedAtBlock: null,
            deployer: null,
            tokenType: null
        }
    }
}
  , mT = new hg(1e4,[hT])
  , gT = ug((e => e), (async e => {
    const t = await im.batchGetStaticMarketInfo({
        marketIds: [e]
    });
    return t.infos.forEach((e => {
        mT.set(fg(e.chain, e.marketAddress, e.protocol.type === Lc.FOUR_MEME ? {
            type: "fourmeme",
            tokenAddress: e.baseToken.address
        } : null), e)
    }
    )),
    t
}
), 60)
  , xT = M((e => {
    gT(e).catch((e => {}
    ))
}
), 100, {
    leading: !0,
    trailing: !0
})
  , bT = new Ag("fetch-market-smart",{})
  , fT = new hg(1e4)
  , vT = ug(( ({query: e}) => e), (async e => {
    const t = performance.now()
      , n = e.withDeepCacheWarm ? await rm.getMarketSmartWithWarm(e.query) : await rm.getMarketSmart(e.query);
    return (null == n ? void 0 : n.chain) === Pd.SOLANA && bT.recordInit(performance.now() - t),
    n && fg(n.chain, n.marketAddress, n.protocol.type === Lc.FOUR_MEME ? {
        type: "fourmeme",
        tokenAddress: n.baseToken.address
    } : null) === e.query && mT.set(e.query, n),
    n
}
), 60)
  , ST = M((e => {
    vT(e).catch((e => {}
    ))
}
), 100, {
    leading: !0,
    trailing: !0
})
  , yT = () => {
    const e = me()
      , t = pT()
      , [n] = xe();
    return y.useCallback(( ({tokenAddress: r, chain: a, navigationOptions: s, keepSearchParams: o, tradePageOrigin: l}) => {
        if (!r)
            return;
        const c = fT.get(`${a}-${r}`);
        if (c && c.storedAt > i().unix() - 3)
            t({
                marketId: c.bestMarketId,
                keepSearchParams: o,
                tradePageOrigin: l
            });
        else {
            const t = new URLSearchParams(o ? n : void 0);
            e({
                pathname: `${tT.TRADE}/${eg(a)}/${r}`,
                search: t.toString()
            }, {
                ...s ? {
                    ...s
                } : {},
                state: {
                    ...(null == s ? void 0 : s.state) ? {
                        ...s.state
                    } : {},
                    tradePageOrigin: l
                }
            })
        }
    }
    ), [e, t, n])
}
  , kT = "tpo"
  , CT = e => Object.values(nT).includes(e) ? e : null
  , AT = () => {
    const e = ( () => {
        const [e,t] = xe()
          , [n,r] = y.useState(null);
        return y.useEffect(( () => {
            const a = e.get(kT);
            if (!a)
                return void (null !== n && r(null));
            const s = new URLSearchParams(e);
            s.delete(kT),
            t(s, {
                replace: !0
            }),
            r(CT(a))
        }
        ), [e, n, t]),
        n
    }
    )();
    return ( () => {
        const e = he()
          , t = me()
          , n = e.state
          , [r,a] = y.useState(null);
        return y.useEffect(( () => {
            const r = null == n ? void 0 : n.tradePageOrigin
              , s = () => {
                const r = {
                    ...n ?? {}
                };
                delete r.tradePageOrigin,
                t({
                    pathname: e.pathname,
                    search: e.search,
                    hash: e.hash
                }, {
                    replace: !0,
                    state: Object.keys(r).length ? r : null
                })
            }
            ;
            if ("string" != typeof r)
                return a(null),
                void (void 0 !== r && s());
            a(CT(r)),
            s()
        }
        ), [e.hash, e.pathname, e.search, t, n]),
        r
    }
    )() ?? e
}
  , wT = 1e3
  , jT = "padreV2-lastWalletGroupId"
  , TT = {
    borderRadius: "16px",
    borderColor: "transparent",
    "&:hover, &:focus": {
        borderColor: "transparent"
    }
}
  , IT = {
    ...TT,
    px: .75,
    minWidth: 60
}
  , ET = 100
  , MT = {
    tradeType: eT,
    amountInUsd: {},
    mcapInUsd: {},
    tokenAgeSeconds: {}
}
  , NT = y.createContext({
    liveTrades: {},
    alertsEnabled: !1,
    toggleAlertsEnabled: c.noop,
    soundEffectEnabled: !1,
    setSoundEffectEnabled: c.noop,
    selectedSoundEffect: $h.CORK,
    setSelectedSoundEffect: c.noop,
    notificationsVolume: ET,
    setNotificationsVolume: c.noop,
    notificationsDuration: 5,
    setNotificationsDuration: c.noop,
    filters: MT,
    setFilters: c.noop,
    filtersCount: 0
});
class PT extends Error {
    constructor(e) {
        super(`Safe(${OT(e)}): ${LT(e)}`),
        e instanceof Error && (this.stack = e.stack,
        this.name = RT(e.name ?? "SafeError"))
    }
}
const OT = e => (null == e ? void 0 : e.constructor.name) || "unknown"
  , LT = e => e instanceof Error ? RT(e.message ?? "") : "[redacted]"
  , RT = e => e.trim().split(" ").map((e => e.length > 10 ? `${e.slice(0, 10)}...[redacted]` : e)).join(" ").slice(0, 20)
  , DT = {
    createAuthenticator: () => Promise.resolve(),
    providePassword: () => Promise.resolve(),
    injectVelvetBundle: () => {}
    ,
    _passwordHash: null,
    _localStoragePassphrase: null,
    _velvetBundleVersion: null,
    isContextLoading: !1,
    lastError: null,
    hasApiAuthenticator: null,
    apiStamper: null
}
  , BT = y.createContext(DT);
BT.displayName = "VelvetContext";
const _T = e => {
    const t = (e + "=".repeat((4 - e.length % 4) % 4)).replace(/-/g, "+").replace(/_/g, "/")
      , n = window.atob(t)
      , r = new Uint8Array(n.length);
    for (let a = 0; a < n.length; ++a)
        r[a] = n.charCodeAt(a);
    return r
}
  , UT = new be({
    baseUrl: "https://api.turnkey.com"
},new fe({
    rpId: Du.PADRE_TURNKEY_RP_ID
}))
  , WT = e => {
    if (e && 0 !== e.length) {
        const t = new fe({
            rpId: Du.PADRE_TURNKEY_RP_ID,
            allowCredentials: e.map((e => ({
                type: "public-key",
                id: _T(e)
            })))
        });
        return new be({
            baseUrl: "https://api.turnkey.com"
        },t)
    }
    return UT
}
  , FT = (e, t, n) => {
    if (t && !n)
        throw new Error("Missing apiStamper");
    return t && n ? new be({
        baseUrl: "https://api.turnkey.com"
    },n) : WT(e)
}
  , VT = (e, t) => ve.AES.encrypt(e, t).toString()
  , HT = (e, t) => {
    try {
        const n = ve.AES.decrypt(e.encryptedPrivateKey, t).toString(ve.enc.Utf8);
        return n ? new Se({
            apiPublicKey: e.publicKey,
            apiPrivateKey: n
        }) : null
    } catch (W$e) {
        return o(new PT(W$e)),
        null
    }
}
  , zT = "0209f7c49290e791f3a43cd6b40c7a78b9b006cfa421b67de5f3be1652a207d099"
  , $T = ({password: e, passphrase: t}) => {
    const n = ve.enc.Utf8.parse(t);
    return ve.PBKDF2(e, n, {
        keySize: 8,
        iterations: 1e3
    }).toString()
}
  , GT = async () => {
    const e = async () => {
        const e = h()
          , t = h()
          , n = ye()
          , r = FT([], !0, new Se({
            apiPrivateKey: n.privateKey,
            apiPublicKey: n.publicKey
        }));
        return await r.stampCreateApiKeys({
            type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
            organizationId: t,
            timestampMs: String(+(await kg())),
            parameters: {
                userId: e,
                apiKeys: [{
                    apiKeyName: h(),
                    publicKey: zT,
                    expirationSeconds: String(3660),
                    curveType: "API_KEY_CURVE_P256"
                }]
            }
        }),
        n
    }
    ;
    for (let t = 0; t < 10; ++t)
        try {
            return await e()
        } catch (fNe) {}
    return e()
}
;
class qT extends Error {
}
const KT = y.memo(( ({children: e}) => {
    const {user: t, refreshUser: n} = VK()
      , [r,a] = y.useState(!0)
      , [s,l] = y.useState(null)
      , i = pK()
      , c = null == t ? void 0 : t.uid
      , [d,u] = y.useState(null)
      , {velvetBundle: p, injectVelvetBundle: m, isContextLoading: g} = ( () => {
        const {user: e, loading: t} = VK()
          , n = (null == e ? void 0 : e.uid) ?? null
          , [r,a] = y.useState(null)
          , [s,o] = y.useState(!1)
          , [l,i] = y.useState(!1);
        y.useRef(n).current = n;
        const c = y.useCallback((e => {
            e.uid === n && a(e)
        }
        ), [n, a]);
        y.useEffect(( () => {
            if (t || !n)
                return void o(!1);
            let e = !1;
            return i(!0),
            o(!0),
            (async () => {
                let t = 0;
                for (; ; )
                    try {
                        const t = await Em.getVelvetBundles(n);
                        if (e)
                            return;
                        const r = t.bundles.find((e => "2" === e.version))
                          , s = t.bundles.find((e => "2" !== e.version));
                        a(r ?? s ?? null);
                        break
                    } catch (W$e) {
                        if (await Hu(Math.min(2e3 * t, 1e4)),
                        t++,
                        e)
                            return
                    }
                i(!1)
            }
            )(),
            () => {
                i(!1),
                e = !0
            }
        }
        ), [n, t]);
        const d = !n || l || !s
          , u = !r || r.uid === n;
        return n ? {
            velvetBundle: u ? r : null,
            isContextLoading: d,
            injectVelvetBundle: c
        } : {
            velvetBundle: null,
            isContextLoading: !1,
            injectVelvetBundle: () => {}
        }
    }
    )()
      , {passwordHash: x, savePasswordHash: b} = (e => {
        const [t,n] = dx("padreV2-stamper", {})
          , {user: r, loading: a} = VK()
          , s = (null == r ? void 0 : r.uid) ?? null;
        y.useEffect(( () => {
            s || a || n({})
        }
        ), [s, a, n]);
        const o = y.useCallback((t => {
            e && s && n({
                [s]: ve.AES.encrypt(t, e.localStoragePassphrase).toString()
            })
        }
        ), [s, e, n]);
        return {
            passwordHash: y.useMemo(( () => {
                if (!s || !e || s !== e.uid)
                    return null;
                const n = t[s];
                return n ? ve.AES.decrypt(n, e.localStoragePassphrase).toString(ve.enc.Utf8) : null
            }
            ), [s, e, t]),
            savePasswordHash: o
        }
    }
    )(p)
      , f = d ?? x;
    y.useEffect(( () => {
        d && d !== x && b(d)
    }
    ), [d, x, b]);
    const S = y.useMemo(( () => c && p && f && c === p.uid ? HT(p, f) : null), [p, f, c])
      , k = y.useCallback((async e => {
        if (!c)
            throw new Error("User is not logged in, but tried to provide password");
        if (!e)
            throw new Error("Password can't be empty");
        if (!p)
            throw new Error("Tried to provide password, but no velvetBundle");
        a(!0);
        try {
            const t = $T({
                password: e,
                passphrase: p.localStoragePassphrase
            })
              , n = HT(p, t);
            if (!n)
                throw new qT;
            if (await (async e => {
                const t = h()
                  , n = h()
                  , r = FT([], !0, e);
                try {
                    await r.stampCreateApiKeys({
                        type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
                        organizationId: n,
                        timestampMs: String(+(await kg())),
                        parameters: {
                            userId: t,
                            apiKeys: [{
                                apiKeyName: h(),
                                publicKey: zT,
                                expirationSeconds: String(5),
                                curveType: "API_KEY_CURVE_P256"
                            }]
                        }
                    })
                } catch (W$e) {
                    return o(new PT(W$e)),
                    !0
                }
                return !1
            }
            )(n))
                throw new qT;
            u(t)
        } catch (fNe) {
            if (fNe instanceof qT)
                l("Invalid password"),
                i({
                    message: uu.incorrectPassword,
                    snackName: pu.loginFail,
                    type: "error"
                }, "velvet-login-error");
            else {
                const t = new PT(fNe);
                o(t),
                i({
                    message: uu.tryAgainLater,
                    snackName: pu.somethingWentWrong,
                    type: "error"
                }, "velvet-login-error")
            }
        } finally {
            a(!1)
        }
    }
    ), [c, p, i])
      , C = y.useRef(k);
    C.current = k;
    const A = y.useCallback((async e => {
        if (!c || !e)
            return;
        const t = await GT()
          , r = ( (e, t, n) => {
            const r = () => {
                const r = ve.lib.WordArray.random(32).toString(ve.enc.Hex)
                  , a = $T({
                    password: e,
                    passphrase: r
                })
                  , s = {
                    uid: t,
                    publicKey: n.publicKey,
                    encryptedPrivateKey: VT(n.privateKey, a),
                    localStoragePassphrase: r,
                    version: "2"
                };
                return HT(s, a) ? s : null
            }
            ;
            for (let a = 0; a < 100; a++) {
                const e = r();
                if (e)
                    return e
            }
            return o(new Error("Failed to generate velvet bundle after 100")),
            null
        }
        )(e, c, t);
        try {
            if (!r)
                throw new Error("Failed to create velvet bundle");
            await Em.createVelvetBundle(c, r),
            np.info("[Velvet] createAuthenticator called", {
                uid: c,
                version: r.version ?? null
            }),
            m(r),
            await n(),
            await C.current(e)
        } catch (fNe) {
            o(new PT(fNe), {
                extra: {
                    name: "VelvetContextProvider.createAuthenticator"
                }
            }),
            l(fNe instanceof Error ? fNe.message : "Unknown error"),
            i({
                message: uu.tryAgainLater,
                snackName: pu.createPasswordFail,
                type: "error"
            }, "velvet-create-error")
        }
    }
    ), [c, i, n, m])
      , w = y.useMemo(( () => ({
        createAuthenticator: A,
        providePassword: k,
        lastError: s,
        hasApiAuthenticator: !!p,
        apiStamper: S,
        isVerifingPassword: r,
        isContextLoading: g,
        injectVelvetBundle: m,
        _passwordHash: f,
        _localStoragePassphrase: (null == p ? void 0 : p.localStoragePassphrase) ?? null,
        _velvetBundleVersion: (null == p ? void 0 : p.version) ?? null
    })), [A, k, s, p, g, S, r, m, f]);
    return v.jsx(BT.Provider, {
        value: w,
        children: e
    })
}
))
  , YT = () => y.useContext(BT)
  , XT = (e, t, n, r, a, s) => {
    const o = Ax()
      , l = YT()
      , i = y.useMemo(( () => Hj(n)), [n])
      , c = y.useCallback((n => r && o && !ke(e) && l.hasApiAuthenticator && l.apiStamper ? fm.subscribeWalletGroup(e, t, {
        onMessage: t => {
            a.current && a.current(t, e),
            n.onMessage(t)
        }
        ,
        close: e => {
            n.close && n.close(e)
        }
    }) : {
        unsubscribe: () => {}
    }), [o, a, e, t, l.hasApiAuthenticator, l.apiStamper, r])
      , d = kx(c, i);
    return y.useMemo(( () => s ? d : QT), [d, s])
}
  , QT = {
    trades: [],
    richHoldingInfo: {}
}
  , ZT = y.memo(( ({emoji: e, size: t=JT}) => v.jsx("span", {
    style: {
        display: "inline-block",
        width: t,
        height: t,
        fontSize: t - 3,
        lineHeight: `${t}px`,
        textAlign: "center"
    },
    role: "img",
    "aria-label": "emoji",
    children: e ?? ""
})))
  , JT = 16
  , eI = ({currentEmoji: e, onEmojiSelected: t, label: n, stopPropagation: r, height: a, alwaysShowButton: s=!1}) => {
    const {buttonProps: o, popoverProps: l, callHandlerAndClose: i} = Fw({
        id: "emoji-selector",
        stopPropagation: r
    })
      , [c,d] = y.useState(null)
      , u = y.useCallback((e => {
        d(e.emoji),
        t(e.emoji),
        i()
    }
    ), [d, t, i]);
    return v.jsxs(v.Fragment, {
        children: [n || s ? v.jsxs(C, {
            ...o,
            display: "flex",
            alignItems: "center",
            sx: tI,
            height: a ?? void 0,
            children: [v.jsx(ZT, {
                emoji: c ?? e
            }), n && v.jsx(k, {
                color: "text.label",
                variant: "paragraph3",
                children: n
            })]
        }) : v.jsx(F, {
            ...o,
            sx: nI,
            children: v.jsx(ZT, {
                emoji: c ?? e
            })
        }), v.jsx(ae, {
            ...l,
            open: l.open,
            onClick: e => {
                e.stopPropagation()
            }
            ,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            children: v.jsx(ee, {
                elevation: 1,
                sx: e => ({
                    background: e.palette.background.secondary,
                    overflow: "auto",
                    border: `1px solid ${e.palette.background.borderSubtle}`,
                    boxShadow: "none"
                }),
                className: "padre-no-scroll",
                children: v.jsx(Ce, {
                    onEmojiClick: u,
                    theme: Ae.DARK,
                    style: {
                        borderRadius: 0,
                        borderWidth: 0
                    },
                    className: "padre-emoji-picker"
                })
            })
        })]
    })
}
  , tI = e => ({
    borderRadius: 1,
    border: `1px solid ${e.palette.background.borderMain}`,
    gap: 1,
    py: .5,
    px: .75,
    "&:hover": {
        cursor: "pointer"
    }
})
  , nI = {
    p: 0,
    height: 16,
    width: 16
}
  , rI = ""
  , aI = y.memo(( ({address: e, customName: t, customEmoji: n, omitSaveIndicator: r=!1}) => {
    const {t: a} = we()
      , s = Ax()
      , [o,l] = y.useState("")
      , [i,c] = y.useState(!1)
      , d = y.useCallback((e => {
        e.stopPropagation(),
        c(!0),
        t && l(t)
    }
    ), [t])
      , [u,p] = y.useState(!1)
      , h = y.useCallback((e => {
        u || l(e.target.value.slice(0, 120))
    }
    ), [u])
      , m = y.useCallback((async () => {
        if (s)
            if (o !== t && (t || o))
                try {
                    p(!0),
                    await ym.updateCustomWalletNames(s, {
                        [ng(e)]: o || null
                    }),
                    await Hu(sI)
                } catch (fNe) {} finally {
                    c(!1),
                    p(!1)
                }
            else
                c(!1)
    }
    ), [e, t, o, s])
      , g = y.useCallback(( () => {
        m()
    }
    ), [m])
      , x = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        m()),
        "Escape" === e.key && (e.preventDefault(),
        c(!1))
    }
    ), [m])
      , b = y.useCallback((t => {
        s && ym.updateCustomWalletEmojis(s, {
            [ng(e)]: t
        })
    }
    ), [s, e])
      , f = y.useMemo(( () => ({
        color: t ? "text.value" : "text.label",
        cursor: "pointer",
        transition: "color 200ms ease-in-out",
        "&:hover": {
            color: "text.main"
        }
    })), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: i ? .25 : .75,
        ml: -.5,
        children: [v.jsx(C, {
            display: "flex",
            width: 16,
            height: 16,
            children: v.jsx(eI, {
                currentEmoji: n ?? rI,
                onEmojiSelected: b,
                stopPropagation: !0
            })
        }), i ? v.jsx(S, {
            width: 110,
            children: v.jsx(je, {
                autoFocus: !0,
                value: o,
                onChange: h,
                onBlur: g,
                onKeyDown: x,
                onClick: Ww,
                size: "xsmall",
                placeholder: a("Custom name"),
                fullWidth: !0,
                sx: oI,
                inputProps: lI
            })
        }) : v.jsx(S, {
            onClick: d,
            sx: f,
            children: v.jsx(k, {
                maxWidth: 110,
                variant: "paragraph3",
                fontWeight: t ? 500 : 400,
                color: "inherit",
                noWrap: !0,
                lineHeight: 1.1,
                children: t ?? a("Add name")
            })
        }), u && !r ? v.jsx(J, {
            color: "inherit",
            style: iI
        }) : r ? null : v.jsx(C, {
            display: "flex",
            width: 12,
            height: 12
        })]
    })
}
))
  , sI = 300
  , oI = {
    height: 22,
    pl: .25
}
  , lI = {
    style: {
        textAlign: "left",
        fontWeight: 500,
        paddingLeft: "4px",
        paddingRight: "2px",
        paddingTop: "18px",
        fontSize: 12,
        lineHeight: 1.1
    },
    inputMode: "text"
}
  , iI = {
    width: 12,
    height: 12
}
  , cI = (e, t, n, r, a, s, o, l, i, d, u, p, h, m, g, x) => {
    const b = ( (e, t) => t.filter((t => {
        const n = `${(r = t).txnHash}-${r.maker}-${r.tradeType}-${r.priceInNative}`;
        var r;
        return !e.current.has(n) && (e.current.set(n, !0),
        !0)
    }
    )))(n, "init" === e.type ? e.snapshot.trades.map((e => Dh(e))) : e.update.newTrades.map((e => Dh(e))));
    r.current[t] && (null == b ? void 0 : b.length) ? l && ( (e, t, n, r, a, s, o, l, i, d, u, p) => {
        c.forEach(e, (e => {
            const {baseTokenAddress: c, marketId: h, maker: m, timestamp: g, amountInNative: x, priceInUsd: b, baseTokenSymbol: f, baseTokenTotalSupply: v, baseTokenDecimals: S, tokenAge: y, tradeType: k} = e;
            if (g < p - 5)
                return;
            const {chain: C} = mg(h)
              , A = ng(m);
            if (l[A])
                return;
            const w = s[A] ?? null
              , j = o[A] ?? rI;
            n && nw.play(r, a);
            const T = ng(c)
              , I = S && v ? b * Number(v) : null
              , E = () => {
                i(h)
            }
              , M = () => {
                d(A)
            }
            ;
            "visible" === document.visibilityState && t({
                tradeSnackDetails: {
                    maker: A,
                    marketId: h,
                    isMigration: !!e.marketLaunchpad && !Pp.includes(e.marketProtocolType) && !Np.includes(e.marketProtocolType),
                    marketProtocolType: e.marketProtocolType,
                    marketLaunchpad: e.marketLaunchpad,
                    marketLaunchpadAux: e.marketLaunchpadAux,
                    chain: C,
                    tokenAddress: T,
                    tokenSymbol: f,
                    customName: w,
                    customEmoji: j,
                    side: Wj(e.tradeType),
                    tradeType: k,
                    marketCapInUsd: I,
                    amountInNative: x,
                    tokenAge: y
                },
                navigateToMarketPage: E,
                onSilenceClick: M,
                variant: lK.NEW_TRADE
            }, "new-trade-snack", {
                autoHideDuration: 1e3 * lb(u, {
                    min: 1,
                    max: 10
                })
            })
        }
        ))
    }
    )(b, o, i, a, s, d, u, p, h, m, g, x) : null !== b && (r.current[t] = !0)
}
  , dI = ({children: e}) => {
    var t, n, r, a, s, o;
    const l = Ax()
      , {pathname: i} = he()
      , {walletGroups: d, customWalletNames: u, customWalletEmojis: p, customWalletSilenced: h, customWalletOnLiveTrades: m} = rf()
      , g = pK()
      , x = pT()
      , b = y.useCallback((e => {
        x({
            marketId: e,
            tradePageOrigin: nT.SNACK_LIVE_TRADES_TRACKER
        })
    }
    ), [x])
      , [f,S] = Mx("padreV2-trackedWalletsNotificationsEnabled", !0)
      , k = y.useCallback(( () => {
        S((e => !e))
    }
    ), [S])
      , [C,A] = Mx("padreV2-trackedWalletsSoundEnabled", !1)
      , [w,j] = Mx("padreV2-trackedWalletsSoundVolume", ET)
      , [T,I] = Mx("padreV2-trackedWalletsNotificationsDuration", 5)
      , [E,M] = Mx("padreV2-trackedWalletsSound", Xw)
      , N = y.useCallback((async e => {
        if (l)
            try {
                await ym.updateCustomWalletSilenced(l, {
                    [e]: !0
                })
            } catch (fNe) {
                g("Failed to silence wallet", "Sile wallet failed")
            }
    }
    ), [g, l])
      , P = y.useRef(new Set)
      , [O,L] = y.useState(!1);
    y.useEffect(( () => {
        P.current = new Set(Object.entries(m).filter(( ([,e]) => !1 === e)).map(( ([e]) => ng(e)))),
        O || L(!0)
    }
    ), [O, m]);
    const [R,D] = Mx("padreV2-liveTradesFilters", MT)
      , B = y.useMemo(( () => {
        var e, t, n, r, a, s;
        return [void 0 !== (null == (e = R.tokenAgeSeconds) ? void 0 : e.min), void 0 !== (null == (t = R.tokenAgeSeconds) ? void 0 : t.max), void 0 !== (null == (n = R.amountInUsd) ? void 0 : n.min), void 0 !== (null == (r = R.amountInUsd) ? void 0 : r.max), void 0 !== (null == (a = R.mcapInUsd) ? void 0 : a.min), void 0 !== (null == (s = R.mcapInUsd) ? void 0 : s.max), void 0 === R.tradeType || R.tradeType.length !== eT.length].filter(Boolean).length
    }
    ), [null == (t = R.amountInUsd) ? void 0 : t.max, null == (n = R.amountInUsd) ? void 0 : n.min, null == (r = R.mcapInUsd) ? void 0 : r.max, null == (a = R.mcapInUsd) ? void 0 : a.min, null == (s = R.tokenAgeSeconds) ? void 0 : s.max, null == (o = R.tokenAgeSeconds) ? void 0 : o.min, R.tradeType])
      , _ = y.useMemo(( () => d ? d.filter((e => e.addresses.length > 0)).length : 0), [d])
      , U = y.useMemo(( () => JSON.stringify({
        ...R,
        tokenAgeSeconds: R.tokenAgeSeconds ? {
            min: void 0 === R.tokenAgeSeconds.min ? void 0 : 60 * R.tokenAgeSeconds.min,
            max: void 0 === R.tokenAgeSeconds.max ? void 0 : 60 * R.tokenAgeSeconds.max
        } : void 0
    })), [R])
      , W = y.useRef(new hg((null == d ? void 0 : d.length) ? 1e3 : 1))
      , F = y.useRef({})
      , V = ZA()
      , H = y.useRef(V);
    H.current = V;
    const z = y.useRef(E);
    z.current = E;
    const $ = y.useRef(w);
    $.current = w;
    const G = y.useRef(u);
    G.current = u;
    const q = y.useRef(p);
    q.current = p;
    const K = y.useRef(h);
    K.current = h;
    const Y = y.useRef(T);
    Y.current = T;
    const X = y.useRef(C);
    X.current = C;
    const Q = y.useMemo(( () => d ? c.reduce(d, ( (e, t) => {
        const {alertDuration: n, soundVolume: r, soundEffect: a, disableSound: s, groupId: o} = t;
        return e[o] = {
            alertDuration: n,
            soundVolume: r,
            soundEffect: a,
            disableSound: s
        },
        e
    }
    ), {}) : {}), [d])
      , Z = y.useRef(Q);
    y.useEffect(( () => {
        Z.current = Q
    }
    ), [Q]);
    const J = y.useCallback(( (e, t) => {
        const n = Z.current[t] ?? null
          , r = (null == n ? void 0 : n.soundEffect) ?? z.current
          , a = (null == n ? void 0 : n.soundVolume) ?? $.current
          , s = (null == n ? void 0 : n.alertDuration) ?? Y.current
          , o = !(null == n ? void 0 : n.disableSound) && X.current;
        cI(e, t, W, F, r, a, g, f, o, G.current, q.current, K.current, b, N, s, H.current)
    }
    ), [g, f, N, b])
      , ee = y.useRef(J);
    y.useEffect(( () => {
        ee.current = J
    }
    ), [J]);
    const te = XT(d && d.length >= 1 ? d[0].groupId : null, U, P, O, ee, !!d && d.length >= 1 && !!d[0].addresses.length)
      , ne = XT(d && d.length >= 2 ? d[1].groupId : null, U, P, O, ee, !!d && d.length >= 2 && !!d[1].addresses.length)
      , re = XT(d && d.length >= 3 ? d[2].groupId : null, U, P, O, ee, !!d && d.length >= 3 && !!d[2].addresses.length)
      , ae = XT(d && d.length >= 4 ? d[3].groupId : null, U, P, O, ee, !!d && d.length >= 4 && !!d[3].addresses.length)
      , se = XT(d && d.length >= 5 ? d[4].groupId : null, U, P, O, ee, !!d && d.length >= 5 && !!d[4].addresses.length)
      , oe = XT(d && d.length >= 6 ? d[5].groupId : null, U, P, O, ee, !!d && d.length >= 6 && !!d[5].addresses.length)
      , le = XT(d && d.length >= 7 ? d[6].groupId : null, U, P, O, ee, !!d && d.length >= 7 && !!d[6].addresses.length)
      , ie = XT(d && d.length >= 8 ? d[7].groupId : null, U, P, O, ee, !!d && d.length >= 8 && !!d[7].addresses.length)
      , ce = XT(d && d.length >= 9 && d[8].addresses.length ? d[8].groupId : null, U, P, O, ee, !!d && d.length >= 9 && !!d[8].addresses.length)
      , de = XT(d && d.length >= 10 && d[9].addresses.length ? d[9].groupId : null, U, P, O, ee, !!d && d.length >= 10 && !!d[9].addresses.length);
    y.useEffect(( () => {
        W.current = new hg((null == d ? void 0 : d.length) ? 1e3 : 1),
        F.current = {}
    }
    ), [d]);
    const ue = y.useMemo(( () => {
        if (i === tT.SIGN_IN)
            return {};
        if (!d)
            return {};
        const e = {};
        if (Number(!!te) + Number(!!ne) + Number(!!re) + Number(!!ae) + Number(!!se) + Number(!!oe) + Number(!!le) + Number(!!ie) + Number(!!ce) + Number(!!de) < _)
            return {};
        if ((null == d ? void 0 : d.length) >= 1) {
            e[d[0].groupId] = te
        }
        if ((null == d ? void 0 : d.length) >= 2) {
            e[d[1].groupId] = ne
        }
        if ((null == d ? void 0 : d.length) >= 3) {
            e[d[2].groupId] = re
        }
        if ((null == d ? void 0 : d.length) >= 4) {
            e[d[3].groupId] = ae
        }
        if ((null == d ? void 0 : d.length) >= 5) {
            e[d[4].groupId] = se
        }
        if ((null == d ? void 0 : d.length) >= 6) {
            e[d[5].groupId] = oe
        }
        if ((null == d ? void 0 : d.length) >= 7) {
            e[d[6].groupId] = le
        }
        if ((null == d ? void 0 : d.length) >= 8) {
            e[d[7].groupId] = ie
        }
        if ((null == d ? void 0 : d.length) >= 9) {
            e[d[8].groupId] = ce
        }
        if ((null == d ? void 0 : d.length) >= 10) {
            e[d[9].groupId] = de
        }
        return e
    }
    ), [_, d, te, ne, re, ae, se, oe, le, ie, ce, de, i])
      , pe = y.useMemo(( () => ({
        liveTrades: ue,
        alertsEnabled: f,
        toggleAlertsEnabled: k,
        soundEffectEnabled: C,
        setSoundEffectEnabled: A,
        selectedSoundEffect: E,
        setSelectedSoundEffect: M,
        notificationsVolume: w,
        setNotificationsVolume: j,
        notificationsDuration: T,
        setNotificationsDuration: I,
        filters: R,
        setFilters: D,
        filtersCount: B
    })), [ue, f, k, C, A, E, M, w, j, T, I, R, D, B]);
    return v.jsx(NT.Provider, {
        value: pe,
        children: e
    })
}
  , uI = () => y.useContext(NT)
  , pI = y.memo(( ({soundEffectEnabled: e, selectedSoundEffect: t, notificationsVolume: n, setNotificationsVolume: r, notificationsDuration: a, setNotificationsDuration: s, isInFloatingWidget: o=!1, usePopper: l=!0}) => {
    const i = D()
      , {buttonProps: c, popoverProps: d} = Fw({
        id: "notification-custom-options"
    })
      , u = y.useCallback((n => {
        e && nw.play(t, n),
        r(n)
    }
    ), [t, r, e])
      , p = y.useMemo(( () => ({
        zIndex: o ? 1290 : 3
    })), [o])
      , h = y.useCallback(( () => {
        d.open ? d.onClose() : c.onClick()
    }
    ), [c, d])
      , m = y.useMemo(( () => v.jsx(ee, {
        elevation: 1,
        sx: xI,
        className: "padre-no-scroll, no-drag",
        children: v.jsxs(S, {
            width: mI,
            height: l ? void 0 !== a && void 0 !== s ? 64 : 32 : void 0,
            className: "padre-no-scroll",
            gap: 1,
            children: [v.jsx(jw, {
                valueSuffix: "%",
                Icon: hS,
                defaultValue: n,
                min: ew,
                max: JA,
                step: 10,
                saveValue: u
            }), void 0 !== a && void 0 !== s && v.jsx(jw, {
                valueSuffix: "s",
                Icon: Fk,
                defaultValue: a,
                min: 1,
                max: 10,
                step: 1,
                saveValue: s
            })]
        })
    })), [a, n, u, s, l]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...c,
            tabIndex: -1,
            onMouseDown: e => e.preventDefault(),
            onClick: h,
            variant: "tertiary",
            size: "xxsmall",
            sx: gI,
            children: v.jsx(Ny, {
                size: hI - 6,
                color: i.palette.text.label
            })
        }), l ? v.jsx(ne, {
            ...d,
            disablePortal: !0,
            onClick: Ww,
            sx: p,
            children: v.jsx(re, {
                onClickAway: d.onClose,
                children: m
            })
        }) : v.jsx(ae, {
            ...d,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: bI,
            transformOrigin: fI,
            children: m
        })]
    })
}
))
  , hI = 24
  , mI = 200
  , gI = {
    p: 0,
    height: hI,
    width: hI,
    minWidth: hI,
    border: "none",
    background: "transparent"
}
  , xI = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    cursor: "auto",
    p: 1.25
})
  , bI = {
    vertical: "bottom",
    horizontal: "center"
}
  , fI = {
    vertical: "top",
    horizontal: "center"
}
  , vI = y.memo(( ({isInFloatingWidget: e=!1}) => {
    const {soundEffectEnabled: t, setSoundEffectEnabled: n, selectedSoundEffect: r, setSelectedSoundEffect: a, notificationsVolume: s, setNotificationsVolume: o} = KA();
    return v.jsxs(v.Fragment, {
        children: [t && v.jsx(C, {
            component: "span",
            children: v.jsx(pI, {
                soundEffectEnabled: t,
                selectedSoundEffect: r,
                notificationsVolume: s,
                setNotificationsVolume: o,
                usePopper: e,
                isInFloatingWidget: e
            })
        }), v.jsx(C, {
            component: "span",
            children: v.jsx(ej, {
                idKey: "notifications",
                soundEffectEnabled: t,
                setSoundEffectEnabled: n,
                selectedSoundEffect: r,
                setSelectedSoundEffect: a,
                volume: s,
                usePopper: e,
                isInFloatingWidget: e,
                disableBackground: !0
            })
        })]
    })
}
))
  , SI = (e, t) => {
    switch (t) {
    case VA.TRUTHSOCIAL:
        return `https://truthsocial.com/${e}`;
    case VA.TWITTER:
        return `https://x.com/${e}`
    }
}
;
var yI = (e => (e.START = "start",
e.END = "end",
e))(yI || {});
const kI = (e, t, n="start") => `${"start" === n ? t : ""}${e}${"end" === n ? t : ""}`
  , CI = (e, t, n) => `${n && t > 0 ? "+" : t < 0 ? "-" : ""}${e}`
  , AI = e => e.replace(/^[-+]+/g, "")
  , wI = (e, {precision: t=2, symbol: n="$", symbolPosition: r=yI.START, forceSign: a=!1}={}) => {
    if (0 === e)
        return kI(`0.${"0".repeat(t)}`, n, r);
    const [s,o] = (l = Math.abs(e)) >= 1e15 ? ["Q", 15] : l >= 1e12 ? ["T", 12] : l >= 1e9 ? ["B", 9] : l >= 1e6 ? ["M", 6] : l >= 1e3 ? ["K", 3] : ["", 0];
    var l;
    return CI(kI(`${AI((e / 10 ** o).toFixed(t))}${s}`, n, r), e, a)
}
  , jI = (e, {precision: t=2, symbol: n="%", omitSign: r=!1, collapseExponent: a=!1}={}) => {
    if (a)
        return wI(e, {
            precision: 0 === t ? 0 : 1,
            symbol: "%",
            forceSign: !0,
            symbolPosition: yI.END
        });
    return `${r ? "" : e > 0 ? "+" : e < 0 ? "-" : ""}${Math.abs(e).toFixed(t)}${n}`
}
  , TI = {
    0: "",
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: ""
}
  , II = ({decimalPart: e, precision: t, zeros: n}) => c.round(Number(`0.${e.slice(n)}`), t).toFixed(t).split(".")[1]
  , EI = (e, {precision: t=4}={}) => {
    const [n,r] = e.toFixed(36).split(".");
    let a = 0;
    for (const l of r) {
        if ("0" !== l)
            break;
        a++
    }
    let s = II({
        decimalPart: r,
        precision: t,
        zeros: a
    });
    return Number(s) || (a--,
    s = II({
        decimalPart: r,
        precision: t,
        zeros: a
    })),
    a < 3 || e >= 1 || 0 === e ? e.toFixed(t + (2 === a ? 2 : 0)) : `${n}.0${o = a,
    Array.from(o.toString()).map((e => TI[e] || "")).join("")}${s}`;
    var o
}
  , MI = (e, t=2) => {
    if (!e.includes("."))
        return t > 0 ? e + "." + "0".repeat(t) : e;
    const [n,r] = e.split(".");
    if (0 === t)
        return n;
    const a = r.replace(/0+$/, "");
    return `${n}.${a + "0".repeat(Math.max(0, t - a.length))}`
}
  , NI = (e, {precision: t=2, symbol: n="$", symbolPosition: r=yI.START, forceSign: a=!1, removeTrailingZerosPrecision: s}={}) => {
    try {
        const [o,l] = e.toFixed(Math.max(s || 0, t)).split(".")
          , i = o.replace(/\B(?=(\d{3})+(?!\d))/g, ",")
          , c = `${AI(i)}${t ? "." : ""}${l ?? ""}`
          , d = void 0 !== s ? MI(c, s) : c;
        return CI(kI(d, n, r), e, a)
    } catch (W$e) {
        return o(W$e),
        "-"
    }
}
  , PI = {
    precision: 2,
    symbol: "$",
    symbolPosition: yI.START,
    padSymbol: !1
}
  , OI = (e, {collapseExponent: t=!1, ...n}={}) => {
    const r = {
        ...PI,
        ...n
    }
      , a = r.symbol && r.padSymbol ? r.symbolPosition === yI.START ? `${r.symbol} ` : ` ${r.symbol}` : r.symbol;
    return (t ? wI : NI)(e, {
        ...r,
        symbol: a
    })
}
  , LI = (e, t) => {
    const {maxPrecision: n=BI, minPrecision: r=DI, symbol: a="", collapseExponent: s=!1, padSymbol: o=!0, symbolPosition: l=yI.END, removeTrailingZerosPrecision: i, noTrailingZeros: c=!1, desiredDigits: d} = t || {}
      , u = "number" == typeof e ? e : Number(e)
      , p = a && o ? l === yI.START ? `${a} ` : ` ${a}` : a;
    let h = n;
    if (0 === u) {
        const e = void 0 !== i ? MI(u.toFixed(r), i) : u.toFixed(r);
        return kI(c ? RI(e) : e, p, l)
    }
    if (u < .01) {
        const e = EI(u, {
            precision: void 0 !== i ? i : Math.max(1, n - 1)
        });
        return kI(c ? RI(e) : e, p, l)
    }
    if (u > 1 && (h = r),
    void 0 !== d && s) {
        const e = u.toString().split(".")[0].length % 3;
        h = Math.max(0, d - (0 === e ? 3 : e))
    }
    const m = OI(u, {
        collapseExponent: s,
        precision: h,
        symbol: p,
        symbolPosition: l,
        removeTrailingZerosPrecision: i
    });
    return c ? RI(m) : m
}
  , RI = e => e.includes(".") ? e.replace(/\.?0+$/, "") : e
  , DI = 2
  , BI = 4
  , _I = (e, t) => {
    const n = e.toString().split(".")[1];
    return ((null == n ? void 0 : n.length) ?? 0) <= 2 ? 2 : "ETH" === t || "WETH" === t ? e > .1 ? 3 : 4 : e > 1 ? 2 : 3
}
  , UI = e => {
    if (!e.includes("."))
        return e;
    const t = e.replace(/0+$/, "")
      , n = t.split(".");
    return t.split(".")[1].length > 0 ? t : n[0]
}
  , WI = (e, t=!1) => {
    if (e < 0)
        return t ? "00:00" : "00:00:00";
    const n = Math.floor(e / 3600)
      , r = Math.floor(e % 3600 / 60)
      , a = e % 60;
    return [...t ? [] : [n.toString().padStart(2, "0")], r.toString().padStart(2, "0"), a.toString().padStart(2, "0")].join(":")
}
  , FI = "#36D8FF"
  , VI = "#86EFAC"
  , HI = 365
  , zI = ["explore", "Signal", "ALERT", "WHALE", "SHILLED", "TOKEN", "KOL", "Cupseyy", "Just", "Soared", "featured", "skyrocketed", "Whale", "", "", "", "", "", "", "", "", "", "", "ant.fun", "bubble", "token", "alert", "new", "smart", "DONE"]
  , $I = 54
  , GI = y.memo(( ({profilePictureUrl: e, twitterUsername: t, royaltyBps: n, isCreator: r, walletAddress: a}) => {
    const [s,o] = y.useMemo(( () => [t ? SI(t, VA.TWITTER) : null, jA(a, Pd.SOLANA)]), [t, a]);
    return v.jsxs(S, {
        height: $I,
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        children: [v.jsxs(S, {
            direction: "row",
            gap: .75,
            alignItems: "center",
            children: [v.jsx(Te, {
                alt: "user's avatar",
                src: e,
                sx: qI
            }), v.jsxs(S, {
                gap: .25,
                justifyContent: "center",
                children: [v.jsx(k, {
                    variant: "paragraph2",
                    color: "text.label",
                    fontSize: 11,
                    children: r ? "created by" : "royalties to"
                }), v.jsxs(S, {
                    gap: .5,
                    justifyContent: "center",
                    children: [t && v.jsx(C, {
                        component: "a",
                        target: "_blank",
                        href: s || "#",
                        display: "flex",
                        sx: KI,
                        gap: .25,
                        alignItems: "center",
                        onClick: Ww,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            noWrap: !0,
                            children: `@${t.slice(0, XI)}`
                        })
                    }), v.jsx(C, {
                        component: "a",
                        target: "_blank",
                        href: o || "#",
                        gap: .75,
                        display: "flex",
                        sx: YI,
                        onClick: Ww,
                        children: v.jsx(k, {
                            variant: "paragraph2",
                            fontSize: 11,
                            color: "inherit",
                            noWrap: !0,
                            children: oA(a)
                        })
                    })]
                })]
            })]
        }), v.jsx(k, {
            variant: "paragraph1",
            color: "text.label",
            children: jI(lb(n / 100, {
                min: 0,
                max: 100
            }), {
                omitSign: !0,
                precision: 0
            })
        })]
    })
}
))
  , qI = {
    width: 38,
    height: 38
}
  , KI = {
    color: FI,
    textDecoration: "none",
    "&:hover": {
        color: FI,
        textDecoration: "underline",
        cursor: "pointer"
    }
}
  , YI = e => ({
    color: e.palette.text.label,
    textDecoration: "none",
    "&:hover": {
        color: e.palette.text.value,
        cursor: "pointer"
    }
})
  , XI = 30
  , QI = new hg(100)
  , ZI = 5e3
  , JI = y.memo(( ({tokenAddress: e}) => {
    var t;
    const n = (e => {
        const {user: t} = VK()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu(ZI),
                        a))
                            return;
                        const t = ng(e);
                        if (QI.has(t))
                            return void r({
                                status: ox.READY,
                                data: QI.get(t)
                            });
                        const s = await jm.getBagsTokenRoyalties(t);
                        if (QI.set(t, s ? s.response : null),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: s ? s.response : null
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [n, t, e]),
        n
    }
    )(e);
    return v.jsxs(S, {
        minWidth: eE,
        gap: .25,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "Bags token royalties"
        }), n.status === ox.LOADING || n.status === ox.INITIAL ? v.jsx(S, {
            height: 112,
            direction: "row",
            children: v.jsx(Km, {})
        }) : n.status === ox.ERROR ? v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            height: 112,
            direction: "row",
            children: v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: "text.label",
                children: "Couldnt load royalties."
            })
        }) : (null == (t = n.data) ? void 0 : t.length) ? v.jsx(S, {
            gap: .5,
            children: n.data.sort(( (e, t) => (t.isCreator ? 1 : 0) - (e.isCreator ? 1 : 0))).map((e => v.jsx(GI, {
                ...e
            }, e.walletAddress)))
        }) : v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            height: 112,
            direction: "row",
            children: v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: "text.label",
                children: "No royalties has been found"
            })
        })]
    })
}
))
  , eE = 230
  , tE = ({chain: e, size: t=nE, forceMonochromatic: n=!1, defaultColor: r}) => {
    const a = rE(e, n);
    return a ? v.jsx(a, {
        size: t,
        color: r
    }) : v.jsx(Ie, {
        variant: "circular",
        width: t,
        height: t
    })
}
  , nE = 16
  , rE = (e, t) => {
    if (!e)
        return null;
    switch (e) {
    case Pd.ARBITRUM:
    case Pd.ARBITRUM_SEPOLIA:
        return lk;
    case Pd.ETH_MAINNET:
    case Pd.ETH_SEPOLIA:
    case Pd.BASE:
        return Qy;
    case Pd.BSC:
        return Yy;
    case Pd.SOLANA:
        return t ? Zy : Jy
    }
}
  , aE = y.memo(( ({useHref: e=!0, ...t}) => {
    const n = y.useMemo(( () => R && t.controlledOnMobile), [t.controlledOnMobile]);
    return e && !n ? v.jsx(oE, {
        ...t
    }) : v.jsx(sE, {
        ...t
    })
}
))
  , sE = ({link: e, Icon: t, iconSize: n=14, chain: r, preventDefault: a=!1, disableHover: s=!1, color: o, showTooltip: l=!0, noTooltipBackground: i, tooltipTitle: c, interactiveTooltipCallback: d, controlledOnMobile: u=!1, forceEnableInteractive: p=!1, circularBackground: h=!1, maxTooltipWidth: m=365}) => {
    const [g,x] = y.useState(!1)
      , b = y.useMemo(( () => R && u), [u])
      , f = y.useCallback(( () => {
        x(!1)
    }
    ), [])
      , S = y.useCallback((t => {
        if (b)return t.stopPropagation(),
            void x((e => !e));
        a && (t.stopPropagation(),
        t.preventDefault()),
        e && window.open(e, "_blank", "noopener,noreferrer")
    }
    ), [b, e, a])
      , k = y.useMemo(( () => t => ({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        width: n + (h ? lE : 0),
        height: n + (h ? lE : 0),
        cursor: e ? "pointer" : "default",
        textDecoration: "none",
        color: o ?? t.palette.text.label,
        ...h ? {
            background: t.palette.background.buttonActive,
            borderRadius: "50%"
        } : {},
        ...s ? {} : {
            "&:hover": {
                filter: "brightness(1.5)"
            }
        }
    })), [n, h, e, o, s])
      , A = v.jsx(C, {
        onClick: S,
        sx: k,
        children: e && r ? v.jsx(tE, {
            chain: r,
            size: n,
            forceMonochromatic: !0,
            defaultColor: "inherit"
        }) : e && t ? v.jsx(t, {
            size: n,
            color: "inherit"
        }) : v.jsx(Ie, {
            variant: "circular",
            width: n,
            height: n
        })
    });
    if (l) {
        const t = v.jsx(GC, {
            ...d || {},
            disableInteractive: !p && !d,
            maxWidth: m,
            title: c ?? e,
            noTooltipBackground: i,
            open: b ? g : void 0,
            children: A
        });
        return b ? v.jsx(re, {
            onClickAway: f,
            children: v.jsx(C, {
                display: "flex",
                children: t
            })
        }) : t
    }
    return A
}
  , oE = ({link: e, Icon: t, iconSize: n=14, chain: r, preventDefault: a=!1, disableHover: s=!1, color: o, showTooltip: l, tooltipTitle: i, noTooltipBackground: c, interactiveTooltipCallback: d, forceEnableInteractive: u=!1, circularBackground: p=!1, maxTooltipWidth: h=365}) => {
    const m = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        e && window.open(e, "_blank", "noopener,noreferrer")
    }
    ), [e])
      , g = y.useMemo(( () => t => ({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        width: n + (p ? lE : 0),
        height: n + (p ? lE : 0),
        cursor: e ? "pointer" : "default",
        textDecoration: "none",
        color: o ?? t.palette.text.label,
        ...p ? {
            background: t.palette.background.buttonActive,
            borderRadius: "50%"
        } : {},
        ...s ? {} : {
            "&:hover": {
                ...o ? {
                    filter: "brightness(1.5)"
                } : {
                    color: t.palette.primary.main
                }
            }
        }
    })), [p, o, s, n, e])
      , x = v.jsx(C, {
        component: "a",
        href: e || "",
        onClick: a ? m : void 0,
        target: "_blank",
        sx: g,
        children: e && r ? v.jsx(tE, {
            chain: r,
            size: n,
            forceMonochromatic: !0,
            defaultColor: "inherit"
        }) : e && t ? v.jsx(t, {
            size: n,
            color: "inherit"
        }) : v.jsx(Ie, {
            variant: "circular",
            width: n,
            height: n
        })
    });
    return l ? v.jsx(GC, {
        ...d || {},
        disableInteractive: !u && !d,
        maxWidth: h,
        title: i ?? e,
        noTooltipBackground: c,
        link: e ?? void 0,
        children: x
    }) : x
}
  , lE = 10
  , iE = y.memo(( () => {
    const e = y.useMemo(( () => ({
        alignItems: "center",
        borderRadius: "4px",
        pr: .5,
        pl: .25,
        border: `1px solid ${dE}80`,
        background: `${dE}20`,
        height: `${cE}px`,
        textDecoration: "none",
        "&:hover": {
            cursor: "pointer"
        }
    })), []);
    return v.jsx(GC, {
        title: "Can traded only when using Binance website",
        children: v.jsxs(S, {
            direction: "row",
            sx: e,
            component: "a",
            target: "_blank",
            gap: .5,
            children: [v.jsx(Vf, {
                size: cE - 6
            }), v.jsx(k, {
                variant: "paragraph1",
                color: dE,
                fontSize: cE - 5,
                children: "PERMISSIONED"
            })]
        })
    })
}
))
  , cE = 16
  , dE = "#FCD535"
  , uE = y.memo(( ({bannerUrl: e}) => e ? v.jsx("img", {
    src: e,
    alt: "Dex Avatar",
    style: pE,
    loading: "lazy",
    referrerPolicy: "no-referrer"
}) : null))
  , pE = {
    width: "100%",
    height: "100%",
    objectFit: "cover",
    borderRadius: "4px"
}
  , hE = (e, t) => e >= 3600 ? t.palette.red[500] : e >= 600 ? t.palette.orange[500] : t.palette.success.main;
const mE = y.memo((function({ts: e, isShort: t, overwriteColors: n, prefixAdornment: r, suffixAdornment: a, getColorForDelay: s, ...o}) {
    const l = y.useRef(null)
      , c = y.useRef(null)
      , d = D()
      , u = y.useCallback((r => {
        if (null !== e && l.current) {
            const a = Math.max(0, r.unix() - e)
              , o = WA(a, t ?? !0);
            if (l.current.textContent = o,
            n) {
                const e = s ? s(a, d) : hE(a, d);
                l.current.style.color = e,
                c.current && (c.current.style.color = e)
            }
        }
    }
    ), [t, e, d, n, s]);
    _A(u);
    const p = e ? (BA ?? i().unix()) - e : null
      , h = y.useMemo(( () => n ? {
        color: s ? s(p ?? 0, d) : hE(p ?? 0, d)
    } : {}), [p, n, d, s]);
    return v.jsxs(k, {
        ref: c,
        ...o,
        ...h,
        children: [r, v.jsx("span", {
            ref: l,
            children: e ? WA(Math.max(0, (BA ?? i().unix()) - e), t ?? !0) : "-"
        }), a]
    })
}
))
  , gE = y.memo(( ({ts: e, isShort: t, tooltipTitle: n, ...r}) => v.jsx(GC, {
    title: n,
    children: v.jsx(C, {
        component: "span",
        children: v.jsx(mE, {
            ts: e,
            isShort: t,
            variant: "inherit",
            color: "inherit",
            ...r
        })
    })
})))
  , xE = y.memo(( ({ts: e, isShort: t=!1, hideTooltip: n=!1, ...r}) => {
    const a = y.useMemo(( () => n ? "" : e ? i(1e3 * e).format("YYYY-MM-DD HH:mm:ss") : ""), [n, e]);
    return v.jsx(gE, {
        ts: e,
        isShort: t ?? !0,
        tooltipTitle: a,
        ...r
    })
}
))
  , bE = new hg(100)
  , fE = 5e3
  , vE = e => {
    try {
        return new URL(e).hostname
    } catch {
        return null
    }
}
  , SE = y.memo(( ({url: e}) => {
    const t = (e => {
        const {user: t} = VK()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu(fE),
                        a))
                            return;
                        const t = vE(e);
                        if (!t)
                            return;
                        if (bE.has(t))
                            return void r({
                                status: ox.READY,
                                data: bE.get(t)
                            });
                        const s = await Fm.getDomainRegistration({
                            domain: t
                        });
                        if (bE.set(t, s.result === Jh.SUCCESS && s.createdAt ? {
                            domain: t,
                            createdAt: s.createdAt
                        } : null),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: s.result === Jh.SUCCESS && s.createdAt ? {
                                domain: t,
                                createdAt: s.createdAt
                            } : null
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [n, t, e]),
        n
    }
    )(e);
    return v.jsxs(S, {
        component: "a",
        href: e,
        target: "_blank",
        sx: kE,
        onClick: Ww,
        children: [t.status === ox.INITIAL || t.status === ox.LOADING ? v.jsx(Ie, {
            width: "100%",
            height: yE
        }) : t.status !== ox.ERROR && t.data ? v.jsxs(S, {
            direction: "row",
            height: yE,
            justifyContent: "space-between",
            width: "100%",
            gap: 1.5,
            alignItems: "flex-end",
            children: [v.jsx(k, {
                variant: "h2",
                fontWeight: 400,
                color: "text.value",
                children: t.data.domain
            }), v.jsx(mE, {
                variant: "paragraph1",
                ts: t.data.createdAt,
                color: "success.main",
                fontWeight: 400
            })]
        }) : null, v.jsx(k, {
            variant: "inherit",
            color: "text.label",
            height: yE,
            fontWeight: 400,
            noWrap: !0,
            children: e
        })]
    })
}
))
  , yE = 16
  , kE = e => ({
    gap: 1,
    py: .75,
    px: 1,
    background: e.palette.background.secondary,
    borderRadius: "4px",
    border: `1px solid ${e.palette.background.borderMain}`,
    textDecoration: "none",
    "&:hover": {
        background: e.palette.background.tertiary,
        cursor: "pointer"
    }
})
  , CE = {
    textDecoration: "none",
    "&:hover": {
        cursor: "pointer"
    }
}
  , AE = y.memo(( ({mayhemUntilTs: e, size: t=14}) => {
    const n = D()
      , r = y.useRef(null)
      , {t: a} = we()
      , s = y.useCallback((e => `${e ? n.palette.text.label : n.palette.success.main}40`), [n.palette.success.main, n.palette.text.label])
      , o = y.useMemo(( () => {
        const t = Math.max(0, e - ZA())
          , n = t <= 0;
        return {
            label: n ? "" : TE(t),
            isCompleted: n
        }
    }
    ), [e])
      , [l,c] = y.useState(o.isCompleted)
      , d = y.useCallback(( () => {
        const t = Math.max(0, e - ZA())
          , n = t <= 0;
        r.current && (r.current.textContent = n ? "" : TE(t)),
        c((e => e === n ? e : n))
    }
    ), [e])
      , u = y.useCallback((e => {
        d()
    }
    ), [d]);
    _A(u),
    y.useEffect(( () => {
        d()
    }
    ), [d]),
    y.useEffect(( () => {
        c(o.isCompleted),
        r.current && (r.current.textContent = o.label)
    }
    ), [o.isCompleted, o.label]);
    const p = y.useMemo(( () => s(l)), [s, l])
      , h = y.useMemo(( () => v.jsx(S, {
        children: v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: l ? a("Mayhem Mode - completed ({{date}})", {
                date: i.unix(e).format("h:mm A  MMM D, YYYY")
            }) : a("Mayhem Mode Active")
        })
    })), [l, e, a])
      , m = y.useMemo(( () => ({
        justifyContent: "center",
        alignItems: "center",
        height: t,
        borderRadius: "4px",
        pl: l ? "1px" : .5,
        pr: l ? "1px" : .75,
        background: `${n.palette.background.default}40`,
        outline: `1px solid ${p}`,
        gap: l ? 0 : .25,
        color: l ? n.palette.text.label : n.palette.success.main
    })), [l, p, t, n.palette.background.default, n.palette.success.main, n.palette.text.label]);
    return v.jsx(GC, {
        title: h,
        children: v.jsx(C, {
            href: WC,
            component: "a",
            target: "_blank",
            sx: CE,
            display: "flex",
            onClick: wE,
            children: v.jsxs(S, {
                direction: "row",
                sx: m,
                children: [v.jsx(jC, {
                    color: "inherit",
                    size: t - 2
                }), !l && v.jsx(k, {
                    variant: "paragraph1",
                    component: "span",
                    sx: jE,
                    fontSize: t - 3,
                    fontFamily: Cu.GEIST,
                    children: v.jsx("span", {
                        ref: r,
                        children: o.label
                    })
                })]
            })
        })
    })
}
))
  , wE = e => {
    e.stopPropagation(),
    e.preventDefault(),
    window.open(WC, "_blank", "noopener,noreferrer")
}
  , jE = {
    color: "inherit",
    fontVariantNumeric: "tabular-nums",
    textAlign: "center"
}
  , TE = e => {
    const t = Math.max(0, Math.floor(e))
      , n = Math.floor(t / 3600)
      , r = Math.floor(t % 3600 / 60)
      , a = t % 60;
    return `${n.toString().padStart(2, "0")}:${r.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}`
}
  , IE = (e, t) => `https://thumbnails.padre.gg/${e}-${ng(t)}`
  , EE = 290
  , ME = y.memo(( ({mint: e, createdAt: t, name: n, description: r, thumbnail: a, lastReply: s, reply_count: o}) => {
    const l = D()
      , {t: i} = we()
      , c = y.useMemo(( () => `https://pump.fun/coin/${e}`), [e]);
    return v.jsxs(S, {
        overflow: "hidden",
        onClick: Ww,
        children: [v.jsxs(C, {
            component: "a",
            href: c,
            target: "_blank",
            position: "relative",
            sx: _E,
            children: [a ? v.jsx(C, {
                component: "img",
                src: a,
                alt: "Profile banner",
                sx: PE
            }) : v.jsx(C, {
                sx: PE
            }), v.jsx(C, {
                position: "absolute",
                top: 0,
                sx: OE,
                className: BE
            }), v.jsx(C, {
                position: "absolute",
                top: 0,
                sx: LE,
                className: DE,
                children: v.jsx(sS, {
                    color: UE,
                    size: RE
                })
            })]
        }), v.jsxs(S, {
            justifyContent: "space-between",
            minHeight: EE - NE - 1,
            py: 1,
            px: 1,
            gap: 1,
            children: [v.jsxs(S, {
                gap: 1.5,
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    children: [v.jsx(C, {
                        component: "img",
                        src: IE(Pd.SOLANA, e),
                        alt: "Avatar",
                        sx: FE
                    }), v.jsxs(S, {
                        pt: .5,
                        flexGrow: 1,
                        children: [v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: .5,
                            ml: .5,
                            flexGrow: 1,
                            children: [v.jsx(k, {
                                component: "a",
                                href: c,
                                target: "_blank",
                                variant: "h2",
                                color: "text.value",
                                sx: VE,
                                noWrap: !0,
                                maxWidth: 95,
                                children: n
                            }), v.jsxs(S, {
                                direction: "row",
                                gap: .5,
                                alignItems: "flex-end",
                                children: [v.jsx(mE, {
                                    ts: t,
                                    variant: "paragraph3",
                                    color: l.palette.lavender[500],
                                    isShort: !1,
                                    noWrap: !0,
                                    minHeight: HE
                                }), v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.label",
                                    noWrap: !0,
                                    minHeight: HE,
                                    children: `${i("replies:")} ${null === o ? Ud : LI(o, {
                                        collapseExponent: !0,
                                        desiredDigits: 3,
                                        noTrailingZeros: !0,
                                        symbol: ""
                                    })}`
                                })]
                            })]
                        }), v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: .5,
                            children: [v.jsx(cA, {
                                address: e,
                                hideIcon: !0,
                                labelVariant: "paragraph3",
                                isInTooltip: !0
                            }), null !== s && v.jsxs(S, {
                                direction: "row",
                                gap: .25,
                                alignItems: "center",
                                children: [v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.label",
                                    children: i("last reply:")
                                }), v.jsx(mE, {
                                    ts: s,
                                    variant: "paragraph3",
                                    overwriteColors: !0
                                })]
                            })]
                        })]
                    })]
                }), v.jsx(k, {
                    variant: "h1",
                    color: "text.label",
                    fontWeight: 400,
                    lineHeight: 1.2,
                    children: r ?? ""
                })]
            }), v.jsx(V, {
                variant: "tertiary",
                sx: WE,
                href: c,
                target: "_blank",
                onClick: Ww,
                children: i("[open in pumpfun]")
            })]
        })]
    })
}
))
  , NE = 170
  , PE = e => ({
    height: NE,
    width: "100%",
    background: e.palette.background.secondary,
    borderTopLeftRadius: "4px",
    borderTopRightRadius: "4px",
    objectFit: "cover",
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , OE = e => ({
    ...PE(e),
    background: "black",
    opacity: 0,
    border: "none"
})
  , LE = e => ({
    ...PE(e),
    opacity: 0,
    background: "transparent",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "none"
})
  , RE = 34
  , DE = "pumpfun-live-banner-pill"
  , BE = "pumpfun-live-hover-bg-pill"
  , _E = {
    "&:hover": {
        [`.${DE}`]: {
            opacity: 1
        },
        [`.${BE}`]: {
            opacity: .15
        }
    }
}
  , UE = "#86EFAC"
  , WE = {
    alignSelf: "center",
    height: 24,
    width: 180,
    border: "none",
    background: "none",
    fontSize: 14,
    fontWeight: 500,
    "&:hover": {
        border: "none",
        background: "none",
        textDecoration: "underline",
        fontSize: 15,
        fontWeight: 600
    },
    "&:focus": {
        border: "none",
        background: "none"
    }
}
  , FE = {
    width: 36,
    height: 36,
    borderRadius: "50%"
}
  , VE = {
    textDecoration: "none",
    "&:hover": {
        textDecoration: "underline",
        cursor: "pointer"
    }
}
  , HE = 14
  , zE = new hg(20)
  , $E = 5e3
  , GE = y.memo(( ({tokenAddress: e}) => {
    const {t: t} = we()
      , n = (e => {
        const t = Ax()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu($E),
                        a))
                            return;
                        const t = ng(e)
                          , s = zE.has(t) ? zE.get(t) : null;
                        if (s && s.addedAt + 120 >= i().unix())
                            return void r({
                                status: ox.READY,
                                data: s.data
                            });
                        s && s.addedAt + 120 < i().unix() && zE.delete(t);
                        const o = await jm.getCurrentlyLivePumpFunMetadata(t);
                        if (zE.set(t, {
                            addedAt: i().unix(),
                            data: o
                        }),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: o ?? null
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [n, t, e]),
        n
    }
    )(e);
    return v.jsx(S, {
        sx: qE,
        children: n.status === ox.LOADING || n.status === ox.INITIAL ? v.jsx(S, {
            minHeight: EE,
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(Km, {})
        }) : n.status !== ox.ERROR && n.data ? v.jsx(ME, {
            ...n.data
        }) : v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            direction: "row",
            minHeight: EE,
            children: v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: "text.label",
                children: t("Preview unavailable")
            })
        })
    })
}
))
  , qE = e => ({
    background: e.palette.background.secondary,
    width: 300,
    minHeight: EE,
    borderRadius: "4px",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , KE = y.memo(( ({link: e, tokenAddress: t, labelSize: n=14, interactiveTooltipCallback: r}) => {
    const a = y.useMemo(( () => t ? v.jsx(GE, {
        tokenAddress: t
    }) : null), [t])
      , s = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        e && window.open(e, "_blank", "noopener,noreferrer")
    }
    ), [e])
      , o = y.useMemo(( () => ({
        display: "flex",
        alignItems: "center",
        borderRadius: "4px",
        gap: .25,
        pr: .5,
        pl: .25,
        border: `1px solid ${VI}80`,
        background: `${VI}20`,
        height: `${Math.min(YE, n)}px`,
        textDecoration: "none",
        "&:hover": {
            cursor: "pointer"
        }
    })), [n]);
    return v.jsx(GC, {
        ...r || {},
        disableInteractive: !a,
        maxWidth: HI,
        title: a ?? e,
        noTooltipBackground: !0,
        link: e ?? void 0,
        children: v.jsxs(C, {
            sx: o,
            component: "a",
            href: e || "",
            onClick: s,
            target: "_blank",
            children: [v.jsx(Ok, {
                size: Math.min(YE, n) - 2
            }), v.jsx(k, {
                variant: "paragraph1",
                color: VI,
                fontSize: Math.min(YE, n) - 5,
                children: "LIVE"
            })]
        })
    })
}
))
  , YE = 16
  , XE = (e, t, n) => e && t ? `${RC}${tT.TRADE}/${eg(e)}/${ng(t)}${n ? `?${kT}=${n}` : ""}` : void 0
  , QE = (e, t) => e ? `${RC}${tT.TRADE}${uT(e)}${t ? `?${kT}=${t}` : ""}` : void 0
  , ZE = Pd.SOLANA
  , JE = "#86EFAC"
  , eM = y.memo(( ({...e}) => v.jsx(S, {
    sx: tM,
    children: v.jsx(S, {
        direction: "row",
        gap: 1,
        children: v.jsxs(S, {
            justifyContent: "space-between",
            gap: .5,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: .25,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: JE,
                    sx: nM,
                    children: e.headline
                }), e.createdAt && v.jsx(mE, {
                    ts: e.createdAt,
                    variant: "paragraph3",
                    color: `${JE}A8`,
                    lineHeight: 1.15
                })]
            }), v.jsx(k, {
                variant: "paragraph1",
                color: "text.label",
                sx: rM,
                children: e.preview
            })]
        })
    })
})))
  , tM = {
    p: .5,
    gap: 1,
    borderRadius: 2,
    textDecoration: "none",
    minHeight: 120,
    width: 320,
    minWidth: 320
}
  , nM = {
    display: "-webkit-box",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical",
    overflow: "hidden",
    textOverflow: "ellipsis",
    lineHeight: 1.15
}
  , rM = {
    lineHeight: 1.15
}
  , aM = new hg(20)
  , sM = 5e3
  , oM = y.memo(( ({articleId: e}) => {
    const {t: t} = we()
      , n = (e => {
        const t = Ax()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu(sM),
                        a))
                            return;
                        const {missingArticles: t, cachedArticles: s} = c.reduce(e, ( (e, t) => {
                            if (aM.has(t)) {
                                const n = aM.get(t);
                                return n && n.addedAt + 120 < i().unix() ? (aM.delete(t),
                                e.missingArticles.push(t),
                                e) : ((null == n ? void 0 : n.data) ? e.cachedArticles.push(n.data) : e.missingArticles.push(t),
                                e)
                            }
                            return e.missingArticles.push(t),
                            e
                        }
                        ), {
                            missingArticles: [],
                            cachedArticles: []
                        });
                        if (s.length === e.length)
                            return void r({
                                status: ox.READY,
                                data: s
                            });
                        const o = await $m.getArticles(t);
                        if (t.forEach((e => {
                            aM.set(e, {
                                addedAt: i().unix(),
                                data: o.articles.find((t => t.articleId === e)) ?? null
                            })
                        }
                        )),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: [...o.articles, ...s]
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [n, t, e]),
        n
    }
    )(y.useMemo(( () => [e]), [e]))
      , r = y.useMemo(( () => {
        const e = n.status === ox.READY ? n.data.length : 1;
        return 2 * lM * 8 + e * cM * 8 + 120 * e
    }
    ), [n])
      , a = y.useMemo(( () => e => ({
        p: lM,
        background: e.palette.background.secondary,
        width: iM,
        minHeight: r,
        borderRadius: "4px",
        border: `1px solid ${e.palette.background.borderMain}`
    })), [r]);
    return v.jsx(S, {
        sx: a,
        children: n.status === ox.LOADING || n.status === ox.INITIAL ? v.jsx(S, {
            minHeight: r,
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(Km, {})
        }) : n.status !== ox.ERROR && n.data ? v.jsx(S, {
            gap: cM,
            children: n.data.map((e => v.jsx(eM, {
                ...e
            }, e.articleId)))
        }) : v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            direction: "row",
            minHeight: r,
            children: v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: "text.label",
                children: t("Preview unavailable")
            })
        })
    })
}
))
  , lM = 1
  , iM = 320 + 8 * lM * 2
  , cM = 1
  , dM = y.memo(( ({link: e, articleId: t, tokenAddress: n, chain: r, labelSize: a=14}) => {
    const s = y.useMemo(( () => v.jsx(oM, {
        articleId: t
    })), [t])
      , o = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        e && window.open(e, "_blank", "noopener,noreferrer")
    }
    ), [e])
      , l = y.useMemo(( () => ({
        display: "flex",
        alignItems: "center",
        borderRadius: "4px",
        gap: .25,
        pr: .5,
        pl: .25,
        border: `1px solid ${VI}80`,
        background: "transparent",
        height: `${Math.min(uM, a)}px`,
        textDecoration: "none",
        "&:hover": {
            cursor: "pointer"
        }
    })), [a]);
    return v.jsx(GC, {
        maxWidth: HI,
        title: s ?? "",
        noTooltipBackground: !0,
        link: XE(r, n, nT.PUMP_NEWS_INDICATOR) ?? void 0,
        children: v.jsxs(C, {
            sx: l,
            component: "a",
            href: XE(r, n, nT.PUMP_NEWS_INDICATOR) || "",
            onClick: o,
            target: "_blank",
            children: [v.jsx(Ok, {
                size: Math.min(uM, a) - 2
            }), v.jsx(k, {
                variant: "paragraph1",
                color: VI,
                fontSize: Math.min(uM, a) - 5,
                mt: "1px",
                children: "NEWS"
            })]
        })
    })
}
))
  , uM = 16
  , pM = ({target: e, onInteractionStart: t, onInteractionStop: n, child: r}) => {
    const [a,s] = JC(!1, 200);
    y.useEffect(( () => {
        if (!e.current)
            return;
        const a = r ? e.current.querySelector(r) : e.current;
        if (a)
            return t && (a.addEventListener("mouseenter", t),
            a.addEventListener("touchstart", t, {
                passive: !0
            })),
            n && a.addEventListener("mouseleave", n),
            () => {
                t && (a.removeEventListener("mouseenter", t),
                a.removeEventListener("touchstart", t)),
                n && a.removeEventListener("mouseleave", n)
            }
            ;
        s(!0)
    }
    ), [t, n, s, e, r, a])
}
  , hM = ""
  , mM = ""
  , gM = y.memo(( ({presetValues: e, chain: t, isTooltip: n=!0}) => {
    const {t: r} = we()
      , a = y.useMemo(( () => t === Pd.BSC), [t]);
    return v.jsxs(S, {
        gap: .75,
        ...n ? {} : {
            direction: "row",
            alignItems: "center",
            divider: v.jsx(Ee, {
                flexItem: !0,
                orientation: "vertical",
                sx: {
                    mt: .75
                }
            })
        },
        children: [v.jsxs(S, {
            ...bM,
            children: [v.jsx(wy, {
                size: xM
            }), v.jsx(k, {
                ...fM,
                children: vM(e.prio)
            })]
        }), (!a || e.mevProtection) && v.jsxs(S, {
            ...bM,
            children: [v.jsx(_k, {
                size: xM
            }), v.jsx(k, {
                ...fM,
                children: vM(e.tip)
            })]
        }), v.jsxs(S, {
            ...bM,
            children: [v.jsx(Uk, {
                size: xM
            }), v.jsx(k, {
                ...fM,
                children: SM(e.slippage)
            })]
        }), v.jsxs(S, {
            ...bM,
            flex: 0,
            children: [!e.customRpcUrl && e.mevProtection ? v.jsx(Py, {
                size: xM
            }) : v.jsx(Oy, {
                size: xM
            }), v.jsx(k, {
                ...fM,
                children: e.customRpcUrl ? r("Off") : e.mevProtection ? r("On") : r("Off")
            })]
        }), e.customRpcUrl && v.jsx(S, {
            ...bM,
            flex: 0,
            children: v.jsxs(S, {
                children: [v.jsx(k, {
                    ...fM,
                    children: n ? "Custom RPC" : "RPC"
                }), n && v.jsx(k, {
                    ...fM,
                    maxWidth: 100,
                    noWrap: !0,
                    children: e.customRpcUrl
                })]
            })
        })]
    })
}
))
  , xM = 14
  , bM = {
    direction: "row",
    flex: 1,
    alignItems: "flex-end",
    justifyContent: "space-between",
    height: xM,
    mt: .5,
    gap: .5
}
  , fM = {
    variant: "paragraph3",
    color: "text.label"
}
  , vM = e => {
    const t = Number(e);
    return !t || isNaN(t) ? Ud : UI(t > 1 ? wI(t, {
        precision: 2,
        symbol: ""
    }) : EI(t, {
        precision: 3
    }))
}
  , SM = e => {
    const t = Number(e);
    return t && !isNaN(t) ? UI(t >= 1 ? wI(t, {
        precision: 0,
        symbol: "%",
        symbolPosition: yI.END
    }) : `${EI(t, {
        precision: 1
    })}%`) : Ud
}
  , yM = y.memo(( ({positionLeft: e, size: t, color: n, adjustMiddle: r}) => {
    const a = y.useMemo(( () => ({
        zIndex: 3,
        position: "absolute",
        width: kM,
        height: t,
        backgroundColor: n,
        left: `${e}%`,
        transform: (r ? "translateY(0.5px) " : "") + " translate(-50%, -25%)"
    })), [r, n, e, t]);
    return v.jsx(C, {
        sx: a
    })
}
))
  , kM = 2
  , CM = y.memo(( ({name: e, value: t, percentValue: n, isLarge: r}) => v.jsxs(S, {
    direction: "row",
    justifyContent: "space-between",
    gap: 2,
    minWidth: r ? jM : TM,
    children: [v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        children: e
    }), v.jsxs(S, {
        direction: "row",
        divider: v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: wM
        }),
        children: [void 0 !== n && v.jsx(k, {
            variant: "paragraph3",
            color: n > 0 ? "success.main" : n < 0 ? "error.main" : "text.label",
            children: `${jI(n, {
                precision: 0
            })}`
        }), v.jsx(k, {
            sx: AM,
            textAlign: "end",
            variant: "paragraph3",
            color: "text.value",
            children: t
        })]
    })]
})))
  , AM = {
    minWidth: 40
}
  , wM = {
    my: .25,
    ml: .75
}
  , jM = 140
  , TM = 100
  , IM = y.memo(( ({migratedPoolCreatedAt: e, requireMigratedPool: t, curveProgress: n, curveProgressAth: r, migrationPriceInUsd: a, priceInUsd: s, postMigrationPriceInUsdAtl: o, postMigrationPriceInUsdAth: l, totalSupply: i, decimals: c, showAthIndicator: d}) => {
    const u = D()
      , p = y.useMemo(( () => null !== o && a ? Math.min(o / a * 100, NM + 100) / (NM + 100) * 100 : null), [a, o])
      , h = y.useMemo(( () => null !== l && a ? Math.min(l / a * 100, NM + 100) / (NM + 100) * 100 : null), [a, l])
      , m = y.useMemo(( () => null !== s && a ? Math.min(s / a * 100, NM + 100) : null), [a, s])
      , g = y.useMemo(( () => e => ({
        width: "100%",
        height: EM,
        position: "relative",
        backgroundColor: e.palette.background.borderMain,
        borderRadius: "2px"
    })), [])
      , x = y.useMemo(( () => e => ({
        position: "absolute",
        zIndex: 2,
        width: `${Math.min(n, 100)}%`,
        height: "100%",
        backgroundColor: `${e.palette.success.main}${PM}`,
        borderBottomRightRadius: "2px",
        borderTopRightRadius: "2px"
    })), [n])
      , b = y.useMemo(( () => e => null !== m ? {
        position: "absolute",
        zIndex: 2,
        left: `${MM}%`,
        width: Math.abs(m - 100) / 100 * MM + "%",
        transform: m < 100 ? "translateX(-100%)" : "none",
        height: "100%",
        backgroundColor: m < 100 ? `${e.palette.error.main}${PM}` : `${e.palette.success.main}${PM}`,
        borderRadius: "2px"
    } : {
        display: "none"
    }), [m]);
    return v.jsx(GC, {
        title: null !== c && (!e && t || i) ? v.jsxs(S, {
            divider: v.jsx(Ee, {
                orientation: "vertical",
                flexItem: !0,
                sx: {
                    my: .25
                }
            }),
            children: [null === a && v.jsx(CM, {
                name: "Curve",
                value: jI(n, {
                    omitSign: !0
                })
            }), null === a && v.jsx(CM, {
                name: "ATH",
                value: jI(r, {
                    omitSign: !0
                })
            }), (e || !t) && i && null !== a && v.jsx(CM, {
                isLarge: !0,
                name: "MCap",
                value: LI(i * s / 10 ** c, {
                    symbol: "$",
                    symbolPosition: yI.START,
                    padSymbol: !1,
                    collapseExponent: !0,
                    desiredDigits: 2
                }),
                percentValue: a ? (s - a) / a * 100 : void 0
            }), (e || !t) && i && null !== a && v.jsx(CM, {
                isLarge: !0,
                name: "ATH",
                value: null !== l ? `${LI(i * l / 10 ** c, {
                    symbol: "$",
                    symbolPosition: yI.START,
                    padSymbol: !1,
                    collapseExponent: !0,
                    desiredDigits: 2
                })}` : Ud,
                percentValue: l ? l / a * 100 - 100 : void 0
            }), (e || !t) && i && null !== a && v.jsx(CM, {
                name: "Init MCap",
                value: LI(i * a / 10 ** c, {
                    symbol: "$",
                    symbolPosition: yI.START,
                    padSymbol: !1,
                    collapseExponent: !0,
                    desiredDigits: 2
                })
            }), (e || !t) && i && null !== a && v.jsx(CM, {
                isLarge: !0,
                name: "ATL",
                value: null !== o ? `${LI(i * o / 10 ** c, {
                    symbol: "$",
                    symbolPosition: yI.START,
                    padSymbol: !1,
                    collapseExponent: !0,
                    desiredDigits: 2
                })}` : Ud,
                percentValue: o ? o / a * 100 - 100 : void 0
            })]
        }) : "",
        enterDelay: OM,
        enterNextDelay: OM,
        children: v.jsx(C, {
            sx: LM,
            children: v.jsx(C, {
                sx: g,
                children: !e && t || null === a ? v.jsxs(v.Fragment, {
                    children: [v.jsx(C, {
                        sx: x
                    }), v.jsx(yM, {
                        positionLeft: Math.min(r, 100),
                        size: 6,
                        color: u.palette.success.main
                    })]
                }) : v.jsxs(v.Fragment, {
                    children: [null !== m && v.jsx(C, {
                        sx: b
                    }), null !== p && d && v.jsx(yM, {
                        positionLeft: p,
                        size: 6,
                        color: u.palette.error.main
                    }), null !== h && d && v.jsx(yM, {
                        positionLeft: h,
                        size: 6,
                        color: u.palette.success.main
                    }), v.jsx(yM, {
                        positionLeft: MM,
                        size: 6,
                        color: u.palette.text.main
                    })]
                })
            })
        })
    })
}
))
  , EM = 3
  , MM = 16.67
  , NM = 500
  , PM = "AA"
  , OM = 150
  , LM = {
    width: "100%",
    mb: "-4px",
    mt: "-4px",
    height: 8 + EM,
    position: "relative",
    alignItems: "center",
    display: "flex"
}
  , RM = (e, t, n, r) => {
    if (e)
        return [r.palette.gold[500], r.palette.gold[500]];
    if (t)
        switch (t) {
        case "believe":
            return ["#0D8E32", r.palette.originalGreen[700]];
        case "bonk":
        case "launchlab":
            return ["#FF8B69", "#522D2D"];
        case "moonshot":
            return ["#FE88FE", "#905392"];
        case "tvt":
            return ["#3EBDAA", "#126458"];
        case "bags":
            return ["#3E9A00", "#244816"];
        case "jup":
            return ["#FE997B", "#70473E"];
        case "pumpfun":
            return [r.palette.originalGreen[500], r.palette.originalGreen[700]];
        case "sugar":
            return ["#EA9DBA", "#994680"];
        case "moonit":
            return ["#DFFF16", "#59661E"];
        case "heaven":
            return ["#EEEEEE", "#888888"];
        case "token-mill":
            return ["#E21C23", "#5F1D20"];
        case "boop":
            return ["#43A1F9", "#0E3253"];
        case "meteora-curve":
            return ["#D11F3B", "#590F1B"];
        case "fourmeme":
            return ["#7CE660", "#244816"]
        }
    switch (n) {
    case Lc.AERODROME_V2:
    case Lc.AERODROME_V3:
        return ["#FFFFFF", "#FFFFFF"];
    case Lc.VISTA:
        return ["", ""];
    case Lc.PANCAKE_V3:
        return ["#3FCBD9", "#29575C"];
    case Lc.FOUR_MEME:
        return ["#7CE660", "#244816"];
    case Lc.UNISWAP_V2:
    case Lc.UNISWAP_V3:
        return ["#FF37C8", "#FF37C8"];
    case Rc.METEORA_CURVE:
    case Rc.METEORA_DAMM_V2:
    case Rc.METEORA_DLMM:
    case Rc.METEORA_OLD:
        return ["#D11F3B", "#590F1B"];
    case Rc.RAYDIUM:
    case Rc.RAYDIUM_CLMM:
    case Rc.RAYDIUM_CP:
    case Rc.WHIRLPOOL:
        return [r.palette.gold[500], r.palette.gold[500]];
    case Rc.BOOP:
        return ["#43A1F9", "#0E3253"];
    case Rc.PUMP_FUN:
        return [r.palette.originalGreen[500], r.palette.originalGreen[700]];
    case Rc.MOONIT:
        return ["#DFFF16", "#59661E"];
    case Rc.PUMP_SWAP:
        return [r.palette.gold[500], r.palette.gold[500]];
    case Rc.LAUNCH_LAB:
        return ["#FF8B69", "#522D2D"];
    case Rc.TOKEN_MILL:
        return ["#E21C23", "#5F1D20"]
    }
    return [r.palette.text.label, r.palette.text.value]
}
  , DM = y.memo(( ({migrated: e, curveProgress: t, curveProgressAth: n, launchpad: r, launchpadAux: a, protocolType: s, showAthIndicator: o}) => {
    const l = D()
      , i = y.useMemo(( () => e ? 100 : t), [t, e])
      , [c,d] = y.useMemo(( () => RM(e, a ?? r, s, l)), [r, a, e, l, s])
      , u = y.useMemo(( () => t => ({
        position: "absolute",
        zIndex: 2,
        width: `${Math.min(i, 100)}%`,
        height: "100%",
        backgroundColor: e ? t.palette.gold[500] : c,
        borderRadius: "2px"
    })), [e, i, c])
      , p = y.useMemo(( () => ({
        width: _M,
        height: BM,
        position: "relative",
        backgroundColor: d,
        borderRadius: "2px",
        transform: "translateY(2px)"
    })), [d]);
    return v.jsxs(C, {
        sx: p,
        children: [v.jsx(C, {
            sx: u
        }), !e && o && v.jsx(yM, {
            positionLeft: Math.min(n, 100),
            size: 2,
            color: c,
            adjustMiddle: !0
        })]
    })
}
))
  , BM = 2
  , _M = 66
  , UM = y.memo(( ({label: e, selectedColor: t, setSelectedColor: n, defaultColor: r, placeholderColor: a}) => {
    const s = D()
      , [o,l] = y.useState(null)
      , [i,d] = y.useState(t ?? a);
    y.useEffect(( () => {
        t || d(a)
    }
    ), [a, t]),
    y.useEffect(( () => {
        i && !/^#([0-9A-F]{3}){1,2}$/i.test(i) && (n(r),
        d(r ?? a))
    }
    ), [i, n, r, a]);
    const u = y.useCallback((e => {
        l(e.currentTarget)
    }
    ), [])
      , p = y.useCallback(( () => {
        l(null)
    }
    ), [])
      , h = y.useRef(c.debounce((e => {
        n(e)
    }
    ), HM, {
        maxWait: HM
    })).current
      , m = y.useCallback((e => {
        d(e.hex),
        h(e.hex)
    }
    ), [h])
      , g = y.useCallback(( () => {
        n(null),
        d(r ?? a)
    }
    ), [r, a, n])
      , x = y.useMemo(( () => e => ({
        width: WM,
        height: WM,
        borderRadius: .5,
        backgroundColor: i || e.palette.success.main,
        border: `1px solid ${Me(i || e.palette.success.main, .08)}`,
        cursor: "pointer"
    })), [i]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: zM,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.value",
            children: e
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(C, {
                onClick: u,
                sx: x
            }), v.jsx(F, {
                sx: VM,
                onClick: g,
                children: v.jsx(_S, {
                    size: FM
                })
            })]
        }), v.jsx(ae, {
            open: !!o,
            anchorEl: o,
            onClose: p,
            anchorOrigin: $M,
            children: v.jsx(re, {
                onClickAway: p,
                children: v.jsx(Ne, {
                    color: i || s.palette.success.main,
                    onChange: m,
                    disableAlpha: !0
                })
            })
        })]
    })
}
))
  , WM = 16
  , FM = 14
  , VM = {
    p: .5
}
  , HM = 100
  , zM = e => ({
    px: 1.75,
    height: 31,
    background: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , $M = {
    vertical: "bottom",
    horizontal: "left"
}
  , GM = y.memo(( ({label: e, defaultValue: t, min: n, max: r, step: a, saveValue: s}) => {
    const [o,l] = y.useState(t)
      , i = y.useMemo(( () => c.debounce((e => {
        s(e)
    }
    ), qM, {
        maxWait: qM
    })), [s]);
    y.useEffect(( () => (i(o),
    () => {
        i.cancel()
    }
    )), [o, i]);
    return v.jsxs(S, {
        gap: .25,
        sx: KM,
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.value",
            noWrap: !0,
            children: e
        }), v.jsx(Z, {
            size: "small",
            step: a,
            min: n,
            max: r,
            value: o,
            onChange: (e, t) => {
                l(t)
            }
            ,
            sx: YM
        })]
    })
}
))
  , qM = 200
  , KM = e => ({
    px: 1.75,
    height: 33,
    background: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , YM = {
    maxWidth: 105,
    transition: "none",
    "& .MuiSlider-thumb": {
        transition: "none",
        boxShadow: "none",
        "&:hover, &:focus, &.Mui-active, &.Mui-focusVisible": {
            boxShadow: "none"
        }
    },
    "& .MuiSlider-track": {
        transition: "none"
    },
    "& .MuiSlider-rail": {
        transition: "none"
    },
    "&:hover": {
        backgroundColor: "transparent"
    }
}
  , XM = N(( () => {
    const e = new Set;
    return {
        registerTrenchesNewSearch: t => (e.add(t),
        () => {
            e.delete(t)
        }
        ),
        invokeTrenchesNewSearch: t => {
            e.forEach((e => e(t)))
        }
        ,
        hasListeners: () => e.size > 0
    }
}
))
  , QM = y.memo(( ({twitterUrl: e, twitterHandle: t, maxWidth: n=ZM}) => t ? v.jsx(GC, {
    title: t,
    children: v.jsx(C, {
        display: "flex",
        component: "a",
        href: e,
        target: "_blank",
        rel: "noopener nofollow",
        sx: JM,
        onClick: Ww,
        children: v.jsx(k, {
            sx: eN,
            variant: "paragraph3",
            color: FI,
            noWrap: !0,
            maxWidth: n,
            children: `@${t}`
        })
    })
}) : null))
  , ZM = 75
  , JM = {
    textDecoration: "none"
}
  , eN = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    flexShrink: 1,
    "&:hover": {
        textDecoration: "underline"
    }
}
  , tN = "fast-search-available"
  , nN = "tweet-url"
  , rN = "tweet-mention-handle"
  , aN = "tweet-hashtag"
  , sN = "#1D9BF0"
  , oN = e => Array.from(e).filter((e => e.charCodeAt(0) <= 255)).join("")
  , lN = (e, t, n) => {
    switch (n) {
    case VA.TRUTHSOCIAL:
        return `https://truthsocial.com/${t}${e ? `/posts/${e}` : ""}`;
    case VA.TWITTER:
        return `https://x.com/${t}${e ? `/status/${e}` : ""}`
    }
}
  , iN = {
    border: "none",
    background: "transparent"
}
  , cN = (e, t, n, r, a) => {
    const s = y.useMemo(( () => c.reduce(Object.values(r), ( (e, t) => (t.displayName && (e[t.displayName] = t),
    e)), {})), [r])
      , o = y.useCallback((o => {
        var l;
        const i = o.target;
        if ("span" === i.tagName.toLowerCase()) {
            const d = null == (l = i.textContent) ? void 0 : l.trim();
            if (!d)
                return;
            const u = i.className;
            if (!u)
                return;
            switch (u) {
            case tN:
                {
                    e && o.stopPropagation();
                    const n = oN(d.replace(/^\$/, "").replace(/[.,?!]+$/g, "").toLowerCase());
                    n.length && t(n);
                    break
                }
            case nN:
                o.stopPropagation(),
                s[d] && window.open(s[d].url, "_blank"),
                r[d] && window.open(r[d].url, "_blank");
                break;
            case rN:
                o.stopPropagation(),
                n[d] && window.open(SI(n[d].handle, a), "_blank");
                break;
            case aN:
                o.stopPropagation(),
                window.open(`https://x.com/hashtag/${(c = d).startsWith("#") ? c.slice(1) : c}`, "_blank")
            }
        }
        var c
    }
    ), [t, n, a, e, s, r]);
    return {
        messageTextSx: y.useMemo(( () => t => ({
            whiteSpace: "pre-line",
            [`.${tN}`]: {
                ...e ? {
                    "&:hover": {
                        cursor: "pointer",
                        textDecoration: "underline",
                        color: t.palette.text.value
                    }
                } : {}
            },
            [`.${nN}`]: {
                color: sN,
                "&:hover": {
                    cursor: "pointer",
                    textDecoration: "underline"
                }
            },
            [`.${rN}`]: {
                color: sN,
                fontWeight: 500,
                "&:hover": {
                    cursor: "pointer",
                    textDecoration: "underline"
                }
            },
            [`.${aN}`]: {
                color: sN,
                fontWeight: 500,
                "&:hover": {
                    cursor: "pointer",
                    textDecoration: "underline"
                }
            }
        })), [e]),
        onMessageClicked: o
    }
}
  , dN = y.memo(( ({platform: e, message: t, mentionsLookup: n, urlsLookup: r, color: a="text.value", variant: s="paragraph3", fontFamily: o, fontWeight: l, lineHeight: i, fontSize: c, disableShortcuts: d=!1}) => {
    const {pathname: u} = he()
      , p = y.useMemo(( () => (u === tT.TRENCHES || u === tT.TRENDING) && !d), [u, d])
      , h = XM((e => e.invokeTrenchesNewSearch))
      , {messageTextSx: m, onMessageClicked: g} = cN(p, h, n, r, e)
      , x = y.useMemo(( () => ( (e, t, n) => e.split(/(\s+)/).map(( (e, r) => {
        var a;
        if (/^\s+$/.test(e))
            return e.includes("\n") ? v.jsx("hr", {
                style: iN
            }, r) : v.jsx("span", {
                children: e
            }, r);
        let s = "";
        return s = t[e] ? rN : n[e] ? nN : e.length > 1 && e.startsWith("#") ? aN : tN,
        v.jsx("span", {
            className: s,
            children: (null == (a = n[e]) ? void 0 : a.displayName) || e
        }, r)
    }
    )))(t, n, r)), [n, t, r]);
    return v.jsx(k, {
        color: a,
        variant: s,
        fontWeight: l,
        lineHeight: i,
        fontSize: c,
        fontFamily: o,
        onClick: g,
        sx: m,
        children: x
    })
}
))
  , uN = 20
  , pN = y.memo(( ({id: e, userId: t, platform: n}) => {
    const r = y.useMemo(( () => {
        switch (n) {
        case VA.TRUTHSOCIAL:
            return v.jsx(hy, {
                size: hN,
                color: "inherit"
            });
        case VA.TWITTER:
            return v.jsx(Mk, {
                size: hN,
                color: "inherit"
            })
        }
    }
    ), [n])
      , a = y.useMemo(( () => e => ({
        width: uN,
        minWidth: uN,
        height: uN,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: e.palette.background.buttonActive,
        color: e.palette.text.label,
        "&:hover": {
            cursor: "pointer",
            color: e.palette.text.main,
            background: e.palette.background.buttonHover
        },
        borderRadius: 1
    })), []);
    return v.jsx(C, {
        component: "a",
        target: "_blank",
        rel: "noopener nofollow",
        href: lN(e, t, n),
        sx: a,
        children: r
    })
}
))
  , hN = 14
  , mN = y.memo(( ({tweetType: e}) => {
    const t = D()
      , [n,r] = y.useMemo(( () => {
        switch (e) {
        case FA.QUOTE:
            return [v.jsx(LS, {
                size: gN,
                color: t.palette.blue[200]
            }), t.palette.blue[800]];
        case FA.FOLLOW:
            return [v.jsx(Lv, {
                size: gN,
                color: "#EC396A"
            }), "#2E1C23"];
        case FA.REPLY:
            return [v.jsx(Iy, {
                size: gN,
                color: t.palette.yellow[200]
            }), t.palette.yellow[800]];
        case FA.RETWEET:
            return [v.jsx(Ty, {
                size: gN,
                color: t.palette.originalGreen[200]
            }), t.palette.originalGreen[900]];
        case FA.TWEET:
            return [v.jsx(qy, {
                size: gN
            }), t.palette.blue[800]];
        case FA.PROFILE_UPDATE:
            return [v.jsx(Lv, {
                size: gN,
                color: t.palette.originalPrimary.main
            }), t.palette.originalPrimary.background]
        }
    }
    ), [t.palette.blue, t.palette.originalGreen, t.palette.originalPrimary, t.palette.yellow, e])
      , a = y.useMemo(( () => ({
        width: uN,
        minWidth: uN,
        height: uN,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: r,
        borderRadius: 1
    })), [r]);
    return v.jsx(C, {
        sx: a,
        children: n
    })
}
))
  , gN = 14
  , xN = y.memo(( ({userId: e, userName: t, avatarUrl: n, isVerified: r, platform: a, createdAt: s, tweetType: o, tweetId: l, actionLabel: i, actionAdornment: c, ActionIcon: d}) => {
    const {t: u} = we()
      , p = y.useMemo(( () => SI(e, a)), [a, e]);
    return v.jsxs(S, {
        gap: .75,
        direction: "row",
        alignItems: "center",
        position: "relative",
        children: [v.jsx(C, {
            component: "a",
            href: p,
            target: "_blank",
            rel: "noopener nofollow",
            sx: kN,
            onClick: Ww,
            children: v.jsx(Te, {
                src: n ?? void 0,
                sx: yN
            })
        }), v.jsxs(S, {
            gap: .5,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(C, {
                    display: "flex",
                    component: "a",
                    href: p,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: SN,
                    onClick: Ww,
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        sx: CN,
                        noWrap: !0,
                        children: t
                    })
                }), r && v.jsx(GC, {
                    title: u("Verified"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "flex",
                        children: v.jsx(SC, {
                            size: fN
                        })
                    })
                }), v.jsx(mE, {
                    ts: s,
                    variant: "paragraph2",
                    prefixAdornment: `@${e} ${hM} `,
                    isShort: !0
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [d && v.jsx(d, {
                    size: vN
                }), v.jsx(k, {
                    color: "text.label",
                    variant: "paragraph3",
                    children: i
                }), c]
            })]
        }), v.jsxs(C, {
            display: "flex",
            gap: bN,
            position: "absolute",
            right: 0,
            top: 0,
            children: [v.jsx(pN, {
                id: l,
                userId: e,
                platform: a
            }), v.jsx(mN, {
                tweetType: o
            })]
        })]
    })
}
))
  , bN = .5
  , fN = 14
  , vN = 14
  , SN = {
    textDecoration: "none"
}
  , yN = {
    width: 42,
    height: 42
}
  , kN = {
    ...SN,
    ...yN,
    borderRadius: "50%"
}
  , CN = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    flexShrink: 1,
    maxWidth: "100%",
    "&:hover": {
        cursor: "pointer",
        textDecoration: "underline"
    }
}
  , AN = y.memo(( ({url: e, children: t}) => {
    const n = y.useCallback(( () => {
        window.open(e, "_blank")
    }
    ), [e]);
    return v.jsx(S, {
        pl: .5,
        pr: .25,
        py: .5,
        width: "100%",
        sx: wN,
        children: v.jsx(C, {
            display: "flex",
            flexDirection: "column",
            sx: jN,
            onClick: n,
            children: t
        })
    })
}
))
  , wN = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , jN = e => ({
    width: "100%",
    pl: .75,
    pr: .75,
    py: .5,
    gap: 1.5,
    "&:hover": {
        background: e.palette.background.buttonDefault,
        cursor: "pointer"
    }
})
  , TN = e => ({
    width: "100%",
    border: `1px solid ${e.palette.background.borderMain}`,
    px: 1.5,
    py: "7px",
    borderRadius: 2,
    overflow: "clip",
    gap: 1
})
  , IN = e => ({
    cursor: "zoom-in",
    borderRadius: 2,
    border: `2px solid ${e.palette.background.borderSubtle}`,
    width: "100%",
    maxWidth: 500,
    alignSelf: "center"
})
  , EN = y.memo(( ({platform: e, createdTs: t, authorName: n, authorAvatarUrl: r, authorIsVerified: a, authorUserId: s, followedName: o, followedAvatarUrl: l, followedIsVerified: i, followedUserId: d, followedDesc: u}) => {
    const {t: p} = we()
      , h = y.useMemo(( () => SI(s, e)), [e, s])
      , m = y.useMemo(( () => SI(d, e)), [d, e])
      , g = y.useMemo(( () => ( (e, t) => {
        switch (t) {
        case VA.TRUTHSOCIAL:
            return null;
        case VA.TWITTER:
            return `https://x.com/intent/follow?screen_name=${e}`
        }
    }
    )(d, e)), [d, e])
      , x = y.useMemo(( () => v.jsx(C, {
        display: "flex",
        component: "a",
        href: m,
        target: "_blank",
        rel: "noopener nofollow",
        sx: NN,
        onClick: Ww,
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "yellow.200",
            sx: LN,
            noWrap: !0,
            children: `@${d}`
        })
    })), [d, m])
      , [b,f] = y.useMemo(( () => [{}, c.reduce(u.urls, ( (e, t) => (e[t.name] = t,
    e)), {})]), [u.urls]);
    return v.jsxs(AN, {
        url: h,
        children: [v.jsx(xN, {
            userId: s,
            userName: n,
            avatarUrl: r,
            isVerified: a,
            platform: e,
            createdAt: t,
            tweetType: FA.FOLLOW,
            tweetId: null,
            actionLabel: "followed",
            actionAdornment: x,
            ActionIcon: $S
        }), v.jsxs(S, {
            sx: TN,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [v.jsx(C, {
                    component: "a",
                    href: m,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: ON,
                    onClick: Ww,
                    children: v.jsx(Te, {
                        src: l ?? void 0,
                        sx: PN
                    })
                }), v.jsx(C, {
                    display: "flex",
                    component: "a",
                    href: m,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: NN,
                    onClick: Ww,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        color: "text.value",
                        sx: LN,
                        noWrap: !0,
                        children: o
                    })
                }), i && v.jsx(GC, {
                    title: p("Verified"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "flex",
                        children: v.jsx(SC, {
                            size: MN
                        })
                    })
                }), v.jsx(C, {
                    display: "flex",
                    component: "a",
                    href: m,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: NN,
                    onClick: Ww,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        color: "text.label",
                        sx: LN,
                        noWrap: !0,
                        children: `@${d}`
                    })
                }), g && v.jsx(k, {
                    variant: "paragraph2",
                    color: "text.label",
                    noWrap: !0,
                    children: hM
                }), g && v.jsx(C, {
                    display: "flex",
                    component: "a",
                    href: g,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: NN,
                    onClick: Ww,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        color: FI,
                        sx: LN,
                        noWrap: !0,
                        children: "Follow"
                    })
                })]
            }), v.jsx(dN, {
                platform: e,
                message: u.text,
                mentionsLookup: b,
                urlsLookup: f
            })]
        })]
    })
}
))
  , MN = 14
  , NN = {
    textDecoration: "none"
}
  , PN = {
    width: 18,
    height: 18
}
  , ON = {
    ...NN,
    ...PN,
    borderRadius: "50%"
}
  , LN = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    flexShrink: 1,
    maxWidth: "100%",
    "&:hover": {
        cursor: "pointer",
        textDecoration: "underline"
    }
}
  , RN = y.memo(( ({createdTs: e, platform: t, beforeAvatar: n, beforeBanner: r, beforeDescText: a, currentName: s, currentUserId: o, currentIsVerified: l, currentAvatar: i, currentBanner: d, currentDesc: u}) => {
    const {descChanged: p, avatarChanged: h, bannerChanged: m} = y.useMemo(( () => ( ({currentDesc: e, beforeDesc: t, currentAvatar: n, beforeAvatar: r, currentBanner: a, beforeBanner: s}) => ({
        descChanged: e !== t,
        avatarChanged: n !== r,
        bannerChanged: a !== s
    }))({
        currentDesc: u.text,
        beforeDesc: a,
        currentAvatar: i,
        beforeAvatar: n,
        currentBanner: d,
        beforeBanner: r
    })), [n, r, a, i, d, u.text])
      , [g,x] = y.useMemo(( () => [{}, c.reduce(u.urls, ( (e, t) => (e[t.name] = t,
    e)), {})]), [u.urls])
      , b = y.useMemo(( () => SI(o, t)), [t, o]);
    return p || h || m ? v.jsxs(AN, {
        url: b,
        children: [v.jsx(xN, {
            userId: o,
            userName: s,
            avatarUrl: i,
            isVerified: l,
            platform: t,
            createdAt: e,
            tweetType: FA.PROFILE_UPDATE,
            tweetId: null,
            actionLabel: `updated profile ${[p ? "bio" : "", h ? "avatar" : "", m ? "banner" : ""].filter((e => "" !== e)).join("/")}`,
            ActionIcon: Ky
        }), v.jsxs(S, {
            sx: TN,
            children: [p && v.jsx(dN, {
                platform: t,
                message: u.text,
                mentionsLookup: g,
                urlsLookup: x
            }), h ? i ? v.jsx(C, {
                sx: IN,
                component: "img",
                src: i,
                alt: "Image"
            }) : v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: "Avatar has been removed"
            }) : null, m ? d ? v.jsx(C, {
                sx: IN,
                component: "img",
                src: d,
                alt: "Image"
            }) : v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: "Banner has been removed"
            }) : null]
        })]
    }) : null
}
))
  , DN = new hg(50)
  , BN = ug((e => e), (async e => {
    const t = DN.get(e);
    if (t)
        return t;
    const r = n.resolvedLanguage ?? "en"
      , a = await Nm.fetchFullTweetTranslation(e, r);
    if (a.tweetTranslation) {
        const t = ( (e, t) => ({
            body: {
                text: {
                    detectedLanguageCode: e.body.text.detectedLanguageCode,
                    translatedText: (e.body.text.detectedLanguageCode ?? "").trim().toLowerCase().split(/[-_]/)[0] === t ? null : e.body.text.translatedText
                }
            },
            subtweet: e.subtweet ? (e.subtweet.body.text.detectedLanguageCode ?? "").trim().toLowerCase().split(/[-_]/)[0] === t ? null : {
                body: {
                    text: {
                        detectedLanguageCode: e.subtweet.body.text.detectedLanguageCode,
                        translatedText: e.subtweet.body.text.translatedText
                    }
                }
            } : null
        }))(a.tweetTranslation, r);
        return DN.set(e, t),
        t
    }
    return null
}
), 10)
  , _N = Symbol("TWEET_TRANSLATION_DOESNT_EXIST")
  , UN = e => {
    const [t,n] = y.useState(!1)
      , [r,a] = JC(!1, WN)
      , s = y.useCallback(( () => {
        a(!0),
        n(!0)
    }
    ), [a])
      , o = ( (e, t) => {
        const [n,r] = y.useState(( () => DN.get(e)));
        return y.useEffect(( () => {
            let a = !1;
            return t ? (n && n !== _N || BN(e).then((e => {
                a || r(e ?? _N)
            }
            )).catch((e => {
                r(_N)
            }
            )),
            () => {
                a = !0
            }
            ) : () => {
                a = !0
            }
        }
        ), [e, n, t]),
        DN.get(e) ?? (n === _N ? n : null)
    }
    )(e, t)
      , [l,i,c] = y.useMemo(( () => {
        var e;
        return o === _N ? [!1, null, null] : o ? [!1, o.body.text.translatedText, (null == (e = o.subtweet) ? void 0 : e.body.text.translatedText) ?? null] : [!0, null, null]
    }
    ), [o]);
    return {
        isTranslationLoading: l || r || !t,
        requestTranslation: s,
        translation: i,
        subtweetTranslation: c
    }
}
  , WN = 1e3
  , FN = y.memo(( ({imageUrl: e, imageBoxSx: t, maxZoomWidth: n=$N}) => {
    const [r,a] = y.useState(null)
      , s = Boolean(r)
      , o = y.useMemo(( () => ({
        borderRadius: "12px",
        border: `1px solid ${zN}`,
        width: n
    })), [n]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(C, {
            component: "img",
            src: e,
            alt: "Tweeted image",
            width: "100%",
            onMouseEnter: e => {
                a(e.currentTarget)
            }
            ,
            onMouseLeave: () => {
                a(null)
            }
            ,
            sx: t
        }), v.jsx(ne, {
            open: s,
            anchorEl: r,
            placement: "auto",
            modifiers: VN,
            sx: HN,
            children: v.jsx(C, {
                component: "img",
                src: e,
                alt: "Preview",
                sx: o
            })
        })]
    })
}
))
  , VN = [{
    name: "flip",
    enabled: !0
}, {
    name: "preventOverflow",
    enabled: !0,
    options: {
        padding: 8
    }
}, {
    name: "offset",
    options: {
        offset: [0, 8]
    }
}]
  , HN = e => ({
    zIndex: e.zIndex.tooltip + 1,
    pointerEvents: "none"
})
  , zN = "#425364"
  , $N = 500
  , GN = /[\p{Script=Han}]/u
  , qN = /[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/
  , KN = /[\p{Script=Latin}]/u
  , YN = /[A-Za-z]/
  , XN = /[\p{Script=Cyrillic}]/u
  , QN = /[\u0400-\u04FF]|[\u0500-\u052F]|[\u2DE0-\u2DFF]|[\uA640-\uA69F]/u
  , ZN = /[\p{Script=Arabic}]/u
  , JN = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]/
  , eP = /[\p{Script=Hangul}]/u
  , tP = /[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]/
  , nP = /[\p{Script=Hiragana}]/u
  , rP = /[\u3040-\u309F]/
  , aP = /[\p{Script=Katakana}]/u
  , sP = /[\u30A0-\u30FF\u31F0-\u31FF]/
  , oP = /[\p{Script=Hebrew}]/u
  , lP = /[\u0590-\u05FF]/
  , iP = /[\p{Script=Thai}]/u
  , cP = /[\u0E00-\u0E7F]/
  , dP = /[\p{Script=Devanagari}]/u
  , uP = /[\u0900-\u097F]/
  , pP = /[\p{Script=Greek}]/u
  , hP = /[\u0370-\u03FF\u1F00-\u1FFF]/
  , mP = (e, t, n) => e.test(n) || t.test(n)
  , gP = new Set(["en", "id", "ms", "vi", "es", "fr", "de", "pt", "it", "tr", "pl", "nl", "sv", "da", "fi", "no", "nb", "ro", "cs", "sk", "hu"])
  , xP = new Set(["ru", "uk", "bg", "sr", "mk"])
  , bP = new Set(["zh", "zh-CN", "zh-TW", "zh-HK", "zh-Hans", "zh-Hant"])
  , fP = new Set(["ja"])
  , vP = new Set(["ko"])
  , SP = new Set(["ar", "fa", "ur"])
  , yP = new Set(["he", "iw"])
  , kP = new Set(["th"])
  , CP = new Set(["hi", "mr", "ne"])
  , AP = new Set(["el"])
  , wP = e => {
    const t = (n.resolvedLanguage ?? "en").replace("_", "-").split("-")[0]
      , r = (e => ({
        han: mP(GN, qN, e),
        latin: mP(KN, YN, e),
        cyrillic: mP(XN, QN, e),
        arabic: mP(ZN, JN, e),
        hangul: mP(eP, tP, e),
        hira: mP(nP, rP, e),
        kata: mP(aP, sP, e),
        hebrew: mP(oP, lP, e),
        thai: mP(iP, cP, e),
        devanagari: mP(dP, uP, e),
        greek: mP(pP, hP, e)
    }))(e);
    if (gP.has(t))
        return r.han || r.cyrillic || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek;
    if (xP.has(t))
        return r.latin || r.han || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek;
    if (bP.has(t))
        return r.latin || r.cyrillic || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek;
    if (fP.has(t)) {
        return !(r.hira || r.kata || r.han) && (r.latin || r.cyrillic || r.hangul || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek)
    }
    if (vP.has(t)) {
        return !(r.hangul || r.han) && (r.latin || r.cyrillic || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek)
    }
    return SP.has(t) ? r.latin || r.cyrillic || r.han || r.hangul || r.hira || r.kata || r.hebrew || r.thai || r.devanagari || r.greek : yP.has(t) ? r.latin || r.cyrillic || r.han || r.hangul || r.hira || r.kata || r.arabic || r.thai || r.devanagari || r.greek : kP.has(t) ? r.latin || r.cyrillic || r.han || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.devanagari || r.greek : CP.has(t) ? r.latin || r.cyrillic || r.han || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.greek : AP.has(t) ? r.latin || r.cyrillic || r.han || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari : r.han || r.cyrillic || r.hangul || r.hira || r.kata || r.arabic || r.hebrew || r.thai || r.devanagari || r.greek
}
  , jP = y.memo(( ({isLoading: e, requestTranslation: t, translation: n, platform: r, mentionsLookup: a, urlsLookup: s}) => {
    const {t: o} = we()
      , [l,i] = y.useState(!1)
      , c = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        i((e => !e)),
        t()
    }
    ), [t])
      , d = y.useCallback(( () => {
        t()
    }
    ), [t]);
    return e || n ? v.jsxs(S, {
        gap: .75,
        width: "100%",
        py: .5,
        children: [v.jsxs(C, {
            display: "flex",
            alignItems: "center",
            gap: .5,
            onMouseEnter: d,
            onClick: c,
            sx: TP,
            children: [v.jsx(fk, {
                color: "inherit"
            }), v.jsx(k, {
                variant: "paragraph1",
                color: "inherit",
                fontWeight: 400,
                fontSize: 13,
                noWrap: !0,
                children: o(l ? "Hide translation" : "Show translation")
            })]
        }), l ? null === n ? v.jsx(Ie, {
            variant: "rounded",
            height: 80,
            width: "100%"
        }) : v.jsx(C, {
            display: "flex",
            sx: IP,
            children: v.jsx(dN, {
                platform: r,
                message: n,
                mentionsLookup: a,
                urlsLookup: s,
                lineHeight: "16px",
                fontWeight: 400
            })
        }) : null]
    }) : null
}
))
  , TP = {
    color: FI,
    minWidth: 100,
    "&:hover": {
        cursor: "pointer",
        color: "text.value"
    }
}
  , IP = e => ({
    p: 1,
    background: `${e.palette.background.buttonHover}40`,
    borderRadius: "8px"
})
  , EP = y.memo(( ({userId: e, createdTs: t}) => v.jsxs(S, {
    direction: "row",
    gap: .25,
    children: [v.jsx(k, {
        variant: "paragraph2",
        noWrap: !0,
        children: `${e} ${hM}`
    }), v.jsx(mE, {
        ts: t,
        variant: "paragraph2",
        isShort: !0
    })]
})))
  , MP = y.memo(( ({id: e, message: t, userName: n, userId: r, createdTs: a, userAvatarUrl: s, videoUrl: o, imageUrl: l, tweetType: i, platform: d, isVerified: u, isEdited: p, isReply: h=!1, replyingToUserId: m, urls: g, mentions: x, userAccountId: b, isTranslationLoading: f, requestTranslation: A, translation: w}) => {
    const {t: j} = we()
      , {unsubscribeUser: T, trackedAccounts: I} = KA()
      , E = y.useMemo(( () => e => ({
        width: h ? `calc(100% - ${RP.width + 8 * NP}px)` : "100%",
        border: h ? `1px solid ${e.palette.background.borderMain}` : "none",
        py: h ? "7px" : 1,
        borderRadius: h ? 2 : 0,
        px: h ? 1.5 : .75,
        ml: h ? `${RP.width + 8 * NP}px` : 0,
        overflow: h ? "clip" : "visible",
        background: h ? e.palette.background.secondary : "transparent",
        "&:hover": {
            background: e.palette.background.buttonDefault,
            cursor: "pointer"
        }
    })), [h])
      , M = y.useMemo(( () => SI(r, d)), [d, r])
      , N = y.useMemo(( () => SI(m ?? "", d)), [d, m])
      , P = y.useMemo(( () => lN(e, r, d)), [e, d, r])
      , [O,L] = y.useMemo(( () => {
        switch (i) {
        case FA.REPLY:
            return ["Replying to", {
                minWidth: 64
            }];
        case FA.QUOTE:
            return ["Quoting", {
                minWidth: 46
            }];
        case FA.RETWEET:
            return ["Retweeting", {
                minWidth: 64
            }];
        default:
            return ["", {}]
        }
    }
    ), [i])
      , [R,D] = y.useMemo(( () => [c.reduce(x, ( (e, t) => (e[`@${t.handle}`] = t,
    e)), {}), c.reduce(g, ( (e, t) => (e[t.name] = t,
    e)), {})]), [x, g])
      , B = y.useCallback(( () => {
        window.open(P, "_blank")
    }
    ), [P])
      , _ = y.useCallback((async e => {
        e.stopPropagation(),
        e.preventDefault();
        try {
            await T(b)
        } catch (fNe) {}
    }
    ), [T, b])
      , U = y.useMemo(( () => wP(t)), [t]);
    return v.jsx(C, {
        sx: E,
        display: "flex",
        flexDirection: "column",
        onClick: B,
        children: v.jsxs(S, {
            direction: "row",
            width: "100%",
            gap: NP,
            children: [!h && v.jsxs(C, {
                display: "flex",
                position: "relative",
                sx: zP,
                children: [!!(null == I ? void 0 : I.length) && v.jsx(C, {
                    sx: HP,
                    className: VP,
                    children: v.jsx(GC, {
                        title: j("Stop tracking user"),
                        children: v.jsx(C, {
                            component: "span",
                            children: v.jsx(V, {
                                onClick: _,
                                variant: "tertiary",
                                size: "xxsmall",
                                sx: $P,
                                className: VP,
                                children: v.jsx(Ek, {})
                            })
                        })
                    })
                }), v.jsx(C, {
                    component: "a",
                    href: M,
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: FP,
                    onClick: Ww,
                    children: v.jsx(Te, {
                        src: s ?? void 0,
                        sx: RP
                    })
                })]
            }), v.jsxs(S, {
                gap: .5,
                width: `calc(100% - ${h ? 0 : RP.width + 8 * NP}px)`,
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    gap: 1,
                    position: "relative",
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        width: `calc(100% - ${h ? 0 : 2 * (uN + 8 * PP)}px)`,
                        gap: 1.25,
                        children: [v.jsx(C, {
                            component: "a",
                            href: M,
                            target: "_blank",
                            rel: "noopener nofollow",
                            sx: _P,
                            onClick: Ww,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: .5,
                                overflow: "hidden",
                                textOverflow: "hidden",
                                minWidth: 0,
                                children: [h && v.jsx(Te, {
                                    src: s ?? void 0,
                                    sx: DP
                                }), v.jsx(k, {
                                    variant: "paragraph1",
                                    color: "text.value",
                                    sx: UP,
                                    noWrap: !0,
                                    children: n
                                }), u && v.jsx(GC, {
                                    title: j("Verified"),
                                    children: v.jsx(C, {
                                        component: "span",
                                        display: "flex",
                                        children: v.jsx(SC, {
                                            size: OP
                                        })
                                    })
                                })]
                            })
                        }), v.jsx(EP, {
                            userId: r,
                            createdTs: a
                        })]
                    }), !h && v.jsxs(C, {
                        display: "flex",
                        gap: PP,
                        position: "absolute",
                        right: 0,
                        top: 0,
                        children: [v.jsx(pN, {
                            id: e,
                            userId: r,
                            platform: d
                        }), v.jsx(mN, {
                            tweetType: i
                        })]
                    })]
                }), v.jsxs(S, {
                    gap: .5,
                    width: "100%",
                    children: [!h && m && v.jsxs(S, {
                        direction: "row",
                        gap: .25,
                        alignItems: "center",
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            noWrap: !0,
                            sx: L,
                            children: O
                        }), v.jsx(C, {
                            display: "flex",
                            component: "a",
                            href: N,
                            target: "_blank",
                            rel: "noopener nofollow",
                            sx: BP,
                            onClick: Ww,
                            children: v.jsx(k, {
                                variant: "paragraph3",
                                color: WP,
                                sx: UP,
                                noWrap: !0,
                                children: m
                            })
                        })]
                    }), v.jsx(dN, {
                        platform: d,
                        message: t,
                        mentionsLookup: R,
                        urlsLookup: D,
                        lineHeight: "16px",
                        fontWeight: 400
                    }), p && v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        sx: LP,
                        fontWeight: 400,
                        children: "Edited"
                    }), (U || w) && v.jsx(jP, {
                        isLoading: f,
                        requestTranslation: A,
                        translation: w,
                        platform: d,
                        mentionsLookup: R,
                        urlsLookup: D
                    }), o && v.jsxs(C, {
                        onClick: Ww,
                        sx: IN,
                        component: "video",
                        controls: !0,
                        children: [v.jsx("source", {
                            src: o,
                            type: "video/mp4"
                        }), "Your browser does not support the video tag."]
                    }), l && v.jsx(FN, {
                        imageUrl: l,
                        imageBoxSx: IN,
                        maxZoomWidth: 600
                    })]
                })]
            })]
        })
    })
}
))
  , NP = 1
  , PP = .5
  , OP = 14
  , LP = {
    opacity: .4
}
  , RP = {
    width: 42,
    height: 42
}
  , DP = {
    width: 20,
    height: 20
}
  , BP = {
    textDecoration: "none"
}
  , _P = {
    ...BP,
    minWidth: 0
}
  , UP = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    flexShrink: 1,
    maxWidth: "100%",
    "&:hover": {
        textDecoration: "underline"
    }
}
  , WP = "#1D9BF0"
  , FP = {
    ...BP,
    ...RP,
    borderRadius: "50%"
}
  , VP = "hide-account-button"
  , HP = {
    opacity: 0,
    display: "flex",
    position: "absolute",
    top: -4,
    left: -6,
    zIndex: 5
}
  , zP = {
    "&:hover": {
        [`.${VP}`]: {
            opacity: 1
        }
    }
}
  , $P = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    p: 0,
    minWidth: 0,
    width: 22,
    height: 22,
    borderRadius: "50%"
}
  , GP = y.memo(( ({message: e, reply: t}) => {
    const {isTranslationLoading: n, translation: r, subtweetTranslation: a, requestTranslation: s} = UN(e.id)
      , o = y.useMemo(( () => n => ({
        pt: .5,
        pb: e.tweetType !== FA.REPLY && e.tweetType !== FA.QUOTE || !t ? .5 : 1,
        pr: 0,
        gap: .5,
        width: "100%",
        borderBottom: `1px solid ${n.palette.background.borderMain}`
    })), [e.tweetType, t]);
    return v.jsx(S, {
        pl: .5,
        pr: .25,
        width: "100%",
        children: v.jsxs(S, {
            sx: o,
            children: [v.jsx(MP, {
                replyingToUserId: null == t ? void 0 : t.userId,
                ...e,
                isTranslationLoading: n,
                requestTranslation: s,
                translation: r
            }), (e.tweetType === FA.REPLY || e.tweetType === FA.QUOTE) && t && v.jsx(MP, {
                isReply: !0,
                ...t,
                isTranslationLoading: n,
                requestTranslation: s,
                translation: a
            })]
        })
    })
}
))
  , qP = y.memo(( ({createdTs: e, platform: t, name: n, userId: r, isVerified: a, avatar: s, banner: o, desc: l, oldAvatar: i, oldBanner: d, oldBio: u}) => {
    const {descChanged: p, avatarChanged: h, bannerChanged: m} = y.useMemo(( () => ({
        descChanged: void 0 !== u,
        avatarChanged: void 0 !== i,
        bannerChanged: void 0 !== d
    })), [i, d, u])
      , [g,x] = y.useMemo(( () => [{}, c.reduce(l.urls, ( (e, t) => (e[t.name] = t,
    e)), {})]), [l.urls])
      , b = y.useMemo(( () => SI(r, t)), [t, r])
      , [f,A] = y.useMemo(( () => s ? ZP(s) : [null, !1]), [s])
      , [w,j] = y.useState(!1)
      , T = y.useCallback(( () => {
        j(!0)
    }
    ), []);
    return p || h || m ? v.jsxs(AN, {
        url: b,
        children: [v.jsx(xN, {
            userId: r,
            userName: n,
            avatarUrl: s,
            isVerified: a,
            platform: t,
            createdAt: e,
            tweetType: FA.PROFILE_UPDATE,
            tweetId: null,
            actionLabel: `updated profile ${[p ? "bio" : "", h ? "avatar" : "", m ? "banner" : ""].filter((e => "" !== e)).join("/")}`,
            ActionIcon: Ky
        }), v.jsxs(S, {
            sx: QP,
            children: [p && (l.text ? v.jsx(dN, {
                platform: t,
                message: l.text,
                mentionsLookup: g,
                urlsLookup: x
            }) : v.jsx(k, {
                variant: "paragraph1",
                color: "text.label",
                children: "Bio has been removed"
            })), h ? f ? v.jsx(C, {
                sx: !A || w ? YP : XP,
                component: "img",
                src: w ? s ?? "" : f,
                alt: "Image",
                onError: T
            }) : v.jsx(k, {
                variant: "paragraph1",
                color: "text.label",
                children: "Avatar has been removed"
            }) : null, m ? o ? v.jsx(C, {
                sx: IN,
                component: "img",
                src: o,
                alt: "Image"
            }) : v.jsx(k, {
                variant: "paragraph1",
                color: "text.label",
                children: "Banner has been removed"
            }) : null]
        })]
    }) : null
}
))
  , KP = e => ({
    border: `2px solid ${e.palette.background.borderSubtle}`,
    borderRadius: "50%",
    width: "100%",
    alignSelf: "center"
})
  , YP = e => ({
    ...KP(e),
    maxWidth: 50
})
  , XP = e => ({
    ...KP(e),
    maxWidth: 200,
    minHeight: 200
})
  , QP = {
    width: "100%",
    px: 1.5,
    py: "7px",
    overflow: "clip",
    gap: 1
}
  , ZP = e => e.includes("https://pbs.twimg.com/profile_images") ? [e.replace(/_(normal|bigger|mini)(?=\.\w+$)/, ""), !0] : [e, !1]
  , JP = y.memo(( ({isLive: e, setIsLive: t}) => {
    const {t: n} = we()
      , {trackedMessages: r} = KA()
      , a = y.useRef(null)
      , s = y.useCallback(( () => {
        t(!1)
    }
    ), [t])
      , o = y.useCallback(( () => {
        t(!0)
    }
    ), [t]);
    pM({
        target: a,
        onInteractionStart: s,
        onInteractionStop: o
    });
    const l = y.useRef(null);
    y.useEffect(( () => {
        !e && l.current && l.current.length || (l.current = r || [])
    }
    ), [e, r]);
    const i = y.useMemo(( () => !e && l.current && l.current.length ? l.current : r), [e, r])
      , c = y.useCallback((e => e.variant === HA.TWEET ? v.jsx(GP, {
        message: e,
        reply: e.replyTo
    }, e.id) : (e => e.variant === HA.FOLLOW)(e) ? v.jsx(EN, {
        platform: VA.TWITTER,
        createdTs: e.createdTs,
        authorName: e.author.profile.name,
        authorAvatarUrl: e.author.profile.avatar,
        authorIsVerified: e.author.verified,
        authorUserId: e.author.handle,
        followedName: e.following.profile.name,
        followedAvatarUrl: e.following.profile.avatar,
        followedIsVerified: e.following.verified,
        followedUserId: e.following.handle,
        followedDesc: e.following.profile.description
    }, e.id) : (e => e.variant === HA.PROFILE_UPDATE)(e) ? v.jsx(RN, {
        platform: VA.TWITTER,
        createdTs: e.createdTs,
        beforeAvatar: e.before.profile.avatar,
        beforeBanner: e.before.profile.banner,
        beforeDescText: e.before.profile.description.text,
        currentName: e.current.profile.name,
        currentUserId: e.current.handle,
        currentIsVerified: e.current.verified,
        currentAvatar: e.current.profile.avatar,
        currentBanner: e.current.profile.banner,
        currentDesc: e.current.profile.description
    }, e.id) : (e => e.variant === HA.PROFILE_UPDATE_V2)(e) ? v.jsx(qP, {
        platform: VA.TWITTER,
        createdTs: e.createdTs,
        name: e.author.profile.name,
        userId: e.author.handle,
        isVerified: e.author.verified,
        avatar: e.author.profile.avatar,
        banner: e.author.profile.banner,
        desc: e.author.profile.description,
        oldAvatar: e.oldAvatar,
        oldBanner: e.oldBanner,
        oldBio: e.oldBio
    }, e.id) : null), []);
    return v.jsx(S, {
        ref: a,
        alignItems: "center",
        width: "100%",
        minHeight: "100%",
        children: i ? i.length ? i.map(c) : v.jsx(S, {
            height: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: n("No tweets to display")
            })
        }) : v.jsx(S, {
            height: "100%",
            children: v.jsx(Km, {})
        })
    })
}
))
  , eO = "#8B98A6"
  , tO = "#E6E6E6"
  , nO = "#425364"
  , rO = "#15202B"
  , aO = "https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png"
  , sO = y.memo(( ({desc: e, urls: t, color: n=eO}) => {
    const [r,a] = y.useMemo(( () => [{}, c.reduce(t ?? [], ( (e, t) => (e[t.name] = t,
    e)), {})]), [t]);
    return null === e ? v.jsxs(S, {
        gap: .25,
        children: [v.jsx(Ie, {
            width: "100%",
            height: 15
        }), v.jsx(Ie, {
            width: "100%",
            height: 15
        })]
    }) : v.jsx(dN, {
        platform: VA.TWITTER,
        message: e ?? "",
        mentionsLookup: r,
        urlsLookup: a,
        variant: "paragraph1",
        color: n
    })
}
))
  , oO = y.memo(( ({url: e}) => e ? v.jsx(C, {
    component: "img",
    src: e,
    alt: "Profile banner",
    sx: lO
}) : v.jsx(C, {
    sx: lO
})))
  , lO = {
    height: 110,
    width: "100%",
    background: "#1C2733",
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
    objectFit: "cover",
    borderBottom: "1px solid rgb(66, 83, 100)"
}
  , iO = y.memo(( ({url: e, label: t}) => {
    const n = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        e && window.open(e, "_blank", "noopener,noreferrer")
    }
    ), [e]);
    return e ? v.jsx(S, {
        alignItems: "center",
        justifyContent: "center",
        width: "100%",
        children: v.jsx(V, {
            onClick: n,
            fullWidth: !0,
            variant: "tertiary",
            sx: cO,
            children: v.jsx(k, {
                variant: "h2",
                color: FI,
                children: `See ${t} on X`
            })
        })
    }) : v.jsx(Ie, {
        variant: "rounded",
        width: "100%",
        sx: dO
    })
}
))
  , cO = {
    border: `1px solid ${eO}77`,
    height: 32,
    borderRadius: 4,
    background: "transparent",
    "&:hover": {
        borderColor: `${eO}77`,
        background: `${FI}20`
    },
    "&focus": {
        borderColor: `${eO}77`,
        background: "transparent"
    }
}
  , dO = {
    borderRadius: 4,
    height: 32
}
  , uO = y.memo(( ({isLoading: e, avatarUrl: t, name: n, handle: r, profileUrl: a, isVerified: s, reuses: o}) => {
    const l = D()
      , c = y.useMemo(( () => {
        if (!(o && ((null == o ? void 0 : o.length) ?? 0) > 1))
            return "";
        const e = i().unix();
        return v.jsx(S, {
            children: o.map(( (t, n) => {
                const r = WA(e - t.lastCheckedTs, !0);
                return v.jsxs(te, {
                    onClick: e => {
                        e.stopPropagation(),
                        e.preventDefault(),
                        window.open(SI(t.username, VA.TWITTER), "_blank", "noopener,noreferrer")
                    }
                    ,
                    sx: fO,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: pO,
                        noWrap: !0,
                        children: `@${t.username}`
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: eO,
                        children: r
                    })]
                }, n)
            }
            ))
        })
    }
    ), [o])
      , d = y.useMemo(( () => xO(s ?? !1)), [s]);
    return v.jsxs(S, {
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [e ? v.jsx(Ie, {
                sx: mO,
                variant: "rounded"
            }) : v.jsx(C, {
                component: "img",
                src: t ?? aO,
                alt: "Avatar",
                sx: mO
            }), v.jsxs(S, {
                gap: .25,
                children: [e ? v.jsx(Ie, {
                    variant: "rounded",
                    width: 160,
                    height: 15
                }) : v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    children: [v.jsx(C, {
                        component: "a",
                        href: a ?? "#",
                        target: "_blank",
                        rel: "noopener nofollow",
                        sx: gO,
                        children: v.jsx(k, {
                            variant: "h1",
                            color: "#FFFFFF",
                            sx: d,
                            noWrap: !0,
                            children: n
                        })
                    }), s && v.jsx(SC, {
                        size: bO
                    })]
                }), e ? v.jsx(Ie, {
                    variant: "rounded",
                    width: 120,
                    height: 15
                }) : v.jsx(GC, {
                    title: c,
                    disableInteractive: !1,
                    noPadding: !0,
                    children: v.jsx(C, {
                        component: "a",
                        href: a ?? "#",
                        target: "_blank",
                        rel: "noopener nofollow",
                        sx: gO,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            color: ((null == o ? void 0 : o.length) ?? 0) > 1 ? pO : eO,
                            sx: d,
                            noWrap: !0,
                            children: `@${r}`
                        })
                    })
                })]
            })]
        }), v.jsx(Mk, {
            size: hO,
            color: l.palette.text.value
        })]
    })
}
))
  , pO = "#FF7324"
  , hO = 26
  , mO = {
    width: 48,
    height: 48,
    borderRadius: "50%"
}
  , gO = {
    textDecoration: "none",
    maxWidth: 180,
    textOverflow: "ellipsis",
    overflow: "clip",
    whiteSpace: "nowrap",
    color: eO
}
  , xO = e => ({
    maxWidth: e ? 155 : 180,
    "&:hover": {
        textDecoration: "underline"
    }
})
  , bO = 16
  , fO = {
    height: 26,
    dispaly: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 1,
    px: 1,
    maxWidth: 200
}
  , vO = y.memo(( ({isLoading: e, location: t, joinedAt: n}) => {
    const r = y.useMemo(( () => {
        if (n)
            return `Joined ${i(n).format("MMM YYYY")}`
    }
    ), [n]);
    return e || !r ? v.jsx(Ie, {
        width: "100%",
        height: 15
    }) : v.jsxs(S, {
        direction: "row",
        gap: 1,
        width: "100%",
        children: [t && v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            overflow: "clip",
            children: [v.jsx(Pe, {
                sx: SO
            }), v.jsx(k, {
                variant: "paragraph1",
                color: eO,
                noWrap: !0,
                children: t
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsx(Oe, {
                sx: SO
            }), v.jsx(k, {
                variant: "paragraph1",
                color: eO,
                children: r
            })]
        })]
    })
}
))
  , SO = {
    fontSize: 16,
    color: eO
}
  , yO = y.memo(( ({isLoading: e, following: t, followers: n}) => e ? v.jsx(Ie, {
    width: "100%",
    variant: "rounded",
    height: 15
}) : v.jsxs(S, {
    direction: "row",
    gap: 1,
    children: [null !== t && v.jsxs(S, {
        direction: "row",
        gap: .5,
        children: [v.jsx(k, {
            variant: "h2",
            color: "#FFFFFF",
            children: 0 === t ? 0 : OI(t, {
                symbol: "",
                collapseExponent: !0,
                precision: 0
            })
        }), v.jsx(k, {
            variant: "h2",
            color: eO,
            noWrap: !0,
            children: "Following"
        })]
    }), null !== n && v.jsxs(S, {
        direction: "row",
        gap: .5,
        children: [v.jsx(k, {
            variant: "h2",
            color: "#FFFFFF",
            children: 0 === n ? 0 : OI(n, {
                symbol: "",
                collapseExponent: !0,
                precision: 0
            })
        }), v.jsx(k, {
            variant: "h2",
            color: eO,
            noWrap: !0,
            children: "Followers"
        })]
    })]
})))
  , kO = new hg(100)
  , CO = 5e3
  , AO = y.memo(( ({id: e, reuses: t}) => {
    const r = (e => {
        const {user: t} = VK()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu(CO),
                        a))
                            return;
                        if (kO.has(e))
                            return void r({
                                status: ox.READY,
                                data: kO.get(e)
                            });
                        const t = await Nm.getAccount({
                            idOrHandle: /^\d+$/.test(e) ? {
                                refType: "id",
                                ref: e
                            } : {
                                refType: "handle",
                                ref: e
                            }
                        });
                        if (kO.set(e, t),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: t
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [e, n, t]),
        n
    }
    )(e)
      , a = y.useMemo(( () => r.status !== ox.READY ? null : r.data), [r])
      , s = y.useMemo(( () => a ? SI(null == a ? void 0 : a.handle, VA.TWITTER) : null), [a]);
    return r.status === ox.READY && null === a || r.status === ox.ERROR ? v.jsx(S, {
        sx: TO,
        children: v.jsx(k, {
            color: eO,
            variant: "paragraph1",
            children: r.status === ox.ERROR ? "Error upon loading profile" : "Profile doesn't exists"
        })
    }) : v.jsxs(C, {
        sx: jO,
        minHeight: a ? void 0 : wO,
        onClick: Ww,
        children: [v.jsx(oO, {
            url: (null == a ? void 0 : a.profile.banner) ?? null
        }), v.jsxs(S, {
            p: 2,
            gap: 2,
            children: [v.jsxs(S, {
                gap: 1,
                children: [v.jsx(uO, {
                    isLoading: !a,
                    avatarUrl: (null == a ? void 0 : a.profile.avatar) ?? null,
                    name: (null == a ? void 0 : a.profile.name) ?? null,
                    handle: (null == a ? void 0 : a.handle) ?? null,
                    profileUrl: s,
                    isVerified: (null == a ? void 0 : a.verified) ?? null,
                    reuses: t
                }), v.jsx(sO, {
                    desc: (null == a ? void 0 : a.profile.description.text) ?? null,
                    urls: (null == a ? void 0 : a.profile.description.urls) ?? null
                })]
            }), v.jsxs(S, {
                gap: 1,
                children: [v.jsx(vO, {
                    isLoading: !a,
                    location: (null == a ? void 0 : a.profile.location) ?? null,
                    joinedAt: (null == a ? void 0 : a.joined_at) ?? null
                }), v.jsx(yO, {
                    isLoading: !a,
                    following: (null == a ? void 0 : a.metrics.following) ?? null,
                    followers: (null == a ? void 0 : a.metrics.followers) ?? null
                }), v.jsx(iO, {
                    url: s,
                    label: n.t("profile")
                })]
            })]
        })]
    })
}
))
  , wO = 340
  , jO = {
    display: "flex",
    flexDirection: "column",
    width: 300,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO
}
  , TO = {
    width: 300,
    height: wO,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO,
    alignItems: "center",
    justifyContent: "center",
    px: 3
}
  , IO = y.memo(( ({followers: e, following: t}) => v.jsxs(S, {
    direction: "row",
    gap: 1.25,
    alignItems: "center",
    children: [v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: tO,
            fontWeight: 700,
            noWrap: !0,
            children: LI(e, {
                symbol: "",
                collapseExponent: !0,
                ...e >= 1e3 ? {
                    desiredDigits: 3
                } : {
                    maxPrecision: 0,
                    minPrecision: 0
                }
            })
        }), v.jsx(k, {
            variant: "paragraph1",
            color: eO,
            noWrap: !0,
            children: "Followers"
        })]
    }), v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: tO,
            fontWeight: 700,
            noWrap: !0,
            children: LI(t, {
                symbol: "",
                collapseExponent: !0,
                ...t >= 1e3 ? {
                    desiredDigits: 3
                } : {
                    maxPrecision: 0,
                    minPrecision: 0
                }
            })
        }), v.jsx(k, {
            variant: "paragraph1",
            color: eO,
            noWrap: !0,
            children: "Following"
        })]
    })]
})))
  , EO = y.memo(( ({creator: e}) => {
    const t = y.useMemo(( () => SI(e.handle, VA.TWITTER)), [e.handle]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            variant: "paragraph2",
            color: eO,
            children: "Created by"
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            children: [v.jsx(C, {
                component: "img",
                src: e.profile.avatar ?? aO,
                alt: "Avatar",
                sx: NO
            }), v.jsxs(S, {
                gap: .5,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(C, {
                        component: "a",
                        href: t ?? "#",
                        target: "_blank",
                        rel: "noopener nofollow",
                        sx: PO,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            noWrap: !0,
                            color: tO,
                            sx: OO,
                            children: e.profile.name
                        })
                    }), e.verified && v.jsx(SC, {
                        size: MO
                    })]
                }), v.jsx(C, {
                    component: "a",
                    href: t ?? "#",
                    target: "_blank",
                    rel: "noopener nofollow",
                    sx: PO,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        noWrap: !0,
                        color: eO,
                        sx: OO,
                        children: `@${e.handle}`
                    })
                })]
            })]
        }), v.jsx(IO, {
            followers: e.metrics.followers,
            following: e.metrics.following
        })]
    })
}
))
  , MO = 16
  , NO = {
    width: 36,
    height: 36,
    borderRadius: "50%"
}
  , PO = {
    textDecoration: "none",
    maxWidth: 160,
    textOverflow: "ellipsis",
    overflow: "clip",
    whiteSpace: "nowrap",
    color: eO
}
  , OO = {
    maxWidth: 160,
    "&:hover": {
        textDecoration: "underline"
    }
}
  , LO = y.memo(( ({memberCount: e, memberAvatars: t}) => {
    const n = y.useMemo(( () => (null == t ? void 0 : t.length) ? t.slice(0, RO) : null), [t]);
    return v.jsxs(S, {
        height: DO,
        direction: "row",
        alignItems: "center",
        children: [n && v.jsx(S, {
            position: "relative",
            direction: "row",
            height: BO,
            width: BO + (n.length - 1) * (BO / 2),
            ml: 1.5,
            mr: -1,
            children: n.map(( (e, t) => v.jsx(C, {
                position: "absolute",
                left: BO / 2 * (t - 1),
                component: "img",
                alt: "AV",
                src: e,
                sx: _O,
                zIndex: t
            }, t)))
        }), null !== e ? v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: tO,
                fontWeight: 700,
                noWrap: !0,
                children: e
            }), v.jsx(k, {
                variant: "paragraph1",
                color: eO,
                noWrap: !0,
                children: "Members"
            })]
        }) : v.jsx(Ie, {
            variant: "rounded",
            height: BO
        })]
    })
}
))
  , RO = 5
  , DO = 30
  , BO = 26
  , _O = {
    width: BO,
    height: BO,
    borderRadius: "50%",
    border: "1px solid #1A1A1A"
}
  , UO = new hg(100)
  , WO = 5e3
  , FO = y.memo(( ({id: e}) => {
    const t = (e => {
        const {user: t} = VK()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let a = !1;
            if (t && n.status !== ox.READY)
                return (async () => {
                    try {
                        if (n.status === ox.ERROR && (await Hu(WO),
                        a))
                            return;
                        if (UO.has(e))
                            return void r({
                                status: ox.READY,
                                data: UO.get(e)
                            });
                        const t = await Nm.getCommunity({
                            idOrUrl: {
                                refType: "id",
                                ref: e
                            }
                        });
                        if (UO.set(e, t),
                        a)
                            return;
                        r({
                            status: ox.READY,
                            data: t
                        })
                    } catch (fNe) {
                        if (a)
                            return;
                        r({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    a = !0
                }
        }
        ), [e, n, t]),
        n
    }
    )(e)
      , r = y.useMemo(( () => t.status !== ox.READY ? null : t.data), [t])
      , a = y.useMemo(( () => r ? `https://x.com/i/communities/${e}` : null), [e, r])
      , s = y.useMemo(( () => {
        if (r && r.createdAt)
            return `Created ${i(r.createdAt).format("MMM YYYY")}`
    }
    ), [r]);
    return t.status === ox.READY && null === r || t.status === ox.ERROR ? v.jsx(S, {
        sx: zO,
        children: v.jsx(k, {
            color: eO,
            variant: "paragraph1",
            children: t.status === ox.ERROR ? "Error upon loading profile" : "Community doesn't exist"
        })
    }) : v.jsxs(C, {
        sx: HO,
        minHeight: r ? void 0 : VO,
        onClick: Ww,
        children: [v.jsx(oO, {
            url: (null == r ? void 0 : r.bannerUrl) ?? null
        }), v.jsxs(S, {
            p: 2,
            gap: 2,
            children: [v.jsxs(S, {
                gap: 1,
                children: [v.jsxs(S, {
                    height: 40,
                    direction: "row",
                    justifyContent: "space-between",
                    gap: 1,
                    children: [r ? v.jsx(k, {
                        variant: "paragraph3",
                        color: "#E6E6E6",
                        fontSize: 16,
                        fontWeight: 700,
                        sx: GO,
                        children: r.name
                    }) : v.jsx(Ie, {
                        variant: "rounded",
                        width: 100,
                        height: 22
                    }), v.jsx(S, {
                        width: $O,
                        children: v.jsx(Mk, {
                            size: $O,
                            color: tO
                        })
                    })]
                }), v.jsx(sO, {
                    desc: (null == r ? void 0 : r.description) ?? null,
                    urls: null,
                    color: tO
                })]
            }), v.jsxs(S, {
                gap: 1.5,
                children: [v.jsx(LO, {
                    memberCount: (null == r ? void 0 : r.memberCount) ?? null,
                    memberAvatars: (null == r ? void 0 : r.memberAvatars) ?? null
                }), v.jsx(Ee, {
                    flexItem: !0,
                    sx: qO
                }), (null == r ? void 0 : r.creator) && v.jsx(EO, {
                    creator: r.creator
                }), s && (null == r ? void 0 : r.createdAt) && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .75,
                    children: [v.jsx(mE, {
                        ts: r.createdAt / 1e3,
                        variant: "paragraph1",
                        color: eO
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: eO,
                        children: hM
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: [v.jsx(Oe, {
                            sx: KO
                        }), v.jsx(k, {
                            variant: "paragraph1",
                            noWrap: !0,
                            color: eO,
                            children: s
                        })]
                    })]
                }), v.jsx(iO, {
                    url: a,
                    label: n.t("community")
                })]
            })]
        })]
    })
}
))
  , VO = 465
  , HO = {
    display: "flex",
    flexDirection: "column",
    width: 300,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO
}
  , zO = {
    width: 300,
    height: VO,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO,
    alignItems: "center",
    justifyContent: "center",
    px: 3
}
  , $O = 24
  , GO = {
    display: "-webkit-box",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical",
    overflow: "hidden",
    textOverflow: "ellipsis"
}
  , qO = {
    borderColor: nO
}
  , KO = {
    fontSize: 16,
    color: eO,
    mt: "-2px"
}
  , YO = {
    textDecoration: "none",
    textOverflow: "ellipsis",
    overflow: "clip",
    whiteSpace: "nowrap",
    "&:hover": {
        textDecoration: "underline"
    }
}
  , XO = Cu.GEIST
  , QO = y.memo(( ({tweetId: e, likesCount: t, repliesCount: n, retweetsCount: r}) => {
    const [a,s,o] = y.useMemo(( () => [eL(e), tL(e), nL(e)]), [e]);
    return v.jsxs(S, {
        direction: "row",
        display: "grid",
        gridTemplateColumns: "1fr auto 1fr",
        alignItems: "center",
        my: 1,
        children: [v.jsxs(C, {
            component: "a",
            target: "_blank",
            href: a,
            justifySelf: "start",
            sx: JO,
            children: [v.jsx(yC, {
                size: ZO,
                color: rL
            }), v.jsx(k, {
                variant: "paragraph1",
                fontSize: 14,
                color: eO,
                fontFamily: XO,
                children: LI(t, {
                    collapseExponent: !0,
                    maxPrecision: 0,
                    minPrecision: 0,
                    desiredDigits: 3,
                    noTrailingZeros: !0
                })
            })]
        }), v.jsxs(C, {
            component: "a",
            target: "_blank",
            href: s,
            justifySelf: "center",
            sx: JO,
            children: [v.jsx(CC, {
                size: ZO,
                color: aL
            }), v.jsx(k, {
                variant: "paragraph1",
                fontSize: 14,
                color: eO,
                fontFamily: XO,
                children: LI(r, {
                    collapseExponent: !0,
                    maxPrecision: 0,
                    minPrecision: 0,
                    desiredDigits: 3,
                    noTrailingZeros: !0
                })
            })]
        }), v.jsxs(C, {
            component: "a",
            target: "_blank",
            href: o,
            justifySelf: "end",
            sx: JO,
            children: [v.jsx(kC, {
                size: ZO,
                color: sL
            }), v.jsx(k, {
                variant: "paragraph1",
                fontSize: 14,
                color: eO,
                fontFamily: XO,
                children: LI(n, {
                    collapseExponent: !0,
                    maxPrecision: 0,
                    minPrecision: 0,
                    desiredDigits: 3,
                    noTrailingZeros: !0
                })
            })]
        })]
    })
}
))
  , ZO = 20
  , JO = {
    display: "flex",
    gap: .5,
    alignItems: "center",
    textDecoration: "none",
    color: eO,
    "&:hover": {
        textDecoration: "underline"
    }
}
  , eL = e => `https://x.com/intent/like?tweet_id=${e}`
  , tL = e => `https://x.com/intent/retweet?tweet_id=${e}`
  , nL = e => `https://x.com/intent/tweet?in_reply_to=${e}`
  , rL = "#E2387E"
  , aL = "#00BA7C"
  , sL = "#40AAE4"
  , oL = y.memo(( ({authorCreatedAt: e, authorFollowersCount: t}) => {
    const n = y.useMemo(( () => cL(t ?? 0)), [t]);
    return v.jsxs(S, {
        gap: 1.25,
        mb: 1,
        children: [v.jsxs(S, {
            direction: "row",
            width: "100%",
            alignItems: "flex-end",
            justifyContent: void 0 === e ? "flex-end" : void 0 === t ? "flex-start" : "space-between",
            children: [void 0 !== e && v.jsxs(S, {
                width: "100%",
                alignItems: "center",
                direction: "row",
                gap: .5,
                children: [v.jsx(Oe, {
                    sx: lL
                }), v.jsx(k, {
                    variant: "h2",
                    color: eO,
                    fontWeight: 400,
                    fontFamily: XO,
                    children: `Joined ${i.unix(e).format("MMM YYYY")}`
                })]
            }), void 0 !== t && v.jsxs(S, {
                direction: "row",
                width: "100%",
                alignItems: "flex-end",
                justifyContent: "flex-end",
                gap: .25,
                children: [v.jsx(k, {
                    variant: "h1",
                    color: n,
                    fontFamily: XO,
                    children: LI(t, {
                        minPrecision: 0,
                        maxPrecision: 0,
                        desiredDigits: 3,
                        collapseExponent: !0,
                        noTrailingZeros: !0
                    })
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: eO,
                    fontWeight: 400,
                    fontFamily: XO,
                    children: "followers"
                })]
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: iL
        })]
    })
}
))
  , lL = {
    fontSize: 14,
    color: eO
}
  , iL = {
    borderColor: nO
}
  , cL = e => e >= 1e6 ? "#FFD700" : e >= 1e5 ? tO : e >= 1e3 ? "#1DA1F2" : "#8B4513"
  , dL = y.memo(( ({description: e, urls: t, mentions: n, isQuote: r=!1}) => {
    const [a,s] = y.useMemo(( () => [c.reduce(n, ( (e, t) => (e[`@${t.handle}`] = t,
    e)), {}), c.reduce(t, ( (e, t) => (e[t.name] = t,
    e)), {})]), [n, t]);
    return v.jsx(dN, {
        platform: VA.TWITTER,
        message: e,
        mentionsLookup: a,
        urlsLookup: s,
        variant: "paragraph1",
        fontSize: r ? 13 : 18,
        disableShortcuts: r,
        fontFamily: XO,
        fontWeight: 400,
        lineHeight: r ? "16px" : "21px",
        color: tO
    })
}
))
  , uL = y.memo(( ({userAccountId: e}) => {
    const {trackedAccounts: t, subscribeUser: n, unsubscribeUser: r} = KA()
      , a = y.useMemo(( () => !!t && t.some((t => t.accountId === e))), [t, e])
      , [s,o] = y.useState(!1)
      , l = y.useCallback((async () => {
        try {
            o(!0),
            a ? await r(e) : await n(e)
        } catch (fNe) {} finally {
            o(!1)
        }
    }
    ), [a, n, r, e])
      , i = y.useMemo(( () => v.jsx(k, {
        variant: "inherit",
        color: tO,
        children: a ? "Stop tracking handle" : "Track handle"
    })), [a]);
    return t ? v.jsx(GC, {
        title: i,
        slotProps: gL,
        children: v.jsx(C, {
            display: "flex",
            component: "span",
            children: v.jsx(F, {
                sx: pL,
                onClick: l,
                children: s ? v.jsx(J, {
                    size: 14,
                    sx: mL
                }) : a ? v.jsx(wS, {
                    color: hL
                }) : v.jsx(XS, {
                    color: tO
                })
            })
        })
    }) : null
}
))
  , pL = {
    p: .25,
    height: 18,
    width: 18,
    "&:hover, &:focus": {
        backgroundColor: "transparent"
    }
}
  , hL = "#E73A44"
  , mL = {
    color: eO
}
  , gL = {
    tooltip: {
        sx: {
            backgroundColor: rO,
            border: `1px solid ${nO}`
        }
    }
}
  , xL = y.memo(( ({avatarUrl: e, userName: t, userHandle: n, userAccountId: r, isVerified: a}) => {
    const s = y.useMemo(( () => SI(n, VA.TWITTER)), [n]);
    return v.jsxs(S, {
        direction: "row",
        justifyContent: "space-between",
        gap: .5,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            children: [v.jsx(C, {
                component: "img",
                src: e ?? aO,
                alt: "Avatar",
                sx: yL
            }), v.jsxs(S, {
                gap: 1,
                maxWidth: bL,
                overflow: "hidden",
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    children: [v.jsx(C, {
                        component: "a",
                        href: s ?? "#",
                        target: "_blank",
                        rel: "noopener nofollow",
                        sx: YO,
                        color: tO,
                        maxWidth: bL,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            color: tO,
                            fontWeight: 600,
                            fontSize: 16,
                            noWrap: !0,
                            fontFamily: XO,
                            children: t
                        })
                    }), a && v.jsx(SC, {
                        size: SL
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(C, {
                        component: "a",
                        href: s ?? "#",
                        target: "_blank",
                        rel: "noopener nofollow",
                        sx: YO,
                        color: eO,
                        maxWidth: fL,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            color: eO,
                            fontSize: 15,
                            fontWeight: 400,
                            noWrap: !0,
                            fontFamily: XO,
                            children: `@${n}`
                        })
                    }), v.jsx(C, {
                        display: "flex",
                        mt: "-2px",
                        children: v.jsx(uL, {
                            userAccountId: r
                        })
                    })]
                })]
            })]
        }), v.jsx(Mk, {
            size: vL,
            color: tO
        })]
    })
}
))
  , bL = 190
  , fL = 155
  , vL = 26
  , SL = 16
  , yL = {
    width: 48,
    height: 48,
    borderRadius: "50%"
}
  , kL = y.memo(( ({createdAt: e, bookmarksCount: t}) => v.jsxs(S, {
    direction: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: .5,
    mt: 1,
    children: [v.jsx(k, {
        variant: "paragraph1",
        fontWeight: 400,
        color: eO,
        fontFamily: XO,
        children: i(e).format("h:mm A  MMM D, YYYY")
    }), null !== t && v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .25,
        children: [v.jsx(Le, {
            sx: CL
        }), v.jsx(k, {
            variant: "paragraph1",
            fontWeight: 400,
            color: eO,
            fontFamily: XO,
            children: LI(t, {
                collapseExponent: !0,
                maxPrecision: 0,
                minPrecision: 0,
                desiredDigits: 3,
                noTrailingZeros: !0
            })
        })]
    })]
})))
  , CL = {
    fontSize: 14,
    color: eO
}
  , AL = y.memo(( ({imageUrl: e, imageUrl2: t, videoUrl: n, isQuote: r=!1}) => {
    const a = y.useMemo(( () => ({
        border: `1px solid ${nO}`,
        borderRadius: r ? 0 : "12px",
        overflow: "hidden"
    })), [r]);
    return v.jsxs(S, {
        gap: 1.5,
        children: [n && v.jsxs(C, {
            sx: wL,
            component: "video",
            width: "100%",
            controls: !0,
            onEnded: e => e.currentTarget.load(),
            borderRadius: r ? 0 : "12px",
            onClick: Uw,
            muted: !0,
            children: [v.jsx("source", {
                src: n,
                type: "video/mp4"
            }), "Your browser does not support the video tag."]
        }), e && !t && v.jsx(jL, {
            imageUrl: e,
            isQuote: r
        }), e && t && v.jsxs(C, {
            display: "flex",
            sx: a,
            children: [v.jsx(jL, {
                imageUrl: e,
                isQuote: r,
                isHalf: !0
            }), v.jsx(jL, {
                imageUrl: t,
                isQuote: r,
                isHalf: !0,
                isRight: !0
            })]
        })]
    })
}
))
  , wL = {
    border: `1px solid ${nO}`
}
  , jL = y.memo(( ({imageUrl: e, isQuote: t, isHalf: n=!1, isRight: r=!1}) => {
    const a = y.useMemo(( () => ({
        borderRadius: t || n ? 0 : "12px",
        ...n ? t ? IL : r ? ML : EL : TL
    })), [n, t, r]);
    return v.jsx(FN, {
        imageUrl: e,
        imageBoxSx: a
    })
}
))
  , TL = {
    ...wL,
    cursor: "zoom-in"
}
  , IL = {
    ...TL,
    objectFit: "cover",
    height: "auto",
    width: "50%",
    border: "none"
}
  , EL = {
    ...IL,
    borderTopLeftRadius: "12px",
    borderBottomLeftRadius: "12px",
    borderRight: `1px solid ${nO}`
}
  , ML = {
    ...IL,
    borderTopRightRadius: "12px",
    borderBottomRightRadius: "12px"
}
  , NL = y.memo(( ({userHandle: e, tweetId: t}) => {
    const n = y.useMemo(( () => lN(t, e, VA.TWITTER)), [t, e]);
    return v.jsx(V, {
        href: n,
        target: "_blank",
        variant: "tertiary",
        size: "medium",
        sx: PL,
        children: v.jsx(k, {
            variant: "paragraph1",
            fontSize: 14,
            fontWeight: 600,
            color: "#6CC9FB",
            fontFamily: XO,
            children: "Read more on X"
        })
    })
}
))
  , PL = {
    borderRadius: 4,
    border: "1px solid #5B6075",
    background: "transparent",
    "&:hover": {
        border: "1px solid #5B6075",
        background: "#6CC9FB20"
    },
    "&:focus": {
        border: "1px solid #5B6075",
        background: "transparent"
    }
}
  , OL = y.memo(( ({replyTweetId: e, replyToHandle: t}) => {
    const n = y.useMemo(( () => lN(e, t, VA.TWITTER)), [e, t]);
    return v.jsx(C, {
        component: "a",
        href: n ?? "#",
        target: "_blank",
        rel: "noopener nofollow",
        sx: YO,
        color: eO,
        maxWidth: 250,
        children: v.jsx(k, {
            variant: "paragraph1",
            color: eO,
            fontWeight: 400,
            fontSize: 14,
            noWrap: !0,
            fontFamily: XO,
            children: `Replying to @${t}`
        })
    })
}
))
  , LL = y.memo(( ({retweetTweetId: e, retweetHandle: t}) => {
    const n = y.useMemo(( () => lN(e, t, VA.TWITTER)), [t, e]);
    return v.jsx(C, {
        component: "a",
        href: n ?? "#",
        target: "_blank",
        rel: "noopener nofollow",
        sx: YO,
        color: eO,
        maxWidth: 250,
        children: v.jsx(k, {
            variant: "paragraph1",
            color: eO,
            fontWeight: 400,
            fontSize: 14,
            noWrap: !0,
            fontFamily: XO,
            children: `Retweeting @${t}`
        })
    })
}
))
  , RL = y.memo(( ({isLoading: e, requestTranslation: t, translation: n, isSmall: r=!1}) => {
    const {t: a} = we()
      , [s,o] = y.useState(!1)
      , l = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        o((e => !e)),
        t()
    }
    ), [t])
      , i = y.useCallback(( () => {
        t()
    }
    ), [t]);
    return e || n ? v.jsxs(S, {
        gap: .75,
        width: "100%",
        py: .5,
        children: [v.jsxs(C, {
            display: "flex",
            alignItems: "center",
            gap: .5,
            onMouseEnter: i,
            onClick: l,
            sx: BL,
            children: [v.jsx(fk, {
                color: "inherit"
            }), v.jsx(k, {
                variant: "paragraph1",
                color: "inherit",
                fontWeight: 400,
                fontSize: 13,
                noWrap: !0,
                fontFamily: XO,
                children: a(s ? "Hide translation" : "Show translation")
            })]
        }), s ? null === n ? v.jsx(Ie, {
            variant: "rounded",
            height: 80,
            width: "100%",
            sx: DL
        }) : v.jsx(C, {
            display: "flex",
            sx: _L,
            children: v.jsx(k, {
                variant: "paragraph1",
                fontFamily: XO,
                fontWeight: 400,
                color: tO,
                fontSize: r ? 13 : 16,
                lineHeight: r ? "15px" : "19px",
                children: n
            })
        }) : null]
    }) : null
}
))
  , DL = {
    bgcolor: `${tO}10`
}
  , BL = {
    color: FI,
    minWidth: 100,
    "&:hover": {
        cursor: "pointer",
        color: tO
    }
}
  , _L = {
    p: 1,
    background: `${tO}10`,
    borderRadius: "8px"
}
  , UL = y.memo(( ({tweetId: e, userHandle: t, userName: n, avatarUrl: r, isVerified: a, description: s, mentions: o, urls: l, imageUrl: i, imageUrl2: c, videoUrl: d, bookmarksCount: u, likesCount: p, repliesCount: h, retweetsCount: m, requestTranslation: g, translation: x, isTranslationLoading: b}) => {
    const f = y.useMemo(( () => SI(t, VA.TWITTER)), [t])
      , A = y.useMemo(( () => lN(e, t, VA.TWITTER)), [e, t])
      , w = y.useMemo(( () => wP(s)), [s]);
    return v.jsxs(S, {
        position: "relative",
        overflow: "clip",
        children: [v.jsxs(S, {
            position: "absolute",
            top: 8,
            left: 8,
            direction: "row",
            gap: .5,
            height: WL,
            overflow: "clip",
            alignItems: "center",
            children: [v.jsx(C, {
                component: "img",
                src: r ?? aO,
                alt: "Avatar",
                sx: VL
            }), v.jsx(C, {
                component: "a",
                href: f ?? "#",
                target: "_blank",
                rel: "noopener nofollow",
                sx: YO,
                color: tO,
                maxWidth: HL,
                children: v.jsx(k, {
                    variant: "paragraph1",
                    color: tO,
                    fontWeight: 600,
                    fontSize: 16,
                    noWrap: !0,
                    fontFamily: XO,
                    children: n
                })
            }), v.jsx(C, {
                component: "a",
                href: f ?? "#",
                target: "_blank",
                rel: "noopener nofollow",
                sx: YO,
                color: eO,
                maxWidth: HL,
                children: v.jsx(k, {
                    variant: "paragraph1",
                    color: eO,
                    fontSize: 15,
                    fontWeight: 400,
                    noWrap: !0,
                    fontFamily: XO,
                    children: `@${t}`
                })
            }), a && v.jsx(SC, {
                size: zL
            })]
        }), v.jsxs(C, {
            sx: FL,
            component: "a",
            target: "_blank",
            href: A,
            children: [v.jsx(C, {
                height: WL
            }), v.jsx(dL, {
                isQuote: !0,
                description: s,
                mentions: o,
                urls: l
            }), (w || x) && v.jsx(RL, {
                isLoading: b,
                requestTranslation: g,
                translation: x,
                isSmall: !0
            }), v.jsx(C, {
                mx: -1,
                children: v.jsx(AL, {
                    isQuote: !0,
                    imageUrl: i,
                    imageUrl2: c,
                    videoUrl: d
                })
            }), v.jsxs(S, {
                direction: "row",
                children: [v.jsxs(C, {
                    sx: $L,
                    justifyContent: "flex-start",
                    children: [v.jsx(yC, {
                        size: GL,
                        color: eO
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: eO,
                        fontFamily: XO,
                        children: LI(p, {
                            collapseExponent: !0,
                            maxPrecision: 0,
                            minPrecision: 0,
                            desiredDigits: 3,
                            noTrailingZeros: !0
                        })
                    })]
                }), v.jsxs(C, {
                    sx: $L,
                    justifyContent: "flex-start",
                    children: [v.jsx(CC, {
                        size: GL,
                        color: eO
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: eO,
                        fontFamily: XO,
                        children: LI(m, {
                            collapseExponent: !0,
                            maxPrecision: 0,
                            minPrecision: 0,
                            desiredDigits: 3,
                            noTrailingZeros: !0
                        })
                    })]
                }), v.jsxs(C, {
                    sx: $L,
                    justifyContent: "flex-start",
                    children: [v.jsx(kC, {
                        size: GL,
                        color: eO
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: eO,
                        fontFamily: XO,
                        children: LI(h, {
                            collapseExponent: !0,
                            maxPrecision: 0,
                            minPrecision: 0,
                            desiredDigits: 3,
                            noTrailingZeros: !0
                        })
                    })]
                }), null !== u && v.jsxs(C, {
                    sx: $L,
                    justifyContent: "flex-start",
                    children: [v.jsx(Le, {
                        sx: qL
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: eO,
                        fontFamily: XO,
                        children: LI(u, {
                            collapseExponent: !0,
                            maxPrecision: 0,
                            minPrecision: 0,
                            desiredDigits: 3,
                            noTrailingZeros: !0
                        })
                    })]
                })]
            })]
        })]
    })
}
))
  , WL = 24
  , FL = {
    display: "flex",
    flexDirection: "column",
    borderRadius: "12px",
    overflow: "clip",
    p: 1,
    gap: 1,
    border: `1px solid ${nO}`,
    textDecoration: "none",
    "&:hover": {
        background: "#FFFFFF10",
        cursor: "pointer"
    }
}
  , VL = {
    width: WL,
    height: WL,
    borderRadius: "50%"
}
  , HL = 150
  , zL = 14
  , $L = {
    flex: 1,
    display: "flex",
    alignItems: "center",
    gap: .5
}
  , GL = 12
  , qL = {
    fontSize: GL,
    color: eO
}
  , KL = new hg(50)
  , YL = ug((e => e), (async e => {
    const t = KL.get(e);
    if (t)
        return t;
    const n = await Nm.fetchFullTweet(e);
    if (n.response) {
        const t = XL(n.response);
        return KL.set(e, t),
        t
    }
    return null
}
), 10)
  , XL = e => ({
    tweetId: e.id,
    createdAt: e.created_at,
    avatarUrl: e.author.profile.avatar ?? null,
    userName: e.author.profile.name,
    userHandle: e.author.handle,
    userAccountId: e.author.id,
    isVerified: e.author.verified ?? !1,
    authorCreatedAt: e.author.joined_at,
    authorFollowersCount: e.author.metrics.followers,
    description: e.body.text,
    mentions: e.body.mentions,
    urls: e.body.urls,
    imageUrl: e.media.images.length ? e.media.images[0] : null,
    imageUrl2: e.media.images.length > 1 ? e.media.images[1] : null,
    videoUrl: e.media.videos.length ? e.media.videos[0] : null,
    bookmarksCount: e.metrics.bookmarksCount ?? null,
    likesCount: e.metrics.likesCount,
    repliesCount: e.metrics.repliesCount,
    retweetsCount: e.metrics.retweetsCount,
    replyTo: e.reply ? {
        tweetId: e.reply.id,
        userHandle: e.reply.handle
    } : null,
    subtweet: !e.subtweet || "QUOTE" !== e.type && "RETWEET" !== e.type ? null : {
        tweetId: e.subtweet.id,
        userHandle: e.subtweet.author.handle,
        userName: e.subtweet.author.profile.name,
        userAccountId: e.subtweet.author.id,
        avatarUrl: e.subtweet.author.profile.avatar,
        description: e.subtweet.body.text,
        mentions: e.subtweet.body.mentions,
        urls: e.subtweet.body.urls,
        imageUrl: e.subtweet.media.images.length ? e.subtweet.media.images[0] : null,
        imageUrl2: e.subtweet.media.images.length > 1 ? e.subtweet.media.images[1] : null,
        videoUrl: e.subtweet.media.videos.length ? e.subtweet.media.videos[0] : null,
        isVerified: e.subtweet.author.verified ?? !1,
        bookmarksCount: e.subtweet.metrics.bookmarksCount ?? null,
        likesCount: e.subtweet.metrics.likesCount,
        repliesCount: e.subtweet.metrics.repliesCount,
        retweetsCount: e.subtweet.metrics.retweetsCount
    },
    isRetweet: "RETWEET" === e.type
})
  , QL = Symbol("TWEET_DOESNT_EXIST")
  , ZL = y.memo(( ({id: e}) => {
    const t = (e => {
        const [t,n] = y.useState(( () => KL.get(e)));
        return y.useEffect(( () => {
            let r = !1;
            return t && t !== QL && t.tweetId === e || YL(e).then((e => {
                r || n(e ?? QL)
            }
            )).catch((e => {
                n(QL)
            }
            )),
            () => {
                r = !0
            }
        }
        ), [e, t]),
        KL.get(e) ?? (t === QL || (null == t ? void 0 : t.tweetId) === e ? t : null)
    }
    )(e)
      , {tweetCreationThresholds: n} = bA()
      , {isTranslationLoading: r, translation: a, subtweetTranslation: s, requestTranslation: o} = UN(e)
      , l = y.useMemo(( () => t && t !== QL && wP(t.description)), [t])
      , i = y.useCallback((e => {
        e.stopPropagation()
    }
    ), [])
      , c = y.useCallback((e => MA(e, n)), [n]);
    return t ? t === QL ? v.jsx(C, {
        sx: JL,
        children: v.jsx(k, {
            variant: "h1",
            children: "Tweet not found"
        })
    }) : v.jsxs(C, {
        className: "padre-no-scroll",
        sx: tR,
        onClick: i,
        children: [v.jsx(xL, {
            avatarUrl: t.avatarUrl,
            userName: t.userName,
            userHandle: t.userHandle,
            userAccountId: t.userAccountId,
            isVerified: t.isVerified
        }), v.jsxs(S, {
            position: "relative",
            children: [v.jsx(S, {
                position: "absolute",
                top: -20,
                right: 0,
                children: v.jsx(mE, {
                    variant: "h2",
                    fontWeight: 800,
                    overwriteColors: !0,
                    ts: t.createdAt / 1e3,
                    getColorForDelay: c,
                    fontFamily: XO
                })
            }), v.jsx(oL, {
                authorCreatedAt: t.authorCreatedAt / 1e3,
                authorFollowersCount: t.authorFollowersCount
            })]
        }), t.replyTo && v.jsx(OL, {
            replyTweetId: t.replyTo.tweetId,
            replyToHandle: t.replyTo.userHandle
        }), t.isRetweet && t.subtweet && v.jsx(LL, {
            retweetTweetId: t.subtweet.tweetId,
            retweetHandle: t.subtweet.userHandle
        }), v.jsx(dL, {
            description: t.description,
            mentions: t.mentions,
            urls: t.urls
        }), (l || a) && v.jsx(RL, {
            isLoading: r,
            requestTranslation: o,
            translation: a
        }), v.jsx(AL, {
            imageUrl: t.imageUrl,
            imageUrl2: t.imageUrl2,
            videoUrl: t.videoUrl
        }), t.subtweet && v.jsx(UL, {
            ...t.subtweet,
            translation: s,
            requestTranslation: o,
            isTranslationLoading: r
        }), v.jsx(kL, {
            createdAt: t.createdAt,
            bookmarksCount: t.bookmarksCount
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: rR
        }), v.jsx(QO, {
            tweetId: t.tweetId,
            likesCount: t.likesCount,
            repliesCount: t.repliesCount,
            retweetsCount: t.retweetsCount
        }), v.jsx(NL, {
            userHandle: t.userHandle,
            tweetId: t.tweetId
        })]
    }) : v.jsxs(C, {
        sx: eR,
        onClick: i,
        children: [v.jsx(Ie, {
            variant: "rounded",
            sx: nR,
            height: 60
        }), v.jsx(Ie, {
            variant: "rounded",
            sx: nR,
            height: 170
        }), v.jsx(Ie, {
            variant: "rounded",
            sx: nR,
            height: 60
        })]
    })
}
))
  , JL = {
    display: "flex",
    width: 300,
    height: 450,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO,
    alignItems: "center",
    justifyContent: "center",
    px: 3
}
  , eR = {
    display: "flex",
    flexDirection: "column",
    width: 300,
    height: 450,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO,
    p: 1.75,
    gap: .75
}
  , tR = {
    display: "flex",
    flexDirection: "column",
    width: 300,
    borderRadius: 3,
    border: `1px solid ${nO}`,
    background: rO,
    py: 1.25,
    px: 2,
    maxHeight: 450,
    gap: .75,
    overflow: "scroll"
}
  , nR = {
    bgcolor: `${tO}10`
}
  , rR = {
    borderColor: nO
}
  , aR = e => {
    if (!e)
        return null;
    if ("string" != typeof e)
        return o(new Error("Invalid telegram link of type " + typeof e), {
            extra: {
                potentialTelegramLink: e
            }
        }),
        null;
    if (e.startsWith("https://") || e.startsWith("http://"))
        return e;
    if (e.startsWith("/"))
        return `https://t.me${e}`;
    if (e.startsWith("t.me"))
        return `https://${e}`;
    if (!e.includes("/"))
        return `https://t.me/${e}`;
    const t = oR(e);
    return (e => {
        try {
            return Boolean(new URL(e))
        } catch (fNe) {
            return !1
        }
    }
    )(t) ? t : null
}
  , sR = e => /^(https?:\/\/)?(twitter\.com|x\.com)\/([a-zA-Z0-9_]+)/.test(e)
  , oR = e => `${/^https?:\/\//i.test(e) ? "" : "https://"}${e}`
  , lR =  (e, t, n) => {
    if (!e)
        return null;
    const r = `${`(${e} OR url:${e}${t ? ` OR url:${t}` : ""})`} ${(null == n ? void 0 : n.length) ? n.map((e => `-${e}`)).join(" ") : ""}`.trim();
    return `https://x.com/search?q=${encodeURIComponent(r)}&f=live`
}
  , iR = e => e ? `https://pump.fun/coin/${e}` : null
  , cR = e => `https://www.google.com/search?q=${e}&tbm=nws`
  , dR = e => {
    if (!e)
        return null;
    return `https://x.com/search?q=${encodeURIComponent(e)}&f=live`
}
;
function uR(e) {
    try {
        const t = new URL(e);
        if (!["twitter.com", "x.com", "www.twitter.com", "www.x.com", "mobile.twitter.com"].includes(t.hostname))
            return null;
        const n = t.pathname.split("/").filter(Boolean)
          , r = n.findIndex((e => "status" === e));
        if (-1 !== r && n.length > r + 1) {
            const e = n[r + 1];
            return /^[0-9]+$/.test(e) ? e : null
        }
        return null
    } catch {
        return null
    }
}
var pR = (e => (e.YOUTUBE = "youtube",
e.KICK = "kick",
e.TWITCH = "twitch",
e.TIKTOK = "tiktok",
e.FACEBOOK = "facebook",
e.GITHUB = "github",
e.INSTAGRAM = "instagram",
e))(pR || {});
const hR = {
    youtube: ["youtube.com", "youtu.be"],
    kick: ["kick.com"],
    twitch: ["twitch.tv"],
    tiktok: ["tiktok.com"],
    facebook: ["facebook.com"],
    github: ["github.com"],
    instagram: ["instagram.com"]
}
  , mR = e => {
    try {
        const {hostname: t} = new URL(e)
          , n = t.toLowerCase();
        for (const [e,r] of Object.entries(hR))
            if (r.some((e => n === e || n.endsWith(`.${e}`))))
                return e;
        return null
    } catch (fNe) {
        return null
    }
}
  , gR = {
    youtube: e => v.jsx(mf, {
        icon: qi,
        ...e
    }),
    kick: e => v.jsx(mf, {
        icon: Ki,
        ...e
    }),
    twitch: e => v.jsx(mf, {
        icon: Gi,
        ...e
    }),
    tiktok: e => v.jsx(mf, {
        icon: $i,
        ...e
    }),
    facebook: e => v.jsx(mf, {
        icon: Vi,
        ...e
    }),
    github: e => v.jsx(mf, {
        icon: Hi,
        ...e
    }),
    instagram: e => v.jsx(mf, {
        icon: zi,
        ...e
    })
}
  , xR = e => {
    if (!e)
        return yk;
    const t = mR(e);
    return t ? gR[t] : yk
}
  , bR = e => {
    if (/^\d+$/.test(e))
        return parseInt(e, 10);
    const t = e.match(/^(\d+)s$/i);
    if (t)
        return parseInt(t[1], 10);
    const n = e.match(/^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/i);
    if (n) {
        const e = 3600 * (n[1] ? parseInt(n[1], 10) : 0) + 60 * (n[2] ? parseInt(n[2], 10) : 0) + (n[3] ? parseInt(n[3], 10) : 0);
        return Number.isNaN(e) ? null : e
    }
    return null
}
  , fR = e => {
    try {
        const t = new URL(e)
          , n = t.hostname.replace(/^www\./, "");
        if ("twitter.com" !== n && "x.com" !== n)
            return [null, !1];
        const r = t.pathname.split("/").filter(Boolean)
          , a = new Set(["home", "explore", "i", "search", "notifications", "messages", "settings", "logout", "signup", "login", "compose", "hashtag", "communities"])
          , s = r[0]
          , o = r[1]
          , l = r[2];
        return s && !a.has(s.toLowerCase()) ? [s, !1] : s && "communities" === s.toLowerCase() && o ? [o, !0] : o && "communities" === o.toLowerCase() && l ? [l, !0] : [null, !1]
    } catch {
        return [null, !1]
    }
}
  , vR = e => {
    switch (e) {
    case pR.YOUTUBE:
        return Re.YouTubeEmbed;
    case pR.TIKTOK:
        return Re.TikTokEmbed;
    case pR.INSTAGRAM:
        return Re.InstagramEmbed;
    case pR.FACEBOOK:
        return Re.FacebookEmbed;
    default:
        return null
    }
}
  , SR = y.memo(( ({url: e}) => {
    const t = mR(e)
      , n = vR(t)
      , r = y.useMemo(( () => t !== pR.YOUTUBE ? {
        overflow: "scroll"
    } : void 0), [t])
      , a = y.useMemo(( () => t === pR.YOUTUBE ? (e => {
        try {
            const t = new URL(e)
              , n = t.searchParams.get("start");
            if (n && /^\d+$/.test(n))
                return t.toString();
            const r = t.searchParams.get("t");
            if (!r)
                return t.toString();
            const a = bR(r);
            return null == a || t.searchParams.set("start", String(a)),
            t.toString()
        } catch {
            return e
        }
    }
    )(e) : e), [t, e]);
    if (!n)
        return null;
    const s = (e => e === pR.YOUTUBE ? 360 : 425)(t)
      , o = t === pR.INSTAGRAM || t === pR.TIKTOK
      , l = yR - (o ? 4 : 0);
    return v.jsx(kR, {
        height: s,
        bgColor: o ? "#FFFFFF" : void 0,
        children: v.jsx(n, {
            url: a,
            className: "padre-no-scroll",
            width: l,
            embedPlaceholder: o ? v.jsxs(S, {
                gap: 1,
                height: "100%",
                width: "100%",
                px: t === pR.INSTAGRAM ? .5 : 4,
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .75,
                    children: [v.jsx(Ie, {
                        variant: "circular",
                        sx: CR,
                        height: 24,
                        width: 24
                    }), v.jsx(Ie, {
                        variant: "rounded",
                        width: "100%",
                        height: 24,
                        sx: CR
                    })]
                }), v.jsx(Ie, {
                    variant: "rounded",
                    width: "100%",
                    sx: CR,
                    height: 20
                }), v.jsx(Ie, {
                    variant: "rounded",
                    width: "100%",
                    sx: CR,
                    height: 20
                })]
            }) : v.jsx(S, {
                className: "padre-no-scroll",
                alignItems: "center",
                justifyContent: "center",
                height: s,
                children: v.jsx(Km, {})
            }),
            height: s,
            style: r
        })
    })
}
))
  , yR = 380
  , kR = y.memo(( ({height: e, bgColor: t, children: n}) => v.jsx(S, {
    alignItems: "center",
    justifyContent: "center",
    sx: e => ({
        borderRadius: 3,
        border: `1px solid ${e.palette.background.borderMain}`,
        background: t ?? e.palette.background.secondary,
        py: 1
    }),
    width: yR,
    maxWidth: yR,
    minHeight: e,
    children: n
})))
  , CR = e => ({
    background: e.palette.text.label
})
  , AR = e => {
    if (!e)
        return null;
    const t = mR(e);
    if (t === pR.TIKTOK && !(e => {
        try {
            const t = new URL(e);
            return !!t.hostname.toLowerCase().includes("tiktok.com") && /^\/@[\w.-]+\/video\/\d+\/?$/.test(t.pathname)
        } catch {
            return !1
        }
    }
    )(e))
        return null;
    if (t === pR.YOUTUBE && !(e => {
        try {
            const t = new URL(e)
              , n = t.hostname.toLowerCase()
              , r = t.pathname;
            return !("www.youtube.com" !== n && "youtube.com" !== n && "m.youtube.com" !== n && "youtu.be" !== n) && (n.includes("youtube.com") && "/watch" === r ? t.searchParams.has("v") : "youtu.be" === n && /^\/[\w-]{11}$/.test(r))
        } catch {
            return !1
        }
    }
    )(e))
        return null;
    return vR(t) ? v.jsx(SR, {
        url: e
    }) : null
}
  , wR = y.memo(( ({isPermissioned: e=!1, tokenAddress: t, showPumpfunLink: n, showFourmemeLink: r, showBoopLink: a, showLaunchlabLink: s, showBagsLink: o, showBelieveLink: l, showBonkLink: d, showDaosLink: u, tokenSocials: p, deployerAddress: h, pumpFunNewsArticleId: m, marketAddress: g, omitAggregator: x=!1, omitTwitterSearch: b=!1, preventDefault: f=!1, pumpfunAddress: C, tooltipTitle: A, color: w, useHref: j=!0, isDexPaid: T, isDexBoosted: I, mayhemUntilTs: E, isConfirmedBot: M=!1, iconSize: N, interactiveTooltipCallback: P}) => {
    var O, L, R, B, _;
    const U = D()
      , {t: W} = we()
      , {isCustomBgLight: F, isCustomTextLight: V} = Vb()
      , {livePumpfuns: H} = y.useContext(vA)
      , z = y.useMemo(( () => !!t && H.has(t)), [H, t])
      , {settings: $} = rf()
      , G = PA({
        immediateRunAfterPageBecomesVisible: !0,
        refreshRate: 59152
    })
      , {tweetCreationThresholds: q} = bA()
      , {tweetId: K, tweetUrl: Y} = y.useMemo(( () => {
        const e = uR((null == p ? void 0 : p.twitterUrl) ?? "");
        if (e)
            return {
                tweetId: e,
                tweetUrl: (null == p ? void 0 : p.twitterUrl) ?? ""
            };
        const t = uR((null == p ? void 0 : p.projectWebsiteUrl) ?? "");
        return t ? {
            tweetId: t,
            tweetUrl: (null == p ? void 0 : p.projectWebsiteUrl) ?? ""
        } : {
            tweetId: null,
            tweetUrl: null
        }
    }
    ), [null == p ? void 0 : p.twitterUrl, null == p ? void 0 : p.projectWebsiteUrl])
      , [X,Q] = y.useState(c.isNil(null == (O = null == p ? void 0 : p.twitterLaunchMetadata) ? void 0 : O.tweetCreatedAt) ? FI : MA(Math.max(0, i().unix() - p.twitterLaunchMetadata.tweetCreatedAt / 1e3), q))
      , Z = y.useCallback((e => {
        var t;
        if (c.isNil(null == (t = null == p ? void 0 : p.twitterLaunchMetadata) ? void 0 : t.tweetCreatedAt))
            return void (X !== FI && Q(FI));
        const n = MA(Math.max(0, e.unix() - p.twitterLaunchMetadata.tweetCreatedAt / 1e3), q);
        n !== X && Q(n)
    }
    ), [null == (L = null == p ? void 0 : p.twitterLaunchMetadata) ? void 0 : L.tweetCreatedAt, q, X]);
    _A(Z);
    const J = y.useMemo(( () => {
        if (!p)
            return t ? {
                dexscreener: null,
                discord: null,
                telegram: null,
                projectWebsite: null,
                twitter: null,
                aggregator: null,
                farcaster: null,
                twitterSearch: lR(t, g ?? null, (null == $ ? void 0 : $.twitterSearchExclusions) ?? zI),
                devSearch: lR(h, null),
                pumpfun: null,
                pumpfunNews: null,
                pumpfunBot: null,
                fourmeme: null,
                launchlab: null,
                boop: null,
                bags: null,
                believe: null,
                meteoraCurve: null,
                bonk: null,
                daos: null
            } : null;
        let e = ( (e, t) => e && sR(e) ? oR(e) : !e && t && sR(t) ? oR(t) : null)(p.twitterUrl, p.projectWebsiteUrl)
          , i = !p.projectWebsiteUrl || sR(p.projectWebsiteUrl) && oR(p.projectWebsiteUrl) === e ? null : oR(p.projectWebsiteUrl);
        return e === Y && (e = null),
        i === Y && (i = null),
        {
            dexscreener: TA(p.chain, g),
            discord: p.discordUrl ? oR(p.discordUrl) : null,
            telegram: aR(p.telegramUrl),
            projectWebsite: i,
            twitter: e,
            aggregator: wA(p.tokenAddress, p.chain),
            farcaster: p.farcasterUrl ? oR(p.farcasterUrl) : null,
            twitterSearch: lR(p.tokenAddress, g ?? null, (null == $ ? void 0 : $.twitterSearchExclusions) ?? zI),
            devSearch: lR(h, null),
            pumpfun: C ? iR(C) : n ? iR(t) : null,
            pumpfunNews: iR(C ?? null) ?? iR(t),
            pumpfunBot: M ? iR(C ?? null) ?? iR(t) : null,
            fourmeme: r ? `https://four.meme/token/${t}` : null,
            boop: a ? `https://boop.fun/tokens/${t}` : null,
            bags: o ? `https://bags.fm/${t}` : null,
            believe: l ? `https://believe.app/coin/${t}` : null,
            launchlab: s && !d ? `https://raydium.io/launchpad/token/?mint=${t}` : null,
            bonk: d ? `https://bonk.fun/token/${t}` : null,
            daos: u ? `https://www.daos.fun/${t}` : null
        }
    }
    ), [Y, p, g, n, t, C, h, r, s, a, o, l, d, u, null == $ ? void 0 : $.twitterSearchExclusions, M])
      , ee = (null == (R = null == p ? void 0 : p.twitterReuse) ? void 0 : R.reuses) ?? null
      , te = y.useMemo(( () => P ?? {
        onOpen: c.noop,
        onClose: c.noop
    }), [P])
      , [ne,re,ae] = y.useMemo(( () => {
        if ((null == J ? void 0 : J.projectWebsite) && sR(J.projectWebsite)) {
            const [e,t] = fR(J.projectWebsite);
            if (!e)
                return [null, Mk, !0];
            return [t ? v.jsx(FO, {
                id: e
            }) : v.jsx(AO, {
                id: e,
                reuses: null
            }), t ? Wk : $S, !0]
        }
        return [(null == J ? void 0 : J.projectWebsite) ? AR(J.projectWebsite) ?? v.jsx(SE, {
            url: J.projectWebsite
        }) : null, xR((null == J ? void 0 : J.projectWebsite) ?? null), !1]
    }
    ), [null == J ? void 0 : J.projectWebsite])
      , [se,oe] = y.useMemo(( () => {
        var e;
        if (!(null == J ? void 0 : J.twitter))
            return [null, !1];
        const [t,n] = fR(J.twitter);
        if (!t)
            return [null, !1];
        return [n ? v.jsx(FO, {
            id: t
        }) : v.jsx(AO, {
            id: t,
            reuses: (null == (e = null == p ? void 0 : p.twitterReuse) ? void 0 : e.reuses) ?? null
        }), n]
    }
    ), [null == J ? void 0 : J.twitter, null == (B = null == p ? void 0 : p.twitterReuse) ? void 0 : B.reuses])
      , le = y.useMemo(( () => (null == J ? void 0 : J.bags) && t ? v.jsx(JI, {
        tokenAddress: t
    }) : null), [null == J ? void 0 : J.bags, t])
      , ie = y.useMemo(( () => M && (null == J ? void 0 : J.pumpfunBot) ? v.jsxs(S, {
        children: [v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: W("Coin created using a bot")
        }), v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: null == J ? void 0 : J.pumpfunBot
        })]
    }) : null), [M, null == J ? void 0 : J.pumpfunBot, W])
      , ce = M && (null == J ? void 0 : J.pumpfunBot)
      , de = v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: [ce && v.jsx(aE, {
            Icon: aS,
            link: J.pumpfunBot,
            preventDefault: f,
            color: U.palette.error.main,
            useHref: j,
            tooltipTitle: ie ?? void 0,
            iconSize: N,
            showTooltip: !0,
            interactiveTooltipCallback: ie ? te : void 0,
            controlledOnMobile: !!ie,
            maxTooltipWidth: 460
        }), e && v.jsx(iE, {}), E && v.jsx(AE, {
            mayhemUntilTs: E,
            size: N
        }), z && (null == J ? void 0 : J.pumpfun) && v.jsx(KE, {
            link: J.pumpfun,
            tokenAddress: t,
            labelSize: N
        }), t && m && (null == p ? void 0 : p.chain) && (null == J ? void 0 : J.pumpfunNews) && v.jsx(dM, {
            link: J.pumpfunNews,
            tokenAddress: t,
            chain: null == p ? void 0 : p.chain,
            articleId: m,
            labelSize: N
        }), se && v.jsx(aE, {
            Icon: oe ? Wk : $S,
            color: ((null == ee ? void 0 : ee.length) ?? 0) > 1 && !oe ? U.palette.warning.main : FI,
            link: (null == J ? void 0 : J.twitter) ?? "",
            preventDefault: f,
            useHref: j,
            showTooltip: !0,
            iconSize: N,
            tooltipTitle: se ?? void 0,
            noTooltipBackground: !0,
            interactiveTooltipCallback: te,
            controlledOnMobile: !0
        }), K && v.jsx(aE, {
            Icon: qy,
            link: Y ?? "https://trade.padre.gg",
            color: X,
            preventDefault: f,
            useHref: j,
            tooltipTitle: v.jsx(ZL, {
                id: K
            }),
            noTooltipBackground: !0,
            iconSize: N,
            showTooltip: !0,
            interactiveTooltipCallback: te,
            controlledOnMobile: !0
        }), (null == J ? void 0 : J.projectWebsite) && v.jsx(aE, {
            Icon: re,
            link: J.projectWebsite,
            preventDefault: f,
            color: ae && ne ? FI : w,
            useHref: j,
            tooltipTitle: ne ?? void 0,
            noTooltipBackground: !!ne,
            iconSize: N,
            showTooltip: !0,
            interactiveTooltipCallback: ne ? te : void 0,
            controlledOnMobile: !!ne
        }), !se && (null == J ? void 0 : J.twitter) && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            children: [v.jsx(aE, {
                Icon: Mk,
                link: J.twitter,
                preventDefault: f,
                color: ((null == (_ = null == p ? void 0 : p.twitterReuse) ? void 0 : _.reuses.length) ?? 0) > 1 ? U.palette.warning.main : w,
                useHref: j,
                showTooltip: !A,
                iconSize: N,
                tooltipTitle: ((null == ee ? void 0 : ee.length) ?? 0) > 1 ? v.jsx(S, {
                    maxWidth: 150,
                    gap: .25,
                    children: null == ee ? void 0 : ee.map((e => v.jsxs(k, {
                        noWrap: !0,
                        variant: "paragraph2",
                        color: U.palette.lavender[500],
                        children: [`@${iu(e.username, 32)}`, " ", v.jsx("span", {
                            style: {
                                color: U.palette.text.value
                            },
                            children: WA(Math.max(G.unix() - e.lastCheckedTs, 0), !0)
                        })]
                    }, e.username)))
                }) : void 0
            }), ((null == ee ? void 0 : ee.length) ?? 0) > 1 && v.jsx(k, {
                variant: "paragraph3",
                fontSize: 8,
                color: U.palette.warning.main,
                children: null == ee ? void 0 : ee.length
            })]
        }), (null == J ? void 0 : J.telegram) && v.jsx(aE, {
            Icon: Ly,
            link: J.telegram,
            preventDefault: f,
            color: w,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), (null == J ? void 0 : J.discord) && v.jsx(aE, {
            Icon: PS,
            link: J.discord,
            preventDefault: f,
            color: w,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), (null == J ? void 0 : J.farcaster) && v.jsx(aE, {
            Icon: uS,
            link: J.farcaster,
            preventDefault: f,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), !z && !ce && C && (null == J ? void 0 : J.pumpfun) && v.jsx(aE, {
            Icon: aS,
            link: J.pumpfun,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N,
            maxTooltipWidth: 460
        }), (null == J ? void 0 : J.bags) && v.jsx(aE, {
            Icon: Gk,
            link: J.bags,
            preventDefault: f,
            useHref: j,
            showTooltip: !0,
            iconSize: N,
            tooltipTitle: le ?? void 0,
            controlledOnMobile: !0,
            forceEnableInteractive: !0
        }), (null == J ? void 0 : J.believe) && v.jsx(aE, {
            Icon: gC,
            link: J.believe,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N,
            color: U.palette.originalGreen[500]
        }), (null == J ? void 0 : J.bonk) && v.jsx(aE, {
            Icon: nC,
            link: J.bonk,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N,
            color: F && !V ? U.palette.background.default : void 0
        }), (null == J ? void 0 : J.launchlab) && v.jsx(aE, {
            Icon: zk,
            link: J.launchlab,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N,
            color: F && !V ? U.palette.background.default : void 0
        }), (null == J ? void 0 : J.boop) && v.jsx(aE, {
            Icon: Zk,
            link: J.boop,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), (null == J ? void 0 : J.daos) && v.jsx(aE, {
            Icon: Jk,
            link: J.daos,
            preventDefault: f,
            disableHover: !0,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), !b && (null == J ? void 0 : J.twitterSearch) && v.jsx(aE, {
            Icon: cy,
            link: J.twitterSearch,
            preventDefault: f,
            useHref: j,
            showTooltip: !0,
            tooltipTitle: W("Search on X"),
            iconSize: N
        }), !z && !C && (null == J ? void 0 : J.pumpfun) && !ce && v.jsx(aE, {
            Icon: aS,
            link: J.pumpfun,
            preventDefault: f,
            color: w,
            useHref: j,
            showTooltip: !A,
            iconSize: N,
            maxTooltipWidth: 460
        }), !x && p && v.jsx(aE, {
            chain: p.chain,
            link: wA(p.tokenAddress, p.chain),
            preventDefault: f,
            useHref: j,
            showTooltip: !A,
            iconSize: N
        }), (null == J ? void 0 : J.dexscreener) && v.jsx(aE, {
            Icon: OS,
            link: J.dexscreener,
            preventDefault: f,
            useHref: j,
            showTooltip: !A,
            tooltipTitle: v.jsxs(S, {
                gap: 2,
                justifyContent: "center",
                alignItems: "center",
                children: [T && I && v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    children: "Dex paid and boosted in the last 24h"
                }), !I && v.jsx(k, {
                    variant: "inherit",
                    color: T ? U.palette.success.main : void 0,
                    children: T ? "Dex paid" : "Dex not paid"
                }), (null == p ? void 0 : p.dexBannerUrl) && v.jsx(uE, {
                    bannerUrl: (null == p ? void 0 : p.dexBannerUrl) ?? null
                })]
            }),
            color: I ? U.palette.gold[500] : T ? U.palette.success.main : void 0,
            iconSize: N
        })]
    });
    return A ? v.jsx(GC, {
        title: A,
        children: de
    }) : de
}
), c.isEqual)
  , jR = y.memo(( ({isOpen: e, unmountOnClose: t, hideHandle: n=!1, noScroll: r=!1, children: a}) => {
    const s = xw()
      , o = y.useMemo(( () => ({
        maxHeight: s ? void 0 : `calc(100vh - ${IR + MR + ER}px)`,
        overflowY: "scroll",
        p: TR,
        pt: n ? 2 : 0
    })), [n, s]);
    return !e && t ? null : v.jsxs(S, {
        children: [!n && v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(C, {
                sx: NR
            })
        }), v.jsx(S, {
            className: r ? "padre-no-scroll" : void 0,
            sx: o,
            children: a
        })]
    })
}
))
  , TR = 2
  , IR = 44
  , ER = 20
  , MR = 53
  , NR = {
    width: 80,
    height: 4,
    borderRadius: 2,
    backgroundColor: "text.placeholder",
    cursor: "grab",
    mt: 2,
    mb: 3
}
  , PR = () => {
    const e = bw();
    return R && !e
}
  , OR = () => {
    const e = PR()
      , {isLandscape: t} = De();
    return y.useMemo(( () => ({
        isLandscape: t && e
    })), [t, e])
}
  , LR = !0
  , RR = Hh.BELOW_NAV
  , DR = "padreV2-expectedTopBarButton"
  , BR = "padreV2-expectedTopBarPosition"
  , _R = e => {
    var t;
    const n = ( () => {
        const e = xw()
          , t = fw()
          , [n] = dx(DR, !0)
          , {settings: r} = rf()
          , a = y.useMemo(( () => e && (r ? r.showTopBar ?? !0 : n)), [e, r, n]);
        return y.useMemo(( () => (t ? 62 : 56) + (e && a ? 29 : 0)), [t, a, e])
    }
    )()
      , {isLandscape: r} = OR()
      , a = y.useMemo(( () => {
        var t;
        const a = {
            top: r ? n : "auto"
        };
        return {
            ...null == (t = null == e ? void 0 : e.PaperProps) ? void 0 : t.sx,
            ...a
        }
    }
    ), [n, r, null == (t = null == e ? void 0 : e.PaperProps) ? void 0 : t.sx]);
    return v.jsx(Be, {
        ...e,
        PaperProps: {
            ...e.PaperProps,
            sx: a
        }
    })
}
  , UR = y.memo(( ({sx: e, ...t}) => {
    const {isCustomBgLight: n, isCustomTextLight: r} = Vb()
      , a = y.useMemo(( () => e ? "object" == typeof e ? {
        ...n && !r ? {
            color: e => e.palette.text.value
        } : {},
        ...e
    } : t => ({
        color: e => e.palette.text.value,
        ...n && !r ? {
            color: t.palette.text.value
        } : {},
        ...e(t)
    }) : n && !r ? {
        color: e => e.palette.text.value
    } : void 0), [n, r, e]);
    return v.jsx(_e, {
        sx: a,
        ...t
    })
}
))
  , WR = y.memo(( ({label: e, isChecked: t, onClick: n, useSwitch: r=!1, disabled: a=!1, disabledTooltip: s, enabledTooltip: o, Icon: l, iconSize: i=16, size: d="small", textVariant: u="paragraph3", fontWeight: p, isFullWidth: h=!1}) => {
    const m = y.useCallback((e => {
        n && n(e)
    }
    ), [n])
      , g = y.useMemo(( () => ({
        border: "none",
        px: h ? .25 : 0,
        gap: r ? 1 : .5,
        py: 0,
        height: bu.XXSMALL,
        cursor: a && s ? "help" : "pointer",
        backgroundColor: "transparent",
        "&:hover": {
            backgroundColor: "transparent"
        },
        "&:focus": {
            backgroundColor: "transparent"
        },
        ...h ? {
            justifyContent: "space-between",
            flexDirection: "row-reverse"
        } : {}
    })), [a, s, h, r])
      , x = y.useMemo(( () => t ? {
        "&.Mui-disabled": {
            color: e => e.palette.primary[700]
        }
    } : void 0), [t]);
    return v.jsx(GC, {
        title: a ? s ?? "" : o ?? "",
        children: v.jsx(C, {
            component: "span",
            children: v.jsxs(V, {
                size: "small",
                onClick: a ? c.noop : m,
                variant: "tertiary",
                autoFocus: !1,
                sx: g,
                fullWidth: h,
                children: [!r && v.jsx(UR, {
                    tabIndex: -1,
                    disabled: a,
                    checked: t,
                    size: d,
                    sx: x
                }), l && v.jsx(C, {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: void 0,
                    width: i,
                    height: i,
                    p: 0,
                    children: v.jsx(l, {
                        size: i
                    })
                }), "string" == typeof e ? v.jsx(k, {
                    fontWeight: p,
                    variant: u,
                    color: "text.value",
                    textAlign: "start",
                    noWrap: !0,
                    children: e
                }) : e, r && v.jsx(Ue, {
                    color: t ? "success" : "neutral",
                    checked: t,
                    size: d,
                    disabled: a
                })]
            })
        })
    })
}
))
  , FR = y.memo(( ({label: e, isChecked: t, onClick: n, disabled: r, disabledTooltip: a, enabledTooltip: s, Icon: o, selectedColor: l, selectedBgColor: i, textVariant: d="paragraph3", height: u=VR, iconSize: p=HR}) => {
    const h = y.useMemo(( () => e => {
        const n = l ?? e.palette.success.main
          , s = i ?? `${e.palette.success.background}55`;
        return {
            display: "flex",
            alignItems: "center",
            px: .5,
            gap: .5,
            py: 0,
            height: u,
            cursor: r && a ? "help" : "pointer",
            color: t ? n : e.palette.text.label,
            border: `1px solid ${t ? n : e.palette.background.borderSecondary}`,
            background: t ? s : e.palette.background.buttonDefault,
            "&:hover": {
                background: t ? s : e.palette.background.hover,
                border: `1px solid ${t ? n : e.palette.background.borderSecondary}`
            },
            "&:focus": {
                background: t ? s : e.palette.background.buttonDefault,
                border: `1px solid ${t ? n : e.palette.background.borderSecondary}`
            }
        }
    }
    ), [r, a, u, t, i, l]);
    return v.jsx(GC, {
        title: r ? a ?? "" : s ?? "",
        children: v.jsx(C, {
            display: "flex",
            component: "span",
            children: v.jsxs(V, {
                size: "small",
                onClick: r ? c.noop : n,
                variant: "tertiary",
                autoFocus: !1,
                sx: h,
                children: [o && v.jsx(o, {
                    size: p,
                    color: "inherit"
                }), "string" == typeof e ? v.jsx(k, {
                    variant: d,
                    color: "inherit",
                    textAlign: "start",
                    noWrap: !0,
                    children: e
                }) : e]
            })
        })
    })
}
))
  , VR = 22
  , HR = 14
  , zR = zh.NORMAL
  , $R = y.createContext({
    selectedPreset: zR,
    setSelectedPreset: c.noop,
    buttonValue: null,
    buttonDisplayValue: 0,
    setButtonValue: c.noop,
    insufficientBalance: null,
    includeExitStrategies: !1,
    toggleIncludeExitStrategies: c.noop
})
  , GR = y.createContext({
    selectedPreset: zR,
    setSelectedPreset: c.noop,
    buttonValue: null,
    buttonDisplayValue: 0,
    setButtonValue: c.noop,
    insufficientBalance: null,
    includeExitStrategies: !1,
    toggleIncludeExitStrategies: c.noop
})
  , qR = y.createContext({
    exitStrategies: [],
    addStrategy: c.noop,
    removeStrategy: c.noop,
    updateStrategy: c.noop,
    openModal: c.noop,
    isModalOpen: !1,
    limitReached: !1,
    includeExitStrategies: !1,
    toggleIncludeExitStrategies: c.noop
});
qR.displayName = "ExitStrategiesContext";
const KR = () => y.useContext(qR)
  , YR = new Set([Pd.SOLANA])
  , XR = (e, t, n) => {
    const r = Math.max(0, t)
      , a = Number(e);
    if (isNaN(a))
        return e;
    if (null !== n && n < a)
        return n.toString();
    const [s,o] = e.split(".");
    if (!o || o.length <= r)
        return e;
    const l = o.slice(0, r)
      , i = l.slice(0, -1) + ("0" === l.slice(-1) ? "1" : l.slice(-1));
    return 0 === t ? s : `${s}${r > 0 ? "." : ""}${i}`
}
  , QR = c.flow((e => e.replace(",", ".")), (e => e.replace(/[^0-9.]/g, "")), (e => {
    if (e.split(".").length - 1 > 1) {
        const t = e.indexOf(".", e.indexOf(".") + 1);
        e = e.slice(0, t) + e.slice(t).replace(/\./g, "")
    }
    return e
}
), (e => (e.length > 1 && "0" === e[0] && "." !== e[1] && (e = e.slice(1)),
e)), (e => e.startsWith(".") ? e = "0" + e : e));
var ZR = (e => (e.AMOUNT = "AMOUNT",
e.CHANGE = "CHANGE",
e))(ZR || {});
const JR = y.memo(( ({strategyType: e, inputMode: t, value: n, saveValue: r, tradeSide: a, disabled: s=!1, chain: o}) => {
    const l = y.useCallback(( ({target: {value: n}}) => {
        const a = QR(n)
          , s = XR(a, 3, t === ZR.AMOUNT || e === hD.STOP_LOSS ? 100 : null);
        r(s ? `${t === ZR.AMOUNT ? "" : e === hD.STOP_LOSS ? "-" : "+"}${s}` : "")
    }
    ), [t, r, e])
      , i = y.useMemo(( () => e => ({
        flex: 1,
        borderRadius: "8px",
        ...s ? {
            border: `1px solid ${e.palette.background.borderMain}`
        } : {}
    })), [s])
      , c = fD[e];
    return v.jsx(je, {
        disabled: s,
        value: s ? " " : n,
        onChange: l,
        size: "xsmall",
        sx: i,
        placeholder: t === ZR.AMOUNT ? "0" : e === hD.STOP_LOSS ? "-0" : "+0",
        fullWidth: !0,
        inputProps: {
            style: {
                fontWeight: 500,
                textAlign: "right",
                paddingRight: "4px",
                paddingLeft: "0px"
            },
            inputMode: "decimal"
        },
        "data-pseudotype": "numberLike",
        inputMode: "decimal",
        startAdornment: v.jsx(We, {
            position: "start",
            sx: {
                width: 32,
                ml: -.75,
                pointerEvents: "none"
            },
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [(t === ZR.CHANGE || t === ZR.AMOUNT && e === hD.DEV_SOLD && a) && v.jsx(C, {
                    display: "flex",
                    mt: e === hD.DEV_SOLD ? -.25 : 0,
                    children: v.jsx(c, {})
                }), v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.label",
                    noWrap: !0,
                    ...Nu,
                    children: t === ZR.AMOUNT ? e === hD.DEV_SOLD && a ? s && o ? `Dev Sell not supported on ${eg(o).toLocaleUpperCase()}` : `${Jd(a)} Amount on Dev Sell` : "Amount" : bD[e]
                })]
            })
        }),
        endAdornment: s ? void 0 : v.jsx(We, {
            position: "start",
            sx: {
                width: 16,
                mr: -.25,
                mt: .125,
                pointerEvents: "none"
            },
            children: v.jsx(S, {
                alignItems: "center",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    noWrap: !0,
                    ...Nu,
                    children: "%"
                })
            })
        })
    })
}
))
  , eD = y.memo(( ({exitStrategy: e, index: t, chain: n}) => {
    const {t: r} = we()
      , {removeStrategy: a, updateStrategy: s} = KR()
      , o = y.useCallback(( () => {
        a(t)
    }
    ), [t, a])
      , l = y.useCallback((n => {
        mD(e) && s(t, {
            ...e,
            changePct: n
        })
    }
    ), [e, t, s])
      , i = y.useCallback((n => {
        (mD(e) || gD(e)) && s(t, {
            ...e,
            amountPct: n
        })
    }
    ), [e, t, s]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        children: [mD(e) && v.jsx(JR, {
            strategyType: e.type,
            inputMode: ZR.CHANGE,
            value: e.changePct,
            saveValue: l,
            tradeSide: null,
            chain: n
        }), (mD(e) || gD(e)) && v.jsx(JR, {
            strategyType: e.type,
            inputMode: ZR.AMOUNT,
            value: e.amountPct,
            saveValue: i,
            tradeSide: gD(e) ? e.side : null,
            disabled: gD(e) && !!n && !YR.has(n),
            chain: n
        }), v.jsx(GC, {
            title: r("Remove"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(F, {
                    disableRipple: !0,
                    onClick: o,
                    sx: nD,
                    children: v.jsx(wS, {
                        color: "inherit",
                        size: tD
                    })
                })
            })
        })]
    })
}
))
  , tD = 16
  , nD = e => ({
    p: .5,
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.error.main,
        backgroundColor: "transparent"
    }
})
  , rD = y.memo(( ({chain: e}) => {
    const t = D()
      , {exitStrategies: n, limitReached: r, addStrategy: a} = KR()
      , s = y.useMemo(( () => {
        const e = n.some((e => e.type === hD.DEV_SOLD));
        return vD.filter((t => !e || t !== hD.DEV_SOLD))
    }
    ), [n])
      , {buttonProps: o, popoverProps: l} = Fw({
        id: "add-exit-strategy-select-popover"
    });
    return v.jsxs(S, {
        width: "100%",
        gap: 1,
        position: "relative",
        children: [n.map(( (t, n) => v.jsx(eD, {
            exitStrategy: t,
            index: n,
            chain: e
        }, n))), !r && v.jsx(V, {
            ...o,
            disabled: r,
            fullWidth: !0,
            variant: "tertiary",
            size: "xsmall",
            sx: oD,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                width: "100%",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: "Add"
                }), v.jsx(XS, {
                    color: t.palette.text.value
                })]
            })
        }), v.jsx(ae, {
            ...l,
            onClick: Ww,
            anchorOrigin: lD,
            transformOrigin: iD,
            children: v.jsx(ee, {
                elevation: 1,
                sx: sD,
                className: "padre-no-scroll",
                children: v.jsx(S, {
                    children: s.map((e => {
                        const t = fD[e];
                        return v.jsx(te, {
                            value: e,
                            sx: aD,
                            onClick: () => {
                                a(e),
                                l.onClose()
                            }
                            ,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                width: "100%",
                                children: [v.jsx(t, {}), v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    children: xD[e]
                                })]
                            })
                        }, e)
                    }
                    ))
                })
            })
        })]
    })
}
))
  , aD = e => ({
    bgcolor: e.palette.background.secondary,
    pl: 1,
    pr: 1.5,
    py: 1
})
  , sD = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , oD = e => ({
    px: 1,
    borderRadius: 2,
    borderColor: "transparent",
    "&:hover, &:focus": {
        backgroundColor: e.palette.background.buttonDefault,
        borderColor: e.palette.background.borderMain
    }
})
  , lD = {
    vertical: "bottom",
    horizontal: "left"
}
  , iD = {
    vertical: "top",
    horizontal: "left"
}
  , cD = y.memo(( ({isOpen: e, onClose: t}) => {
    const {t: n} = we()
      , r = D();
    return v.jsx(Sw, {
        open: e,
        stackSx: {
            p: 0,
            zIndex: 1307
        },
        onClose: t,
        minDesktopHeight: uD,
        maxDesktopWidth: pD,
        minDesktopWidth: pD,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsxs(S, {
                direction: "row",
                sx: e => ({
                    p: 2,
                    gap: 1,
                    alignItems: "center",
                    justifyContent: "space-between",
                    borderBottom: `1px solid ${e.palette.background.borderMain}`
                }),
                children: [v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: n("Exit strategies")
                }), v.jsx(F, {
                    sx: {
                        px: 0,
                        width: dD,
                        height: dD
                    },
                    onClick: t,
                    children: v.jsx(kS, {
                        color: r.palette.text.value
                    })
                })]
            }), v.jsx(S, {
                width: "100%",
                alignSelf: "center",
                alignItems: "center",
                maxWidth: pD,
                px: {
                    xs: 0,
                    md: 2
                },
                pb: 2,
                children: v.jsx(rD, {
                    chain: null
                })
            })]
        })
    })
}
))
  , dD = 16
  , uD = 200
  , pD = 325;
var hD = (e => (e.TAKE_PROFIT = "TAKE_PROFIT",
e.STOP_LOSS = "STOP_LOSS",
e.DEV_SOLD = "DEV_SOLD",
e))(hD || {});
const mD = e => "STOP_LOSS" === e.type || "TAKE_PROFIT" === e.type
  , gD = e => "DEV_SOLD" === e.type
  , xD = {
    [hD.TAKE_PROFIT]: "Take Profit",
    [hD.STOP_LOSS]: "Stop Loss",
    [hD.DEV_SOLD]: "Dev Sold"
}
  , bD = {
    [hD.TAKE_PROFIT]: "TP",
    [hD.STOP_LOSS]: "SL",
    [hD.DEV_SOLD]: "DS"
}
  , fD = {
    [hD.TAKE_PROFIT]: JS,
    [hD.STOP_LOSS]: ey,
    [hD.DEV_SOLD]: Vv
}
  , vD = [hD.TAKE_PROFIT, hD.STOP_LOSS, hD.DEV_SOLD]
  , SD = xc.SELL
  , yD = e => {
    switch (e) {
    case hD.STOP_LOSS:
    case hD.TAKE_PROFIT:
        return {
            type: e,
            changePct: "",
            amountPct: ""
        };
    case hD.DEV_SOLD:
        return {
            type: e,
            amountPct: "",
            side: SD
        };
    default:
        throw new Error("Unsupported exit strategy type")
    }
}
  , kD = ({children: e}) => {
    const [t,n] = Mx("padreV2-activeExitStrategies", [])
      , [r,a] = Mx("padreV2-marketPageExitStrategies", !1)
      , s = y.useCallback(( () => {
        a((e => !e))
    }
    ), [a])
      , [o,l] = y.useState(!1)
      , i = y.useCallback(( () => {
        l(!0)
    }
    ), [])
      , c = y.useCallback(( () => {
        l(!1)
    }
    ), [])
      , d = y.useCallback((e => {
        t.length >= 5 || n((t => [...t, yD(e)]))
    }
    ), [t.length, n])
      , u = y.useCallback((e => {
        n((t => t.filter(( (t, n) => n !== e))))
    }
    ), [n])
      , p = y.useCallback(( (e, t) => {
        n((n => n.map(( (n, r) => r === e ? t : n))))
    }
    ), [n])
      , h = y.useMemo(( () => ({
        exitStrategies: t.slice(0, 5),
        addStrategy: d,
        removeStrategy: u,
        updateStrategy: p,
        openModal: i,
        isModalOpen: o,
        limitReached: t.length >= 5,
        includeExitStrategies: r,
        toggleIncludeExitStrategies: s
    })), [d, t, r, i, o, u, s, p]);
    return v.jsxs(qR.Provider, {
        value: h,
        children: [e, o && v.jsx(cD, {
            isOpen: o,
            onClose: c
        })]
    })
}
  , CD = y.createContext({
    availableWallets: null,
    hasAnyWallet: null,
    selectedWalletsAddresses: [],
    toggleSelectedWalletAddress: c.noop,
    performBuy: async () => !1
})
  , AD = () => y.useContext(CD)
  , wD = [Pd.ETH_MAINNET, Pd.BASE, Pd.SOLANA, Pd.BSC]
  , jD = [Pd.ETH_MAINNET, Pd.BASE, Pd.BSC];
function TD(e) {
    return wD.includes(e)
}
const ID = e => {
    switch (e) {
    case Pd.ETH_MAINNET:
        return "Ethereum";
    case Pd.BASE:
        return "Base";
    case Pd.SOLANA:
        return "Solana";
    case Pd.BSC:
        return "BSC";
    default:
        throw new Error(`Unsupported chain ${e}`)
    }
}
  , ED = e => {
    switch (e) {
    case Pd.ETH_MAINNET:
    case Pd.BASE:
    case Pd.BSC:
        return pc.ETH;
    case Pd.SOLANA:
        return pc.SOL;
    default:
        throw new Error(`Unsupported chain ${e}`)
    }
}
  , MD = {
    [Pd.ETH_MAINNET]: void 0,
    [Pd.ETH_SEPOLIA]: void 0,
    [Pd.BASE]: void 0,
    [Pd.BSC]: void 0,
    [Pd.ARBITRUM]: void 0,
    [Pd.ARBITRUM_SEPOLIA]: void 0,
    [Pd.SOLANA]: void 0
}
  , ND = y.createContext({
    lastSelectedWalletsPerChain: MD,
    setLastSelectedWalletsPerChain: c.noop
})
  , PD = ({children: e}) => {
    const [t,n] = Mx("padreV2-lastOrderWalletsStorageKeyV2", MD)
      , r = pK()
      , a = y.useMemo(( () => e => {
        n((t => {
            const n = "function" == typeof e ? e(t) : e
              , a = Object.entries(n);
            for (const [e,s] of a) {
                const n = e;
                if (!TD(n))
                    continue;
                const a = ED(n);
                if (s && c.size(s) > gc(a))
                    return r({
                        message: gu(a),
                        snackName: pu.tooManyWallets,
                        type: "error"
                    }, "max-wallets-error"),
                    t
            }
            return n
        }
        ))
    }
    ), [n, r])
      , s = y.useMemo(( () => ({
        lastSelectedWalletsPerChain: t,
        setLastSelectedWalletsPerChain: a
    })), [t, a]);
    return v.jsx(ND.Provider, {
        value: s,
        children: e
    })
}
  , OD = () => y.useContext(ND)
  , LD = y.createContext(null)
  , RD = e => ({
    state: null,
    retry: O,
    feeBps: 100,
    cashbackBps: 0,
    ethSubOrgId: null,
    solSubOrgId: null,
    ethEndUserId: null,
    solEndUserId: null,
    credentialId: null,
    hasLimitRawSigningPolicy: null,
    requiresVelvetSolanaMigration: !1,
    createPasskey: () => Promise.resolve({}),
    credentialIds: [],
    initializeUser: () => Promise.resolve(),
    ackWallets: () => Promise.resolve(),
    createLimitRawSigningPolicy: () => Promise.resolve(),
    setWalletsState: t => {
        e(t)
    }
});
N()(RD);
window.createEthTradingPolicy = async (e, t) => {
    const n = await WT(null).stampCreatePolicy({
        type: "ACTIVITY_TYPE_CREATE_POLICY_V3",
        timestampMs: String(+(await kg())),
        organizationId: e,
        parameters: {
            effect: "EFFECT_ALLOW",
            policyName: "TRADING_ON_UNIVERSAL_ROUTER_V2_ETHEREUM",
            notes: "Service Account can make trades on Universal Router",
            condition: "eth.tx.chain_id == 1 && eth.tx.to == '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD'",
            consensus: `approvers.any(user, user.id == '${t}')`
        }
    });
    return await am.createPolicy(await Ru(), {
        signedRequest: n
    })
}
,
window.createBaseTradingPolicy = async (e, t) => {
    const n = await WT(null).stampCreatePolicy({
        type: "ACTIVITY_TYPE_CREATE_POLICY_V3",
        timestampMs: String(+(await kg())),
        organizationId: e,
        parameters: {
            effect: "EFFECT_ALLOW",
            policyName: "TRADING_ON_UNIVERSAL_ROUTER_V2_BASE",
            notes: "Service Account can make trades on Universal Router",
            condition: "eth.tx.chain_id == 8453 && eth.tx.to == '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD'",
            consensus: `approvers.any(user, user.id == '${t}')`
        }
    });
    return await am.createPolicy(await Ru(), {
        signedRequest: n
    })
}
;
const DD = e => {
    if (!e)
        throw new Error("Not implemented: initializeUser without publicKey");
    return (async e => {
        if (!e)
            throw new Error("Can't initialize user if there's no publicKey");
        return am.initializeUser({
            type: "publicKey",
            publicKey: e
        })
    }
    )(e)
}
;
var BD = (e => (e.INITIALIZING = "INITIALIZING",
e.ERROR = "ERROR",
e.TRADING_NOT_ENABLED = "TRADING_NOT_ENABLED",
e.WALLETS_NOT_ACKNOWLEDGED = "WALLETS_NOT_ACKNOWLEDGED",
e.READY = "READY",
e))(BD || {});
const _D = ({children: e}) => {
    var t;
    const n = VK()
      , r = y.useRef(Fe(RD))
      , a = r.current.setState
      , s = pK()
      , l = YT()
      , {setCreatedPasskey: c, trackCreatedPasskey: d} = hf()
      , u = y.useRef({})
      , p = (null == (t = n.user) ? void 0 : t.uid) ?? null
      , h = mx(( (e, t) => {
        const n = y.useCallback((n => e ? (t.current.socketStartTs || (t.current.socketStartTs = i().unix()),
        am.onResourceUpdate(e, n)) : {
            unsubscribe: () => {}
        }), [e, t]);
        return yx(n, void 0, t)
    }
    )(p, u))
      , [m,g] = dx("padreV2-walletsCache", {})
      , [x,b] = dx("padreV2-hiddenWalletsCache", {})
      , [f,S] = dx("padreV2-withdrawalWalletsCache", {})
      , k = n.loading;
    y.useEffect(( () => {
        if (!k)
            return n.user ? void (h && (g({
                [n.user.uid]: h.wallets
            }),
            b({
                [n.user.uid]: h.hiddenWallets
            }),
            S({
                [n.user.uid]: h.withdrawalWallets
            }))) : (g({}),
            b({}),
            void S({}))
    }
    ), [k, n.user, h, g, b, S]);
    const [C] = y.useState(null);
    y.useEffect(( () => {
        const e = p ? m[p] : void 0
          , t = p ? x[p] : void 0
          , n = p ? f[p] : void 0;
        if (l.isContextLoading || k)
            return a({
                state: BD.INITIALIZING,
                wallets: e || [],
                hiddenWallets: t || [],
                withdrawalWallets: n || []
            });
        if (!p)
            return a({
                state: null,
                wallets: [],
                hiddenWallets: [],
                withdrawalWallets: []
            });
        if (C)
            return a({
                state: BD.ERROR
            });
        if (!h)
            return a({
                state: BD.INITIALIZING,
                wallets: e,
                hiddenWallets: t || [],
                withdrawalWallets: n
            });
        if (!(h.areWalletsAcked || (h.wallets.length || h.hiddenWallets.length || 0) > 0))
            return a({
                state: BD.TRADING_NOT_ENABLED,
                initializeUser: async () => {
                    var e;
                    await DD((null == (e = l.apiStamper) ? void 0 : e.apiPublicKey) ?? null)
                }
            }),
            void c();
        const {ethSubOrgId: r, solSubOrgId: i, ethEndUserId: d, solEndUserId: u, wallets: g, hiddenWallets: b} = h;
        if (!h.areWalletsAcked)
            return void a({
                state: BD.WALLETS_NOT_ACKNOWLEDGED,
                feeBps: h.feeBps,
                cashbackBps: h.cashbackBps,
                wallets: g,
                hiddenWallets: b,
                ethSubOrgId: r,
                solSubOrgId: i,
                ethEndUserId: d,
                solEndUserId: u,
                ackWallets: async () => {
                    try {
                        await (async ({uid: e}) => am.ackWallets({
                            uid: e
                        }))({
                            uid: p
                        })
                    } catch (fNe) {
                        o("Ack wallets failed"),
                        s({
                            message: uu.unknownError,
                            snackName: pu.unknownError,
                            type: "error"
                        }, "padre-ack-wallets-failed")
                    }
                }
            });
        const {credentialIds: v, hasLimitRawSigning: S, requiresVelvetSolanaMigration: y, withdrawalWallets: A} = h;
        a({
            state: BD.READY,
            feeBps: h.feeBps,
            cashbackBps: h.cashbackBps,
            ethSubOrgId: r,
            solSubOrgId: i,
            ethEndUserId: d,
            solEndUserId: u,
            credentialIds: v,
            wallets: g,
            hiddenWallets: b,
            withdrawalWallets: A,
            hasLimitRawSigningPolicy: S,
            requiresVelvetSolanaMigration: y,
            createLimitRawSigningPolicy: async e => {
                r && h.ethLimitTraderId && await (async e => {
                    const t = await e.turnkeyClient.stampCreatePolicy({
                        type: "ACTIVITY_TYPE_CREATE_POLICY_V3",
                        timestampMs: String(+(await kg())),
                        organizationId: e.subOrgId,
                        parameters: {
                            effect: "EFFECT_ALLOW",
                            policyName: "LIMIT_RAW_PAYLOAD_SIGNING_V2",
                            notes: "Limit Trader can sign raw payloads",
                            consensus: (n = e.limitTraderId,
                            `approvers.any(user, user.id == '${n}')`),
                            condition: "activity.type == 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2' || activity.type == 'ACTIVITY_TYPE_SIGN_TRANSACTION_V2'"
                        }
                    });
                    var n;
                    return await am.createPolicy(e.uid, {
                        signedRequest: t
                    })
                }
                )({
                    uid: e,
                    subOrgId: r,
                    limitTraderId: h.ethLimitTraderId,
                    turnkeyClient: FT(v, !!l.hasApiAuthenticator, l.apiStamper)
                })
            }
        }),
        c()
    }
    ), [p, k, a, c, d, C, h, l, m, f, x, s]);
    const A = y.useCallback(( () => {
        const e = "undefined" != typeof navigator ? navigator.onLine : null
          , t = r.current.getState()
          , n = h && (h.areWalletsAcked || (h.wallets.length || h.hiddenWallets.length || 0) > 0);
        return {
            isOnline: e,
            uid: p,
            state: t.state,
            velvelContextLoading: l.isContextLoading,
            velvetHasApiStamper: !!l.apiStamper,
            velvetHasApiAuthenticator: l.hasApiAuthenticator,
            isAuthLoading: k,
            resourcePreset: !!h,
            areWalletsAcked: (null == h ? void 0 : h.areWalletsAcked) ?? null,
            isTradingEnabled: n,
            resourceReconnectCount: u.current.reconnectCount,
            resourceHasReceivedAnyEvent: u.current.hasReceivedAnyEvent,
            resourceFirstEventTs: u.current.firstEventTs,
            resourceSocketStartTs: u.current.socketStartTs
        }
    }
    ), [k, h, p, l.apiStamper, l.hasApiAuthenticator, l.isContextLoading])
      , w = y.useRef(A);
    return y.useEffect(( () => {
        w.current = A
    }
    ), [A]),
    y.useEffect(( () => {
        if (!p)
            return;
        const e = window.setTimeout(( () => {
            const e = w.current();
            e.state !== BD.READY && (!e.isAuthLoading && e.isOnline && !e.velvelContextLoading && e.resourcePreset && e.isTradingEnabled || Ve("Wallets are still loading after 10s", {
                extra: e
            }))
        }
        ), 1e4);
        return () => window.clearTimeout(e)
    }
    ), [p, h]),
    v.jsx(LD.Provider, {
        value: r.current,
        children: e
    })
}
  , UD = e => {
    const t = y.useContext(LD);
    if (!t)
        throw new Error("useWalletsStoreContext must be used within WalletsStoreProvider");
    return He(t, e, ze)
}
  , WD = () => UD((e => c.uniq([...(e.withdrawalWallets ?? []).filter((e => e.walletType === pc.SOL)).map((e => ({
    address: e.walletAddress,
    name: e.name
}))), ...(e.wallets ?? []).filter((e => e.walletType === pc.SOL)).filter((e => !e.isHidden)).map((e => ({
    address: e.publicAddress,
    name: e.walletName
})))])))
  , FD = e => {
    const t = pK()
      , n = y.useMemo(( () => ED(e)), [e])
      , {wallets: r} = UD((e => e))
      , a = y.useMemo(( () => r ? new Set(r.filter((e => e.walletType === n)).map((e => ng(e.publicAddress)))) : null), [n, r])
      , {lastSelectedWalletsPerChain: s, setLastSelectedWalletsPerChain: o} = OD()
      , [l,i] = y.useState(s[e] ?? []);
    y.useEffect(( () => {
        s && s[e] && i(s[e] ?? [])
    }
    ), [e, s]);
    const c = y.useMemo(( () => a ? l.filter((e => a.has(ng(e)))) : []), [a, l])
      , d = y.useCallback(( (r, a=!1) => {
        const s = a ? [ng(r)] : c.includes(r) ? c.filter((e => e !== ng(r))) : [...c, ng(r)]
          , l = gc(n);
        s.length > l ? t({
            message: gu(n),
            snackName: pu.tooManyWallets,
            type: "error"
        }, "max-wallets-error") : (o((t => ({
            ...t,
            [e]: s
        }))),
        i(s))
    }
    ), [e, t, c, o, n]);
    return y.useMemo(( () => ({
        selectedWalletsAddresses: c,
        toggleSelectedWalletAddress: d
    })), [c, d])
}
  , VD = () => ({
    luts: [{
        addr: "DSaHkhDp17UexbZsg2VUnWjEuTwKNCJrnG4LW122ANfd",
        dataBase64: "AQAAAP//////////o8jpFQAAAAB+AQc1EEhOmtdvu4/ZulKjiU4iAXA+yyadcFePFoapJPiSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAabiFf+q4GE+2h/Y0YYwDXaxDncGus7VZig8AAAAAABeqi2lv6rugmjMFqKmF6Hp1in/tS0zWUifSdQaMADAZ7G+nrzvtutOj1l82qryXQxsbvkwtL24OR8pgIDRS9dYQFW4PaTZlrPRNsVaL8XW6pRicuX9dL/O2VdK7b9bRiwS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is2l1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDgNoX46QkFPkWBIcZvWnau3HcGqhHIL4qpUqjyt4eakMFN78gl7GdpQlCBi7ZUBl9CmNMVbVcbTU+AkMGOmoYwUEO5VNyibh75G1LE+Pia+Kb1rIxiFW8XHPDyGsUckiCWAMpST3sbfWzLHDlzqgMw0ZA9pgHMm13uPGYrTK0UkJLSE1ZXoVnCuH1LZqcNuOl1I4n/dqryBs7QY6OPla7QTp4S+8hOgmyTLM6eJkDM4VWQwcYnOwklcIujuFILC8zPgC1MzMhNf7IbX3O0nYGhbFtMiO4yOU4ckdNYjMQIAI6qwnvz7gZJm9i/3PiEXMdO8pV3PosO2OPMoVadihl9pjaB9yhrzIBnGeLCtQogFXJDv8lmixFSC8U4Q+3NsIQVewWA8xxfzkSmJYLbz5147nWUOghKOTs1A2jSKJkwj9vzhcCrPz0f/j6SyuigEW/2Pijx6zeG/ORNTWuqAbKL4gIUlzHg+itOC3pKCP8er7ia0Hl9jePLom5LL3ccDiBt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAA86EED9glv4WMHdJchvP2ZZvDPQq6PniaYqUsrsmZ94Fs1syAx7ALJMIQIDhDP0iqD8qO5+gZAzwP4funKN/1DIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZ8Q18wwzQ0HIqfwx9/+RqPHtMQ5n6GAB9GCyFWGxa6XjTdCF2uJxeFMlrdImYQh84EB4J5cWTMbFotiXNJxW7Jg+/6IRtaFy9xizKfgTH6PaNzDE6sxJ34uARKi7A4FLlOoZeae4PVIDKvPZjV+TcLxjVjUXB6nSJ+zcj2Xk8cqZKwvjQ3Vy8l+MonBl8tQYqVPPZVrnOblEV+WVnqlyz5qzxNusB/BxOiD0jyLWESrWaN/Zq3VfF6aw7U+BZ01xkCfAAJtCHAWUBD3Khgd1VXcYt8LKUHJUH/X1c+eUV+m3vTLgdgtbvzRsFCwzRglgunkpLgRb1mECEWN0eKF6Qij1uRy5npG6mtL0Lq539NeK0xy8dbVnC6rlclCVzrSLxuHDhLdN5iRVh0un6jyZDGDTrc28vJPwqKk3/H9XcpN/yy7m3YO3bGFcGMDBjrTPXtXKW6gLU4DNeMc6vpMxC3Sp257NEZAoc/FlMi8rQoJEBHKx90Va/g6gz+yII63et8szVNayl8XNqyCLdB3Pk2S+9ilmylANQApWpARxzqeUFVIpee3hAkTvMh3Rw/HjksvtNF0IY0a7K5eu86kvD2fEaRJ1GuYUIgi9CagSQEy9EVQCEHw2TiabYi7x0PH9ILQchPa2FavNBhFTJySoWI76WRAZWKxLeRXK3QoW4qALxS/Za1WvSunFeRXQsIx8n1jYhz1t3jzfBokiVHRdWAqeMHvLBF6ZLmjIzizz6B2ToR74q+Jb8P0Z840hr1yFnBqfVFxh70WY12tQEVf3CwMEkxo8hVnWl27rLXwgAAAAEj5zWqIFaGT2og3haJw5consDbYrvnOBvgrPs41NkpQljxpWBMA1EQ5yjuxb+8oNLPxR0jKPeJ33hSGly/cxBDCd4AllSPt2v7EQy6ado/KkFS6lF/JzCzg2rN9OEOqIzOpiKixqq9qyOHx2MaZFs2I5JxVzhtPdyc/L/o7xV6hX/HWApm9NXTdIsthjG+tgKNxaTAjmfhjC8fqnxQtmD0R3OqY37DQ8n/goMPJ5BuNzfm9ZE6Y/1L0D8arkHtPEbDTmBiOXCangzFe2yrLZRZmp52K5i8ah5s5yKAGNreNSXqVESB9AbCUohter8SIRSybiL2wBV25F5WVcKhIF2dMjFiI8mhphwvE9aSNJcoDjzYD0PSeM21ihj1VPZ+oAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTeDAy9H1S8gskwm0f5j+vNbTFZd3lZRU+TKCSKzmykK1rN82t9jD9NhP3dv2XL9dJZhxkB4hxU+hiFn9cIR3/SMikui/kJZbH+/1qGuIZMLn/WJzOqVgaAUoY8T0i+wgtw3B5jB3dz+AJxoS0/J5thcsyGrJ9dvKPu5go6nsQl7bBwcvBUq0jZh9pOWWnmMs3fON1kFBNJ2kGwtpW5HRXDrKPvikpvPN+SSKKRRk0leMFgIeqe2XRnTec3pIv8xnifeZIEgc1FyW9dRVBVvmF14wNtv5eshfnKaCWJaFe545Me9mAcJTSf1camllFRZkVq3TbFPBiF9vbbJklH53WxAFSlNamSkhBk0k6HFg2jh8fDW13bySu4HkH6hAQQVEjRIHuZs13eKOS57e6X5J12OXtaSgyT+v0nTHhqAGjt1vB4OoFSYhD5Sg6OhNIIcAOzpCYNKc552s/iGk6ncfpijZ43muccQHrOyvERB3Ee6vHb7tmq6FmYSy3N5CMGKU7lcajgHI33gg+dZrPHNluNHkr6gbeFTMLvdc71i9CIZ+ivpro2mDt+m3zIPowcs8c1jyuho0megn5AqmGg6gGVLrANn1spK0IUrH0De01vBkULlkYA3zcwUrtehPL46aZwoMriR0CcV0l184fsLYAnBWa9Tpr3hLrjU3x9SWPHibXUmdil1hblsWasDh5sJWABrW9K3PTy33GYeeXGvj9M91H2LlA2xBOBz0Wwn7g4Yk7fnXHeUDgReJf0qOF2BbDSS1YbdR0y1157gHIoM9HvvlDxa2PEqpUJdcEaQZHeUesyE/uov5yH+pHkeBlijDg+AL6n6Yx6A+A7oQac/D9vM2WG+qq5uih5B1KnlWsGkB7whnLNce2gygx0IxhdXXq2SNvhccB6aY2Sd2MovUICUFRkoufg/kb+mx6TMpdYnaaKcBLhGGRJx8S6GTUUGSAo9FcNx8DL4Hme46yN5KhkDPbnFjh5I8loyGH4DxKfr2PZOX5LFlBCvNDLjBye3QnxieJKUh7ePjtR1P+BzY2MkuwAnQUXvRb3zBgOHGTsoitr3UP8jr1LyewlzlICfHvNEMbgkQtFXuzQ9gSMoXhzsPtTnsJdQbtZs/Ya8PwHq58Aqnuh5ZHCAnsglvL4WB1yqoZWkypUzkh1hyE9T4R/lMbHfb5DatFZIwzFuT1gsXHO7jjGq0p2Oxycb+2LOxbrivMC4GjgF+AHzS7BZVcLHG+bPEtPy0h29mlwgEdmZOqjccK4w1mB4cChtBX1AvWdgUXCCxrE0gGqgWuVwXgKN0vQIKNs4L1ItWX9q+kz2pGSQsg337kyHesw0Tkufs53iAgBZpVQ16tNNZDPj5dkWT/qdwHiFww/pvlVQk82Ipy5cQJS+X2ZKkZdJaecwakPvKM3uz6kUDs4HDoW7qmwDqCbURYA8vd8QgAlhme+8MDpuFzI84jaB7syB7Sqm5pHY7ewZ+02ykZaa55/8Ob57WnElGfpzzUomnjKkMbDRQhwZMPJI5MLyTumAnGeNR25y6ytECD9EjCQpB2fY7GSmQZT4UMoIZA7FcLztowS1Y2BRcILGsTSAaqBa5XBeAo3S9Ago2zgvUi1Zf2r6TPakZJCyDffuTId6zDROS5+zneICAFmlVDXq001kM+Pl2RZP+p3AeIXDD+m+VVCTzYinLlxAlL5fZkqRl0lp5zBqQ+8oze7PqRQOzgcOhbuqbAOoJtRFgDy93xCACWGZ77wwOm4XMjziNoHuzIHtKqbmkdjt7Bn7TbKRlprnn/w5vntacSUZ+nPNSiaeMqQxsNFCHBkw8kjkwvJO6YCcZ41HbnLrK0QIP0SMJCkHZ9jsZKZBlPhQyghkDsVwvO2jBLVjYFFwgsaxNIBqoFrlcF4CjdL0CCjbOC9SLVl/avpM9qRkkLIN9+5Mh3rMNE5Ln7Od4gIAWaVUNerTTWQz4+XZFk/6ncB4hcMP6b5VUJPNiKcuXECUvl9mSpGXSWnnMGpD7yjN7s+pFA7OBw6Fu6psA6gm1EWAPL3fEIAJYZnvvDA6bhcyPOI2ge7Mge0qpuaR2O3sGftNspGWmuef/Dm+e1pxJRn6c81KJp4ypDGw0UIcGTDySOTC8k7pgJxnjUducusrRAg/RIwkKQdn2OxkpkGU+FDKCGQOxXC87aMEtWNgUXCCxrE0gGqgWuVwXgKN0vQIKNs4L1ItWX9q+kz2pGSQsg337kyHesw0Tkufs53iAgBZpVQ16tNNZDPj5dkWT/qdwHiFww/pvlVQk82Ipy5cQJS+X2ZKkZdJaecwakPvKM3uz6kUDs4HDoW7qmwDqCbURYA8vd8QgAlhme+8MDpuFzI84jaB7syB7Sqm5pHY7ewZ+02ykZaa55/8Ob57WnElGfpzzUomnjKkMbDRQhwZMPJI5MLyTumAnGeNR25y6ytECD9EjCQpB2fY7GSmQZT4UMoIZA7FcLztowS1YHgWkIKKyWGULIe4iEv4YKJdx6wqNJ/Ea4/Z5+I6Y71NmL0HvO/zrBFfis2egJjUnPObQOb4WKb9UbnvvCQQpCVf44ufqAeupzcLOIL/F3O9xkpYaqvNps30VW3Vg8AlDYE77KEttatQXg7BlV0HGwGVSexu/n9ivRQipHEE7G/Lvd1Exqh8v+ZUN6PZ/HhfsFDdSaZrqic9h2mlTa9WMhHQVjOy/zhEmWkJ66ayPa3uJ9T6R89ic/aIFxRtBwrSOi6gFL72gENZo8Xoi18mwrTm2L5gSX4CjuOR/BY5PhT1BiKZq3u+BBOVfEeSxGuut/gMaTKaXqY72yXUXrS+TSLaInroPRNHsE6RFMVFkBlTDS9FO5JANAFS+k29VC5BDwnOkEPOaHXiIxRyjpUZScnkl1SZi/L29VIDs7GyT1T8bszEecKyfG4HFEUlHyC7xIqPA5TRCABeeKygI5zE8tPHpkGpt/qkSqbx7RdRYtKdsrrlu5SAeYZcQDQa+rKwvlrk70zTPX/xp9fLekdys0GUMRxTjGuXx1umYBl6hwxryf3It+QLCsJkIQLSWMAbuRZcoGsUP322T2MHTkA/BKg=="
    }]
})
  , HD = e => e.luts.map((e => new $e({
    key: mj(e.addr),
    state: $e.deserialize(Buffer.from(e.dataBase64, "base64"))
})))
  , zD = y.createContext({
    get: () => null,
    solBalances: null,
    getPadreLutData: VD
});
zD.displayName = "SolFastDataContext";
const $D = y.memo(( ({children: e}) => {
    const [t,n] = y.useState(null)
      , r = UD((e => e.wallets))
      , a = UD((e => e.feeBps))
      , s = UD((e => e.cashbackBps))
      , o = y.useMemo(( () => r ? r.filter((e => e.walletType === pc.SOL)).map((e => e.publicAddress)) : null), [r])
      , l = y.useMemo(( () => o ? o.join("-") : null), [o])
      , i = ( () => {
        const e = Ax()
          , t = y.useCallback(( (t, n) => e ? om.subscribeShortLivedBlockhash(n) : {
            unsubscribe: () => {}
        }), [e])
          , n = y.useMemo(( () => ({
            transition: (e, t) => t,
            extractPageCursor: () => ""
        })), []);
        return fx(t, n)
    }
    )()
      , c = ( () => {
        const e = Ax()
          , t = y.useCallback(( (t, n) => e ? om.subscribePadreLutData(n) : {
            unsubscribe: () => {}
        }), [e])
          , n = y.useMemo(( () => ({
            transition: (e, t) => t,
            extractPageCursor: () => ""
        })), [])
          , r = fx(t, n);
        return y.useCallback(( () => {
            const t = r();
            return null === t ? (np.warn("No LUT data", {
                uid: e
            }),
            {
                luts: [{
                    addr: "DSaHkhDp17UexbZsg2VUnWjEuTwKNCJrnG4LW122ANfd",
                    dataBase64: "AQAAAP//////////o8jpFQAAAAB+AQc1EEhOmtdvu4/ZulKjiU4iAXA+yyadcFePFoapJPiSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAabiFf+q4GE+2h/Y0YYwDXaxDncGus7VZig8AAAAAABeqi2lv6rugmjMFqKmF6Hp1in/tS0zWUifSdQaMADAZ7G+nrzvtutOj1l82qryXQxsbvkwtL24OR8pgIDRS9dYQFW4PaTZlrPRNsVaL8XW6pRicuX9dL/O2VdK7b9bRiwS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is2l1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDgNoX46QkFPkWBIcZvWnau3HcGqhHIL4qpUqjyt4eakMFN78gl7GdpQlCBi7ZUBl9CmNMVbVcbTU+AkMGOmoYwUEO5VNyibh75G1LE+Pia+Kb1rIxiFW8XHPDyGsUckiCWAMpST3sbfWzLHDlzqgMw0ZA9pgHMm13uPGYrTK0UkJLSE1ZXoVnCuH1LZqcNuOl1I4n/dqryBs7QY6OPla7QTp4S+8hOgmyTLM6eJkDM4VWQwcYnOwklcIujuFILC8zPgC1MzMhNf7IbX3O0nYGhbFtMiO4yOU4ckdNYjMQIAI6qwnvz7gZJm9i/3PiEXMdO8pV3PosO2OPMoVadihl9pjaB9yhrzIBnGeLCtQogFXJDv8lmixFSC8U4Q+3NsIQVewWA8xxfzkSmJYLbz5147nWUOghKOTs1A2jSKJkwj9vzhcCrPz0f/j6SyuigEW/2Pijx6zeG/ORNTWuqAbKL4gIUlzHg+itOC3pKCP8er7ia0Hl9jePLom5LL3ccDiBt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAA86EED9glv4WMHdJchvP2ZZvDPQq6PniaYqUsrsmZ94Fs1syAx7ALJMIQIDhDP0iqD8qO5+gZAzwP4funKN/1DIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZ8Q18wwzQ0HIqfwx9/+RqPHtMQ5n6GAB9GCyFWGxa6XjTdCF2uJxeFMlrdImYQh84EB4J5cWTMbFotiXNJxW7Jg+/6IRtaFy9xizKfgTH6PaNzDE6sxJ34uARKi7A4FLlOoZeae4PVIDKvPZjV+TcLxjVjUXB6nSJ+zcj2Xk8cqZKwvjQ3Vy8l+MonBl8tQYqVPPZVrnOblEV+WVnqlyz5qzxNusB/BxOiD0jyLWESrWaN/Zq3VfF6aw7U+BZ01xkCfAAJtCHAWUBD3Khgd1VXcYt8LKUHJUH/X1c+eUV+m3vTLgdgtbvzRsFCwzRglgunkpLgRb1mECEWN0eKF6Qij1uRy5npG6mtL0Lq539NeK0xy8dbVnC6rlclCVzrSLxuHDhLdN5iRVh0un6jyZDGDTrc28vJPwqKk3/H9XcpN/yy7m3YO3bGFcGMDBjrTPXtXKW6gLU4DNeMc6vpMxC3Sp257NEZAoc/FlMi8rQoJEBHKx90Va/g6gz+yII63et8szVNayl8XNqyCLdB3Pk2S+9ilmylANQApWpARxzqeUFVIpee3hAkTvMh3Rw/HjksvtNF0IY0a7K5eu86kvD2fEaRJ1GuYUIgi9CagSQEy9EVQCEHw2TiabYi7x0PH9ILQchPa2FavNBhFTJySoWI76WRAZWKxLeRXK3QoW4qALxS/Za1WvSunFeRXQsIx8n1jYhz1t3jzfBokiVHRdWAqeMHvLBF6ZLmjIzizz6B2ToR74q+Jb8P0Z840hr1yFnBqfVFxh70WY12tQEVf3CwMEkxo8hVnWl27rLXwgAAAAEj5zWqIFaGT2og3haJw5consDbYrvnOBvgrPs41NkpQljxpWBMA1EQ5yjuxb+8oNLPxR0jKPeJ33hSGly/cxBDCd4AllSPt2v7EQy6ado/KkFS6lF/JzCzg2rN9OEOqIzOpiKixqq9qyOHx2MaZFs2I5JxVzhtPdyc/L/o7xV6hX/HWApm9NXTdIsthjG+tgKNxaTAjmfhjC8fqnxQtmD0R3OqY37DQ8n/goMPJ5BuNzfm9ZE6Y/1L0D8arkHtPEbDTmBiOXCangzFe2yrLZRZmp52K5i8ah5s5yKAGNreNSXqVESB9AbCUohter8SIRSybiL2wBV25F5WVcKhIF2dMjFiI8mhphwvE9aSNJcoDjzYD0PSeM21ihj1VPZ+oAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTeDAy9H1S8gskwm0f5j+vNbTFZd3lZRU+TKCSKzmykK1rN82t9jD9NhP3dv2XL9dJZhxkB4hxU+hiFn9cIR3/SMikui/kJZbH+/1qGuIZMLn/WJzOqVgaAUoY8T0i+wgtw3B5jB3dz+AJxoS0/J5thcsyGrJ9dvKPu5go6nsQl7bBwcvBUq0jZh9pOWWnmMs3fON1kFBNJ2kGwtpW5HRXDrKPvikpvPN+SSKKRRk0leMFgIeqe2XRnTec3pIv8xnifeZIEgc1FyW9dRVBVvmF14wNtv5eshfnKaCWJaFe545Me9mAcJTSf1camllFRZkVq3TbFPBiF9vbbJklH53WxAFSlNamSkhBk0k6HFg2jh8fDW13bySu4HkH6hAQQVEjRIHuZs13eKOS57e6X5J12OXtaSgyT+v0nTHhqAGjt1vB4OoFSYhD5Sg6OhNIIcAOzpCYNKc552s/iGk6ncfpijZ43muccQHrOyvERB3Ee6vHb7tmq6FmYSy3N5CMGKU7lcajgHI33gg+dZrPHNluNHkr6gbeFTMLvdc71i9CIZ+ivpro2mDt+m3zIPowcs8c1jyuho0megn5AqmGg6gGVLrANn1spK0IUrH0De01vBkULlkYA3zcwUrtehPL46aZwoMriR0CcV0l184fsLYAnBWa9Tpr3hLrjU3x9SWPHibXUmdil1hblsWasDh5sJWABrW9K3PTy33GYeeXGvj9M91H2LlA2xBOBz0Wwn7g4Yk7fnXHeUDgReJf0qOF2BbDSS1YbdR0y1157gHIoM9HvvlDxa2PEqpUJdcEaQZHeUesyE/uov5yH+pHkeBlijDg+AL6n6Yx6A+A7oQac/D9vM2WG+qq5uih5B1KnlWsGkB7whnLNce2gygx0IxhdXXq2SNvhccB6aY2Sd2MovUICUFRkoufg/kb+mx6TMpdYnaaKcBLhGGRJx8S6GTUUGSAo9FcNx8DL4Hme46yN5KhkDPbnFjh5I8loyGH4DxKfr2PZOX5LFlBCvNDLjBye3QnxieJKUh7ePjtR1P+BzY2MkuwAnQUXvRb3zBgOHGTsoitr3UP8jr1LyewlzlICfHvNEMbgkQtFXuzQ9gSMoXhzsPtTnsJdQbtZs/Ya8PwHq58Aqnuh5ZHCAnsglvL4WB1yqoZWkypUzkh1hyE9T4R/lMbHfb5DatFZIwzFuT1gsXHO7jjGq0p2Oxycb+2LOxbrivMC4GjgF+AHzS7BZVcLHG+bPEtPy0h29mlwgEdmZOqjccK4w1mB4cChtBX1AvWdgUXCCxrE0gGqgWuVwXgKN0vQIKNs4L1ItWX9q+kz2pGSQsg337kyHesw0Tkufs53iAgBZpVQ16tNNZDPj5dkWT/qdwHiFww/pvlVQk82Ipy5cQJS+X2ZKkZdJaecwakPvKM3uz6kUDs4HDoW7qmwDqCbURYA8vd8QgAlhme+8MDpuFzI84jaB7syB7Sqm5pHY7ewZ+02ykZaa55/8Ob57WnElGfpzzUomnjKkMbDRQhwZMPJI5MLyTumAnGeNR25y6ytECD9EjCQpB2fY7GSmQZT4UMoIZA7FcLztowS1Y2BRcILGsTSAaqBa5XBeAo3S9Ago2zgvUi1Zf2r6TPakZJCyDffuTId6zDROS5+zneICAFmlVDXq001kM+Pl2RZP+p3AeIXDD+m+VVCTzYinLlxAlL5fZkqRl0lp5zBqQ+8oze7PqRQOzgcOhbuqbAOoJtRFgDy93xCACWGZ77wwOm4XMjziNoHuzIHtKqbmkdjt7Bn7TbKRlprnn/w5vntacSUZ+nPNSiaeMqQxsNFCHBkw8kjkwvJO6YCcZ41HbnLrK0QIP0SMJCkHZ9jsZKZBlPhQyghkDsVwvO2jBLVjYFFwgsaxNIBqoFrlcF4CjdL0CCjbOC9SLVl/avpM9qRkkLIN9+5Mh3rMNE5Ln7Od4gIAWaVUNerTTWQz4+XZFk/6ncB4hcMP6b5VUJPNiKcuXECUvl9mSpGXSWnnMGpD7yjN7s+pFA7OBw6Fu6psA6gm1EWAPL3fEIAJYZnvvDA6bhcyPOI2ge7Mge0qpuaR2O3sGftNspGWmuef/Dm+e1pxJRn6c81KJp4ypDGw0UIcGTDySOTC8k7pgJxnjUducusrRAg/RIwkKQdn2OxkpkGU+FDKCGQOxXC87aMEtWNgUXCCxrE0gGqgWuVwXgKN0vQIKNs4L1ItWX9q+kz2pGSQsg337kyHesw0Tkufs53iAgBZpVQ16tNNZDPj5dkWT/qdwHiFww/pvlVQk82Ipy5cQJS+X2ZKkZdJaecwakPvKM3uz6kUDs4HDoW7qmwDqCbURYA8vd8QgAlhme+8MDpuFzI84jaB7syB7Sqm5pHY7ewZ+02ykZaa55/8Ob57WnElGfpzzUomnjKkMbDRQhwZMPJI5MLyTumAnGeNR25y6ytECD9EjCQpB2fY7GSmQZT4UMoIZA7FcLztowS1YHgWkIKKyWGULIe4iEv4YKJdx6wqNJ/Ea4/Z5+I6Y71NmL0HvO/zrBFfis2egJjUnPObQOb4WKb9UbnvvCQQpCVf44ufqAeupzcLOIL/F3O9xkpYaqvNps30VW3Vg8AlDYE77KEttatQXg7BlV0HGwGVSexu/n9ivRQipHEE7G/Lvd1Exqh8v+ZUN6PZ/HhfsFDdSaZrqic9h2mlTa9WMhHQVjOy/zhEmWkJ66ayPa3uJ9T6R89ic/aIFxRtBwrSOi6gFL72gENZo8Xoi18mwrTm2L5gSX4CjuOR/BY5PhT1BiKZq3u+BBOVfEeSxGuut/gMaTKaXqY72yXUXrS+TSLaInroPRNHsE6RFMVFkBlTDS9FO5JANAFS+k29VC5BDwnOkEPOaHXiIxRyjpUZScnkl1SZi/L29VIDs7GyT1T8bszEecKyfG4HFEUlHyC7xIqPA5TRCABeeKygI5zE8tPHpkGpt/qkSqbx7RdRYtKdsrrlu5SAeYZcQDQa+rKwvlrk70zTPX/xp9fLekdys0GUMRxTjGuXx1umYBl6hwxryf3It+QLCsJkIQLSWMAbuRZcoGsUP322T2MHTkA/BKg=="
                }]
            }) : t
        }
        ), [r, e])
    }
    )()
      , d = ( (e, t) => {
        const n = Ax()
          , r = y.useCallback(( (t, r) => n && e ? om.subscribeWalletsOrderContext(e, r) : {
            unsubscribe: () => {}
        }), [n, e])
          , a = y.useMemo(( () => ({
            transition: (e, t) => e ? {
                info: {
                    ...e.info,
                    [t.walletAddr]: t.ctx
                }
            } : {
                info: {
                    [t.walletAddr]: t.ctx
                }
            },
            extractPageCursor: () => ""
        })), []);
        return fx(r, a, t)
    }
    )(l, y.useCallback((e => {
        e && n((t => ({
            ...t,
            ...Object.entries(e.info).reduce(( (e, [t,n]) => (e[t] = {
                [Gc]: n.solBalance
            },
            e)), {})
        })))
    }
    ), []))
      , u = y.useMemo(( () => ({
        solBalances: t,
        get: e => {
            var t, n;
            const r = i()
              , o = (null == (n = null == (t = d()) ? void 0 : t.info) ? void 0 : n[e]) ?? null;
            if (!r || !o)
                return null;
            return {
                blockhash: r,
                walletCtx: o,
                userCtx: {
                    padreFeeBps: a,
                    cashbackBps: s
                }
            }
        }
        ,
        getPadreLutData: c
    })), [s, a, i, d, c, t]);
    return v.jsx(zD.Provider, {
        value: u,
        children: e
    })
}
))
  , GD = e => {
    switch (e) {
    case Pd.BASE:
    case Pd.ETH_MAINNET:
        return "ETH";
    case Pd.SOLANA:
        return "SOL";
    case Pd.BSC:
        return "BNB"
    }
    return "???"
}
  , qD = "This field is required."
  , KD = "Quantity must be a positive number."
  , YD = "You need at least"
  , XD = e => `Insufficient ${e} wallet balance.`
  , QD = e => `Must have no more than ${e} decimal places.`
  , ZD = ({chain: e, value: t, tip: n, prio: r, decimals: a, quoteAddress: s, padreFeeBps: o, hasBaseToken: l, useMevProtection: i, isInInfernoMode: c}) => {
    if (void 0 === t || !s || void 0 === a)
        return null;
    const d = ( ({chain: e, value: t, tip: n, prio: r, decimals: a, quoteAddress: s, padreFeeBps: o, hasBaseToken: l, useMevProtection: i, isInInfernoMode: c}) => {
        if (void 0 === t || !s || void 0 === a)
            return null;
        const d = Number(t ?? "0");
        switch (e) {
        case Pd.SOLANA:
            return void 0 === o || void 0 === l ? null : d * (1 + o / 1e4) + Number(c ? "0" : n ?? "0") + Number(c ? "0" : r ?? "0") + (l ? 0 : xB) + xB + gB[e] + .00207408 + bB + (c ? pB : 0);
        case Pd.BSC:
            {
                const t = i ? Number(n ?? "0") : 0;
                return ru(s) ? gB[e] + d + t : gB[e]
            }
        default:
            return ru(s) ? gB[e] + d : gB[e]
        }
    }
    )({
        chain: e,
        value: t,
        tip: n,
        prio: r,
        decimals: a,
        quoteAddress: s,
        padreFeeBps: o,
        hasBaseToken: l,
        useMevProtection: i,
        isInInfernoMode: c
    });
    return null === d ? null : `${d.toFixed(mB[e])} ${e === Pd.SOLANA ? "SOL" : "ETH"}`
}
  , JD = ({chain: e, value: t, tip: n, prio: r, decimals: a, quoteAddress: s, padreFeeBps: o, hasBaseToken: l, useMevProtection: i, isInInfernoMode: c}) => {
    const d = ZD({
        chain: e,
        value: t,
        tip: n,
        prio: r,
        decimals: a,
        quoteAddress: s,
        padreFeeBps: o,
        hasBaseToken: l,
        useMevProtection: i,
        isInInfernoMode: c
    });
    return d ? `${YD} ${d} to safely cover this trade ${e === Pd.SOLANA || e === Pd.BSC && i ? "and related txn fees" : `(${null !== t ? "value + " : ""}${gB[e]} ETH)`}.` : `${YD} ${gB[e]} ${GD(e)}`
}
  , eB = /^[0-9]+$/
  , tB = /^[0-9]+(\.[0-9]+)?$/;
Ge(qe, "numberLike", (function(e="Value must be an integer") {
    return this.test({
        name: "numberLike",
        exclusive: !0,
        message: e,
        test: e => !e || eB.test(e)
    })
}
)),
Ge(qe, "numberLikeDecimal", (function(e="Value must be a valid number") {
    return this.test({
        name: "numberLikeDecimal",
        exclusive: !0,
        message: e,
        test: e => !e || tB.test(e)
    })
}
)),
Ge(qe, "positive", (function(e="Value must be a positive number") {
    return this.test({
        name: "positive",
        exclusive: !0,
        message: e,
        test: e => {
            if (!e)
                return !0;
            const t = parseFloat(e);
            return !Number.isNaN(t) && t > 0
        }
    })
}
));
var nB = (e => (e.VALUE = "VALUE",
e.PERCENTAGE = "PERCENTAGE",
e))(nB || {})
  , rB = (e => (e.PRICE = "PRICE",
e.FDV = "FDV",
e))(rB || {});
class aB {
    constructor(e, n=1n) {
        t(this, "numerator"),
        t(this, "denominator"),
        this.numerator = e,
        this.denominator = n
    }
    fromFractionLike(e) {
        if (e instanceof aB)
            return e;
        const t = new ce(e)
          , n = t.decimalPlaces();
        if (null === n)
            throw new Error(`Value must have a decimal part ${e}`);
        const r = BigInt(t.multipliedBy(10 ** n).toFormat({
            groupSeparator: "",
            decimalSeparator: ""
        }))
          , a = 10n ** BigInt(n);
        return new aB(r,a)
    }
    multiply(e) {
        const t = this.fromFractionLike(e);
        return new aB(this.numerator * t.numerator,this.denominator * t.denominator)
    }
    divide(e) {
        return new aB(this.numerator * e.denominator,this.denominator * e.numerator)
    }
    equals(e) {
        const t = this.fromFractionLike(e);
        return this.numerator * t.denominator == t.numerator * this.denominator
    }
    lessThan(e) {
        const t = this.fromFractionLike(e);
        return this.numerator * t.denominator < t.numerator * this.denominator
    }
    greaterThan(e) {
        const t = this.fromFractionLike(e);
        return this.numerator * t.denominator > t.numerator * this.denominator
    }
    toFixed(e) {
        return ce(this.numerator.toString()).dividedBy(this.denominator.toString()).toFixed(e)
    }
    toNumber() {
        return ce(this.numerator.toString()).dividedBy(this.denominator.toString()).toNumber()
    }
    toExact() {
        return (e => {
            if ("string" == typeof e)
                return e;
            if ("bigint" == typeof e)
                return e.toString();
            if ("number" == typeof e || e instanceof ce) {
                const t = ce(e).toFormat({
                    groupSeparator: "",
                    decimalSeparator: "."
                });
                if (t.length > 100)
                    throw new Error("Formatted number is too large");
                return t
            }
            throw new Error(`Unsupported value type ${e}`)
        }
        )(ce(this.numerator.toString()).dividedBy(this.denominator.toString()))
    }
}
class sB extends aB {
    constructor(e, t) {
        if (super(t, 10n ** BigInt(e.decimals)),
        this.currency = e,
        this.rawAmount = t,
        this.rawAmount > Ke)
            throw new Error(`Amount ${t} is too large`)
    }
    static fromFractionalAmount(e, t) {
        const n = ce(10).pow(e.decimals)
          , r = ce(t).multipliedBy(n)
          , a = BigInt(r.toFixed(0));
        return new sB(e,a)
    }
    getRawAmount() {
        return this.rawAmount
    }
    getDecimals() {
        return this.currency.decimals
    }
}
const oB = ({value: e, decimals: t}) => {
    const [,n] = e ? UI(e).split(".") : ["", ""];
    return (null == n ? void 0 : n.length) > t
}
  , lB = ({value: e, balance: t}) => {
    if (!e)
        return !1;
    const n = t.getDecimals();
    if (oB({
        value: e,
        decimals: n
    }))
        return !1;
    const r = sB.fromFractionalAmount({
        decimals: n
    }, e || "0");
    return t.lessThan(r)
}
  , iB = ({value: e, decimals: t}) => !!e && oB({
    value: e,
    decimals: t
})
  , cB = e => Rd.includes(e) ? Qe().when("isInInfernoMode", {
    is: e => !e,
    then: t => t.shape({
        useMevProtection: Dd.includes(e) ? Je() : Je().nullable(),
        gasSettings: Qe()
    }).when("customRpcUrl", {
        is: e => !e,
        then: t => t.shape({
            gasSettings: Qe().when("useMevProtection", {
                is: e => !0 === e,
                then: t => t.shape({
                    prio: qe().numberLikeDecimal().positive().required("Priority fee per gas is required"),
                    tip: Od.includes(e) ? qe().numberLikeDecimal().positive("MEV protection requires a tip of at least 0.001").test({
                        test: function(e, {createError: t}) {
                            return !!(Number(e) >= .001) || t({
                                message: "MEV protection requires a tip of at least 0.001"
                            })
                        }
                    }) : qe().nullable()
                }),
                otherwise: t => t.shape({
                    prio: qe().numberLikeDecimal().positive().required("Priority fee per gas is required"),
                    tip: Od.includes(e) ? qe().min(0).test({
                        test: function(e, {createError: t}) {
                            const n = Number(e ?? "0");
                            return isNaN(n) ? t({
                                message: "Invalid tip format"
                            }) : n >= 0 || t({
                                message: "Tip can't be negative"
                            })
                        }
                    }) : qe().nullable()
                })
            })
        }),
        otherwise: t => t.shape({
            gasSettings: Qe().shape({
                prio: qe().numberLikeDecimal().positive().required("Priority fee per gas is required"),
                tip: Od.includes(e) ? qe().min(0).test({
                    test: function(e, {createError: t}) {
                        const n = Number(e ?? "0");
                        return isNaN(n) ? t({
                            message: "Invalid tip format"
                        }) : n >= 0 || t({
                            message: "Tip can't be negative"
                        })
                    }
                }) : qe().nullable()
            })
        })
    })
}) : Qe().nullable()
  , dB = ({chainId: e, walletsAddresses: t, baseBalances: n, baseDecimals: r, baseCurrency: a, baseCurrencySymbol: s, quoteForExecutionBalances: o, quoteForExecutionDecimals: l, quoteForExecutionCurrency: i, quoteForExecutionCurrencySymbol: c, hasBaseToken: d, devAddress: u, padreFeeBps: p}) => {
    const h = 1 === t.length ? o[t[0]] ?? "0" : "0"
      , m = new sB({
        decimals: l
    },BigInt(h))
      , g = 1 === t.length ? n[t[0]] ?? "0" : "0"
      , x = new sB({
        decimals: r
    },BigInt(g));
    return Qe().shape({
        specificType: qe().oneOf(cc).test({
            name: "dev-sell-requires-devaddress",
            message: "Dev address is required for Dev Sell",
            test: e => e !== ic.DEV_SELL_BUY && e !== ic.DEV_SELL_SELL || null != u
        }),
        customRpcUrl: qe().test("is-valid-url", "Invalid custom RPC URL format", (t => !Bd.includes(e) || (!t || ou.test(t)))),
        quantityPercentageValue: qe().numberLikeDecimal().positive(KD).when("quantityInputMode", {
            is: e => e === nB.PERCENTAGE,
            then: e => e.test({
                message: "Percentage must be between 0% and 100%",
                test: (e, t) => {
                    const n = t.parent
                      , r = isNaN(Number(n.quantityPercentageValue ?? "0")) ? 0 : Number(n.quantityPercentageValue ?? "0");
                    return !(r < 0 || r > 100)
                }
            })
        }),
        quantityValue: qe().numberLikeDecimal().when("quantityInputMode", {
            is: e => e !== nB.PERCENTAGE,
            then: e => e.positive(KD)
        }).when("specificType", {
            is: e => Tc(e) === bc.QUOTE && ru(i) || Tc(e) === bc.BASE && ru(a),
            then: n => n.test({
                message: JD({
                    chain: e
                }),
                test: (n, r) => {
                    var s, o, c, u;
                    const m = r.parent;
                    if (t.length > 1)
                        return !0;
                    const g = hB(BigInt(h), a, {
                        address: i,
                        decimals: l
                    }, e, (null == (o = null == (s = null == m ? void 0 : m.executionOptions) ? void 0 : s.gasSettings) ? void 0 : o.tip) ?? null, (null == (u = null == (c = null == m ? void 0 : m.executionOptions) ? void 0 : c.gasSettings) ? void 0 : u.prio) ?? null, d, void 0 !== p ? BigInt(p) : void 0, null == m ? void 0 : m.isInInfernoMode, null == m ? void 0 : m.executionOptions.useMevProtection);
                    return !( ({value: e, quoteForExecutionDecimals: t, quantityMax: n}) => !!e && (!oB({
                        value: e,
                        decimals: t
                    }) && sB.fromFractionalAmount({
                        decimals: t
                    }, e || "0").toNumber() > n))({
                        value: n,
                        quoteForExecutionDecimals: l,
                        quantityMax: g.toNumber()
                    })
                }
            })
        }).when("specificType", {
            is: e => Tc(e) === bc.BASE,
            then: e => e.test({
                message: QD(r),
                test: e => !iB({
                    value: e,
                    decimals: r
                })
            })
        }).when("specificType", {
            is: e => Tc(e) === bc.QUOTE,
            then: e => e.test({
                message: QD(l),
                test: e => !iB({
                    value: e,
                    decimals: l
                })
            })
        }).when("specificType", {
            is: e => jc(e) === xc.SELL && Tc(e) === bc.BASE,
            then: e => e.test({
                message: XD(s),
                test: e => t.length > 1 || !lB({
                    value: e,
                    balance: x
                })
            })
        }).when("specificType", {
            is: e => jc(e) === xc.BUY && Tc(e) === bc.QUOTE,
            then: e => e.test({
                message: XD(c),
                test: e => t.length > 1 || !lB({
                    value: e,
                    balance: m
                })
            })
        }),
        quantityUnit: qe().oneOf(yc),
        slippageValuePercent: qe().when("isInInfernoMode", {
            is: e => !e,
            then: e => e.numberLikeDecimal().positive()
        }),
        executionOptions: cB(e),
        triggerPrice: qe().when("specificType", {
            is: e => [ic.MARKET_BUY, ic.MARKET_SELL, ic.TRAILING_STOP_LOSS, ic.DEV_SELL_BUY, ic.DEV_SELL_SELL].includes(e),
            then: e => e.nullable(),
            otherwise: e => e.numberLikeDecimal().positive().required()
        }),
        trailingDelta: qe().when("specificType", {
            is: e => e === ic.TRAILING_STOP_LOSS,
            then: e => e.required("Trailing Delta is required").numberLikeDecimal("Trailing Delta must be a number").test("is-valid-range", "Trailing Delta must be positive", (e => {
                const t = Number(e);
                return !isNaN(t) && t > 0 && t <= 100
            }
            )),
            otherwise: e => e.notRequired()
        }),
        timeToLiveInSeconds: Ze().positive().nullable()
    })
}
  , uB = e => {
    switch (e) {
    case Pd.BSC:
    case Pd.ETH_MAINNET:
        return {
            prio: "3",
            tip: null
        };
    case Pd.BASE:
        return {
            prio: "0.01",
            tip: null
        };
    case Pd.SOLANA:
        return {
            prio: "0.001",
            tip: "0.002"
        };
    default:
        throw new Error("Unsupported chain")
    }
}
  , pB = .05
  , hB = (e, t, n, r, a, s, o, l=100n, i, c) => {
    const d = !tu(t, r)
      , u = ru(n.address) ? e - vB[r] - (r === Pd.SOLANA ? Xe(((i ? pB : 0) + Number(i ? "0" : a ?? "0") + Number(i ? "0" : s ?? "0")).toFixed(9), 9) + yB + SB + (o ? Xe("0.0", 9) : SB) : Xe("0.0", 9)) - (r === Pd.BSC && c ? Xe(Number(a ?? "0").toFixed(18), 18) : Xe("0.0", 18)) : e
      , p = d ? 10000n * u / (10000n + l + (r === Pd.SOLANA ? 0n : 10n)) : u;
    return new sB(n,p)
}
  , mB = {
    [Pd.ETH_MAINNET]: 3,
    [Pd.ETH_SEPOLIA]: 3,
    [Pd.BASE]: 5,
    [Pd.BSC]: 4,
    [Pd.ARBITRUM]: 5,
    [Pd.ARBITRUM_SEPOLIA]: 5,
    [Pd.SOLANA]: 4
}
  , gB = {
    [Pd.ETH_MAINNET]: .005,
    [Pd.ETH_SEPOLIA]: .003,
    [Pd.BASE]: 1e-5,
    [Pd.BSC]: 4e-4,
    [Pd.ARBITRUM]: 1e-5,
    [Pd.ARBITRUM_SEPOLIA]: 1e-5,
    [Pd.SOLANA]: 1e-5
}
  , xB = .00203928
  , bB = .00207408
  , fB = 4e5
  , vB = {
    [Pd.ETH_MAINNET]: Ye("0.005"),
    [Pd.ETH_SEPOLIA]: Ye("0.003"),
    [Pd.BASE]: Ye("0.00001"),
    [Pd.BSC]: Ye("0.0004"),
    [Pd.ARBITRUM]: Ye("0.00001"),
    [Pd.ARBITRUM_SEPOLIA]: Ye("0.00001"),
    [Pd.SOLANA]: Xe("0.00001", 9)
}
  , SB = Xe("0.00203928", 9)
  , yB = Xe("0.00207408", 9)
  , kB = [Rc.PUMP_FUN, Rc.RAYDIUM, Rc.PUMP_SWAP]
  , CB = [ic.STOP_LOSS, ic.TAKE_PROFIT, ic.TRAILING_STOP_LOSS]
  , AB = [ic.MARKET_SELL, ic.DEV_SELL_SELL]
  , wB = [ic.STOP_LOSS, ic.TAKE_PROFIT, ic.BUY_DIP]
  , jB = {
    variant: "paragraph1",
    lineHeight: "18px",
    fontSize: 14,
    fontWeight: 800,
    noWrap: !0,
    ...Nu
}
  , TB = (e, t=IB) => {
    const n = Number(e);
    return isNaN(n) ? "0" : n > t ? t.toString() : e || "0"
}
  , IB = .1
  , EB = e => {
    if (!e)
        return {};
    switch (e) {
    case Pd.BSC:
        return {
            tipLimit: .1
        };
    case Pd.SOLANA:
        return {
            prioLimit: IB,
            tipLimit: IB
        };
    default:
        return {}
    }
}
  , MB = (e, t, n, r, a, s, o, l, c, d, u) => {
    switch (Ac(e.specificType)) {
    case rc.MARKET:
        return {
            type: rc.MARKET,
            attribution: {
                firstUserClickMs: +i(),
                clientSentPerf: performance.now()
            },
            ...NB(e, t, n, a, s, o, l, c, d, u)
        };
    case rc.STOP:
        return {
            type: rc.STOP,
            ...NB(e, t, n, a, s, o, l, c, d, u),
            priceCondition: VB(e),
            ttlSeconds: e.ttlSeconds
        };
    case rc.TRAILING_STOP:
        return {
            type: rc.TRAILING_STOP,
            ...NB(e, t, n, a, s, o, l, c, d, u),
            source: HB({
                ...e,
                isPreMigrationPumpfun: r
            }),
            trailingDelta: zB(e),
            activation: $B(),
            ttlSeconds: null,
            attribution: {
                firstUserClickMs: +i(),
                clientSentPerf: performance.now()
            }
        };
    case rc.DEV_SOLD:
        return {
            type: rc.DEV_SOLD,
            ...NB(e, t, n, a, s, o, l, c, d, u),
            baseTokenAddress: e.baseCurrency,
            sellType: "partial",
            definedOn: {
                type: "marketId",
                marketId: e.marketId
            },
            ttlSeconds: null
        };
    default:
        throw new Error(`Unknown order specific type: ${e.specificType}`)
    }
}
  , NB = (e, t, n, r, a, s, o, l, i, c) => ({
    tradeParams: RB(e),
    executionOptions: UB({
        ...e,
        maxRevertCount: n
    }),
    context: FB({
        displayedBasePriceInUsd: a,
        displayedBasePriceInQuote: s,
        displayedQuoteToken: o,
        multiWalletId: l,
        multiWalletCount: e.walletsAddresses.length,
        selectedPresetName: i
    }),
    postSuccessHook: LB(e.hasExitStrategies, e.specificType, r, c),
    idemp: t
})
  , PB = e => e.replace(/[+-]/g, "")
  , OB = (e, t) => c.reduce(e, ( (e, n) => {
    switch (n.type) {
    case hD.STOP_LOSS:
    case hD.TAKE_PROFIT:
        {
            if (!n.amountPct || !n.changePct)
                return e;
            const t = Number(n.amountPct)
              , r = Number(n.changePct);
            if (isNaN(t) || isNaN(r))
                return e;
            if (t <= 0 || t > 100)
                return e;
            if (n.type === hD.STOP_LOSS ? r >= 0 || r <= -100 : r <= 0)
                return e;
            e.push({
                type: rc.STOP,
                side: xc.SELL,
                quantity: {
                    unit: bc.BASE,
                    value: {
                        type: "pct",
                        pctValue: PB(n.amountPct)
                    }
                },
                priceChange: {
                    type: "percent",
                    direction: n.type === hD.STOP_LOSS ? nc.LOWER : nc.GREATER,
                    pctValue: PB(n.changePct)
                }
            });
            break
        }
    case hD.DEV_SOLD:
        {
            if (!n.amountPct || !n.side || !t)
                return e;
            const r = Number(n.amountPct);
            if (isNaN(r))
                return e;
            if (r <= 0 || r > 100)
                return e;
            e.push({
                type: rc.DEV_SOLD,
                side: n.side,
                quantity: {
                    unit: bc.BASE,
                    value: {
                        type: "pct",
                        pctValue: PB(n.amountPct)
                    }
                },
                sellType: "partial"
            });
            break
        }
    }
    return e
}
), [])
  , LB = (e, t, n, r) => {
    if (!e || !uc.includes(t) || !n.length)
        return;
    const a = OB(n, r);
    return a.length ? {
        orderTriggers: a
    } : void 0
}
  , RB = e => ({
    pair: {
        baseCurrency: e.baseCurrency,
        quoteCurrency: e.quoteForExecutionCurrency
    },
    side: jc(e.specificType),
    quantity: DB(e),
    slippage: BB(e),
    routingFilters: _B(e)
})
  , DB = ({specificType: e, validatedQuantityValue: t}) => {
    if (!CB.includes(e) && !fc(t))
        throw new Error(`percentage mode not supported by ${e}`);
    if (!e || (fc(t) ? !t : !t.pctValue))
        throw new Error(`missing quantity data: ${e}, ${fc(t) ? "" : "pct "}${fc(t) ? t : t.pctValue}`);
    return {
        unit: Tc(e),
        value: t
    }
}
  , BB = e => {
    if (!e.slippageValuePercent)
        throw new Error("missing slippage value");
    return {
        type: "MANUAL",
        valueBps: 100 * Number(e.slippageValuePercent)
    }
}
  , _B = e => Ac(e.specificType) === rc.STOP ? {
    reliableMarketIds: [e.marketId]
} : {
    marketIds: [e.marketId]
}
  , UB = ({chainId: e, specificType: t, executionOptions: n, maxRevertCount: r, isInInfernoMode: a, customRpcUrl: s}) => ({
    ...Rd.includes(e) ? {
        gasSettings: WB(e, n.gasSettings, n.useMevProtection, a)
    } : {},
    ...Dd.includes(e) ? {
        useMevProtection: !(!a && Bd.includes(e) && s) && n.useMevProtection
    } : {},
    ..._d.includes(e) && Ac(t) === rc.STOP && null !== r ? {
        retrySettings: {
            maxRevertCount: r
        }
    } : {},
    ...!a && Bd.includes(e) && s ? {
        customRpc: {
            type: "solana",
            url: s
        }
    } : {}
})
  , WB = (e, t, n, r) => {
    if (!t)
        throw new Error("Missing gas settings");
    if (r && !$b.includes(e))
        throw new Error("Unsupported inferno mode chain");
    switch (e) {
    case Pd.SOLANA:
        return r ? {
            type: "SOLBEAST"
        } : {
            type: "SOLANA",
            tipInSolUi: TB(t.tip || "0"),
            prioInSolUi: TB(t.prio)
        };
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return {
            type: "EVM",
            prioInGweiUi: t.prio
        };
    case Pd.BSC:
        return n && t.tip && "0" !== t.tip ? {
            type: "EVM_WITH_TIP",
            prioInGweiUi: t.prio,
            tipInNativeUi: t.tip
        } : {
            type: "EVM",
            prioInGweiUi: t.prio
        };
    default:
        throw new Error("Unknown gas settings")
    }
}
  , FB = ({displayedBasePriceInUsd: e, displayedBasePriceInQuote: t, displayedQuoteToken: n, multiWalletId: r, multiWalletCount: a, selectedPresetName: s}) => {
    if (!e || !t)
        throw new Error(`missing context data: ${e}, ${t}`);
    return {
        displayedBasePriceInUsd: String(e),
        displayedBasePriceInQuote: String(t),
        displayedQuoteToken: n,
        multiWalletId: r,
        multiWalletCount: a,
        rev: Du.SENTRY_RELEASE_HASH,
        selectedPresetName: s
    }
}
  , VB = e => {
    const t = wc(e.specificType);
    if (null === t || !e.triggerPrice)
        throw new Error(`Missing price condition data: ${e.triggerPrice}`);
    return {
        direction: t,
        price: {
            type: "usd",
            value: e.triggerPrice
        }
    }
}
  , HB = ({marketId: e, baseCurrency: t, isPreMigrationPumpfun: n}) => {
    if (!e || !t)
        throw new Error(`missing source data: ${e}, ${t}`);
    return n ? {
        type: "pumpfun",
        tokenAddress: t,
        preMigrationMarketId: e
    } : {
        type: "market",
        marketId: e
    }
}
  , zB = ({trailingDelta: e}) => {
    if ("" === e)
        throw new Error(`missing trailing delta data: ${e}`);
    return {
        type: "percent",
        direction: nc.LOWER,
        pctValue: e
    }
}
  , $B = () => ({
    type: "immediate"
})
  , GB = ({type: e, orderStatus: t, txnStatus: n, iconSize: r=KB, labelTypographyOverrides: a, isShort: s=!1}) => {
    const o = D();
    if (!t)
        return v.jsx(Ie, {
            variant: "text",
            width: 80
        });
    const {color: l, indicator: i, label: c} = ( () => {
        const a = {
            color: o.palette.error.main,
            indicator: v.jsx(Wy, {
                color: "inherit",
                size: r
            }),
            label: s ? "Fail" : "Failed"
        }
          , l = {
            color: o.palette.error.main,
            indicator: v.jsx(Wy, {
                color: "inherit",
                size: r
            }),
            label: s ? "Revd." : "Reverted"
        }
          , i = {
            color: o.palette.success.main,
            indicator: v.jsx(vy, {
                color: "inherit",
                size: r
            }),
            label: s ? "Filled" : "Success"
        }
          , c = {
            color: o.palette.warning.main,
            indicator: v.jsx(J, {
                size: 12,
                color: "inherit"
            }),
            label: s ? "Exec" : "Executing"
        };
        if (n && qB.includes(n))
            return n === HC.REVERTED ? l : a;
        if (n === HC.DONE)
            return i;
        switch (t) {
        case sc.EXECUTING:
            return c;
        case sc.EXECUTION_FAILED:
            return a;
        case sc.FILLED:
            return i;
        case sc.WAITING:
            return {
                color: o.palette.warning.main,
                indicator: e === rc.MARKET ? v.jsx(J, {
                    size: 12,
                    color: "inherit"
                }) : v.jsx(Sk, {
                    color: "inherit",
                    size: r
                }),
                label: e === rc.MARKET ? "Executing" : "Open"
            };
        case sc.CANCELED:
            return {
                color: o.palette.text.meta,
                indicator: null,
                label: "Canceled"
            };
        default:
            return c
        }
    }
    )();
    return v.jsxs(S, {
        direction: "row",
        gap: t === sc.EXECUTING ? 1 : .5,
        color: l,
        alignItems: "center",
        children: [v.jsx(S, {
            alignItems: "center",
            minHeight: r,
            children: i
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            lineHeight: 1,
            ...a,
            children: c
        })]
    })
}
  , qB = [HC.FAILED, HC.REVERTED, HC.TIMED_OUT]
  , KB = 12
  , YB = e => null != e
  , XB = (e, {bucketSize: t=100, debounceTime: n=1e3, alreadyExists: r=et(!1), getItemKey: a=tt}) => {
    const s = new Map
      , o = new Map
      , l = M(( () => {
        e(s, o),
        s.clear(),
        o.clear()
    }
    ), n);
    return e => {
        e && !s.get(a(e)) && (r(e) ? o.set(a(e), e) : (s.set(a(e), e),
        l(),
        s.size >= t && l.flush()))
    }
}
  , QB = "padreV2-cachedBasicTokenInfosStorageKey"
  , ZB = e => `${e.chain}-${e.tokenAddress}`
  , JB = e => {
    const t = e.keys().next().value;
    e.delete(t)
}
  , e_ = 100
  , t_ = y.createContext({
    basicTokenInfos: new Map,
    enqueueRequest: c.noop
})
  , n_ = ({children: e}) => {
    var t;
    const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null;
    y.useEffect(( () => {
        null !== localStorage.getItem(QB) && localStorage.removeItem(QB)
    }
    ), []);
    const {getItems: r, putItems: a} = ( (e, t=hx) => {
        const [n,r] = dx(e, {})
          , a = y.useCallback(( (e, n) => {
            r((r => {
                const a = {
                    ...r,
                    [n]: {
                        item: e,
                        cacheTimestamp: i().unix()
                    }
                };
                return px(a, t)
            }
            ))
        }
        ), [r, t])
          , s = y.useCallback((e => {
            var t;
            return (null == (t = n[e]) ? void 0 : t.item) || null
        }
        ), [n])
          , o = y.useCallback((e => {
            const n = i().unix();
            r((r => {
                const a = c.reduce(e, ( (e, {item: t, key: r}) => (e[r] = {
                    item: t,
                    cacheTimestamp: n
                },
                e)), {
                    ...r
                });
                return px(a, t)
            }
            ))
        }
        ), [t, r])
          , l = y.useCallback((e => c.reduce(e, ( (e, t) => {
            const r = n[t];
            return r && (e[t] = r.item),
            e
        }
        ), {})), [n]);
        return y.useMemo(( () => ({
            putItem: a,
            getItem: s,
            putItems: o,
            getItems: l
        })), [a, s, o, l])
    }
    )("padreV2-cachedBasicTokenInfosStorageKeyV2", 500)
      , [s,l] = y.useState(new Map)
      , d = y.useRef(s);
    d.current = s;
    const u = y.useCallback(( (e, t) => {
        if (!n)
            return;
        const s = Array.from(e.values());
        l((n => (t.forEach((e => {
            const t = ZB(e)
              , r = n.get(t);
            void 0 !== r && (n.delete(t),
            n.set(t, r))
        }
        )),
        e.forEach((e => {
            const t = ZB(e);
            void 0 === n.get(t) && (n.set(t, null),
            n.size > 1e4 && JB(n))
        }
        )),
        new Map(n))));
        const i = r(s.map((e => ZB(e))));
        (async e => {
            if (!e.length)
                return [];
            try {
                const t = c.chunk(e, e_).map((e => im.batchGetBasicTokenInfo({
                    tokens: e
                })))
                  , n = await Promise.all(t)
                  , r = c.reduce(n, ( (e, t) => (e.push(...t.infos),
                e)), []);
                return c.reduce(r, ( (e, t) => (e.push([ZB(t), t]),
                e)), [])
            } catch (fNe) {
                return []
            }
        }
        )(c.reduce(s, ( (e, t) => (i[ZB(t)] || e.push(t),
        e)), [])).then((e => {
            e.length && a(e.map(( ([e,t]) => ({
                item: t,
                key: e
            }))));
            const t = new Map([...Object.entries(i), ...e]);
            l((e => (t.forEach(( (t, n) => {
                e.set(n, t),
                e.size > 1e4 && JB(e)
            }
            )),
            new Map(e))))
        }
        )).catch((e => {
            o(e)
        }
        ))
    }
    ), [r, a, n])
      , p = y.useMemo(( () => {
        const e = XB(u, {
            alreadyExists: e => void 0 !== d.current.get(ZB(e)),
            getItemKey: ZB,
            debounceTime: 250,
            bucketSize: 500
        });
        return t => {
            t.forEach(e)
        }
    }
    ), [u])
      , h = y.useMemo(( () => ({
        basicTokenInfos: s,
        enqueueRequest: p
    })), [s, p]);
    return v.jsx(t_.Provider, {
        value: h,
        children: e
    })
}
  , r_ = e => {
    const {basicTokenInfos: t, enqueueRequest: n} = y.useContext(t_);
    return y.useEffect(( () => {
        e && e.length && n(e)
    }
    ), [n, e]),
    y.useMemo(( () => e && e.length ? e.filter((e => t.has(ZB(e)))).map((e => t.get(ZB(e)))).filter(YB) : null), [e, t])
}
  , a_ = y.createContext({
    cancellingOrderListIds: [],
    registerCancel: c.noop
});
a_.displayName = "OrderListCancelContext";
const s_ = ({children: e}) => {
    const [t,n] = y.useState([])
      , r = y.useCallback((e => {
        n((t => t.length > o_ ? [e, ...t].slice(0, o_) : [e, ...t]))
    }
    ), [])
      , a = y.useMemo(( () => ({
        cancellingOrderListIds: t,
        registerCancel: r
    })), [t, r]);
    return v.jsx(a_.Provider, {
        value: a,
        children: e
    })
}
  , o_ = 10
  , l_ = () => y.useContext(a_)
  , i_ = (e, t) => {
    if (!e || !t)
        return null;
    const n = ng(t)
      , r = e.find((e => ng(e.publicAddress) === n)) || null;
    return (null == r ? void 0 : r.walletName) || null
}
;
var c_ = (e => (e.NORMAL = "NORMAL",
e.SMALL = "SMALL",
e.MINI = "MINI",
e))(c_ || {});
const d_ = (e, t) => {
    switch (e) {
    case Pd.ETH_MAINNET:
        return u_;
    case Pd.BASE:
        return p_;
    case Pd.BSC:
        return h_;
    case Pd.SOLANA:
        return m_;
    default:
        return t || "transparent"
    }
}
  , u_ = "#627EEA"
  , p_ = "#0052FF"
  , h_ = "#F0B90B"
  , m_ = "#9945FF"
  , g_ = y.memo(( ({src: e, size: t=x_}) => {
    const [n,r] = y.useState(!1);
    y.useEffect(( () => {
        r(!1)
    }
    ), [e]);
    const a = y.useMemo(( () => e => ({
        width: t,
        height: t,
        outline: `2px solid ${e.palette.background.borderMain}`,
        borderRadius: "4px",
        bgcolor: e.palette.background.default,
        opacity: 1,
        transition: "opacity 0.3s ease-in-out"
    })), [t])
      , s = y.useMemo(( () => ({
        img: {
            onError: () => {
                r(!0)
            }
        }
    })), []);
    return !e || n ? "" : v.jsx(Te, {
        src: e ?? "",
        alt: "avatar",
        sx: a,
        slotProps: s
    })
}
))
  , x_ = 256
  , b_ = y.memo(( ({url: e, name: t, chain: n, padreAvatarUrl: r, imageData: a, protocolInfo: s, protocolMarkerSize: o=S_, protocolMarkerOffset: l=y_, protocolMarkerInnerIconSize: i, size: c=f_, markerIcon: d, markerSize: u=v_, thickBorder: p=!1, hideBorder: h=!1, useLaunchpadBorderColor: m=!1, markerTooltip: g, markerOverrides: x={}, showLens: b=!1, miniLens: f=!1, borderRadius: S="4px", alwaysShowBorder: k=!1, alwaysShowPointer: A=!1, actionButtonSize: w=c_.NORMAL, onHideClick: j, isHidden: T=!1, onBlacklistClick: I, isBlacklisted: E=!1, onHandleBlacklistClick: M, isHandleBlacklisted: N=!1, hideHoverAvatar: P=!1, cornerButtons: O=!1}) => {
    const L = D()
      , {t: R} = we()
      , [B,_] = y.useState(!1)
      , [U,W] = y.useState(!1)
      , F = y.useCallback(( () => {
        _(!0),
        W(!0)
    }
    ), [])
      , H = y.useCallback(( () => {
        _(!0),
        W(!1)
    }
    ), [])
      , {settings: z} = rf()
      , $ = b && !!r
      , G = y.useMemo(( () => d ? v.jsx(GC, {
        title: g ?? "",
        children: v.jsx(C, {
            zIndex: 2,
            position: "absolute",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            bgcolor: L.palette.background.secondary,
            top: -2,
            left: c / 2 + 2,
            borderRadius: "50%",
            height: u + 2,
            width: u + 2,
            ...x,
            children: v.jsx(C, {
                display: "flex",
                children: d
            })
        })
    }) : null), [d, x, u, g, c, L.palette.background.secondary])
      , [q] = y.useMemo(( () => RM((null == s ? void 0 : s.isMigrated) ?? !1, (null == s ? void 0 : s.launchpadAux) ?? (null == s ? void 0 : s.launchpad) ?? null, (null == s ? void 0 : s.protocolType) ?? null, L)), [s, L])
      , K = y.useMemo(( () => e => ({
        position: "absolute",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: -l,
        bottom: -l,
        width: o,
        height: o,
        border: `1px solid ${q}`,
        borderRadius: "50%",
        background: e.palette.background.default
    })), [l, o, q])
      , Y = y.useMemo(( () => {
        const {Icon: e} = s || {};
        return s && e ? v.jsx(GC, {
            title: s.name,
            placement: "bottom",
            children: v.jsx(C, {
                sx: K,
                children: v.jsx(C, {
                    sx: F_,
                    children: v.jsx(e, {
                        size: i ?? o - 4
                    })
                })
            })
        }) : null
    }
    ), [s, K, i, o])
      , X = y.useMemo(( () => `_${r ?? "default"}`), [r])
      , Q = y.useCallback((e => {
        if (!$)
            return;
        e.stopPropagation(),
        e.preventDefault();
        const t = `https://lens.google.com/uploadbyurl?url=${r}`;
        window.open(t, "_blank", "noopener,noreferrer")
    }
    ), [$, r])
      , Z = y.useMemo(( () => ({
        "&:hover": {
            cursor: A || $ ? "pointer" : "auto",
            ...$ ? {
                [`.${w_}`]: {
                    opacity: A_
                },
                [`.${j_}`]: {
                    display: "flex"
                }
            } : {},
            ...j ? {
                [`.${T_}`]: {
                    display: "flex"
                }
            } : {}
        }
    })), [A, $, j])
      , J = y.useMemo(( () => ({
        width: c,
        height: c,
        ...B ? {} : {
            opacity: 0
        },
        outline: h ? "none" : n && (!U || k) ? `${p ? 2 : 1}px solid ${m ? q : d_(n)}` : "none",
        borderRadius: S,
        bgcolor: n && !U ? `${d_(n)}44` : void 0,
        color: n ? d_(n) : void 0,
        fontSize: Math.max(C_, c - k_)
    })), [m, q, k, S, n, h, U, B, c, p])
      , ee = y.useMemo(( () => ({
        img: {
            onLoad: F,
            onError: H
        }
    })), [H, F])
      , te = y.useMemo(( () => !P && !!(r || e || a) && (!(!!e && !a && !r) || U) ? v.jsx(g_, {
        src: a ?? r ?? e ?? null,
        size: V_((null == z ? void 0 : z.tokenAvatarPreviewSize) ?? Yh.SMALL)
    }) : ""), [P, r, e, a, U, null == z ? void 0 : z.tokenAvatarPreviewSize])
      , ne = y.useMemo(( () => ({
        sx: e => ({
            zIndex: e.zIndex.tooltip + 1
        })
    })), [])
      , re = y.useMemo(( () => __(1, w, O)), [O, w])
      , ae = y.useMemo(( () => __(2, w, O)), [O, w])
      , se = y.useMemo(( () => __(O || I ? 3 : 2, w, O)), [O, I, w]);
    return v.jsxs(C, {
        display: "flex",
        position: "relative",
        children: [v.jsxs(C, {
            position: "relative",
            sx: Z,
            onClick: $ ? Q : void 0,
            children: [G, $ && v.jsx(C, {
                zIndex: 1,
                position: "absolute",
                display: "flex",
                alignItems: "center",
                className: j_,
                sx: I_,
                children: v.jsx(nt, {
                    color: "primary",
                    style: f ? M_ : E_
                })
            }), j && v.jsx(C, {
                zIndex: 4,
                position: "absolute",
                display: "flex",
                alignItems: "center",
                className: T_,
                sx: re,
                children: v.jsx(GC, {
                    title: R(T ? "Show token" : "Hide token"),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            onClick: j,
                            variant: "tertiary",
                            size: "xxsmall",
                            sx: w === c_.NORMAL ? U_ : W_,
                            children: T ? v.jsx(Ek, {
                                color: L.palette.error.main,
                                size: P_[w]
                            }) : v.jsx(Tk, {
                                size: P_[w]
                            })
                        })
                    })
                })
            }), I && v.jsx(C, {
                zIndex: 4,
                position: "absolute",
                display: "flex",
                alignItems: "center",
                className: T_,
                sx: ae,
                children: v.jsx(GC, {
                    title: E ? "Remove dev from blacklist" : "Blacklist dev",
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            onClick: I,
                            variant: "tertiary",
                            size: "xxsmall",
                            sx: w === c_.NORMAL ? U_ : W_,
                            children: v.jsx(Vv, {
                                size: N_[w],
                                color: E ? L.palette.error.main : void 0
                            })
                        })
                    })
                })
            }), M && v.jsx(C, {
                zIndex: 4,
                position: "absolute",
                display: "flex",
                alignItems: "center",
                className: T_,
                sx: se,
                children: v.jsx(GC, {
                    title: N ? "Remove handle from blacklist" : "Blacklist handle",
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            onClick: M,
                            variant: "tertiary",
                            size: "xxsmall",
                            sx: w === c_.NORMAL ? U_ : W_,
                            children: v.jsx(AC, {
                                size: N_[w],
                                color: N ? L.palette.error.main : void 0
                            })
                        })
                    })
                })
            }), v.jsx(GC, {
                maxWidth: 300,
                title: te,
                noTooltipBackground: !0,
                PopperProps: ne,
                noEnterDelay: !1,
                children: v.jsx(Te, {
                    className: w_,
                    src: a || r || e,
                    alt: t,
                    sx: J,
                    slotProps: ee
                }, X)
            })]
        }), Y]
    })
}
))
  , f_ = 24
  , v_ = 10
  , S_ = 13
  , y_ = 4
  , k_ = 10
  , C_ = 10
  , A_ = .35
  , w_ = "lens-opacity-token-avatar"
  , j_ = "lens-icon-token-avatar"
  , T_ = "hide-buttons-token-avatar"
  , I_ = {
    pointerEvents: "none",
    display: "none",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
}
  , E_ = {
    width: 28,
    height: 28
}
  , M_ = {
    width: 16,
    height: 16
}
  , N_ = {
    [c_.NORMAL]: 14,
    [c_.SMALL]: 12,
    [c_.MINI]: 12
}
  , P_ = {
    [c_.NORMAL]: 16,
    [c_.SMALL]: 14,
    [c_.MINI]: 14
}
  , O_ = {
    display: "none",
    width: 22,
    height: 22
}
  , L_ = {
    display: "none",
    width: 20,
    height: 20
}
  , R_ = {
    display: "none",
    width: 16,
    height: 16
}
  , D_ = {
    [c_.NORMAL]: O_,
    [c_.SMALL]: L_,
    [c_.MINI]: R_
}
  , B_ = -5
  , __ = (e, t, n) => {
    const r = D_[t];
    if (!n) {
        const n = t === c_.SMALL ? 0 : -4;
        switch (e) {
        case 1:
            return {
                ...r,
                top: -4,
                left: n
            };
        case 2:
            return {
                ...r,
                top: t === c_.SMALL ? 14 : 18,
                left: n
            };
        case 3:
            return {
                ...r,
                top: t === c_.SMALL ? 32 : 40,
                left: n
            }
        }
    }
    switch (e) {
    case 1:
        return {
            ...r,
            top: B_,
            left: B_
        };
    case 2:
        return {
            ...r,
            bottom: B_,
            left: B_
        };
    case 3:
        return {
            ...r,
            top: B_,
            right: B_
        }
    }
}
  , U_ = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    p: 0,
    minWidth: 0,
    width: 22,
    height: 22,
    borderRadius: "50%"
}
  , W_ = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    p: 0,
    minWidth: 0,
    width: 20,
    height: 20,
    borderRadius: "50%"
}
  , F_ = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
}
  , V_ = e => {
    switch (e) {
    case Yh.SMALL:
        return 256;
    case Yh.BIG:
        return 400
    }
}
  , H_ = ({tradeSide: e, isShort: t=!1, ...n}) => v.jsx(k, {
    width: "100%",
    variant: "paragraph2",
    alignSelf: "center",
    color: e === xc.BUY ? "positive.main" : "negative.main",
    ...n,
    children: t ? e[0] : Jd(e)
})
  , z_ = y.memo(( ({name: e}) => v.jsx(GC, {
    title: `Inferno mode sets optimal ${e} per builder`,
    children: v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        sx: {
            "&:hover": {
                cursor: "help"
            }
        },
        children: [v.jsx(Cf, {
            size: 14
        }), v.jsx(k, {
            variant: "inherit",
            color: "primary.main",
            children: "Inferno"
        })]
    })
})))
  , $_ = (e=0, t=!0) => ({
    transition: `${e}ms ease-in-out`,
    "&:hover": {
        color: "text.main",
        ...t ? {
            cursor: "help"
        } : {}
    }
})
  , G_ = ({name: e, value: t, nameTooltipTitle: n, preventNameTranslation: r}) => v.jsxs(S, {
    direction: "row",
    justifyContent: "space-between",
    alignItems: "center",
    sx: e => ({
        py: 1,
        px: 1.5,
        height: K_,
        width: "100%",
        borderBottom: `1px solid ${e.palette.background.borderMain}`,
        ":last-of-type": {
            border: "none"
        }
    }),
    children: [v.jsx(z, {
        title: n ?? "",
        children: v.jsx(C, {
            component: "span",
            alignSelf: "center",
            display: "flex",
            children: v.jsx(k, {
                lineHeight: 1,
                variant: "paragraph1",
                color: "text.label",
                sx: n ? {
                    ...$_()
                } : {},
                ...r ? Nu : {},
                children: e
            })
        })
    }), t ? v.jsx(k, {
        lineHeight: 1,
        variant: "paragraph1",
        color: "text.value",
        ...Nu,
        children: t
    }) : v.jsx(Ie, {
        variant: "text",
        width: q_,
        height: Y_
    })]
})
  , q_ = 80
  , K_ = 32
  , Y_ = 18
  , X_ = B(C)(( ({theme: e}) => ({
    backgroundColor: e.palette.background.default,
    borderRadius: "4px",
    border: `1px solid ${e.palette.background.borderMain}`
})))
  , Q_ = y.memo(( ({status: e, baseSymbol: t}) => {
    const n = D()
      , {message: r, title: a, moreInfoUrl: s} = y.useMemo(( () => _G(e, t ?? "")), [e, t]);
    return v.jsx(rt, {
        in: !!r,
        sx: {
            minHeight: Z_,
            width: "100%"
        },
        children: v.jsxs(S, {
            width: "100%",
            gap: 2,
            p: 2,
            borderRadius: 1,
            bgcolor: n.palette.background.tertiary,
            children: [a && v.jsxs(S, {
                direction: "row",
                gap: 1,
                children: [v.jsx(Ck, {
                    size: 20,
                    color: n.palette.error[500]
                }), v.jsx(k, {
                    variant: "h6",
                    children: a
                })]
            }), v.jsx(k, {
                variant: "bodyLarge",
                children: r
            }), s && v.jsx(V, {
                variant: "tertiary",
                children: "Learn more"
            })]
        })
    })
}
))
  , Z_ = 24;
function J_(e) {
    return "SOLBEAST" === e.type
}
var eU = (e => (e.USD = "usd",
e.QUOTE = "quote",
e))(eU || {});
const tU = y.memo(( ({children: e, link: t, hideBackground: n=!1, noPadding: r=!1}) => {
    const a = y.useMemo(( () => e => ({
        bgcolor: n ? "transparent" : e.palette.background.tertiary,
        "&:hover": {
            bgcolor: e.palette.background.active
        }
    })), [n]);
    return t ? v.jsx("a", {
        target: "_blank",
        rel: "noopener noreferrer",
        href: t,
        referrerPolicy: "no-referrer",
        children: v.jsx(C, {
            display: "flex",
            borderRadius: "50%",
            p: r ? 0 : .5,
            sx: a,
            children: e
        })
    }) : null
}
))
  , nU = e => {
    if (!e)
        return null;
    const {status: t, failedExecutionAttempts: n} = e.data;
    if (e.data.status === sc.WAITING)
        return {
            orderStatus: t,
            failedExecutionAttempts: n,
            details: e.data.details
        };
    if ((e => e.status === sc.EXECUTING)(e.data)) {
        const r = e.data.granularState.txnHash || null;
        return {
            orderStatus: t,
            failedExecutionAttempts: n,
            txnState: e.data.granularState,
            txnHash: r
        }
    }
    return (e => e.status === sc.EXECUTION_FAILED)(e.data) ? {
        orderStatus: t,
        failedExecutionAttempts: n,
        txnState: e.data.txnState,
        txnHash: e.data.txnState.status !== HC.FAILED ? e.data.txnState.txnHash : null,
        fillDetails: null,
        errorExplanation: e.data.txnState.status === HC.FAILED ? e.data.txnState.explanation : void 0
    } : (e => e.status === sc.FILLED)(e.data) ? {
        orderStatus: t,
        failedExecutionAttempts: n,
        txnHash: e.data.txnHash,
        fillDetails: e.data.fillDetails
    } : {
        orderStatus: t,
        failedExecutionAttempts: n
    }
}
  , rU = (e, t, n, r, a) => {
    const s = y.useMemo(( () => {
        if (!r)
            return null;
        const {gasSettings: e} = r.def.executionOptions;
        if (!e)
            return Ud;
        switch (e.type) {
        case "AUTO":
            return "Auto";
        case "SLOW":
            return "Auto (slow)";
        case "MANUAL":
            return `prio ${e.maxPriorityFeePerGasInGwei} gwei ${hM} fee ${e.maxFeePerGasInGwei} gwei`;
        case "EVM":
        case "EVM_WITH_TIP":
            return `${e.prioInGweiUi} gwei`;
        case "SOLANA":
            return `${e.prioInSolUi} SOL`;
        case "SOLBEAST":
            return v.jsx(z_, {
                name: "prio"
            });
        default:
            return Ud
        }
    }
    ), [r])
      , o = y.useMemo(( () => {
        if (!r)
            return null;
        const {gasSettings: e} = r.def.executionOptions;
        return e ? J_(e) ? v.jsx(z_, {
            name: "tip"
        }) : "SOLANA" === e.type ? `${e.tipInSolUi} SOL` : "EVM_WITH_TIP" === e.type && e.tipInNativeUi ? `${e.tipInNativeUi} BNB` : null : null
    }
    ), [r])
      , l = y.useMemo(( () => {
        if (!r)
            return null;
        const {gasSettings: e} = r.def.executionOptions;
        if (e && J_(e))
            return v.jsx(z_, {
                name: "slippage"
            });
        const {slippage: t} = r.def.tradeParams;
        return t ? "AUTO" === t.type ? "Auto" : jI(t.valueBps / 100, {
            omitSign: !0
        }) : Ud
    }
    ), [r])
      , i = y.useMemo(( () => {
        if (!r)
            return null;
        const {quantity: e} = r.def.tradeParams
          , a = "base" === e.unit ? t : n;
        if (!a)
            return null;
        return `${( (e, t, n) => {
            if (fc(e)) {
                const r = Number(new sB({
                    decimals: n
                },BigInt(e ?? "0")).toExact());
                return `${OI(r, {
                    symbol: "",
                    precision: _I(r, t)
                })}`
            }
            return jI(Number(e.pctValue ?? "0"), {
                omitSign: !0
            })
        }
        )(e.value, a.symbol, a.decimals)} ${a.symbol}`
    }
    ), [r, t, n])
      , [c,d] = y.useMemo(( () => {
        if (!r)
            return [null, null];
        if (r.def.type === rc.STOP) {
            const {price: e} = r.def.priceCondition
              , a = e.type === eU.USD ? t : n;
            if (!a)
                return [null, null];
            const s = r.def.tradeParams.quantity.value
              , o = fc(s) ? Number(new sB({
                decimals: a.decimals
            },BigInt(s ?? "0")).toExact()) : Number(s.pctValue ?? "0")
              , l = e.type === eU.USD ? Number(e.value ?? "0") : Number(new sB({
                decimals: a.decimals
            },BigInt(e.value ?? "0")).toExact())
              , i = fc(s) ? o * l : o;
            return e.type === eU.USD ? [LI(l, {
                symbol: "$",
                padSymbol: !1,
                collapseExponent: !0
            }), fc(s) ? OI(i) : jI(i, {
                omitSign: !0
            })] : n ? [`${OI(l, {
                collapseExponent: !0,
                symbol: n.symbol
            })}`, fc(s) ? OI(i, {
                collapseExponent: !0,
                symbol: n.symbol
            }) : jI(i, {
                omitSign: !0
            })] : [null, null]
        }
        if (!e)
            return [null, null];
        const a = e.fillDetails;
        if (void 0 === a)
            return [null, null];
        if (!a)
            return [Ud, Ud];
        if (!t)
            return [null, null];
        const s = Number(new sB({
            decimals: t.decimals
        },BigInt(a.quoteAmount ?? "0")).toExact()) * Number(a.executionPriceInUsd);
        return [a ? OI(Number(a.executionPriceInUsd)) : Ud, OI(s)]
    }
    ), [r, e, t, n])
      , u = y.useMemo(( () => {
        if (!e)
            return null;
        if (!r)
            return null;
        if (void 0 === e.txnHash)
            return null;
        const {chain: t} = r.def;
        return [sc.WAITING, sc.EXECUTING].includes(e.orderStatus) ? null : e.txnHash ? v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            mr: -.5,
            children: [oA(e.txnHash), v.jsx(tU, {
                link: AA(e.txnHash, t),
                hideBackground: !0,
                children: v.jsx(tE, {
                    chain: t
                })
            })]
        }) : Ud
    }
    ), [e, r])
      , p = y.useMemo(( () => {
        if (!e)
            return null;
        const t = e.fillDetails;
        if (void 0 === t)
            return null;
        if (!t)
            return Ud;
        const n = Number(t.txnFeeInUsd);
        return OI(Math.max(0, n))
    }
    ), [e])
      , h = y.useMemo(( () => (null == r ? void 0 : r.def.type) === rc.STOP ? `$${EI(Number(r.def.priceCondition.price.value))}` : Ud), [r])
      , m = y.useMemo(( () => t && n ? `${iu(t.symbol)}/${iu(n.symbol)}` : null), [t, n])
      , g = y.useMemo(( () => {
        if (!t || !a)
            return null;
        const {decimals: e, symbol: n} = t
          , r = Number(new sB({
            decimals: e
        },BigInt(a.baseAmount ?? "0")).toExact());
        return n ? `${OI(r, {
            symbol: "",
            precision: _I(r, t.symbol)
        })} ${iu(n)}` : null
    }
    ), [t, a])
      , x = y.useMemo(( () => {
        if (!n || !a)
            return null;
        const {decimals: e, symbol: t} = n
          , r = Number(new sB({
            decimals: e
        },BigInt(a.quoteAmount ?? "0")).toExact());
        return t ? `${OI(r, {
            symbol: "",
            precision: _I(r, n.symbol)
        })} ${iu(t)}` : null
    }
    ), [n, a])
      , [b,f] = y.useMemo(( () => r ? r.def.tradeParams.side === xc.BUY ? [x, g] : [g, x] : [null, null]), [g, r, x]);
    return {
        gasLabel: s,
        slippageLabel: l,
        amountLabel: i,
        priceLabel: c,
        totalLabel: d,
        hashLabel: u,
        feeLabel: p,
        fillPriceLabel: h,
        pairLabel: m,
        spentLabel: b,
        receivedLabel: f,
        tipLabel: o
    }
}
  , aU = ({orderId: e, orderListId: t, expectedData: n, closeModal: r}) => {
    var a, s, o, l, c, d;
    const {t: u} = we()
      , p = D()
      , h = pK()
      , m = UD((e => e.wallets))
      , g = (e => {
        var t;
        const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
          , r = y.useCallback((t => n ? sm.subscribeOrder(e, t) : {
            unsubscribe: () => {}
        }), [e, n]);
        return yx(r)
    }
    )(e)
      , x = y.useMemo(( () => g ? lU(g.currentState) : null), [g])
      , b = y.useMemo(( () => x ? mg(x.originMarketId) : null), [x])
      , f = y.useMemo(( () => x ? `$${EI(Number(x.priceInQuote * x.quotePriceInUsd))}` : null), [x])
      , A = y.useMemo(( () => g ? {
        chain: g.def.chain,
        tokenAddress: g.def.tradeParams.pair.baseCurrency
    } : null), [g])
      , w = yT()
      , j = pT()
      , T = y.useCallback(( () => {
        g && (w({
            chain: g.def.chain,
            tokenAddress: g.def.tradeParams.pair.baseCurrency,
            tradePageOrigin: nT.ORDER_SUMMARY
        }),
        r && r())
    }
    ), [w, g, r])
      , I = y.useCallback(( () => {
        x && (j({
            marketId: x.originMarketId,
            tradePageOrigin: nT.ORDER_SUMMARY
        }),
        r && r())
    }
    ), [x, j, r])
      , E = y.useCallback(( () => {
        x && xT(x.originMarketId)
    }
    ), [x])
      , M = y.useMemo(( () => i_(m || null, (null == g ? void 0 : g.def.walletAddress) || null)), [m, g])
      , [N,P,O] = y.useMemo(( () => [(null == g ? void 0 : g.def.type) ?? n.orderType, (null == g ? void 0 : g.def.tradeParams.side) ?? n.tradeSide, null == g ? void 0 : g.currentState.data.failedExecutionAttempts]), [n, g])
      , L = y.useMemo(( () => {
        if (!(null == O ? void 0 : O.length))
            return Ud;
        const e = O.sort(( (e, t) => t.attemptedAt - e.attemptedAt))[0].attemptedAt;
        return i.unix(e).format("HH:mm:ss DD MMM YYYY")
    }
    ), [O])
      , R = y.useMemo(( () => g && g ? nU(g.currentState) : null), [g])
      , B = y.useMemo(( () => g && g.currentState.data.status === sc.FILLED ? g.currentState.data.fillDetails : null), [g])
      , _ = l_()
      , U = y.useMemo(( () => {
        if (!g)
            return null;
        const {chain: e} = g.def;
        return [{
            chain: e,
            tokenAddress: g.def.tradeParams.pair.baseCurrency
        }, {
            chain: e,
            tokenAddress: g.def.tradeParams.pair.quoteCurrency
        }]
    }
    ), [g])
      , W = r_(U)
      , [F,H] = y.useMemo(( () => {
        if (!g || !W)
            return [null, null];
        const {chain: e} = g.def;
        return [W.find((t => t.chain === e && t.tokenAddress === g.def.tradeParams.pair.baseCurrency)) || null, W.find((t => t.chain === e && t.tokenAddress === g.def.tradeParams.pair.quoteCurrency)) || null]
    }
    ), [g, W])
      , {gasLabel: $, slippageLabel: G, amountLabel: q, hashLabel: K, feeLabel: Y, fillPriceLabel: X, pairLabel: Q, spentLabel: Z, receivedLabel: ee, tipLabel: te} = rU(R, F, H, g, B)
      , ne = (null == g ? void 0 : g.def.type) === rc.TRAILING_STOP ? g.def.trailingDelta.pctValue : null
      , re = Q
      , [ae,se] = y.useState(!1);
    y.useEffect(( () => {
        ae && (null == R ? void 0 : R.orderStatus) === sc.CANCELED && se(!1)
    }
    ), [ae, R]);
    const oe = y.useCallback((async () => {
        if (!t || !_.cancellingOrderListIds.includes(t)) {
            try {
                se(!0),
                t && _.registerCancel(t);
                if ((await sm.cancelOrder(e)).success)
                    return void h({
                        message: pu.orderCancel,
                        type: "success"
                    }, "order-cancel-success")
            } catch (fNe) {}
            h({
                message: uu.orderFailedToCancel,
                snackName: pu.cancelFailed,
                type: "error"
            }, "order-cancel-error"),
            se(!1)
        }
    }
    ), [t, _, h, e])
      , le = (null == (a = null == R ? void 0 : R.txnState) ? void 0 : a.status) === HC.FAILED || (null == (s = null == R ? void 0 : R.txnState) ? void 0 : s.status) === HC.REVERTED || (null == (o = null == R ? void 0 : R.txnState) ? void 0 : o.status) === HC.TIMED_OUT || (null == R ? void 0 : R.orderStatus) === sc.EXECUTION_FAILED || void 0 !== (null == R ? void 0 : R.errorExplanation)
      , ie = (null == (l = null == R ? void 0 : R.txnState) ? void 0 : l.status) === HC.REVERTED
      , ce = ie || (null == R ? void 0 : R.orderStatus) !== sc.EXECUTION_FAILED && [rc.MARKET].includes(N) || !!R && [sc.EXECUTING, sc.FILLED].includes(null == R ? void 0 : R.orderStatus)
      , de = ce && !ie
      , ue = y.useMemo(( () => {
        const e = g && g.def.type === rc.STOP ? g.def.priceCondition.direction : null
          , t = Cc(N, P, e);
        return t ? dc[t] : null
    }
    ), [N, P, g]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(S, {
            gap: 1.5,
            pb: 1.5,
            width: "100%",
            children: [v.jsx(k, {
                ...cU,
                children: u("Order details")
            }), v.jsxs(X_, {
                children: [v.jsx(G_, {
                    name: u("Date"),
                    value: (null == g ? void 0 : g.def.creationTime) ? v.jsx(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: i.unix(g.def.creationTime).format("HH:mm:ss DD MMM YYYY")
                    }) : null
                }), v.jsx(G_, {
                    name: u("Pair"),
                    value: v.jsx(iU, {
                        tokenAddress: (null == A ? void 0 : A.tokenAddress) || null,
                        onClick: T,
                        label: Q,
                        chain: (null == g ? void 0 : g.def.chain) || null,
                        protocolInfo: null
                    })
                }), v.jsx(G_, {
                    name: u("Side"),
                    value: v.jsx(S, {
                        alignItems: "center",
                        children: v.jsx(H_, {
                            tradeSide: P,
                            variant: "paragraph1",
                            textAlign: "end"
                        })
                    })
                }), v.jsx(G_, {
                    name: u("Type"),
                    value: v.jsx(S, {
                        alignItems: "center",
                        children: ue ? v.jsx(k, {
                            variant: "paragraph1",
                            color: "inherit",
                            noWrap: !0,
                            textAlign: "end",
                            children: ue
                        }) : v.jsx(Ie, {
                            variant: "rounded",
                            width: 30
                        })
                    })
                }), v.jsx(G_, {
                    name: P === xc.BUY ? u("Total") : u("Amount"),
                    value: q
                }), N === rc.TRAILING_STOP && v.jsx(G_, {
                    name: u("Trailing Delta"),
                    value: ne ? jI(Number(ne), {
                        omitSign: !0
                    }) : null
                }), N === rc.STOP && v.jsx(G_, {
                    name: u("Stop Price"),
                    value: X
                })]
            }), N === rc.STOP && v.jsxs(v.Fragment, {
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(k, {
                        ...cU,
                        children: u("Fill attempts")
                    }), v.jsx(z, {
                        title: u("Orders may remain unfilled even if the price condition is met, due to factors like slippage tolerance or high market volatility."),
                        children: v.jsx(C, {
                            display: "flex",
                            alignItems: "center",
                            sx: {
                                "&:hover": {
                                    cursor: "help"
                                }
                            },
                            children: v.jsx(QS, {
                                size: 14
                            })
                        })
                    })]
                }), v.jsxs(X_, {
                    children: [v.jsx(G_, {
                        name: u("Last attempt"),
                        value: L
                    }), v.jsx(G_, {
                        name: u("Total attempts"),
                        value: ((null == O ? void 0 : O.length) || 0).toString()
                    })]
                })]
            }), v.jsx(k, {
                ...cU,
                children: u("Execution parameters")
            }), v.jsxs(X_, {
                children: [v.jsx(G_, {
                    name: u("Wallet"),
                    value: g ? v.jsx(cA, {
                        address: null == g ? void 0 : g.def.walletAddress,
                        labelSx: {
                            color: p.palette.text.value,
                            maxWidth: 300
                        },
                        labelVariant: "paragraph1",
                        ...M ? {
                            customName: M
                        } : {}
                    }) : null
                }), v.jsx(G_, {
                    name: u("MEV Protection"),
                    value: g ? "SOLBEAST" === (null == (c = g.def.executionOptions.gasSettings) ? void 0 : c.type) ? v.jsx(z_, {
                        name: u("MEV Protection")
                    }) : g.def.executionOptions.useMevProtection ? u("Enabled") : u("Disabled") : null
                }), N === rc.STOP && v.jsx(G_, {
                    name: u("Expiry"),
                    value: g ? null === g.def.expiresAt ? u("never") : `${i.unix(g.def.expiresAt).format("HH:mm:ss DD MMM YYYY")}` : null
                }), v.jsx(G_, {
                    name: u("Slippage"),
                    value: G
                }), v.jsx(G_, {
                    name: u("Prio"),
                    value: $
                }), te && v.jsx(G_, {
                    name: u("Tip"),
                    value: te
                })]
            }), v.jsx(k, {
                ...cU,
                children: u("On-chain transaction")
            }), v.jsxs(X_, {
                children: [x && v.jsx(G_, {
                    name: u("Triggered"),
                    value: x.blockTimestamp ? v.jsx(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: `${i.unix(x.blockTimestamp).format("HH:mm:ss DD MMM YYYY")}`
                    }) : null
                }), x && f && v.jsx(G_, {
                    name: u("Triggering price"),
                    value: f
                }), x && b && re && v.jsx(G_, {
                    name: u("Triggered on market"),
                    value: v.jsx(iU, {
                        tokenAddress: null,
                        onClick: I,
                        onHover: E,
                        label: re,
                        chain: b.chain,
                        protocolInfo: null
                    })
                }), v.jsx(G_, {
                    name: u("Status"),
                    value: v.jsx(GB, {
                        type: N,
                        orderStatus: (null == R ? void 0 : R.orderStatus) || null,
                        txnStatus: null == (d = null == R ? void 0 : R.txnState) ? void 0 : d.status,
                        iconSize: 16,
                        labelTypographyOverrides: {
                            variant: "paragraph1"
                        }
                    })
                }), ce && v.jsx(G_, {
                    name: u("Hash"),
                    value: K,
                    preventNameTranslation: !0
                }), de && v.jsx(G_, {
                    name: "Transaction Fee",
                    value: Y ? v.jsxs(S, {
                        direction: "row",
                        gap: .5,
                        alignItems: "center",
                        children: [(null == g ? void 0 : g.def.chain) === Pd.SOLANA && ("$0.00" === Y || g.def.tradeParams.side === xc.SELL) && v.jsx(z, {
                            title: u("Includes SOL reclaimed from closing any associated token accounts."),
                            children: v.jsx(C, {
                                component: "span",
                                sx: {
                                    cursor: "help",
                                    mb: -.25
                                },
                                children: v.jsx(QS, {
                                    size: 16
                                })
                            })
                        }), Y]
                    }) : null,
                    nameTooltipTitle: u("Amount paid to process the transaction on-chain")
                })]
            }), B && v.jsxs(v.Fragment, {
                children: [v.jsx(k, {
                    ...cU,
                    children: u("Trade Summary")
                }), v.jsxs(X_, {
                    children: [v.jsx(G_, {
                        name: u("Execution Price"),
                        value: LI(Number(B.executionPriceInUsd), {
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    }), v.jsx(G_, {
                        name: u("Spent"),
                        value: Z
                    }), v.jsx(G_, {
                        name: u("Received"),
                        value: ee
                    }), v.jsx(G_, {
                        name: u("Trade Fee"),
                        value: OI(Number(B.tradeFeeInUsd ?? 0))
                    })]
                })]
            }), le && v.jsx(Ee, {
                flexItem: !0,
                sx: {
                    mb: 1.5
                }
            }), v.jsxs(S, {
                mt: -1.5,
                width: "100%",
                children: [v.jsx(Q_, {
                    status: R,
                    baseSymbol: F ? F.symbol : null
                }), v.jsx(rt, {
                    in: (null == R ? void 0 : R.orderStatus) === sc.WAITING && dU.includes(N),
                    sx: {
                        width: "100%"
                    },
                    children: v.jsx(S, {
                        direction: "row",
                        justifyContent: "flex-end",
                        mt: 1.5,
                        children: v.jsx(V, {
                            disabled: ae || !(!t || !_.cancellingOrderListIds.includes(t)),
                            size: "small",
                            variant: "primary",
                            onClick: oe,
                            sx: {
                                px: .5
                            },
                            startIcon: v.jsx(C, {
                                width: sU
                            }),
                            endIcon: v.jsx(C, {
                                width: sU,
                                children: v.jsx(rt, {
                                    orientation: "horizontal",
                                    unmountOnExit: !0,
                                    in: ae,
                                    sx: {
                                        minWidth: sU
                                    },
                                    children: v.jsx(J, {
                                        size: sU
                                    })
                                })
                            }),
                            children: u("Cancel order")
                        })
                    })
                })]
            })]
        })
    })
}
  , sU = 16
  , oU = {
    gap: .5,
    p: .5,
    height: 20,
    my: -.25,
    mr: -.5,
    border: "none",
    backgroundColor: "transparent",
    "&:hover": {
        backgroundColor: "grey.800"
    }
}
  , lU = e => {
    const {data: t} = e;
    return t.status === sc.WAITING || t.status === sc.CANCELED ? null : t.triggeringEventDetails ?? null
}
  , iU = ({tokenAddress: e, onClick: t, onHover: n, label: r, chain: a, protocolInfo: s}) => v.jsxs(V, {
    onClick: t,
    onMouseEnter: n,
    variant: "tertiary",
    sx: oU,
    disableRipple: !1,
    children: [a && e && v.jsx(b_, {
        url: IE(a, e),
        name: r || "?",
        chain: a,
        padreAvatarUrl: null,
        size: 16,
        protocolInfo: s,
        hideHoverAvatar: !0
    }), r ? v.jsx(k, {
        variant: "paragraph1",
        sx: {
            mx: .5
        },
        children: r
    }) : v.jsx(Ie, {
        width: 40,
        variant: "rounded"
    })]
})
  , cU = {
    variant: "paragraph1",
    color: "text.value"
}
  , dU = [rc.STOP, rc.TRAILING_STOP, rc.DEV_SOLD]
  , uU = ({orderId: e, orderListId: t, isOpen: n, orderType: r, tradeSide: a, onClose: s= () => {}
}) => {
    const o = D();
    if (n)
        return v.jsx(Sw, {
            open: n,
            onClose: s,
            minDesktopWidth: 406,
            desktopWidth: 406,
            maxDesktopHeight: 800,
            stackSx: {
                p: 3
            },
            children: v.jsx(S, {
                justifyContent: "space-between",
                height: "100%",
                children: v.jsxs(S, {
                    gap: 3,
                    children: [v.jsx(S, {
                        m: -3,
                        p: 3,
                        children: v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [v.jsxs(S, {
                                direction: "row",
                                gap: .5,
                                alignItems: "center",
                                children: [v.jsx(k, {
                                    variant: "h1",
                                    children: "Order Summary"
                                }), v.jsx(cA, {
                                    customName: "",
                                    address: e
                                })]
                            }), v.jsx(F, {
                                onClick: s,
                                sx: {
                                    p: 0
                                },
                                children: v.jsx(gy, {
                                    size: 24,
                                    color: o.palette.text.label
                                })
                            })]
                        })
                    }), v.jsx(aU, {
                        orderId: e,
                        orderListId: t,
                        expectedData: {
                            tradeSide: a,
                            orderType: r
                        },
                        closeModal: s
                    })]
                })
            })
        })
}
  , pU = {
    showModal: O,
    isModalOpen: !1
}
  , hU = y.createContext(pU);
hU.displayName = "OrderSummaryContext";
const mU = y.memo(( ({children: e}) => {
    const [t,n] = y.useState(!1)
      , [r,a] = y.useState("")
      , [s,o] = y.useState(null)
      , [l,i] = y.useState(rc.MARKET)
      , [c,d] = y.useState(xc.BUY)
      , u = y.useCallback(( (e, t, r, s) => {
        a(e),
        o(s),
        i(t),
        d(r),
        n(!0)
    }
    ), [])
      , p = y.useCallback(( () => {
        n(!1)
    }
    ), [])
      , h = y.useMemo(( () => ({
        showModal: u,
        isModalOpen: t
    })), [t, u]);
    return v.jsxs(hU.Provider, {
        value: h,
        children: [e, v.jsx(uU, {
            isOpen: t,
            orderId: r,
            orderListId: s,
            orderType: l,
            tradeSide: c,
            onClose: p
        })]
    })
}
))
  , gU = () => y.useContext(hU)
  , xU = {
    getTxnSign: () => Promise.resolve(null)
}
  , bU = y.createContext(xU);
bU.displayName = "FastSignContext";
const fU = () => y.useContext(bU)
  , vU = () => h()
  , SU = e => e === pc.ETH ? yU : kU
  , yU = 18
  , kU = 9
  , CU = e => {
    if (null == e)
        return null;
    const t = "number" == typeof e ? e : Number.parseFloat(e);
    return Number.isFinite(t) ? t : null
}
  , AU = ({orderType: e, quantity: t, basePriceInUsdUi: n, basePriceInQuoteUi: r, baseDecimals: a, quoteDecimals: s}) => {
    if (e !== rc.MARKET)
        return null;
    if ("string" != typeof t.value)
        return null;
    const o = CU(n);
    if (null === o)
        return null;
    const l = t.unit === bc.BASE ? a : s;
    let i;
    try {
        i = new sB({
            decimals: l
        },BigInt(t.value)).toNumber()
    } catch {
        return null
    }
    let c = o;
    if (t.unit === bc.QUOTE) {
        const e = CU(r);
        if (null === e || 0 === e)
            return null;
        if (c = o / e,
        !Number.isFinite(c))
            return null
    }
    const d = i * c;
    return Number.isFinite(d) ? d : null
}
  , wU = ({nativePrice: e, orderValue: t}) => e ? e * t : null
  , jU = ({balanceNative: e, amountInNative: t, tipInNative: n, prioInNative: r}) => {
    const a = r + n + t;
    return e <= a + Math.min(IU, a * TU)
}
  , TU = .05
  , IU = .01
  , EU = [138, 127, 14, 91, 38, 87, 115, 105]
  , MU = [109, 61, 40, 187, 230, 176, 135, 174]
  , NU = "AbgFqRWjGWgUaVrZrLLWU5HDY5dktmAL6zT9aacQW7y1"
  , PU = () => [bj(NU), bj("GVVUi6DaocSEAp8ATnXFAPNF5irCWjCvmPCzoaGAf5eJ"), bj(qc), bj(Gc), bj(Jc), xj(Zc)]
  , OU = e => [xj(e), bj(NU), bj(Gc), bj(Jc), bj(Zc)]
  , LU = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("trading_fees_vault"), mj(e).toBuffer()], mj(gd));
    return t.toString()
}
  , RU = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("bonding_curve_sol_vault"), mj(e).toBuffer()], mj(gd));
    return t.toString()
}
  , DU = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("bonding_curve_vault"), mj(e).toBuffer()], mj(gd));
    return t.toString()
}
  , BU = [102, 6, 61, 18, 1, 218, 235, 234]
  , _U = [51, 230, 133, 164, 1, 127, 131, 173]
  , UU = [250, 234, 13, 123, 213, 156, 19, 236]
  , WU = [24, 211, 116, 40, 105, 3, 153, 56]
  , FU = [149, 39, 222, 155, 211, 124, 152, 26]
  , VU = [95, 200, 71, 34, 8, 9, 11, 166]
  , HU = (e, t) => ij("type", e, {
    "exact-in": e => ({
        ins: e.inputMint === t ? UU : FU,
        amount: e.amountIn,
        otherAmountThreshold: e.minAmountOut
    }),
    "exact-out": e => ({
        ins: e.outputMint !== t ? WU : VU,
        amount: e.amountOut,
        otherAmountThreshold: e.maxAmountIn
    })
})
  , zU = (e, t) => {
    const [n] = se.findProgramAddressSync([mj(e).toBuffer(), mj(t).toBuffer()], mj(fd));
    return n.toString()
}
  , $U = (e, t) => {
    const [n] = se.findProgramAddressSync([mj(e).toBuffer(), mj(t).toBuffer()], mj(fd));
    return n.toString()
}
  , GU = [248, 198, 158, 145, 225, 117, 135, 200]
  , qU = e => ij("type", e, {
    "exact-in": e => ({
        amount: e.amountIn,
        otherAmountThreshold: e.minAmountOut
    }),
    "exact-out": () => {
        throw new hj("Exact-out is not supported for meteora curves",{
            params: e
        })
    }
})
  , KU = [248, 198, 158, 145, 225, 117, 135, 200]
  , YU = [248, 198, 158, 145, 225, 117, 135, 200]
  , XU = [250, 73, 101, 33, 38, 207, 75, 184]
  , QU = () => {
    const [e] = se.findProgramAddressSync([Buffer.from("__event_authority")], mj(md));
    return e.toString()
}
  , ZU = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("oracle"), mj(e).toBuffer()], mj(md));
    return t.toString()
}
  , JU = (e, t, n) => {
    const r = Math.floor(t.activeBinId / 70)
      , a = n ? -1 : 1
      , s = tW(t, r, -a);
    if (!s)
        throw new hj("Could not find an initialized tick array",{
            poolAddr: e
        });
    const o = tW(t, s - a, -a)
      , l = null !== o ? [o, s] : [s]
      , i = tW(t, s + a, a);
    if (null !== i) {
        l.push(i);
        const e = tW(t, i + a, a);
        null !== e && l.push(e)
    }
    return l.map((t => nW(e, t)))
}
;
function eW(e, t) {
    const n = t + 512
      , r = Math.abs(n)
      , a = Math.floor(r / 64);
    if (a >= e.binArrayBitmap.length)
        return !1;
    const s = r % 64;
    return !!(BigInt(e.binArrayBitmap[a]) & 1n << BigInt(s))
}
const tW = (e, t, n) => {
    let r = 0;
    for (; !eW(e, t); )
        if (t += n,
        ++r,
        r > 512)
            return null;
    return t
}
  , nW = (e, t) => {
    const n = Buffer.alloc(8);
    n.writeBigInt64LE(BigInt(t));
    const [r] = se.findProgramAddressSync([Buffer.from("bin_array"), mj(e).toBuffer(), n], mj(md));
    return r.toString()
}
  , rW = [248, 198, 158, 145, 225, 117, 135, 200]
  , aW = [102, 6, 61, 18, 1, 218, 235, 234]
  , sW = [51, 230, 133, 164, 1, 127, 131, 173]
  , oW = "4wTV1YmiEkRvAtNtsSGPtUrqRYQMe5SKy2uB4Jjaxnjf"
  , lW = "62qc2CNXwrYqQScmEdiZFFAnJR262PxWEuNQtxfafNgV"
  , iW = "Ce6TQqeHC9p8KetsN6JsjHK7UTZk7nasjjnr7XxXp9F1"
  , cW = "8Wf5TiAheLUqBrKXeYg2JtAFFMWtKdG2BSFgqUcPVwTt"
  , dW = "GesfTA3X2arioaHp8bbKdjG9vJtskViWACZoYvxp4twS"
  , uW = [231, 63, 153, 131, 243, 237, 227, 60]
  , pW = [153, 24, 200, 10, 126, 182, 25, 149]
  , hW = [51, 230, 133, 164, 1, 127, 131, 173]
  , mW = [102, 6, 61, 18, 1, 218, 235, 234]
  , gW = (e, t, n, r, a) => {
    const s = Buffer.alloc(24);
    let o;
    "exact-in" === a.type ? (o = ad,
    s.set(uW, 0),
    s.writeBigInt64LE(a.amountIn, 8),
    s.writeBigInt64LE(a.minAmountOut, 16)) : (o = rd,
    s.set(mW, 0),
    s.writeBigInt64LE(a.amountOut, 8),
    s.writeBigInt64LE(a.maxAmountIn, 16));
    const l = t.isMayhemMode ? dW : lW
      , i = Tj(r, n.mint, n.tokenType)
      , c = Tj(e, n.mint, n.tokenType)
      , d = yj(n.tokenType)
      , u = bW(t.poolStatic.creator)
      , p = fW(r);
    return {
        feePayer: r,
        instructions: [new ie({
            keys: [bj(oW), xj(l), bj(n.mint), xj(e), xj(c), xj(i), gj(r), bj(Gc), bj(d), xj(u), bj(iW), bj(rd), xj("Hq2wp8uJ9jCPsYgNHex8RtqdvMPfVGoYwjvF1ATiwn2Y"), xj(p), bj(cW), bj(od)],
            programId: mj(o),
            data: s
        })],
        lookupTableAccounts: []
    }
}
  , xW = (e, t, n, r, a) => {
    const s = Buffer.alloc(24);
    let o;
    "exact-in" === a.type ? (o = rd,
    s.set(hW, 0),
    s.writeBigInt64LE(a.amountIn, 8),
    s.writeBigInt64LE(a.minAmountOut, 16)) : (o = ad,
    s.set(pW, 0),
    s.writeBigInt64LE(a.amountOut, 8),
    s.writeBigInt64LE(a.maxAmountIn, 16));
    const l = t.isMayhemMode ? dW : lW
      , i = Tj(r, n.mint, n.tokenType)
      , c = Tj(e, n.mint, n.tokenType)
      , d = yj(n.tokenType)
      , u = bW(t.poolStatic.creator);
    return {
        feePayer: r,
        instructions: [new ie({
            keys: [bj(oW), xj(l), bj(n.mint), xj(e), xj(c), xj(i), gj(r), bj(Gc), xj(u), bj(d), bj(iW), bj(rd), bj(cW), bj(od)],
            programId: mj(o),
            data: s
        })],
        lookupTableAccounts: []
    }
}
  , bW = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("creator-vault"), mj(e).toBuffer()], mj(rd));
    return t.toString()
}
  , fW = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("user_volume_accumulator"), mj(e).toBuffer()], mj(rd));
    return t.toString()
}
  , vW = [44, 124, 170, 112, 140, 232, 199, 233]
  , SW = [102, 6, 61, 18, 1, 218, 235, 234]
  , yW = [198, 46, 21, 82, 180, 217, 232, 112]
  , kW = [51, 230, 133, 164, 1, 127, 131, 173]
  , CW = (e, t) => ij("type", e, {
    "exact-in": e => {
        const n = e.inputMint === t;
        return n ? {
            program: sd,
            ins: Buffer.from(yW),
            isBuy: n,
            amount: e.amountIn,
            otherAmountThreshold: e.minAmountOut
        } : {
            program: sd,
            ins: Buffer.from(kW),
            isBuy: n,
            amount: e.amountIn,
            otherAmountThreshold: e.minAmountOut
        }
    }
    ,
    "exact-out": e => {
        const n = e.outputMint !== t;
        return n ? {
            program: sd,
            ins: Buffer.from(SW),
            isBuy: n,
            amount: e.amountOut,
            otherAmountThreshold: e.maxAmountIn
        } : {
            program: "Z4BMozEdiqTGdzzXkKUURjhfbCGF9Fs3KyTxhfi2bZe",
            ins: Buffer.from(vW),
            isBuy: n,
            amount: e.amountOut,
            otherAmountThreshold: e.maxAmountIn
        }
    }
})
  , AW = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("creator_vault"), mj(e).toBuffer()], mj(sd));
    return t.toString()
}
  , wW = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("user_volume_accumulator"), mj(e).toBuffer()], mj(sd));
    return t.toString()
}
  , jW = (e, t, n) => {
    if (Tj(e, Kc, vc.SOLANA_SPL) === t)
        throw new hj("Cannot invoke sellAllUsdc on user's ATA",{
            userWalletAddr: e,
            tokenAccountAddr: t
        });
    const r = Buffer.alloc(16);
    r.set(IW),
    r.writeBigInt64LE(n, 8);
    const {poolAddr: a, token0Vault: s, token1Vault: o} = Md
      , l = Tj(e, qc, vc.SOLANA_SPL);
    return new ie({
        keys: [bj(Jc), xj(a), bj(ud), xj(a), xj(a), xj(s), xj(o), bj(a), xj(a), xj(a), xj(a), xj(a), xj(a), xj(a), bj(a), xj(t), xj(l), gj(e), bj(dd)],
        programId: mj(TW),
        data: r
    })
}
  , TW = "HEjxeXR9D9CFmraTZhn9pbYTw74joJEeGdwyzxhydxrQ"
  , IW = [39, 251, 125, 131, 64, 111, 111, 240]
  , EW = [43, 4, 237, 11, 26, 201, 30, 98]
  , MW = (e, t, n, r, a, s=!1) => {
    const o = 60 * t.tickSpacing
      , l = Math.floor(t.tickCurrent / o) * o
      , i = r ? +o : -o
      , c = OW(t, n, l, i);
    if (null === c)
        throw new hj("Could not find an initialized tick array",{
            poolAddr: e
        });
    const d = [];
    if (s) {
        const e = OW(t, n, l - i, -i);
        null !== e && d.push(e)
    }
    d.push(c);
    let u = c + i;
    for (; d.length < a; ) {
        const e = OW(t, n, u, i);
        if (null === e)
            break;
        d.push(e),
        u = e + i
    }
    return d.slice(0, a).map((t => PW(e, t)))
}
  , NW = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("pool_tick_array_bitmap_extension"), mj(e).toBuffer()], mj(id));
    return t.toString()
}
  , PW = (e, t) => {
    const [n] = se.findProgramAddressSync([Buffer.from("tick_array"), mj(e).toBuffer(), LW(t)], mj(id));
    return n.toString()
}
  , OW = (e, t, n, r) => {
    let a = RW(e, t, n);
    if ("stop" === a)
        return null;
    for (; !a; )
        if (a = RW(e, t, n += r),
        "stop" === a)
            return null;
    return n
}
;
function LW(e) {
    const t = new ArrayBuffer(4);
    return new DataView(t).setInt32(0, e, !1),
    new Uint8Array(t)
}
function RW(e, t, n) {
    const r = m.chunk(t.negativeTickArrayBitmap, 8)
      , a = e.tickArrayBitmap.slice(0, 8)
      , s = e.tickArrayBitmap.slice(8, 16)
      , o = m.chunk(t.positiveTickArrayBitmap, 8)
      , l = [...r.reverse(), m.chunk(a, 8)[0], m.chunk(s, 8)[0], ...o]
      , i = n / (60 * e.tickSpacing)
      , c = (i + 7680) % 512
      , d = l[Math.floor((i + 7680) / 512)];
    if (!d)
        return "stop";
    const u = Math.floor(c / 64);
    return !!(BigInt(d[u]) & 1n << BigInt(c % 64))
}
const DW = (e, t, n, r, a) => {
    if (Tj(e, Xc, vc.SOLANA_SPL) === t)
        throw new hj("Cannot invoke sellAllUsd1 on user's ATA",{
            userWalletAddr: e,
            tokenAccountAddr: t
        });
    const s = Buffer.alloc(32);
    s.set(_W, 0),
    s.writeBigInt64LE(n, 8),
    pj(s, 0n, 16);
    const {poolStatic: o, config: l, observationKey: i, tickSpacing: c} = a
      , {token0Vault: d, token1Vault: u} = o
      , p = Tj(e, qc, vc.SOLANA_SPL)
      , h = NW(r)
      , m = MW(r, {
        tickCurrent: a.tickCurrent,
        tickSpacing: c,
        tickArrayBitmap: a.tickArrayBitmap
    }, a.bitmapExtension, !0, 3, !0);
    if (!m.length)
        throw new hj("Empty tick array");
    const g = m.length >= 3 ? m.slice(0, 3) : m;
    for (; g.length < 3; )
        g.push(UW[g.length]);
    return new ie({
        keys: [gj(e), bj(l), xj(r), xj(t), xj(p), xj(u), xj(d), xj(i), bj(Jc), bj(ed), bj(ld), bj(Xc), bj(qc), xj(h), ...g.map(xj), bj(id)],
        programId: mj(BW),
        data: s
    })
}
  , BW = "8AvZxgh5d3WeTXs8EP2kLhtNv9TmcMp6yi4Nfr5sQxLs"
  , _W = [134, 206, 218, 120, 236, 201, 182, 120]
  , UW = ["MgSPwURVfouVRx7PmmKPNg31utDTbSGee6ZgnFLqjN9", "GUckwA6M1HBqebUVCETQ4fsu2pUbSEDg3KyvUV3ScJRW", "7nPeXao6FDvDp5qsNgFH8eSkMzuznSVtydk6qg1c1RYo"]
  , WW = [47, 62, 155, 172, 131, 205, 37, 201]
  , FW = [99, 40, 14, 105, 45, 107, 172, 201]
  , VW = [255, 255, 255, 255, 255, 255, 255, 255]
  , HW = (e, t, n, r) => {
    const a = Buffer.alloc(16);
    return a.set(WW, 0),
    a.writeBigInt64LE(r, 8),
    new ie({
        keys: [xj(KW[t]), xj(t), bj(qW[t]), xj(n), gj(e), gj(e), bj(Jc), bj(Zc), bj(Gc), bj(td)],
        programId: mj(GW[t]),
        data: a
    })
}
  , zW = [143, 190, 90, 218, 196, 30, 51, 222]
  , $W = [55, 217, 98, 86, 163, 74, 180, 173]
  , GW = {
    [Mc("pSoL47GE52V2bgUUyQvs9LSdWQZsokarp2yNsWQaLYy")]: "pBasedTVV99yFBmg2u6Uvka9fJueRcs7SB9PJ2HfrEn",
    [Mc("tstd5BAbtB81TG3kwL4zFLF6x73edB2atEnqvUBqqmh")]: "2W8sBc5dskGTdy7X3Sf3cRVksQQH6ePbfFLbMHj29Wiv"
}
  , qW = {
    [Mc("pSoL47GE52V2bgUUyQvs9LSdWQZsokarp2yNsWQaLYy")]: "71J1bTThWGXD9qVxsyYwxZbGG5GbdUzV7t7ohkuGxt5a",
    [Mc("tstd5BAbtB81TG3kwL4zFLF6x73edB2atEnqvUBqqmh")]: "ApZkbtDBd5nvUHw2SqhAywj4WSLNmfiQd4FXWj6Tf5Z7"
}
  , KW = {
    [Mc("pSoL47GE52V2bgUUyQvs9LSdWQZsokarp2yNsWQaLYy")]: "BaAw9xsjbixDxa5DqaXyyNFWcaqvwo3vuw5UzBqMbCfN",
    [Mc("tstd5BAbtB81TG3kwL4zFLF6x73edB2atEnqvUBqqmh")]: "5odN6Ypro1EnMM6hZTpGvZBwC6trKau8r2yK6D65Xx3a"
}
  , YW = [250, 234, 13, 123, 213, 156, 19, 236]
  , XW = [24, 211, 116, 40, 105, 3, 153, 56]
  , QW = [149, 39, 222, 155, 211, 124, 152, 26]
  , ZW = [95, 200, 71, 34, 8, 9, 11, 166]
  , JW = (e, t, n, r, a) => {
    const s = nF(r)
      , o = Buffer.alloc(26);
    o.set(s.ins, 0),
    o.writeBigInt64LE(s.firstArg, 10),
    o.writeBigInt64LE(s.secondArg, 18);
    const [l,i] = aF(t, a)
      , [c] = sF(e, t)
      , [,d] = oF(t, a);
    o.writeUint8(d, 8),
    o.writeUint8(i, 9);
    const u = Tj(n, t, vc.SOLANA_SPL)
      , p = rF(a)
      , h = lF(a)
      , m = tF[a]
      , g = eF[a];
    return {
        feePayer: n,
        instructions: [new ie({
            keys: [bj(p), bj(t), xj(e), xj(l), xj(c), xj(u), gj(n), gj(n), xj(m), bj(Jc), bj(Zc), bj(Gc), xj(td), bj(h), bj(g)],
            programId: mj(g),
            data: o
        })],
        lookupTableAccounts: []
    }
}
  , eF = {
    prod: Cd,
    test: kd
}
  , tF = {
    prod: "2UsBp9iCcykgP1E5kHwwPVJSyi9D1snZYbnkhKUuecPt",
    test: "HbnDo4oayx2hcKWPfrer1mG6wQCgd6XEvBkDR7b1gEWb"
}
  , nF = e => {
    if ("exact-in" === e.type) {
        return Ij(e.inputMint) ? {
            ins: Buffer.from(YW),
            firstArg: e.amountIn,
            secondArg: e.minAmountOut
        } : {
            ins: Buffer.from(QW),
            firstArg: e.amountIn,
            secondArg: e.minAmountOut
        }
    }
    if ("exact-out" === e.type) {
        return !Ij(e.outputMint) ? {
            ins: Buffer.from(XW),
            firstArg: e.maxAmountIn,
            secondArg: e.amountOut
        } : {
            ins: Buffer.from(ZW),
            firstArg: e.maxAmountIn,
            secondArg: e.amountOut
        }
    }
    throw new hj("Invalid params type",{
        params: e
    })
}
  , rF = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("state")], mj(eF[e]));
    return t.toString()
}
  , aF = (e, t) => {
    const [n,r] = se.findProgramAddressSync([Buffer.from("bonding_curve_"), mj(e).toBuffer(), Buffer.from("_sol_vault")], mj(eF[t]));
    return [n.toString(), r]
}
  , sF = (e, t) => {
    const [n,r] = se.findProgramAddressSync([mj(e).toBuffer(), mj(Jc).toBuffer(), mj(t).toBuffer()], mj(Zc));
    return [n.toString(), r]
}
  , oF = (e, t) => {
    const [n,r] = se.findProgramAddressSync([Buffer.from("bonding_curve_"), mj(e).toBuffer()], mj(eF[t]));
    return [n.toString(), r]
}
  , lF = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("__event_authority")], mj(eF[e]));
    return t.toString()
}
  , iF = [248, 198, 158, 145, 225, 117, 135, 200]
  , cF = (e, t) => {
    const n = e.inputMint === t;
    return ij("type", e, {
        "exact-in": e => ({
            swapType: n ? 0 : 2,
            firstArg: e.amountIn,
            secondArg: e.minAmountOut
        }),
        "exact-out": e => ({
            swapType: n ? 1 : 3,
            firstArg: e.maxAmountIn,
            secondArg: e.amountOut
        })
    })
}
  , dF = (e, t) => ({
    ata: e.address,
    program: yj(e.tokenType),
    mint: e.mint,
    vault: t.poolStatic.token0 === e.mint ? t.poolStatic.token0Vault : t.poolStatic.token1Vault
})
  , uF = [43, 4, 237, 11, 26, 201, 30, 98]
  , pF = (e, t, n) => {
    const r = 88 * t.tickSpacing
      , a = Math.floor(t.tickCurrentIndex / r) * r
      , s = n ? -1 : 1;
    return [mF(e, a), mF(e, a + 1 * s * r), mF(e, a + 2 * s * r)]
}
  , hF = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("oracle"), mj(e).toBuffer()], mj(cd));
    return t.toString()
}
  , mF = (e, t) => {
    const [n] = se.findProgramAddressSync([Buffer.from("tick_array"), mj(e).toBuffer(), Buffer.from(t.toString())], mj(cd));
    return n.toString()
}
  , gF = e => {
    const {amountIn: t, reserveIn: n, reserveOut: r, feePpm: a} = e;
    if (t <= 0n)
        throw new hj("Insufficient input amount",e);
    if (0n === n || 0n === r)
        throw new hj("Insufficient liquidity",e);
    const s = t * (1000000n - a);
    return s * r / (1000000n * n + s)
}
  , xF = (e, t, n) => {
    const r = jj(t, n);
    return e === bc.BASE ? r.baseCurrency : r.quoteCurrency
}
  , bF = (e, t, n) => {
    const r = "bigint" == typeof e ? ce(e.toString()) : e
      , a = "min" === n ? Math.max(1e4 - t, 0) : 1e4 + t
      , s = BigInt(r.multipliedBy(a).dividedBy(1e4).toFixed(0));
    return s <= 0n ? 1n : s
}
  , fF = (e, t) => e === xc.BUY && t === bc.QUOTE || e === xc.SELL && t === bc.BASE
  , vF = e => yF[e].supportsExactOut
  , SF = e => yF[e].wrapsNative
  , yF = {
    [Rc.RAYDIUM]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.RAYDIUM_CP]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.RAYDIUM_CLMM]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.METEORA_OLD]: {
        wrapsNative: !0,
        supportsExactOut: !1
    },
    [Rc.METEORA_DLMM]: {
        wrapsNative: !0,
        supportsExactOut: !1
    },
    [Rc.PUMP_FUN]: {
        wrapsNative: !1,
        supportsExactOut: !0
    },
    [Rc.PUMP_SWAP]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.WHIRLPOOL]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.LAUNCH_LAB]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.BOOP]: {
        wrapsNative: !1,
        supportsExactOut: !1
    },
    [Rc.METEORA_CURVE]: {
        wrapsNative: !0,
        supportsExactOut: !1
    },
    [Rc.METEORA_DAMM_V2]: {
        wrapsNative: !0,
        supportsExactOut: !1
    },
    [Rc.MOONIT]: {
        wrapsNative: !1,
        supportsExactOut: !0
    },
    [Rc.HEAVEN]: {
        wrapsNative: !0,
        supportsExactOut: !1
    },
    [Rc.TOKEN_MILL]: {
        wrapsNative: !0,
        supportsExactOut: !0
    },
    [Rc.SUGAR]: {
        wrapsNative: !1,
        supportsExactOut: !0
    },
    [Rc.SUGAR_TEST]: {
        wrapsNative: !1,
        supportsExactOut: !0
    }
}
  , kF = e => {
    if (e.curveType !== Uc.CONSTANT_PRODUCT_V1 && e.curveType !== Uc.CONSTANT_PRODUCT_V2)
        throw new hj("Unsupported curve type",{
            curveType: e.curveType
        });
    const [t,n] = e.curveType === Uc.CONSTANT_PRODUCT_V1 ? [1073000000000000000n, 30000000000n] : [1060000000000000000n, 14000000000n]
      , r = t - BigInt(e.curveTotalSupply) + BigInt(e.vault0Balance);
    return {
        vault0CorrectedAmount: r,
        vault1CorrectedAmount: t * n / r
    }
}
  , CF = e => ({
    vault0CorrectedAmount: BigInt(ce(e.vault0Balance).multipliedBy(e.poolAuxInfo.token0RealVaultTotalAmount).dividedBy(e.poolAuxInfo.token0LpSupply).toFixed(0)),
    vault1CorrectedAmount: BigInt(ce(e.vault1Balance).multipliedBy(e.poolAuxInfo.token1RealVaultTotalAmount).dividedBy(e.poolAuxInfo.token1LpSupply).toFixed(0))
})
  , AF = e => {
    const t = BigInt(e.poolAuxInfo.baseNeedTakePnl)
      , n = BigInt(e.poolAuxInfo.quoteNeedTakePnl);
    return {
        vault0CorrectedAmount: BigInt(e.vault0Balance) - t,
        vault1CorrectedAmount: BigInt(e.vault1Balance) - n
    }
}
  , wF = e => {
    const [t,n] = e.isInputToken0 ? [e.vault0CorrectedAmount, e.vault1CorrectedAmount] : [e.vault1CorrectedAmount, e.vault0CorrectedAmount];
    return (e => {
        const {amountOut: t, reserveIn: n, reserveOut: r, feePpm: a} = e;
        if (t <= 0n)
            throw new hj("Insufficient output amount",e);
        if (0n === n || 0n === r)
            throw new hj("Insufficient liquidity",e);
        const s = 1000000n
          , o = n * t * s
          , l = (r - t) * (s - a);
        if (0n === l)
            throw new hj("Invalid denominator (likely amountOut too large)",e);
        return o / l + 1n
    }
    )({
        amountOut: e.amountOut,
        reserveIn: t,
        reserveOut: n,
        feePpm: 100n * (e.protocolFeeBps ?? 0n)
    })
}
  , jF = e => {
    const {poolCtx: t} = e
      , {amount: n, side: r} = e.txnDef
      , {token0: a, token1: s} = Mj(t, e.baseMint)
      , o = (e => ij("protocolType", e, {
        RAYDIUM: e => AF({
            vault0Balance: e.token0VaultBalance,
            vault1Balance: e.token1VaultBalance,
            poolAuxInfo: e.aux
        }),
        RAYDIUM_CP: e => ({
            vault0CorrectedAmount: BigInt(e.token0VaultBalance) - BigInt(e.creatorFeesToken0),
            vault1CorrectedAmount: BigInt(e.token1VaultBalance) - BigInt(e.creatorFeesToken1)
        }),
        PUMP_FUN: e => ({
            vault0CorrectedAmount: BigInt(e.virtualTokenReserves),
            vault1CorrectedAmount: BigInt(e.virtualSolReserves)
        }),
        METEORA_OLD: e => CF({
            vault0Balance: e.token0VaultBalance,
            vault1Balance: e.token1VaultBalance,
            poolAuxInfo: e.aux
        }),
        PUMP_SWAP: e => ({
            vault0CorrectedAmount: BigInt(e.token0VaultBalance),
            vault1CorrectedAmount: BigInt(e.token1VaultBalance)
        }),
        BOOP: e => ({
            vault0CorrectedAmount: BigInt(e.tokenReserves),
            vault1CorrectedAmount: BigInt(e.solReserves) + BigInt(e.virtualSolReserves)
        }),
        LAUNCH_LAB: e => ({
            vault0CorrectedAmount: BigInt(e.virtual0) - BigInt(e.real0),
            vault1CorrectedAmount: BigInt(e.virtual1) + BigInt(e.real1)
        }),
        MOONIT: e => kF({
            vault0Balance: e.curveAmount,
            vault1Balance: e.poolLamports,
            curveType: e.poolStatic.curveType,
            curveTotalSupply: e.curveTotalSupply
        }),
        HEAVEN: e => ({
            vault0CorrectedAmount: BigInt(e.virtual0),
            vault1CorrectedAmount: BigInt(e.virtual1),
            protocolFeeBps: 110n
        }),
        SUGAR: e => ({
            vault0CorrectedAmount: BigInt(e.virtualTokenReserves),
            vault1CorrectedAmount: BigInt(e.virtualSolReserves)
        }),
        SUGAR_TEST: e => ({
            vault0CorrectedAmount: BigInt(e.virtualTokenReserves),
            vault1CorrectedAmount: BigInt(e.virtualSolReserves)
        })
    }))(t)
      , l = xF(n.unit, a, s)
      , i = (e => {
        const t = Number(e.vault0CorrectedAmount)
          , n = Number(e.vault1CorrectedAmount);
        if (!t || !n || t < 0 || n < 0)
            throw new hj("Unexpected value in cp pool vault",e);
        return ce(e.vault1CorrectedAmount.toString()).dividedBy(e.vault0CorrectedAmount.toString())
    }
    )(o)
      , c = l === a ? i : ce(1).dividedBy(i)
      , d = l === a ? s : a
      , u = ce(n.value).multipliedBy(c);
    if (fF(r, n.unit)) {
        const r = (e => {
            const [t,n] = e.isInputToken0 ? [e.vault0CorrectedAmount, e.vault1CorrectedAmount] : [e.vault1CorrectedAmount, e.vault0CorrectedAmount];
            return gF({
                amountIn: e.amountIn,
                reserveIn: t,
                reserveOut: n,
                feePpm: 100n * (e.protocolFeeBps ?? 0n)
            })
        }
        )({
            ...o,
            amountIn: BigInt(n.value),
            isInputToken0: l === a
        })
          , s = BigInt(u.toFixed(0))
          , i = dj(r, s)
          , c = EF({
            quoted: i,
            estimated: s
        })
          , p = TF({
            originalSlippageBps: e.slippageBps,
            estPriceImpactBps: c,
            protocolType: t.protocolType
        });
        np.info("Selected effective slippage", {
            origBps: e.slippageBps,
            estImpactBps: c,
            effectiveBps: p,
            kickBps: p - e.slippageBps
        });
        const h = bF(u, p, "min");
        return {
            type: "exact-in",
            amountIn: BigInt(n.value),
            minAmountOut: h,
            estAmountOut: s,
            quotedAmountOut: i,
            inputMint: l,
            outputMint: d
        }
    }
    {
        const r = BigInt(n.value)
          , s = wF({
            ...o,
            amountOut: r,
            isInputToken0: d === a
        })
          , i = BigInt(u.toFixed(0))
          , c = EF({
            quoted: s,
            estimated: i
        })
          , p = TF({
            originalSlippageBps: e.slippageBps,
            estPriceImpactBps: c,
            protocolType: t.protocolType
        });
        if (!vF(t.protocolType)) {
            const t = {
                type: "exact-in",
                amountIn: s,
                minAmountOut: bF(r, p, "min"),
                quotedAmountOut: r,
                estAmountOut: r,
                inputMint: d,
                outputMint: l
            };
            return np.info("Replacing exact-out with approximated exact-in", {
                args: e,
                toReturn: t
            }),
            t
        }
        const h = bF(u, p, "max");
        return {
            type: "exact-out",
            amountOut: BigInt(n.value),
            maxAmountIn: h,
            inputMint: d,
            outputMint: l,
            quotedAmountIn: s,
            estAmountIn: i
        }
    }
}
  , TF = e => {
    const t = IF[e.protocolType];
    if (e.originalSlippageBps > Number(e.estPriceImpactBps) + t)
        return e.originalSlippageBps;
    const n = MF(Number(e.estPriceImpactBps), {
        min: 0,
        max: t
    });
    return ce(e.originalSlippageBps).plus(n).integerValue().toNumber()
}
  , IF = {
    [Rc.PUMP_FUN]: 1500,
    [Rc.BOOP]: 1500,
    [Rc.LAUNCH_LAB]: 1500,
    [Rc.HEAVEN]: 1500,
    [Rc.METEORA_CURVE]: 1e3,
    [Rc.MOONIT]: 1e3,
    [Rc.PUMP_SWAP]: 1e3,
    [Rc.RAYDIUM]: 1e3,
    [Rc.RAYDIUM_CP]: 1e3,
    [Rc.TOKEN_MILL]: 1e3,
    [Rc.SUGAR]: 1e3,
    [Rc.SUGAR_TEST]: 1e3,
    [Rc.METEORA_DLMM]: 500,
    [Rc.METEORA_OLD]: 500,
    [Rc.METEORA_DAMM_V2]: 500,
    [Rc.RAYDIUM_CLMM]: 500,
    [Rc.WHIRLPOOL]: 500
}
  , EF = e => {
    return 0n === e.estimated ? 0n : (t = 10000n * e.quoted / e.estimated - 10000n) < 0n ? -t : t;
    var t
}
  , MF = (e, t) => e < t.min ? t.min : e > t.max ? t.max : e
  , NF = (e, t, n, r) => {
    if (r) {
        const r = n.times(t)
          , a = n.plus(e.times(t));
        return r.div(a)
    }
    return t.plus(e.div(n))
}
  , PF = (e, t, n) => e.times(t.minus(n))
  , OF = (e, t, n) => e.times(n.minus(t)).div(t.times(n))
  , LF = (e, t, n, r) => {
    if (e.isZero())
        return t;
    if (r) {
        const r = t.minus(e.div(n));
        if (r.isLessThanOrEqualTo(0))
            throw new hj("Price range is violated",{
                currentSqrtPrice: t.toString(),
                outAmount: e.toString(),
                liquidity: n.toString()
            });
        return r
    }
    const a = n.minus(e.times(t));
    if (a.isLessThanOrEqualTo(0))
        throw new hj("Price range is violated",{
            currentSqrtPrice: t.toString(),
            outAmount: e.toString(),
            liquidity: n.toString()
        });
    return n.times(t).div(a)
}
  , RF = e => {
    const {poolCtx: t, slippageBps: n, validatedPoolPrice: r} = e
      , {amount: a, side: s} = e.txnDef
      , {token0: o, token1: l} = Mj(t, e.baseMint)
      , i = xF(a.unit, o, l)
      , c = i === o ? l : o
      , d = i === o ? r : ce(1).dividedBy(r)
      , u = ce(a.value)
      , p = u.multipliedBy(d)
      , h = (e => ij("protocolType", e, {
        METEORA_DAMM_V2: e => ce(e.liquidity).dividedBy(ce(2).pow(64)),
        METEORA_CURVE: e => ce(e.maxTickLiquidity).dividedBy(ce(2).pow(64)),
        RAYDIUM: () => null,
        RAYDIUM_CP: () => null,
        METEORA_DLMM: () => null,
        METEORA_OLD: () => null,
        PUMP_FUN: () => null,
        PUMP_SWAP: () => null,
        BOOP: () => null,
        LAUNCH_LAB: () => null,
        WHIRLPOOL: () => null,
        RAYDIUM_CLMM: () => null,
        MOONIT: () => null,
        HEAVEN: () => null,
        TOKEN_MILL: () => null,
        SUGAR: () => null,
        SUGAR_TEST: () => null
    }))(t)
      , m = h && !h.isZero() ? h : null
      , g = e.validatedPoolPrice.sqrt();
    if (fF(s, a.unit)) {
        const e = bF(p, n, "min")
          , t = m ? (e => {
            const {amountIn: t, currentSqrtPrice: n, liquidity: r, zeroToOne: a} = e
              , s = NF(t, n, r, a)
              , o = a ? PF(r, n, s) : OF(r, n, s);
            return _j(o)
        }
        )({
            amountIn: u,
            currentSqrtPrice: g,
            liquidity: m,
            zeroToOne: i === o
        }) : null;
        return {
            type: "exact-in",
            amountIn: BigInt(a.value),
            minAmountOut: e,
            estAmountOut: BigInt(p.toFixed(0)),
            quotedAmountOut: t,
            inputMint: i,
            outputMint: c
        }
    }
    {
        const r = i
          , s = m ? (e => {
            const {outAmount: t, currentSqrtPrice: n, liquidity: r, zeroToOne: a} = e;
            if (t.isLessThanOrEqualTo(0))
                return 0n;
            const s = LF(t, n, r, a)
              , o = a ? OF(r, s, n) : PF(r, s, n);
            return _j(o)
        }
        )({
            outAmount: u,
            currentSqrtPrice: g,
            liquidity: m,
            zeroToOne: r === l
        }) : null
          , o = BigInt(p.toFixed(0));
        if (!vF(t.protocolType)) {
            const t = s ?? o
              , l = BigInt(a.value)
              , i = {
                type: "exact-in",
                amountIn: t,
                minAmountOut: bF(l, n, "min"),
                estAmountOut: l,
                quotedAmountOut: null,
                inputMint: c,
                outputMint: r
            };
            return np.info("Replacing exact-out with approximated exact-in", {
                args: e,
                toReturn: i
            }),
            i
        }
        return {
            type: "exact-out",
            amountOut: BigInt(a.value),
            maxAmountIn: bF(p, n, "max"),
            estAmountIn: BigInt(p.toFixed(0)),
            inputMint: c,
            outputMint: r,
            quotedAmountIn: s
        }
    }
}
  , DF = (e, t) => {
    if (e === Kc) {
        const {raydiumUsdcPoolContext: n} = t;
        if (!n)
            throw new hj("Missing required usdc pool context",{
                targetQuote: e,
                originalAuxCtx: t
            });
        return {
            quoteSubPoolAddr: Md.poolAddr,
            quoteSubPoolCtx: {
                protocolType: Rc.RAYDIUM,
                poolStatic: Md,
                ...n,
                poolReadAtSlot: 0,
                token0VaultReadAtSlot: 0,
                token1VaultReadAtSlot: 0
            },
            quoteSubAuxCtx: {
                validatedPoolPrice: null
            }
        }
    }
    if (e === Xc) {
        const {raydiumClmmUsd1PoolContextV2: n} = t;
        if (!n)
            throw new hj("Missing required usd1 pool context",{
                targetQuote: e,
                originalAuxCtx: t
            });
        const r = Rj(!0, n).toFixed(12);
        return {
            quoteSubPoolAddr: n.poolAddr,
            quoteSubPoolCtx: {
                ...n,
                bitmapExtension: n.bitmapExtension ?? {
                    negativeTickArrayBitmap: BF,
                    positiveTickArrayBitmap: BF
                }
            },
            quoteSubAuxCtx: {
                validatedPoolPrice: r
            }
        }
    }
    throw new hj("Unsupported quote for quote sub",{
        targetQuote: e,
        originalAuxCtx: t
    })
}
  , BF = Array.from({
    length: 112
}, ( () => "0"));
function _F(e) {
    return "swap-all" === e.swapParams.type
}
const UF = e => e.side === xc.BUY && e.amount.unit === bc.QUOTE
  , WF = e => e.side === xc.SELL && e.amount.unit === bc.BASE
  , FF = e => e.side === xc.SELL && e.amount.unit === bc.QUOTE
  , VF = 400
  , HF = (e, t, n, r) => {
    const {quoteSubPoolAddr: a, quoteSubPoolCtx: s, quoteSubAuxCtx: o} = DF(t, e)
      , l = QF({
        txnDef: {
            amount: {
                unit: bc.BASE,
                value: r.toString()
            },
            pair: {
                baseMint: t,
                quoteMint: qc
            },
            side: xc.SELL
        },
        poolCtx: s,
        auxCtx: o,
        slippageBps: VF
    });
    if ("exact-in" !== l.type)
        throw new hj("Unexpected swap params type",{
            testWaters: l
        });
    const i = l.quotedAmountOut ?? l.estAmountOut;
    return {
        quoteSwap: {
            swapParams: {
                type: "swap-all",
                minAmountOut: bF(i, n + VF, "min"),
                estAmountOut: i,
                inputMint: t,
                outputMint: qc
            },
            poolAddr: a,
            poolCtx: s
        }
    }
}
  , zF = (e, t, n, r) => {
    const {quoteSubPoolAddr: a, quoteSubPoolCtx: s, quoteSubAuxCtx: o} = DF(n, t)
      , l = QF({
        txnDef: {
            amount: e.amount,
            pair: {
                baseMint: n,
                quoteMint: qc
            },
            side: xc.SELL
        },
        poolCtx: s,
        auxCtx: o,
        slippageBps: VF
    });
    if ("exact-out" !== l.type)
        throw new hj("Unexpected swap params type (sell exact out)",{
            txnDef: e,
            poolQuote: n,
            testWaters: l
        });
    const i = l.quotedAmountIn ?? l.estAmountIn
      , c = bF(l.amountOut, r + VF, "min");
    return {
        adjustedTxnDef: {
            amount: {
                unit: bc.QUOTE,
                value: i.toString()
            },
            pair: {
                baseMint: e.pair.baseMint,
                quoteMint: n
            },
            side: e.side
        },
        quoteSwap: {
            swapParams: {
                type: "swap-all",
                minAmountOut: c,
                estAmountOut: l.amountOut,
                inputMint: n,
                outputMint: qc
            },
            poolAddr: a,
            poolCtx: s
        }
    }
}
  , $F = (e, t, n) => {
    if (!Ij(e.pair.quoteMint))
        throw new hj("Invalid quote for quote substitution",{
            txnDef: e
        });
    if (!fF(e.side, e.amount.unit))
        throw new hj("Exact-out buy transactions are not supported",{
            txnDef: e
        });
    const {quoteSubPoolAddr: r, quoteSubPoolCtx: a, quoteSubAuxCtx: s} = DF(n, t)
      , o = {
        baseMint: n,
        quoteMint: qc
    }
      , l = QF({
        txnDef: {
            amount: e.amount,
            pair: o,
            side: xc.BUY
        },
        poolCtx: a,
        auxCtx: s,
        slippageBps: VF
    });
    if ("exact-in" !== l.type)
        throw new hj("Unexpected exact-out swap params",{
            txnDef: e
        });
    const i = l.quotedAmountOut ?? l.estAmountOut
      , c = QF({
        txnDef: {
            amount: {
                value: i.toString(),
                unit: bc.BASE
            },
            pair: o,
            side: xc.BUY
        },
        poolCtx: a,
        auxCtx: s,
        slippageBps: VF
    });
    if ("exact-out" !== c.type)
        throw new hj("Unexpected exact-in quote sub swap params",{
            txnDef: e,
            quoteSubSwapParams: c
        });
    return {
        quoteSwap: {
            swapParams: c,
            poolAddr: r,
            poolCtx: a
        },
        adjustedTxnDef: {
            pair: {
                baseMint: e.pair.baseMint,
                quoteMint: n
            },
            amount: {
                unit: bc.QUOTE,
                value: i.toString()
            },
            side: xc.BUY
        }
    }
}
  , GF = (e, t, n) => {
    var r;
    const a = e[0];
    if (_F(a))
        throw new hj("Invalid first params",{
            route: e
        });
    const s = a.swapParams
      , o = s.inputMint
      , l = jj(n.token0AtaInfo.mint, n.token1AtaInfo.mint)
      , i = new Set
      , c = oV(o) && SF(a.poolCtx.protocolType);
    c && i.add(o),
    e.forEach((e => {
        const {outputMint: t} = e.swapParams;
        var n;
        Ij(t) && !SF(e.poolCtx.protocolType) || i.add((n = t) === Gc ? qc : n)
    }
    ));
    const d = []
      , u = []
      , p = new Map
      , h = XF(n);
    h.forEach(( (e, t) => {
        p.set(t, e)
    }
    )),
    i.forEach((e => {
        var n;
        const r = e !== l.baseCurrency && e !== l.quoteCurrency && !oV(e)
          , a = r || oV(e);
        Ej(e) || h.has(e) || np.warn("Unexpected mint in ATA opening code, assuming it's NOT token2022", {
            mint: e
        });
        const {txn: s, account: o} = qF(t, e, (null == (n = h.get(e)) ? void 0 : n.tokenType) ?? vc.SOLANA_SPL, r ? "transient" : "ata");
        if (d.push(s),
        p.set(e, o),
        a) {
            const e = YF(t, o);
            u.push(e)
        }
    }
    ));
    let m = 0n;
    if (c) {
        const a = vj(s) ? s.amountIn : s.maxAmountIn
          , l = p.get(o);
        if (!l)
            throw new hj("Programming error: first input mint missing from map",{
                firstInputMint: o,
                route: e,
                ataCtx: n
            });
        const i = a - BigInt((null == (r = h.get(o)) ? void 0 : r.balance) ?? "0");
        i > 0n && (d.push(KF(t, i, l)),
        m = i)
    }
    return {
        openTxns: d,
        closeTxns: u,
        tokenAccountInfos: p,
        nativeLamportsForWsolAta: m
    }
}
  , qF = (e, t, n, r) => {
    if ("transient" === r) {
        const {tokenAccountAddr: r, createCustomTxn: a} = ( (e, t) => {
            const n = `pdr-${Aj(4)}`
              , r = wj(e, n, Jc)
              , a = r.toString()
              , s = de.createAccountWithSeed({
                fromPubkey: mj(e),
                newAccountPubkey: mj(a),
                seed: n,
                basePubkey: mj(e),
                space: 165,
                lamports: Number(Bj),
                programId: mj(Jc)
            })
              , o = Buffer.alloc(33);
            o[0] = 18;
            const l = mj(e).toBuffer();
            return o.set(l, 1),
            {
                tokenAccountAddr: r,
                createCustomTxn: {
                    feePayer: e,
                    instructions: [s, new ie({
                        keys: [xj(a), bj(t)],
                        programId: mj(Jc),
                        data: o
                    })],
                    lookupTableAccounts: []
                }
            }
        }
        )(e, t);
        return {
            txn: a,
            account: {
                address: r,
                mint: t,
                tokenType: n
            }
        }
    }
    {
        const r = {
            mint: t,
            address: Tj(e, t, n),
            tokenType: n
        }
          , a = ( (e, t) => kj(e, e, t))(e, r);
        return {
            txn: {
                feePayer: e,
                instructions: [a],
                lookupTableAccounts: []
            },
            account: r
        }
    }
}
  , KF = (e, t, n) => {
    if (Ij(n.mint))
        return {
            feePayer: e,
            instructions: [de.transfer({
                fromPubkey: mj(e),
                toPubkey: mj(n.address),
                lamports: t
            }), (r = n.address,
            new ie({
                keys: [xj(r)],
                programId: mj(Jc),
                data: Buffer.from([17])
            }))],
            lookupTableAccounts: []
        };
    var r;
    if (n.mint === lV)
        return {
            feePayer: e,
            instructions: [HW(e, n.mint, n.address, t)],
            lookupTableAccounts: []
        };
    throw new hj("Unsupported token for account hydration",{
        userWalletAddr: e,
        lamports: t,
        info: n
    })
}
  , YF = (e, t) => {
    const n = [];
    return t.mint === lV && n.push(( (e, t, n) => {
        const r = Buffer.alloc(16);
        return r.set(FW, 0),
        r.set(VW, 8),
        new ie({
            keys: [xj(KW[t]), xj(t), xj(n), gj(e), bj(Jc)],
            programId: mj(GW[t]),
            data: r
        })
    }
    )(e, t.mint, t.address)),
    n.push(( (e, t) => new ie({
        keys: [xj(t.address), gj(e), gj(e)],
        programId: mj(yj(t.tokenType)),
        data: Buffer.from([9])
    }))(e, t)),
    {
        feePayer: e,
        instructions: n,
        lookupTableAccounts: []
    }
}
  , XF = e => {
    const t = new Map;
    return t.set(e.token0AtaInfo.mint, e.token0AtaInfo),
    t.set(e.token1AtaInfo.mint, e.token1AtaInfo),
    t
}
  , QF = e => {
    if (e.poolCtx.protocolType in Wc) {
        const t = jF({
            ...e,
            poolCtx: e.poolCtx,
            baseMint: e.txnDef.pair.baseMint
        });
        return ZF(t, e.poolCtx)
    }
    if (!e.auxCtx.validatedPoolPrice)
        throw new hj("Cannot calculate non-cp swap params without validatedPoolPrice",e);
    return RF({
        ...e,
        baseMint: e.txnDef.pair.baseMint,
        validatedPoolPrice: ce(e.auxCtx.validatedPoolPrice)
    })
}
  , ZF = (e, t) => {
    if (t.protocolType !== Rc.RAYDIUM_CP)
        return e;
    const n = {
        [t.poolStatic.token0]: t.poolStatic.realToken0,
        [t.poolStatic.token1]: t.poolStatic.realToken1
    };
    if (!(e.inputMint in n) || !(e.outputMint in n))
        throw new hj("Programming error: invalid remapping",{
            swapParams: e,
            poolCtx: t
        });
    return {
        ...e,
        inputMint: n[e.inputMint],
        outputMint: n[e.outputMint]
    }
}
  , JF = (e, t, n, r) => {
    if (_F(t))
        return ij("protocolType", t.poolCtx, {
            RAYDIUM: () => ({
                feePayer: e,
                instructions: [jW(e, nV(n).address, t.swapParams.minAmountOut)],
                lookupTableAccounts: []
            }),
            RAYDIUM_CLMM: r => ({
                feePayer: e,
                instructions: [DW(e, nV(n).address, t.swapParams.minAmountOut, t.poolAddr, r)],
                lookupTableAccounts: []
            })
        });
    const {poolAddr: a, swapParams: s} = t;
    return ij("protocolType", t.poolCtx, {
        RAYDIUM: t => ( (e, t, n, r, a, s) => {
            const o = Buffer.alloc(17);
            return vj(r) ? (o[0] = 16,
            o.writeBigInt64LE(r.amountIn, 1),
            o.writeBigInt64LE(r.minAmountOut, 9)) : (o[0] = 17,
            o.writeBigInt64LE(r.maxAmountIn, 1),
            o.writeBigInt64LE(r.amountOut, 9)),
            {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj(Jc), xj(e), bj(ud), xj(t.token0Vault), xj(t.token1Vault), xj(a), xj(s), gj(n)],
                    programId: mj(dd),
                    data: o
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n).address, nV(r).address),
        RAYDIUM_CP: t => ( (e, t, n, r, a, s) => {
            const o = "exact-in" === r.type ? t.token1 === r.inputMint : t.token0 === r.outputMint
              , [l,i] = o ? [t.token1Vault, t.token0Vault] : [t.token0Vault, t.token1Vault]
              , c = yj(a.tokenType)
              , d = yj(s.tokenType)
              , u = Buffer.alloc(24);
            return vj(r) ? (u.set(zW, 0),
            u.writeBigInt64LE(r.amountIn, 8),
            u.writeBigInt64LE(r.minAmountOut, 16)) : (u.set($W, 0),
            u.writeBigInt64LE(r.maxAmountIn, 8),
            u.writeBigInt64LE(r.amountOut, 16)),
            {
                feePayer: n,
                instructions: [new ie({
                    keys: [gj(n), bj("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"), bj(t.ammConfig), xj(e), xj(a.address), xj(s.address), xj(l), xj(i), bj(c), bj(d), bj(a.mint), bj(s.mint), xj(t.observationKey)],
                    programId: mj(bd),
                    data: u
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        PUMP_FUN: t => ( (e, t, n, r, a) => Ij(a.inputMint) ? gW(e, t, n, r, a) : xW(e, t, n, r, a))(a, t, rV(n, r), e, s),
        PUMP_SWAP: t => ( (e, t, n, r, a, s) => {
            const {poolStatic: o, isMayhemMode: l} = t
              , i = CW(r, o.token1)
              , [c,d] = r.inputMint === o.token0 ? [a, s] : [s, a]
              , u = AW(o.creator)
              , p = Tj(u, o.token1, d.tokenType)
              , h = l ? "GesfTA3X2arioaHp8bbKdjG9vJtskViWACZoYvxp4twS" : "7hTckgnGnLQR6sdH7YkqFTAA7VwTfYFaZ6EhEsU3saCX"
              , m = Tj(h, o.token1, d.tokenType)
              , g = yj(c.tokenType)
              , x = yj(d.tokenType)
              , b = Buffer.alloc(24);
            b.set(i.ins, 0),
            b.writeBigInt64LE(i.amount, 8),
            b.writeBigInt64LE(i.otherAmountThreshold, 16);
            const f = wW(n)
              , v = [];
            return i.isBuy && v.push(xj("C2aFPdENg4A2HQsmrd5rTw5TaYBX5Ku887cWjbFKtZpw"), xj(f)),
            v.push(bj("5PHirr8joyTMp9JMm6nW7hNDVyEYdkzDqazxPD7RaTjx")),
            v.push(bj(od)),
            {
                feePayer: n,
                instructions: [new ie({
                    keys: [xj(e), gj(n), bj("ADyA8hdefvWN2dbGGWFotbzWxrAvLW83WG6QCVXvJKqw"), bj(o.token0), bj(o.token1), xj(c.address), xj(d.address), xj(o.token0Vault), xj(o.token1Vault), bj(h), xj(m), bj(g), bj(x), bj(Gc), bj(Zc), bj("GS4CU59F31iL7aR2Q8zVS8DRrcRnXX1yjQ66TqNVQnaR"), bj(sd), xj(p), xj(u), ...v],
                    programId: mj(i.program),
                    data: b
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t, e, s, nV(n), nV(r)),
        METEORA_OLD: t => ( (e, t, n, r, a, s) => {
            const o = Buffer.alloc(24);
            if (o.set(rW, 0),
            !vj(r))
                throw new hj("MeteoraOld does not support exact out");
            o.writeBigInt64LE(r.amountIn, 8),
            o.writeBigInt64LE(r.minAmountOut, 16);
            const l = t.token1 === r.inputMint ? t.protocolToken1Fee : t.protocolToken0Fee
              , {token0RealVault: i, token1RealVault: c} = t;
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [xj(e), xj(a.address), xj(s.address), xj(i.addr), xj(c.addr), xj(i.tokenVault), xj(c.tokenVault), xj(i.lpMint), xj(c.lpMint), xj(t.token0Vault), xj(t.token1Vault), xj(l), gj(n), bj("24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"), bj(Jc)],
                    programId: mj(pd),
                    data: o
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        METEORA_DLMM: t => ( (e, t, n, r, a, s) => {
            const o = Buffer.alloc(24);
            vj(r) ? (o.set(Buffer.from(YU), 0),
            o.writeBigInt64LE(r.amountIn, 8),
            o.writeBigInt64LE(r.minAmountOut, 16)) : (o.set(Buffer.from(XU), 0),
            o.writeBigInt64LE(r.maxAmountIn, 8),
            o.writeBigInt64LE(r.amountOut, 16));
            const l = "exact-in" === r.type ? t.poolStatic.token1 === r.inputMint : t.poolStatic.token0 === r.outputMint
              , [i,c] = t.poolStatic.token0 === a.mint ? [a, s] : [s, a]
              , d = yj(i.tokenType)
              , u = yj(c.tokenType)
              , p = ZU(e)
              , h = JU(e, t, l);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [xj(e), bj(md), xj(t.poolStatic.token0Vault), xj(t.poolStatic.token1Vault), xj(a.address), xj(s.address), bj(t.poolStatic.token0), bj(t.poolStatic.token1), xj(p), bj(md), gj(n), bj(d), bj(u), bj(QU()), bj(md), ...h.map(xj)],
                    programId: mj(md),
                    data: o
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t, e, s, nV(n), nV(r)),
        METEORA_CURVE: t => ( (e, t, n, r, a, s) => {
            const o = qU(r)
              , l = Buffer.alloc(24);
            l.set(GU, 0),
            l.writeBigInt64LE(o.amount, 8),
            l.writeBigInt64LE(o.otherAmountThreshold, 16);
            const i = a.mint === t.token0 ? a : s
              , c = yj(i.tokenType);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj("FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"), bj(t.config), xj(e), xj(a.address), xj(s.address), xj(t.token0Vault), xj(t.token1Vault), bj(t.token0), bj(t.token1), gj(n), bj(c), bj(Jc), bj(xd), bj("8Ks12pbrD6PXxfty1hVQiE9sc289zgU1zHkvXhrSdriF"), bj(xd)],
                    programId: mj(xd),
                    data: l
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        BOOP: t => ( (e, t, n, r) => {
            const a = Buffer.alloc(24);
            if (!vj(r))
                throw new hj("Exact-out is not yet supported",{
                    poolAddr: e,
                    params: r
                });
            const {baseMint: s} = t
              , o = r.inputMint !== s;
            a.set(o ? EU : MU, 0),
            a.writeBigInt64LE(r.amountIn, 8),
            a.writeBigInt64LE(r.minAmountOut, 16);
            const l = LU(s)
              , i = DU(s)
              , c = RU(s)
              , d = Tj(n, s, vc.SOLANA_SPL)
              , u = o ? PU() : OU(n);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj(t.baseMint), xj(e), xj(l), xj(i), xj(c), xj(d), gj(n), ...u],
                    programId: mj(gd),
                    data: a
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s),
        LAUNCH_LAB: t => ( (e, t, n, r, a, s) => {
            const o = t.token1
              , l = HU(r, o)
              , i = Buffer.alloc(32);
            i.set(l.ins, 0),
            i.writeBigInt64LE(l.amount, 8),
            i.writeBigInt64LE(l.otherAmountThreshold, 16);
            const [c,d] = a.mint === t.token0 ? [a, s] : [s, a]
              , u = c.address
              , p = d.address
              , h = yj(c.tokenType)
              , m = yj(d.tokenType)
              , g = zU(t.platformConfig, t.token1)
              , x = $U(t.creator, t.token1);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [gj(n), bj("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"), bj(t.globalConfig), bj(t.platformConfig), xj(e), xj(u), xj(p), xj(t.token0Vault), xj(t.token1Vault), bj(t.token0), bj(t.token1), bj(h), bj(m), bj("2DPAtwB8L12vrMRExbLuyGnC7n2J5LNoZQSejeQGpwkr"), bj(fd), bj(Gc), xj(g), xj(x)],
                    programId: mj(fd),
                    data: i
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        METEORA_DAMM_V2: t => ( (e, t, n, r, a, s) => {
            const o = Buffer.alloc(24);
            if (o.set(KU, 0),
            !vj(r))
                throw new hj("MeteoraDammV2 does not support exact out");
            o.writeBigInt64LE(r.amountIn, 8),
            o.writeBigInt64LE(r.minAmountOut, 16);
            const [l,i] = t.token0 === a.mint ? [a, s] : [s, a]
              , c = yj(l.tokenType)
              , d = yj(i.tokenType);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj("HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"), xj(e), xj(a.address), xj(s.address), xj(t.token0Vault), xj(t.token1Vault), bj(t.token0), bj(t.token1), gj(n), bj(c), bj(d), bj(hd), bj("3rmHSu74h1ZcmAisVcWerTCiRDQbUrBKmcwptYGjHfet"), bj(hd)],
                    programId: mj(hd),
                    data: o
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        WHIRLPOOL: t => ( (e, t, n, r, a, s) => {
            const o = t.poolStatic.token0 === a.mint
              , [l,i] = o ? [dF(a, t), dF(s, t)] : [dF(s, t), dF(a, t)]
              , c = Buffer.alloc(43)
              , d = Rj(!0, t)
              , u = o ? d.dividedBy(100) : d.multipliedBy(100)
              , p = BigInt(Dj(u));
            c.set(Buffer.from(uF), 0),
            pj(c, p, 24),
            c[41] = o ? 1 : 0,
            c[42] = 0,
            vj(r) ? (c.writeBigInt64LE(r.amountIn, 8),
            c.writeBigInt64LE(r.minAmountOut, 16),
            c[40] = 1) : (c.writeBigInt64LE(r.amountOut, 8),
            c.writeBigInt64LE(r.maxAmountIn, 16),
            c[40] = 0);
            const h = hF(e)
              , m = pF(e, t, o);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj(l.program), bj(i.program), bj(ld), gj(n), xj(e), bj(l.mint), bj(i.mint), xj(l.ata), xj(l.vault), xj(i.ata), xj(i.vault), xj(m[0]), xj(m[1]), xj(m[2]), xj(h)],
                    programId: mj(cd),
                    data: c
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t, e, s, nV(n), nV(r)),
        RAYDIUM_CLMM: t => ( (e, t, n, r, a, s, o=4) => {
            const l = "exact-in" === r.type ? t.poolStatic.token1 === r.inputMint : t.poolStatic.token0 === r.outputMint
              , i = Buffer.alloc(41)
              , c = Rj(!0, t)
              , d = l ? c.multipliedBy(100) : c.dividedBy(100)
              , u = BigInt(Dj(d));
            i.set(Buffer.from(EW), 0),
            vj(r) ? (i.writeBigInt64LE(r.amountIn, 8),
            i.writeBigInt64LE(r.minAmountOut, 16),
            pj(i, u, 24),
            i[40] = 1) : (i.writeBigInt64LE(r.amountOut, 8),
            i.writeBigInt64LE(r.maxAmountIn, 16),
            pj(i, u, 24),
            i[40] = 0);
            const [p,h] = l ? [t.poolStatic.token1, t.poolStatic.token0] : [t.poolStatic.token0, t.poolStatic.token1]
              , [m,g] = [a, s]
              , [x,b] = l ? [t.poolStatic.token1Vault, t.poolStatic.token0Vault] : [t.poolStatic.token0Vault, t.poolStatic.token1Vault]
              , f = NW(e)
              , v = !vj(r)
              , S = MW(e, t, t.bitmapExtension, l, o, v);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [gj(n), bj(t.config), xj(e), xj(m), xj(g), xj(x), xj(b), xj(t.observationKey), bj(Jc), bj(ed), bj(ld), bj(p), bj(h), xj(f), ...S.map(xj)],
                    programId: mj(id),
                    data: i
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t, e, s, nV(n).address, nV(r).address),
        MOONIT: t => ( (e, t, n, r, a) => {
            const s = Buffer.alloc(33)
              , {baseMint: o} = t
              , l = r.inputMint !== o;
            if (s.set(l ? aW : sW, 0),
            vj(r)) {
                const [e,t] = l ? [r.minAmountOut, r.amountIn] : [r.amountIn, r.minAmountOut];
                s.writeBigInt64LE(e, 8),
                s.writeBigInt64LE(t, 16),
                s.writeUint8(0, 24)
            } else {
                const [e,t] = l ? [r.maxAmountIn, r.amountOut] : [r.amountOut, r.maxAmountIn];
                s.writeBigInt64LE(e, 8),
                s.writeBigInt64LE(t, 16),
                s.writeUint8(1, 24)
            }
            s.writeBigInt64LE(0n, 25);
            const i = Tj(e, o, a.tokenType);
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [gj(n), xj(a.address), xj(e), xj(i), xj("3udvfL24waJcLhskRAsStNMoNUvtyXdxrWQz4hgi953N"), xj("5K5RtTWzzLp4P8Npi84ocf7F1vBsAu29N1irG4iiUnzt"), bj(o), bj("36Eru7v11oU5Pfrojyn5oY3nETA1a1iqsw2WUu6afkM9"), bj(Jc), bj(Zc), bj(Gc)],
                    programId: mj(vd),
                    data: s
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, rV(n, r)),
        HEAVEN: t => {
            const o = nV(n)
              , l = nV(r)
              , i = t.poolStatic.token0 === o.mint ? o : l
              , c = t.poolStatic.token1 === o.mint ? o : l;
            return ( (e, t, n, r, a, s) => {
                const o = Buffer.alloc(28)
                  , l = r.inputMint !== t.token0;
                if (o.set(l ? BU : _U, 0),
                !vj(r))
                    throw new hj("ExactOut is not yet supported");
                o.writeBigInt64LE(r.amountIn, 8),
                o.writeBigInt64LE(r.minAmountOut, 16);
                const i = yj(a.tokenType)
                  , c = yj(s.tokenType);
                return {
                    feePayer: n,
                    instructions: [new ie({
                        keys: [bj(i), bj(c), bj(Zc), bj(Gc), xj(e), gj(n), bj(t.token0), bj(t.token1), xj(a.address), xj(s.address), xj(t.token0Vault), xj(t.token1Vault), xj(t.protocolConfig), bj("Sysvar1nstructions1111111111111111111111111"), bj("HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny"), bj("CH31Xns5z3M1cTAbKW34jcxPPciazARpijcHj9rxtemt")],
                        programId: mj(Sd),
                        data: o
                    })],
                    lookupTableAccounts: []
                }
            }
            )(a, t.poolStatic, e, s, i, c)
        }
        ,
        TOKEN_MILL: t => ( (e, t, n, r, a, s) => {
            const o = cF(r, t.token1)
              , l = Buffer.alloc(25);
            l.set(iF, 0),
            l.writeUint8(o.swapType, 8),
            l.writeBigInt64LE(o.firstArg, 9),
            l.writeBigInt64LE(o.secondArg, 17);
            const [i,c] = t.token0 === a.mint ? [a, s] : [s, a]
              , d = t.feeReserve ?? t.creatorFeePool;
            return {
                feePayer: n,
                instructions: [new ie({
                    keys: [bj(t.config), xj(e), xj(t.token0Vault), xj(i.address), xj(t.token1Vault), xj(c.address), xj(d), xj(t.protocolFeeReserve), xj(t.creatorFeePool), gj(n), bj(yd), bj(Jc), bj("2JtBWhLnkYbE8tn2DT8QXVweeQjnNYr43GbyiKhANdt5"), bj(yd)],
                    programId: mj(yd),
                    data: l
                })],
                lookupTableAccounts: []
            }
        }
        )(a, t.poolStatic, e, s, nV(n), nV(r)),
        SUGAR: () => JW(a, rV(n, r).mint, e, s, "prod"),
        SUGAR_TEST: () => JW(a, rV(n, r).mint, e, s, "test")
    })
}
  , eV = e => ({
    amount: vj(e.swapParams) ? e.swapParams.amountIn : e.swapParams.quotedAmountIn ?? e.swapParams.estAmountIn,
    mint: oV(e.swapParams.inputMint) ? Gc : e.swapParams.inputMint
})
  , tV = e => {
    return _F(e) ? {
        amount: e.swapParams.estAmountOut,
        mint: Gc
    } : {
        amount: (t = e.swapParams,
        "exact-out" === t.type ? e.swapParams.amountOut : e.swapParams.quotedAmountOut ?? e.swapParams.estAmountOut),
        mint: oV(e.swapParams.outputMint) ? Gc : e.swapParams.outputMint
    };
    var t
}
  , nV = e => {
    if ("native" === e)
        throw new hj("Invalid input/output",{
            info: e
        });
    return e
}
  , rV = (e, t) => {
    if ("native" === e)
        return nV(t);
    if ("native" === t)
        return nV(e);
    return jj(e.mint, t.mint).baseCurrency === e.mint ? e : t
}
  , aV = (e, t) => e.baseMint === t.baseCurrency && sV(e.quoteMint, t.quoteCurrency)
  , sV = (e, t) => oV(e) ? oV(t) : e === t
  , oV = e => Ij(e) || e === lV
  , lV = "pSoL47GE52V2bgUUyQvs9LSdWQZsokarp2yNsWQaLYy"
  , iV = "J5XGHmzrRmnYWbmw45DbYkdZAU2bwERFZ11qCDXPvFB5"
  , cV = (e, t) => ({
    feePayer: t,
    instructions: [de.transfer({
        fromPubkey: mj(t),
        toPubkey: mj(iV),
        lamports: e
    })],
    lookupTableAccounts: []
})
  , dV = (e, t) => {
    const n = ( (e, t, n, r) => {
        const a = Buffer.alloc(9);
        return a.writeUInt8(3, 0),
        a.writeBigUInt64LE(r, 1),
        new ie({
            keys: [xj(e), xj(t), gj(n)],
            programId: mj(Jc),
            data: a
        })
    }
    )(Tj(t, e.mint, vc.SOLANA_SPL), Tj(iV, e.mint, vc.SOLANA_SPL), t, e.amount);
    return {
        feePayer: t,
        instructions: [n],
        lookupTableAccounts: []
    }
}
  , uV = "12000000"
  , pV = "1000000"
  , hV = [175, 175, 109, 31, 13, 152, 155, 237]
  , mV = [222, 68, 238, 59, 185, 182, 63, 136]
  , gV = e => {
    const t = bV(e);
    return new ie({
        programId: mj(nd),
        keys: [xj(t), gj(e), bj(Gc)],
        data: Buffer.from(hV)
    })
}
  , xV = (e, t) => {
    const n = Buffer.alloc(10);
    n.set(mV, 0),
    n.writeUInt16LE(t, 8);
    const r = bV(e);
    return new ie({
        programId: mj(nd),
        keys: [xj(r), gj(e)],
        data: n
    })
}
  , bV = e => {
    const [t] = se.findProgramAddressSync([Buffer.from("nonce_account"), mj(e).toBuffer()], mj(nd));
    return t.toString()
}
  , fV = (e, t, n) => {
    const r = IV(t, n);
    if (n <= 0n || !Ij(e.feeAmount.mint))
        return {
            ...e,
            stage: "cashback",
            txnCashbackStage: e.txnPadreFeeStage,
            cashbackAmount: {
                amount: 0n,
                mint: Gc
            }
        };
    const a = (null == r ? void 0 : r.amount) ?? 0n
      , s = (e => {
        const t = de.transfer({
            fromPubkey: mj(e.userWalletAddr),
            toPubkey: mj("DoAsxPQgiyAxyaJNvpAAUb2ups6rbJRdYrCPyWxwRxBb"),
            lamports: e.cashbackLamports
        });
        return {
            feePayer: e.userWalletAddr,
            instructions: [t],
            lookupTableAccounts: []
        }
    }
    )({
        cashbackLamports: a,
        userWalletAddr: e.txnPadreFeeStage.feePayer
    });
    return {
        ...e,
        stage: "cashback",
        txnCashbackStage: fj(e.txnPadreFeeStage, s),
        cashbackAmount: {
            amount: a,
            mint: Gc
        }
    }
}
  , vV = (e, t, n, r) => {
    const a = r || IV(t, n)
      , s = ( (e, t) => e.mint === Gc ? cV(e.amount, t) : dV(e, t))(a, e.txnNonceStage.feePayer);
    return {
        ...e,
        stage: "padre-fee",
        txnPadreFeeStage: fj(e.txnNonceStage, s),
        feeAmount: a
    }
}
  , SV = (e, t, n) => {
    const r = ( (e, t, n) => {
        const r = [];
        return n || r.push(gV(e)),
        r.push(xV(e, t)),
        {
            feePayer: e,
            instructions: r,
            lookupTableAccounts: []
        }
    }
    )(e.txnTipStage.feePayer, t, n);
    return {
        ...e,
        stage: "nonce",
        txnNonceStage: fj(r, e.txnTipStage),
        nonceAccountLamports: n ? 0n : 2074080n,
        nonceU16: t
    }
}
  , yV = (e, t) => {
    const n = ( (e, t, n) => {
        const r = {
            units: Sj[t]
        }
          , a = pe.setComputeUnitLimit(r)
          , s = {
            isSigner: !1,
            isWritable: !1,
            pubkey: new se("jitodontfront11111111111TradeWithPadreDotGg")
        };
        a.keys.push(s);
        const o = Number(n) / r.units
          , l = Math.floor(1e6 * o);
        return {
            feePayer: e,
            instructions: [a, pe.setComputeUnitPrice({
                microLamports: l
            })],
            lookupTableAccounts: []
        }
    }
    )(e.txnZeroStage.feePayer, e.creator.protocol, t);
    return {
        ...e,
        stage: "prio",
        txnPrioStage: fj(n, e.txnZeroStage),
        prioLamportsUsed: t
    }
}
  , kV = (e, t) => TV(e, t, Ad)
  , CV = (e, t) => TV(e, t, wd)
  , AV = (e, t) => TV(e, t, jd)
  , wV = (e, t) => TV(e, t, Td)
  , jV = (e, t) => TV(e, t, Id)
  , TV = (e, t, n) => {
    const r = n[( (e, t=0) => {
        let n = 3735928559 ^ t
          , r = 1103547991 ^ t;
        for (let a, s = 0; s < e.length; s++)
            a = e.charCodeAt(s),
            n = Math.imul(n ^ a, 2654435761),
            r = Math.imul(r ^ a, 1597334677);
        return n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(r ^ r >>> 13, 3266489909),
        r = Math.imul(r ^ r >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909),
        4294967296 * (2097151 & r) + (n >>> 0)
    }
    )(t) % n.length];
    return {
        feePayer: t,
        instructions: [de.transfer({
            fromPubkey: mj(t),
            toPubkey: mj(r),
            lamports: e
        })],
        lookupTableAccounts: []
    }
}
  , IV = ({orderIn: e, orderOut: t}, n) => {
    if (Ij(e.mint))
        return {
            mint: Gc,
            amount: Nj(n, e.amount)
        };
    if (Ij(t.mint))
        return {
            mint: Gc,
            amount: Nj(n, t.amount)
        };
    if (Ej(e.mint))
        return {
            mint: e.mint,
            amount: Nj(n, e.amount)
        };
    if (Ej(t.mint))
        return {
            mint: t.mint,
            amount: Nj(n, t.amount)
        };
    throw new hj("Invalid quote, cannot calculate fee",{
        orderIn: e,
        orderOut: t
    })
}
  , EV = (e, t) => {
    const {gasSettings: n} = e;
    if (!n)
        return [];
    if (J_(n))
        return r = {
            estPriceImpactBps: null,
            estTradeSizeInUsd: null
        },
        np.info("Calculating inferno execution params", {
            args: r
        }),
        [{
            builder: Fc.TEMPORAL,
            tipLamports: uV,
            prioLamports: "8000000",
            slippageBps: 2500,
            mevProtection: !0
        }, {
            builder: Fc.ZERO_SLOT,
            tipLamports: uV,
            prioLamports: pV,
            slippageBps: 700,
            mevProtection: !0
        }, {
            builder: Fc.JITO,
            tipLamports: uV,
            prioLamports: pV,
            slippageBps: 2500,
            mevProtection: !0
        }];
    var r;
    if ("SOLANA" !== n.type)
        return [];
    if ("AUTO" === t.type)
        throw new hj("Auto slippage is no longer supported");
    if (e.customRpc)
        return [{
            builder: {
                customRpcUrl: e.customRpc.url
            },
            mevProtection: !!e.useMevProtection,
            prioLamports: Pj(n.prioInSolUi).toString(),
            tipLamports: Pj(n.tipInSolUi).toString(),
            slippageBps: t.valueBps
        }];
    const a = Pj(n.prioInSolUi)
      , s = dj(a, 1000000n)
      , o = !!e.useMevProtection
      , l = Pj(n.tipInSolUi)
      , i = (c = l) < (d = 1000n) ? d : c;
    var c, d;
    var u;
    return (u = Ed,
    Object.keys(u)).filter((e => i >= Ed[e])).filter((n => NV(e, t, n))).map(( (e, n) => ({
        builder: e,
        mevProtection: o,
        prioLamports: 0 === n ? a.toString() : s.toString(),
        tipLamports: i.toString(),
        slippageBps: t.valueBps
    })))
}
  , MV = e => {
    const {txnDef: t, ctx: n, lutData: r} = e
      , {poolCtx: a, auxCtx: s, ataCtx: o, walletCtx: l, poolAddr: i, userCtx: c} = n
      , {quoteMint: d} = t.pair
      , {adjustedTxnDef: u, preDeducedFeeAmount: p} = ( (e, t, n) => {
        if (Ij(t))
            return {
                adjustedTxnDef: e,
                preDeducedFeeAmount: null
            };
        if (e.side !== xc.BUY)
            return {
                adjustedTxnDef: e,
                preDeducedFeeAmount: null
            };
        if (e.amount.unit !== bc.QUOTE)
            return {
                adjustedTxnDef: e,
                preDeducedFeeAmount: null
            };
        const r = BigInt(e.amount.value)
          , a = Nj(n, r)
          , s = r - a;
        return {
            adjustedTxnDef: {
                ...e,
                amount: {
                    ...e.amount,
                    value: s.toString()
                }
            },
            preDeducedFeeAmount: {
                mint: t,
                amount: a
            }
        }
    }
    )(t, d, c.padreFeeBps)
      , {executionParams: h, nonceToUse: m} = e
      , g = (e => {
        const {txnDef: t, poolCtx: n, auxCtx: r} = e
          , {pair: a} = t
          , {token0: s, token1: o} = Mj(n, a.baseMint)
          , l = jj(s, o);
        if (aV(a, l))
            return [{
                swapParams: QF(e),
                poolAddr: e.poolAddr,
                poolCtx: e.poolCtx
            }];
        if (UF(t)) {
            const {quoteSwap: n, adjustedTxnDef: a} = $F(t, r, l.quoteCurrency);
            return [n, {
                swapParams: QF({
                    ...e,
                    txnDef: a
                }),
                poolAddr: e.poolAddr,
                poolCtx: e.poolCtx
            }]
        }
        if (WF(t)) {
            const t = QF(e);
            if ("exact-in" !== t.type)
                throw new hj("Unexpected swap params type",{
                    args: e,
                    swapParams: t
                });
            const {quoteSwap: n} = HF(r, l.quoteCurrency, e.slippageBps, t.quotedAmountOut ?? t.estAmountOut);
            return [{
                swapParams: t,
                poolAddr: e.poolAddr,
                poolCtx: e.poolCtx
            }, n]
        }
        if (FF(t)) {
            const {quoteSwap: n, adjustedTxnDef: a} = zF(t, r, l.quoteCurrency, e.slippageBps);
            return [{
                swapParams: QF({
                    ...e,
                    txnDef: a
                }),
                poolAddr: e.poolAddr,
                poolCtx: e.poolCtx
            }, n]
        }
        throw new hj("Unsupported order type: buy exact-out",t)
    }
    )({
        txnDef: u,
        poolAddr: i,
        poolCtx: a,
        auxCtx: s,
        slippageBps: h.slippageBps
    })
      , x = ( (e, t, n, r) => {
        const {openTxns: a, closeTxns: s, tokenAccountInfos: o, nativeLamportsForWsolAta: l} = GF(e, t, n)
          , i = e.map((e => JF(t, e, o.get(e.swapParams.inputMint) ?? "native", o.get(e.swapParams.outputMint) ?? "native")));
        return {
            stage: "zero",
            creator: {
                type: "direct",
                protocol: r
            },
            nativeLamportsForWsolAta: l,
            txnZeroStage: fj(...a, ...i, ...s)
        }
    }
    )(g, t.userWalletAddr, o, a.protocolType)
      , b = (e => {
        const t = e.at(0)
          , n = e.at(-1);
        if (!t || !n || _F(t))
            throw new hj("Invalid route",{
                route: e
            });
        return {
            orderIn: eV(t),
            orderOut: tV(n)
        }
    }
    )(g)
      , f = ( (e, t, n) => {
        const {feePayer: r} = e.txnPrioStage;
        if ("string" != typeof t) {
            if (n <= 0n)
                return {
                    ...e,
                    stage: "tip",
                    txnTipStage: e.txnPrioStage,
                    tipLamportsUsed: 0n
                };
            const t = wV(n, r);
            return {
                ...e,
                stage: "tip",
                txnTipStage: fj(e.txnPrioStage, t),
                tipLamportsUsed: n
            }
        }
        let a;
        switch (t) {
        case Fc.NEXTBLOCK_DO_NOT_USE:
            a = kV(n, r);
            break;
        case Fc.TEMPORAL:
            a = CV(n, r);
            break;
        case Fc.ZERO_SLOT:
            a = AV(n, r);
            break;
        case Fc.JITO:
            a = wV(n, r);
            break;
        case Fc.AUGUR:
            a = jV(n, r)
        }
        return {
            ...e,
            stage: "tip",
            txnTipStage: fj(e.txnPrioStage, a),
            tipLamportsUsed: n
        }
    }
    )(yV(x, BigInt(h.prioLamports)), h.builder, BigInt(h.tipLamports))
      , v = SV(f, m, l.isTerminalNonceAccountCreated)
      , S = vV(v, b, c.padreFeeBps, p)
      , y = fV(S, b, c.cashbackBps);
    return {
        feePayer: y.txnCashbackStage.feePayer,
        instructions: y.txnCashbackStage.instructions,
        lookupTableAccounts: [...y.txnCashbackStage.lookupTableAccounts, ...HD(r)]
    }
}
  , NV = (e, t, n) => n !== Fc.AUGUR || (!e.useMevProtection || t.valueBps <= 5e3)
  , PV = new hg(25)
  , OV = e => {
    PV.has(e.orderId) || (PV.set(e.orderId, !0),
    Dm.sendOrderStatusTs(e).catch(( () => {}
    )))
}
  , LV = new hg(25)
  , RV = e => {
    LV.has(e.orderId) || (LV.set(e.orderId, !0),
    Dm.sendOrderStatusTs(e).catch(( () => {}
    )))
}
  , DV = async e => {
    var t, n, r;
    e.request.attribution && (e.request.attribution.clientSentPerf = performance.now());
    const a = await sm.createOrder(e.uid, e.chainId, e.walletAddress, e.request);
    var s;
    return (null == (t = e.request.attribution) ? void 0 : t.clientSentPerf) && (s = {
        orderId: a.orderId,
        uid: e.uid,
        isMobile: R,
        origin: e.origin,
        clientSendHighResTs: null == (r = null == (n = e.request) ? void 0 : n.attribution) ? void 0 : r.clientSentPerf,
        clientReceiveHighResTs: performance.now()
    },
    Dm.sendOrderLatency(s).catch(( () => {}
    ))),
    a
}
  , BV = async (e, t, n, r, a) => {
    if (!n)
        return null;
    const s = performance.now()
      , o = ( (e, t) => {
        const n = ce(t.token0AtaInfo.balance || "0")
          , r = ce(t.token1AtaInfo.balance || "0");
        return {
            base: e.baseCurrency === t.token0AtaInfo.mint ? n : r,
            quote: e.baseCurrency === t.token0AtaInfo.mint ? r : n
        }
    }
    )(t.tradeParams.pair, n.ataCtx)
      , l = ( (e, t, n, r) => {
        let a = n.quantity.value;
        if (!fc(a)) {
            const e = r[n.quantity.unit].multipliedBy(a.pctValue).dividedBy(100);
            a = (a.maxExactValue ? ce.min(a.maxExactValue, e) : e).toFixed(0)
        }
        return {
            userWalletAddr: e,
            side: n.side,
            amount: {
                unit: n.quantity.unit,
                value: a
            },
            pair: t
        }
    }
    )(e, {
        baseMint: t.tradeParams.pair.baseCurrency,
        quoteMint: t.tradeParams.pair.quoteCurrency
    }, t.tradeParams, o)
      , i = EV(t.executionOptions, t.tradeParams.slippage)
      , c = Math.min(Math.floor(65536 * Math.random()), 65535)
      , d = i.map((e => MV({
        nonceToUse: c,
        txnDef: l,
        executionParams: e,
        ctx: n,
        lutData: a
    })))
      , u = performance.now()
      , p = u - s;
    np.info(`[FeSign] Built ${d.length} transactions on FE in ${Math.round(p)}ms`, {
        txnCount: d.length,
        time: p
    });
    const h = await Promise.all(d.map((t => r(e, {
        ...t,
        blockhash: n.blockhash.blockhash
    }))))
      , m = performance.now() - u;
    np.info(`[FeSign] Signed ${d.length} transactions on FE in ${Math.round(m)}ms`, {
        txnCount: d.length,
        time: m
    });
    const g = h.filter(cj);
    if (g.length !== d.length) {
        const e = h.findIndex((e => null === e));
        return np.error("Failed to sign some transactions on FE", {
            firstFailed: d[e]
        }),
        null
    }
    const x = g.map(( (e, t) => {
        const n = i[t];
        return {
            txnHash: e.txnHash,
            signedTxnBase64: e.signedTxnBase64,
            executionParams: n
        }
    }
    ));
    return {
        ctx: n,
        txns: x,
        idempU16: c
    }
}
  , _V = (e, t, n, r, a) => {
    const s = gc(ED(a));
    if (t < 1 || t > s || n < 0 || n >= t)
        throw new Error("Invalid input");
    if (1 === t)
        return e;
    const o = lb(r, {
        min: 0,
        max: 25
    });
    if (0 === o || t > 5)
        return e / t;
    const l = 1 / t
      , i = o / 100 * l
      , c = (t - 1) / 2;
    return Array.from({
        length: t
    }, ( (e, t) => l + i * (t - c)))[n] * e
}
  , UV = y.createContext({
    chainStats: null
})
  , WV = ({children: e}) => {
    var t;
    const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
      , r = y.useCallback((e => n ? rm.subscribeChainStats(e) : {
        unsubscribe: () => {}
    }), [n])
      , a = yx(r);
    return v.jsx(UV.Provider, {
        value: {
            chainStats: a
        },
        children: e
    })
}
  , FV = () => y.useContext(UV)
  , VV = e => {
    const {chainStats: t} = FV()
      , n = y.useMemo(( () => {
        if (!t || !e)
            return null;
        const n = t.perChain[e];
        return n ? n.stats.nativePriceInUsdUi : null
    }
    ), [t, e])
      , [r,a] = y.useState(n);
    return y.useEffect(( () => {
        null !== r && null !== n ? HV(r, n) && a(n) : a(n)
    }
    ), [n, r]),
    r
}
  , HV = (e, t) => Math.abs(e - t) > 1e-4 * Math.min(e, t)
  , zV = () => {
    const {settings: e} = rf();
    return y.useCallback(( (t, n) => {
        if (!e)
            return;
        const r = n === xc.BUY ? t ? e.buySuccessSound : e.buyFailedSound : t ? e.sellSuccessSound : e.sellFailedSound;
        r && nw.play(r, e.tradeSoundVolume ?? 100)
    }
    ), [e])
}
  , $V = y.memo(( () => {
    const {t: e} = we()
      , {settings: t, updateTradeSound: n, updateTradeSoundVolume: r, updateTradeNotificationsDuration: a} = rf()
      , [s,o] = y.useState(!1)
      , [l,i] = y.useState((null == t ? void 0 : t.buySuccessSound) ?? null)
      , c = y.useCallback((e => {
        e || (i(null),
        n(null, xc.BUY, !0))
    }
    ), [n])
      , d = y.useCallback((e => {
        i(e),
        n(e, xc.BUY, !0)
    }
    ), [n])
      , [u,p] = y.useState((null == t ? void 0 : t.buyFailedSound) ?? null)
      , h = y.useCallback((e => {
        e || (p(null),
        n(null, xc.BUY, !1))
    }
    ), [n])
      , m = y.useCallback((e => {
        p(e),
        n(e, xc.BUY, !1)
    }
    ), [n])
      , [g,x] = y.useState((null == t ? void 0 : t.sellSuccessSound) ?? null)
      , b = y.useCallback((e => {
        e || (x(null),
        n(null, xc.SELL, !0))
    }
    ), [n])
      , f = y.useCallback((e => {
        x(e),
        n(e, xc.SELL, !0)
    }
    ), [n])
      , [C,A] = y.useState((null == t ? void 0 : t.sellFailedSound) ?? null)
      , w = y.useCallback((e => {
        e || (A(null),
        n(null, xc.SELL, !1))
    }
    ), [n])
      , j = y.useCallback((e => {
        A(e),
        n(e, xc.SELL, !1)
    }
    ), [n])
      , [T,I] = y.useState(void 0 !== (null == t ? void 0 : t.tradeSoundVolume) ? lb(t.tradeSoundVolume, {
        min: ew,
        max: JA
    }) : 100)
      , E = y.useCallback((e => {
        const t = lb(e, {
            min: ew,
            max: JA
        });
        I(t),
        r(t);
        const n = l ?? u ?? g ?? C ?? $h.RING;
        nw.play(n, t)
    }
    ), [u, l, C, g, r])
      , [M,N] = y.useState(void 0 !== (null == t ? void 0 : t.tradeNotificationsDuration) ? lb(t.tradeNotificationsDuration, {
        min: 1,
        max: 10
    }) : 5)
      , P = y.useCallback((e => {
        const t = lb(e, {
            min: 1,
            max: 10
        });
        N(t),
        a(t)
    }
    ), [a]);
    y.useEffect(( () => {
        t && !s && (void 0 !== t.buySuccessSound && i(t.buySuccessSound),
        void 0 !== t.buyFailedSound && p(t.buyFailedSound),
        void 0 !== t.sellSuccessSound && x(t.sellSuccessSound),
        void 0 !== t.sellFailedSound && A(t.sellFailedSound),
        void 0 !== t.tradeSoundVolume && I(t.tradeSoundVolume),
        o(!0))
    }
    ), [t, s]);
    const O = null === l && null === u && null === g && null === C;
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            variant: "h4",
            children: e("Trading notifications")
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Buy success sound")
            }), v.jsx(ej, {
                idKey: "trading-buy-success-sound",
                soundEffectEnabled: null !== l,
                setSoundEffectEnabled: c,
                selectedSoundEffect: l ?? $h.CORK,
                setSelectedSoundEffect: d,
                volume: T,
                usePopper: !0,
                showName: !0
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Buy failed sound")
            }), v.jsx(ej, {
                idKey: "trading-buy-failed-sound",
                soundEffectEnabled: null !== u,
                setSoundEffectEnabled: h,
                selectedSoundEffect: u ?? $h.CORK,
                setSelectedSoundEffect: m,
                volume: T,
                usePopper: !0,
                showName: !0
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Sell success sound")
            }), v.jsx(ej, {
                idKey: "trading-sell-success-sound",
                soundEffectEnabled: null !== g,
                setSoundEffectEnabled: b,
                selectedSoundEffect: g ?? $h.CORK,
                setSelectedSoundEffect: f,
                volume: T,
                usePopper: !0,
                showName: !0
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Sell failed sound")
            }), v.jsx(ej, {
                idKey: "trading-sell-failed-sound",
                soundEffectEnabled: null !== C,
                setSoundEffectEnabled: w,
                selectedSoundEffect: C ?? $h.CORK,
                setSelectedSoundEffect: j,
                volume: T,
                usePopper: !0,
                showName: !0
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Volume")
            }), v.jsx(jw, {
                valueSuffix: "%",
                Icon: O ? mS : hS,
                iconSize: GV,
                defaultValue: T,
                min: ew,
                max: JA,
                step: 10,
                saveValue: E,
                disabled: O,
                width: 200
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: e("Duration")
            }), v.jsx(jw, {
                valueSuffix: "s",
                Icon: Fk,
                iconSize: GV,
                defaultValue: M,
                min: 1,
                max: 10,
                step: 1,
                saveValue: P,
                width: 200
            })]
        })]
    })
}
))
  , GV = 18
  , qV = () => {
    const {settings: e} = rf();
    return y.useMemo(( () => 1e3 * (void 0 !== (null == e ? void 0 : e.tradeNotificationsDuration) ? lb(e.tradeNotificationsDuration, {
        min: 1,
        max: 10
    }) : 5)), [null == e ? void 0 : e.tradeNotificationsDuration])
}
  , KV = (e, t, n) => {
    if (!t)
        return null;
    if (zb(e))
        return null;
    return (((t.orderPresets || Bx)[Pd.SOLANA] || Bx[Pd.SOLANA])[n] || Bx[Pd.SOLANA][n])[e] || Bx[Pd.SOLANA][n][e]
}
  , YV = 100
  , XV = (e, t, n, r, a, s, o, l, i) => {
    const c = zb(i)
      , d = sB.fromFractionalAmount({
        decimals: kU
    }, t.toString()).getRawAmount().toString()
      , u = vU()
      , p = s ? OB(s, YR.has(Pd.SOLANA)) : [];
    return {
        type: rc.MARKET,
        tradeParams: {
            pair: {
                baseCurrency: n,
                quoteCurrency: r
            },
            side: xc.BUY,
            quantity: {
                unit: bc.QUOTE,
                value: d
            },
            slippage: (null == e ? void 0 : e.slippage) ? {
                type: "MANUAL",
                valueBps: Number((100 * Number(e.slippage)).toFixed(0))
            } : {
                type: "AUTO"
            },
            routingFilters: {
                marketIds: [a]
            }
        },
        executionOptions: {
            gasSettings: c ? {
                type: "SOLBEAST"
            } : {
                type: "SOLANA",
                prioInSolUi: TB((null == e ? void 0 : e.prio) ?? "0"),
                tipInSolUi: !c && (null == e ? void 0 : e.customRpcUrl) ? "0" : TB((null == e ? void 0 : e.tip) ?? "0")
            },
            useMevProtection: !(!c && (null == e ? void 0 : e.customRpcUrl)) && ((null == e ? void 0 : e.mevProtection) ?? void 0),
            ...!c && (null == e ? void 0 : e.customRpcUrl) ? {
                customRpc: {
                    type: "solana",
                    url: e.customRpcUrl
                }
            } : {}
        },
        context: {
            displayedBasePriceInUsd: "",
            displayedBasePriceInQuote: "",
            displayedQuoteToken: r,
            multiWalletId: o,
            multiWalletCount: l,
            rev: Du.SENTRY_RELEASE_HASH,
            selectedPresetName: i
        },
        attribution: {
            clientSentPerf: performance.now()
        },
        ...p.length ? {
            postSuccessHook: {
                orderTriggers: p
            }
        } : {},
        idemp: u
    }
}
  , QV = async e => {
    const {walletAddress: t, marketId: n, fastData: r, baseTokenType: a} = e
      , s = t;
    if (!r)
        return null;
    const o = mg(n);
    if (o.chain !== Pd.SOLANA)
        return null;
    const l = await om.getMarketContext(n);
    if (!l)
        return np.warn("Skipping fast trenches sign, market context not found", {
            marketId: n,
            walletAddress: s
        }),
        null;
    const {token0: i, token1: c} = Mj(l.pool, e.baseMint);
    if (Boolean(tu(i, Pd.SOLANA)) === Boolean(tu(c, Pd.SOLANA)))
        return np.error("Skipping fast trenches sign, 0 or 2 tokens are quote currencies", {
            marketId: n,
            walletAddress: s
        }),
        null;
    const d = ZV(i, e)
      , u = ZV(c, e)
      , {token0Type: p, token1Type: h} = JV(d, a);
    return {
        poolAddr: o.marketAddress,
        blockhash: r.blockhash,
        ataCtx: {
            token0AtaInfo: {
                address: Tj(s, d, p),
                mint: d,
                tokenType: p,
                balance: null,
                transferFeeWithheldAmount: null
            },
            token1AtaInfo: {
                address: Tj(s, u, h),
                mint: u,
                tokenType: h,
                balance: null,
                transferFeeWithheldAmount: null
            },
            token0ReadAtSlot: 0,
            token1ReadAtSlot: 0
        },
        auxCtx: l.aux,
        poolCtx: l.pool,
        userCtx: r.userCtx,
        walletCtx: r.walletCtx
    }
}
  , ZV = (e, t) => tu(e, Pd.SOLANA) ? t.quoteForExecutionCurrency : e
  , JV = (e, t) => { const n = tu(e, Pd.SOLANA);
    return {
        token0Type: n ? vc.SOLANA_SPL : t ?? vc.SOLANA_SPL,
        token1Type: n ? t ?? vc.SOLANA_SPL : vc.SOLANA_SPL
    }
}
  , eH = {
    [Dp.WIDGET]: !1,
    [Dp.INSTA_MOUSE]: !1,
    [Dp.INSTA_HOTKEY]: !1,
    [Dp.TRENCHES]: !0,
    [Dp.WALLET_TRACKER]: !0,
    [Dp.PASTE_CA]: !0,
    [Dp.SEARCH]: !0,
    [Dp.TRENDING]: !0,
    [Dp.PUMP_LIVE]: !0,
    [Dp.WATCHLIST]: !0
}
  , tH = ({children: e}) => {
    const {wallets: t} = UD((e => e))
      , {solBalances: n} = y.useContext(zD)
      , r = y.useMemo(( () => ( (e, t) => e && t ? c.reduce(t, ( (t, n) => {
        const {walletName: r, walletId: a, walletType: s, publicAddress: o} = n;
        if (s !== pc.SOL)
            return t;
        const l = ng(o)
          , i = e[l];
        if (!i || !i[Gc])
            return t;
        const c = i[Gc]
          , d = Number(c) / 10 ** kU;
        return t[l] = {
            address: l,
            name: r,
            walletId: a,
            totalSolBalanceInNative: d
        },
        t
    }
    ), {}) : null)(n, t)), [n, t])
      , a = y.useMemo(( () => r ? !c.isEmpty(r) : null), [r])
      , {selectedWalletsAddresses: s, toggleSelectedWalletAddress: o} = FD(Pd.SOLANA)
      , l = (e => {
        const t = Ax()
          , n = pK()
          , {trackCreatedOrder: r} = hf()
          , a = VV(Pd.SOLANA)
          , s = y.useRef(a);
        y.useEffect(( () => {
            s.current = a
        }
        ), [a]);
        const {showModal: o} = gU()
          , {settings: l} = rf()
          , {getTxnSign: i} = fU()
          , {get: c, getPadreLutData: d, solBalances: u} = y.useContext(zD)
          , p = zV()
          , m = qV()
          , g = yT()
          , {setLastSelectedWalletsPerChain: x} = OD()
          , b = y.useCallback((t => {
            e && x((t => ({
                ...t,
                [Pd.SOLANA]: e
            }))),
            g({
                chain: Pd.SOLANA,
                tokenAddress: t,
                tradePageOrigin: nT.SNACK_TRADE
            })
        }
        ), [g, x, e]);
        return y.useCallback((async ({value: a, baseCurrency: g, baseTokenType: x, poolQuoteCurrency: f, quoteForExecutionCurrency: v, baseSymbol: S, quoteSymbol: y, marketId: k, padreAvatarUrl: C, presetName: A, originWidget: w, exitStrategies: j}) => {
            const T = KV(A, l, xc.BUY)
              , I = {
                value: a,
                baseCurrency: g,
                poolQuoteCurrency: f,
                baseSymbol: S,
                quoteSymbol: y,
                marketId: k,
                originWidget: w,
                selectedWalletsAddressesAmount: e.length,
                presetValues: T
            };
            if (!t || !e || !T && !zb(A) || !l)
                return np.warn("Order hasn't been sent - loading state", {
                    orderInfo: I
                }),
                !1;
            if (a < 0)
                return np.warn("Order hasn't been sent - zero or negative value", {
                    orderInfo: I
                }),
                !1;
            if (!e.length)
                return np.warn("Order hasn't been sent - no wallet selected", {
                    orderInfo: I
                }),
                n({
                    message: pu.noWalletSelected,
                    type: "warning"
                }, "no-wallet-selected"),
                !1;
            try {
                const E = h()
                  , M = e.length
                  , N = e.map(( (r, s) => (async () => {
                    l.multiWalletsTradeDelay && s && await Hu(1e3 * l.multiWalletsTradeDelay * s);
                    const h = _V(a, e.length, s, l.multiWalletsTradeSpread ?? 2, Pd.SOLANA)
                      , N = XV(T, h, g, v, k, j, E, M, A);
                    try {
                        if (eH[w])
                            try {
                                const e = N.tradeParams.pair.baseCurrency
                                  , t = c(r)
                                  , n = await QV({
                                    marketId: k,
                                    baseMint: e,
                                    baseTokenType: x,
                                    quoteForExecutionCurrency: v,
                                    walletAddress: r,
                                    fastData: t
                                })
                                  , a = await BV(r, N, n, i, d());
                                a && (N.signV2 = a)
                            } catch (P) {
                                np.error("Error during FE sign, falling back", {
                                    err: P,
                                    orderInfo: I,
                                    orderValueForThisWallet: h
                                })
                            }
                        f === v || N.signV2 || (np.warn("Order hasn't been sent - moonshot not supported in this widget", {
                            orderInfo: I,
                            orderValueForThisWallet: h
                        }),
                        n({
                            message: pu.moonshotBuysNotSupportedInThisWidget,
                            type: "warning"
                        }, "no-wallet-selected"));
                        const s = DV({
                            uid: t,
                            chainId: Pd.SOLANA,
                            walletAddress: r,
                            request: N,
                            origin: w,
                            marketQuoteToken: f
                        })
                          , l = () => {
                            b(g)
                        }
                        ;
                        if (1 === e.length) {
                            const t = T && !isNaN(Number(T.tip)) ? Number(T.tip) : 0
                              , r = T && !isNaN(Number(T.prio)) ? Number(T.prio) : 0
                              , i = u ? u[ng(e[0])] : null
                              , c = i ? i[Gc] : null
                              , d = c ? Number(c) / 10 ** kU : null
                              , x = null !== d && jU({
                                balanceNative: d,
                                amountInNative: a,
                                tipInNative: t,
                                prioInNative: r
                            });
                            n({
                                onOrderResolve: p,
                                onFill: () => {}
                                ,
                                onOpenSummary: o,
                                orderIdPromise: s,
                                variant: lK.SLIM_ORDER_STATUS,
                                orderSnackDetails: {
                                    customAutoTimeoutDuration: m,
                                    orderType: rc.MARKET,
                                    tradeSide: xc.BUY,
                                    baseSymbol: S,
                                    baseValue: "",
                                    quoteSymbol: y,
                                    quoteValue: isNaN(h) ? "" : UI(LI(h, {
                                        collapseExponent: !0,
                                        symbol: ""
                                    })),
                                    tokenAddress: g,
                                    padreAvatarUrl: C,
                                    chain: Pd.SOLANA,
                                    onRedirectClick: l,
                                    showLowBalanceWarning: x
                                }
                            }, "order-slim-status")
                        }
                        return await s
                    } catch (P) {
                        return np.error("Order hasn't been sent - exception thrown during processing order", {
                            err: P,
                            orderInfo: I
                        }),
                        n({
                            message: uu.unknownError,
                            snackName: pu.createFail,
                            type: "error"
                        }, "error-create-order"),
                        {
                            orderId: ""
                        }
                    }
                }
                )()));
                return e.length > 1 && n({
                    onOrderResolve: p,
                    onFill: () => {}
                    ,
                    orderIdPromises: N,
                    variant: lK.MULTI_ORDER_STATUS,
                    orderSnackDetails: {
                        customAutoTimeoutDuration: m,
                        orderType: rc.MARKET,
                        tradeSide: xc.BUY,
                        baseSymbol: S,
                        baseValue: "",
                        quoteSymbol: y,
                        quoteValue: isNaN(a) ? "" : UI(LI(a, {
                            collapseExponent: !0,
                            symbol: ""
                        })),
                        tokenAddress: g,
                        padreAvatarUrl: C,
                        chain: Pd.SOLANA
                    }
                }, "order-multi-status"),
                r({
                    chain: Pd.SOLANA,
                    specificType: ic.MARKET_BUY,
                    originWidget: w,
                    isMultiWallet: e.length > 1,
                    estimatedUsd: wU({
                        nativePrice: s.current,
                        orderValue: a
                    }),
                    tradePageOrigin: null
                }),
                await Promise.allSettled(N),
                await Hu(YV),
                !0
            } catch (E) {
                np.error("Order hasn't been sent - exception thrown during processing orders", {
                    err: E,
                    orderInfo: I
                }),
                n({
                    message: uu.unknownError,
                    snackName: pu.unknownError,
                    type: "error"
                }, "error-create-unknown-error")
            }
            return !1
        }
        ), [l, t, e, n, r, c, i, d, b, u, p, o, m])
    }
    )(s)
      , i = y.useMemo(( () => ({
        availableWallets: r,
        hasAnyWallet: a,
        selectedWalletsAddresses: s,
        toggleSelectedWalletAddress: o,
        performBuy: l
    })), [r, a, s, o, l]);
    return v.jsx(CD.Provider, {
        value: i,
        children: e
    })
}
  , nH = y.createContext({
    userStats: {
        status: ox.INITIAL
    },
    refresh: async () => {}
});
nH.displayName = "UserStatsContext";
const rH = () => y.useContext(nH)
  , aH = e => "kol" === e.type ? {
    type: "kol",
    feeBps: e.feeBps,
    cashbackBps: e.cashbackBps,
    volumeInUsd: e.volumeInUsd,
    kolName: e.kolName,
    designatedSolRewardsWalletAddress: e.designatedSolRewardsWalletAddress,
    customDiscountBps: e.customDiscountBps,
    customRefShareBps: e.customRefShareBps
} : {
    type: "regular",
    feeBps: e.feeBps,
    cashbackBps: e.cashbackBps,
    volumeInUsd: e.volumeInUsd,
    refCode: e.refCode,
    designatedSolRewardsWalletAddress: e.designatedSolRewardsWalletAddress,
    customDiscountBps: e.customDiscountBps
}
  , sH = () => {
    const {user: e} = VK()
      , [t,n] = y.useState({
        status: ox.INITIAL
    })
      , r = y.useCallback((async () => {
        if (e)
            try {
                const t = await km.getUserStats(e.uid);
                n({
                    status: ox.READY,
                    data: aH(t)
                })
            } catch (fNe) {
                n({
                    status: ox.ERROR
                })
            }
    }
    ), [e]);
    return y.useEffect(( () => {
        let r = !1;
        if (e && t.status !== ox.READY)
            return (async () => {
                try {
                    if (t.status === ox.ERROR && (await Hu(oH),
                    r))
                        return;
                    const a = await km.getUserStats(e.uid);
                    if (r)
                        return;
                    n({
                        status: ox.READY,
                        data: aH(a)
                    })
                } catch (fNe) {
                    if (r)
                        return;
                    n({
                        status: ox.ERROR
                    })
                }
            }
            )(),
            () => {
                r = !0
            }
    }
    ), [t, e]),
    {
        userStats: t,
        refresh: r
    }
}
  , oH = 5e3
  , lH = ({children: e}) => {
    const t = sH();
    return v.jsx(nH.Provider, {
        value: t,
        children: e
    })
}
  , iH = e => {
    const {openModal: t} = KR()
      , [n,r] = Mx(`padreV2-${e}IncludeExitStrategies`, !1)
      , a = y.useCallback(( () => {
        n || t(),
        r((e => !e))
    }
    ), [n, t, r])
      , [s,o] = Mx(`padreV2-solanaTradePreset-${e}`, zR)
      , {settings: l} = rf()
      , i = y.useMemo(( () => KV(s, l, xc.BUY)), [s, l])
      , [c,d] = Mx(`padreV2-solanaTradeButtonValue-${e}`, 0)
      , u = y.useMemo(( () => Number((c ?? 0).toFixed(6))), [c])
      , {selectedWalletsAddresses: p, availableWallets: h} = AD()
      , {userStats: m} = rH()
      , g = y.useMemo(( () => m.status !== ox.READY ? null : m.data.feeBps), [m])
      , x = y.useMemo(( () => {
        if (p.length > 1)
            return !1;
        const e = zb(s);
        if (!h || !p || !c || !i && !e || null === g)
            return null;
        const t = 1 === p.length ? h[p[0]] : null;
        if (!t)
            return null;
        const n = ( ({isInInfernoMode: e, selectedBuyPresetValues: t, buttonValue: n, padreFeeBps: r}) => {
            const a = Number(e ? "0" : (null == t ? void 0 : t.tip) ?? "0")
              , s = Number(e ? "0" : (null == t ? void 0 : t.prio) ?? "0")
              , o = e ? pB : 0;
            return n * (1 + r / 1e4) + gB[Pd.SOLANA] + 2 * xB + a + s + bB + o
        }
        )({
            isInInfernoMode: e,
            selectedBuyPresetValues: i,
            buttonValue: c,
            padreFeeBps: g
        });
        return t.totalSolBalanceInNative < n
    }
    ), [h, c, p, i, g, s]);
    return y.useMemo(( () => ({
        selectedPreset: s,
        setSelectedPreset: o,
        buttonValue: c,
        buttonDisplayValue: u,
        setButtonValue: d,
        insufficientBalance: x,
        includeExitStrategies: n,
        toggleIncludeExitStrategies: a
    })), [u, c, n, x, s, d, o, a])
}
  , cH = ({contextId: e, children: t}) => {
    const n = iH(e);
    return v.jsx($R.Provider, {
        value: n,
        children: t
    })
}
  , dH = ({contextId: e, children: t}) => {
    const n = iH(e);
    return v.jsx(GR.Provider, {
        value: n,
        children: t
    })
}
  , uH = (e=!1) => {
    const t = y.useContext($R)
      , n = y.useContext(GR);
    return y.useMemo(( () => e ? n : t), [e, n, t])
}
  , pH = y.memo(( ({height: e, useExtra: t=!1}) => {
    const {insufficientBalance: n, buttonValue: r, setButtonValue: a} = uH(t)
      , [s,o] = y.useState(null === r ? "" : r.toString());
    y.useEffect(( () => {
        null !== r && o(r.toString())
    }
    ), [r]);
    const l = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e)
          , n = XR(t, hH, null);
        o(n)
    }
    ), [])
      , i = y.useCallback(( () => {
        const e = Number(s);
        isNaN(e) || a(e)
    }
    ), [a, s])
      , c = y.useRef(null)
      , d = y.useCallback(( () => {
        var e;
        null == (e = c.current) || e.focus()
    }
    ), [])
      , u = y.useMemo(( () => v.jsx(We, {
        position: "start",
        onClick: d,
        children: v.jsx(S, {
            alignItems: "center",
            children: v.jsx(ay, {
                size: 14
            })
        })
    })), [d])
      , p = y.useMemo(( () => v.jsx(We, {
        position: "end",
        sx: {
            width: 10
        },
        onClick: d,
        children: v.jsx(S, {
            alignItems: "center",
            children: v.jsx(dk, {
                size: 15
            })
        })
    })), [d])
      , h = y.useMemo(( () => ({
        height: e,
        minWidth: mH,
        maxWidth: mH,
        borderRadius: 1,
        pl: 1,
        border: "none",
        outline: "none",
        "& .MuiOutlinedInput-notchedOutline": {
            display: "none"
        },
        background: "transparent"
    })), [e]);
    return v.jsx(je, {
        error: !!n,
        value: s,
        onChange: l,
        onBlur: i,
        disabled: null === r,
        size: "xsmall",
        placeholder: "0",
        inputProps: gH,
        "data-pseudotype": "numberLike",
        inputMode: "decimal",
        sx: h,
        startAdornment: u,
        endAdornment: p,
        inputRef: c
    })
}
))
  , hH = 3
  , mH = 84
  , gH = {
    style: {
        textAlign: "right"
    },
    inputMode: "decimal",
    sx: {
        mr: -.5,
        ml: -.75,
        mt: "1px"
    }
}
  , xH = y.memo(( ({height: e, useExtra: t=!1, extraMargin: n=!1, tooltipOffset: r}) => {
    const a = D()
      , {exitStrategies: s, isModalOpen: o} = KR()
      , {toggleIncludeExitStrategies: l, includeExitStrategies: i} = uH(t)
      , {t: c} = we()
      , d = y.useMemo(( () => t => ({
        height: e,
        width: 1.15 * e,
        p: 0,
        pb: "1px",
        pr: "15%",
        zIndex: 2,
        transition: "none",
        mt: n ? .25 : "1px",
        minWidth: bH,
        border: "none",
        borderRadius: 0,
        backgroundColor: "transparent",
        "&:focus": {
            border: "none",
            backgroundColor: t.palette.background.buttonDefault
        },
        "&:hover": {
            border: "none",
            backgroundColor: t.palette.background.buttonHover
        }
    })), [e, n]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(GC, {
            offset: r,
            title: o ? "" : i && s.length ? v.jsxs(S, {
                gap: .75,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: c("Exit strategies")
                }), v.jsx(S, {
                    gap: .25,
                    children: s.map(( (e, t) => v.jsxs(S, {
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        gap: 2,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: bD[e.type]
                        }), v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            children: [mD(e) && v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.value",
                                children: `${e.changePct || Ud}%`
                            }), gD(e) && v.jsx(k, {
                                variant: "paragraph3",
                                color: e.side === xc.BUY ? "success.main" : "error.main",
                                children: e.side === xc.BUY ? c("Buy") : c("Sell")
                            }), v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.value",
                                children: `${e.amountPct || Ud}%`
                            })]
                        })]
                    }, t)))
                })]
            }) : c("Exit strategies"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    className: "no-drag",
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: l,
                    sx: d,
                    children: v.jsx(C, {
                        display: "flex",
                        children: v.jsx(yS, {
                            color: i ? a.palette.primary.main : a.palette.text.label
                        })
                    })
                })
            })
        })
    })
}
))
  , bH = 22
  , fH = y.memo(( ({label: e, onClick: t, useFlex: n=!0, typographyColor: r="text.label", width: a=vH, lightHover: s=!1}) => {
    const o = y.useMemo(( () => e => ({
        transition: "none",
        flex: n ? 1 : "none",
        color: r ?? e.palette.text.label,
        p: 0,
        px: n ? 0 : 1,
        minWidth: a,
        width: a,
        height: 28,
        border: "none",
        background: "transparent",
        "&:focus": {
            background: "transparent",
            border: "none"
        },
        "&:hover": {
            background: s ? e.palette.background.hover : e.palette.background.buttonDefault,
            border: "none",
            color: e.palette.text.value
        }
    })), [r, n, a, s]);
    return v.jsx(V, {
        disableRipple: !1,
        variant: "tertiary",
        size: "xxsmall",
        onClick: t,
        sx: o,
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            sx: SH,
            children: e
        })
    })
}
))
  , vH = 33
  , SH = {
    display: "flex",
    alignItems: "center",
    height: 15,
    gap: "1px",
    mt: "1px"
}
  , yH = (e, t=14, n=2, r=!0) => {
    switch (e) {
    case zh.NORMAL:
        return "P1";
    case zh.FAST:
        return "P2";
    case zh.ULTRA:
        return "P3";
    case "Inferno":
        return v.jsx(C, {
            mt: `${n}px`,
            children: r ? v.jsx(Cf, {
                size: t
            }) : v.jsx(Af, {
                size: t,
                color: "inherit"
            })
        })
    }
}
  , kH = y.memo(( ({preset: e, size: t=CH, iconSize: n=AH, fontSize: r=wH, filled: a=!0}) => {
    const s = y.useMemo(( () => n => ({
        width: 1.5 * t,
        height: t,
        alignItems: "center",
        justifyContent: "center",
        display: "flex",
        borderRadius: 0,
        pt: "1px",
        ..."Inferno" === e ? {
            border: a ? `1px solid ${n.palette.originalPrimary.main}` : "none",
            background: a ? n.palette.originalPrimary.background : "transparent"
        } : {
            ...a ? {
                background: n.palette.success.main,
                color: n.palette.success.contrastText,
                border: `1px solid ${n.palette.success.main}99`
            } : {
                color: n.palette.text.value
            }
        }
    })), [e, t, a]);
    return v.jsx(C, {
        display: "flex",
        sx: s,
        children: v.jsx(k, {
            variant: "paragraph3",
            fontSize: r,
            children: yH(e, n)
        })
    })
}
))
  , CH = 26
  , AH = 14
  , wH = 13
  , jH = (e, t, n, r, a, s, o, l) => t ? e.palette.text.disabled : n ? "neutral" === r ? e.palette.text.value : l ? e.palette.background.default : a ? s === rg.INDIGO || o === Xh.INDIGO ? e.palette.background.default : e.palette[r].main : e.palette[r].contrastText ?? e.palette.text.value : e.palette.text.label
  , TH = y.memo(( ({activeItemIndex: e, index: t, isChecked: n, value: r, label: a, color: s="neutral", tooltip: o, allItems: l, isDisabled: i, maxItemWidth: c, minItemWidth: d, size: u, secondaryColors: p=!1, backgroundText: h=!1}) => {
    const {colorSkin: m, defaultThemeSkin: g} = Vb()
      , x = y.useMemo(( () => r => {
        var a, o, u, x, b;
        return {
            maxWidth: c,
            position: "relative",
            zIndex: 0,
            flex: "1 1 1px",
            minWidth: d || 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: jH(r, i, n, s, p, m, g, h),
            cursor: i ? "default" : "pointer",
            transition: "none",
            ...0 === t ? {
                "&:before": {
                    zIndex: -1,
                    position: "absolute",
                    top: "50%",
                    left: 0,
                    transform: `translate(${100 * e}%, -50%)`,
                    content: "''",
                    outline: `${i ? 0 : 1}px solid ${(null == (a = l[e]) ? void 0 : a.color) && "negative" === l[e].color ? r.palette.negative[700] : (null == (o = l[e]) ? void 0 : o.color) && "positive" === l[e].color ? r.palette.positive[700] : r.palette.background.borderMain}`,
                    backgroundColor: i ? r.palette.background.disabled : (null == (u = l[e]) ? void 0 : u.color) && "neutral" !== l[e].color ? p ? r.palette[(null == (x = l[e]) ? void 0 : x.color) || "neutral"].background : r.palette[(null == (b = l[e]) ? void 0 : b.color) || "neutral"].main : r.palette.background.buttonActive,
                    height: "100%",
                    width: "100%",
                    opacity: e < 0 || e > l.length - 1 ? 0 : 1,
                    borderRadius: .5,
                    transition: "none"
                }
            } : {}
        }
    }
    ), [n, e, s, t, l, i, c, d, p, m, g, h]);
    return v.jsx(GC, {
        title: o ?? "",
        children: v.jsxs(C, {
            component: "label",
            sx: x,
            children: [v.jsx(at, {
                value: r,
                sx: EH
            }), v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                fontSize: NH(u),
                color: "inherit",
                fontWeight: 600,
                ...Nu,
                children: a
            })]
        })
    }, r)
}
))
  , IH = y.memo(( ({items: e, size: t="xsmall", maxItemWidth: n, minItemWidth: r, isDisabled: a, useMaxHeight: s=!1, ...o}) => {
    const l = e.findIndex(( ({value: e}) => e === o.value))
      , i = y.useMemo(( () => o => ({
        position: "relative",
        height: MH(t),
        ...s ? {
            maxHeight: MH(t)
        } : {},
        flexGrow: 1,
        display: "flex",
        flexDirection: "row",
        flexWrap: "nowrap",
        gap: 0,
        p: 0,
        border: `1px solid ${a ? o.palette.background.disabled : o.palette.background.borderMain}`,
        borderRadius: 1,
        backgroundColor: a ? o.palette.background.disabled : o.palette.background.buttonDefault,
        maxWidth: n ? n * e.length : void 0,
        minWidth: r ? r * e.length : void 0
    })), [t, s, a, n, e.length, r]);
    return v.jsx(st, {
        sx: i,
        ...o,
        onChange: a ? void 0 : o.onChange,
        children: e.map(( (a, s) => v.jsx(TH, {
            index: s,
            isChecked: a.value === o.value,
            activeItemIndex: l,
            maxItemWidth: n,
            minItemWidth: r,
            size: t,
            allItems: e,
            ...a
        }, s)))
    })
}
))
  , EH = {
    visibility: "hidden",
    position: "absolute",
    zIndex: -1
}
  , MH = e => {
    switch (e) {
    case "xlarge":
        return bu.XLARGE;
    case "small":
        return bu.SMALL;
    case "xxsmall":
        return bu.XXSMALL;
    default:
        return bu.XSMALL
    }
}
  , NH = e => {
    switch (e) {
    case "small":
    case "xsmall":
    case "xxsmall":
        return Au.REGULAR;
    default:
        return Au.LARGE
    }
}
  , PH = Pd.ETH_MAINNET
  , OH = "X_TRACKER"
  , LH = "PORTFOLIO"
  , RH = xc.BUY
  , DH = y.createContext({
    lastViewedChain: PH,
    setLastViewedChain: c.noop,
    lastViewedSide: RH,
    setLastViewedSide: c.noop,
    lastViewedPortfolioTab: LH,
    setLastViewedPortfolioTab: c.noop,
    lastViewedMobileTrackerTab: OH,
    setLastViewedMobileTrackerTab: c.noop
})
  , BH = ({children: e}) => {
    const [t,n] = Mx("padreV2-lastViewedChain", PH)
      , [r,a] = dx("padreV2-lastViewedSide", RH)
      , [s,o] = dx("padreV2-portfolioLastViewedTab", LH)
      , [l,i] = dx("padreV2-trackerMobileLastViewedTab", OH)
      , c = y.useMemo(( () => ({
        lastViewedChain: t,
        setLastViewedChain: n,
        lastViewedSide: [xc.BUY, xc.SELL].includes(r) ? r : RH,
        setLastViewedSide: a,
        lastViewedPortfolioTab: s,
        setLastViewedPortfolioTab: o,
        lastViewedMobileTrackerTab: l,
        setLastViewedMobileTrackerTab: i
    })), [t, s, r, n, o, a, l, i]);
    return v.jsx(DH.Provider, {
        value: c,
        children: e
    })
}
  , _H = () => y.useContext(DH)
  , UH = y.memo(( ({modeKey: e, initialValue: t, saveValue: n}) => {
    const {t: r} = we()
      , [a,s] = y.useState(t)
      , o = NA(e);
    y.useEffect(( () => {
        e !== o && s(t)
    }
    ), [o, e, t]);
    const l = y.useRef()
      , i = y.useCallback(( ({target: {value: e}}) => {
        s(e),
        l.current && clearTimeout(l.current),
        l.current = setTimeout(( () => {
            n(e)
        }
        ), 200)
    }
    ), [n])
      , c = y.useMemo(( () => !!a && !ou.test(a)), [a]);
    return v.jsx(je, {
        value: a,
        onChange: i,
        size: "xsmall",
        placeholder: r("Custom RPC URL"),
        fullWidth: !0,
        error: c,
        inputProps: {
            style: {
                textAlign: "left",
                paddingRight: "6px",
                paddingLeft: "12px"
            }
        }
    })
}
))
  , WH = y.memo(( ({modeKey: e, initialValue: t, saveValue: n, disabled: r=!1}) => {
    const {t: a} = we()
      , [s,o] = y.useState(t)
      , {colorSkin: l, defaultThemeSkin: i} = Vb()
      , c = NA(e);
    y.useEffect(( () => {
        e !== c && o(t)
    }
    ), [e, c, t]);
    const d = y.useRef()
      , u = y.useCallback(( (e, t) => {
        o(t),
        d.current && clearTimeout(d.current),
        d.current = setTimeout(( () => {
            n(t)
        }
        ), 200)
    }
    ), [n]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 2,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: a("MEV Protection")
        }), v.jsx(Ue, {
            disabled: r,
            checked: s && !r,
            size: "small",
            color: r ? "neutral" : s ? "positive" : l === rg.INDIGO || i === Xh.INDIGO ? "neutral" : "negative",
            onChange: u
        })]
    })
}
));
var FH = (e => (e.GWEI = "GWEI",
e.PERCENT = "PERCENT",
e.SOL_ICON = "SOL_ICON",
e.BSC_ICON = "BSC_ICON",
e))(FH || {});
const VH = y.memo(( ({modeKey: e, Icon: t, label: n, max: r, minPrecision: a, suffix: s, saveValue: o, isValidValue: l, initialValue: i, disabled: c=!1}) => {
    const [d,u] = y.useState(i)
      , p = D()
      , h = NA(e);
    y.useEffect(( () => {
        e !== h && u(i)
    }
    ), [h, e, i]);
    const m = y.useRef()
      , g = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e)
          , n = XR(t, a, r ?? null);
        u(n),
        m.current && clearTimeout(m.current);
        const s = Number(n ?? "0");
        isNaN(s) || l && !l(s) || (m.current = setTimeout(( () => {
            o(n)
        }
        ), 200))
    }
    ), [a, r, l, o])
      , x = y.useMemo(( () => {
        const e = Number(d ?? "0");
        return !isNaN(e) && (!l || l(e))
    }
    ), [l, d])
      , b = y.useMemo(( () => v.jsx(We, {
        position: "end",
        sx: {
            maxWidth: s === FH.GWEI ? 30 : 16
        },
        children: v.jsx(S, {
            alignItems: "center",
            children: s === FH.BSC_ICON ? v.jsx(rk, {
                color: c ? p.palette.text.label : p.palette.text.value
            }) : s === FH.SOL_ICON ? c ? v.jsx(Jv, {}) : v.jsx(dk, {}) : v.jsx(k, {
                variant: "paragraph1",
                color: c ? "text.label" : "text.value",
                children: s === FH.PERCENT ? "%" : "Gwei"
            })
        })
    })), [c, s, p])
      , f = y.useMemo(( () => ({
        style: {
            textAlign: "right",
            paddingRight: "0px",
            paddingLeft: "0px"
        },
        inputMode: "decimal"
    })), [])
      , C = y.useMemo(( () => ({
        borderRadius: 0,
        pr: "8px",
        "& .MuiOutlinedInput-notchedOutline": {
            border: "none"
        },
        "&:hover .MuiOutlinedInput-notchedOutline": {
            border: "none"
        },
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
            border: "none"
        }
    })), []);
    return v.jsxs(S, {
        sx: HH,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            py: 1,
            children: [v.jsx(t, {}), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: n
            })]
        }), v.jsx(Ee, {
            flexItem: !0
        }), v.jsx(je, {
            disabled: c,
            value: c ? "0" : d,
            onChange: g,
            size: "xsmall",
            placeholder: "0",
            fullWidth: !0,
            inputProps: f,
            "data-pseudotype": "numberLike",
            inputMode: "decimal",
            error: !x,
            sx: C,
            endAdornment: b
        })]
    })
}
))
  , HH = e => ({
    borderRadius: "4px",
    border: `1px solid ${e.palette.background.borderMain}`,
    alignItems: "center",
    flex: 1,
    maxWidth: 132
})
  , zH = y.memo(( ({chain: e, preset: t, initialSide: n}) => {
    const {t: r} = we()
      , {lastViewedSide: a} = _H()
      , {settings: s, updateOrderPreset: o} = rf()
      , [l,i] = y.useState(n ?? a)
      , c = y.useCallback(( (e, t) => {
        i(t)
    }
    ), [i])
      , [d,u] = y.useMemo(( () => {
        const n = ((null == s ? void 0 : s.orderPresets) || Bx)[e] || Bx[e]
          , r = (n[l] ? {
            ...Bx[e][l],
            ...n[l]
        } : Bx[e][l])[t] ? {
            ...Bx[e][l][t],
            ...n[l][t]
        } : Bx[e][l][t]
          , a = !!r.customRpcUrl && ou.test(r.customRpcUrl);
        return [r, `${e}-${l}-${t}-${a}`]
    }
    ), [null == s ? void 0 : s.orderPresets, e, l, t])
      , p = y.useCallback((t => {
        if (Ld.includes(e))
            return !0;
        const n = !!d.customRpcUrl && ou.test(d.customRpcUrl);
        return !(d.mevProtection && !n) || t >= GH
    }
    ), [e, d.customRpcUrl, d.mevProtection])
      , {updatePrio: h, updateTip: m, updateSlippage: g, updateMev: x, updateRpc: b} = y.useMemo(( () => ({
        updatePrio: n => {
            !n || isNaN(Number(n)) || n.length > $H || o({
                prio: n
            }, e, l, t)
        }
        ,
        updateTip: n => {
            isNaN(Number(n ?? "0")) || n.length > $H || o({
                tip: n ?? "0"
            }, e, l, t)
        }
        ,
        updateSlippage: n => {
            !n || isNaN(Number(n)) || n.length > $H || o({
                slippage: n
            }, e, l, t)
        }
        ,
        updateMev: n => {
            o({
                mevProtection: n
            }, e, l, t)
        }
        ,
        updateRpc: n => {
            n && !ou.test(n) || o({
                customRpcUrl: n ?? null
            }, e, l, t)
        }
    })), [o, e, l, t])
      , f = y.useMemo(( () => !!d.customRpcUrl && ou.test(d.customRpcUrl)), [d.customRpcUrl])
      , k = y.useMemo(( () => [{
        value: xc.BUY,
        color: "positive",
        label: r("Buy Settings"),
        secondaryColors: !0
    }, {
        value: xc.SELL,
        color: "negative",
        label: r("Sell Settings"),
        secondaryColors: !0
    }]), [r])
      , {prioLimit: C, tipLimit: A} = y.useMemo(( () => EB(e)), [e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(IH, {
            size: "xsmall",
            value: l,
            onChange: c,
            items: k
        }), v.jsxs(S, {
            direction: "row",
            gap: 2,
            justifyContent: "center",
            children: [v.jsx(VH, {
                modeKey: u,
                Icon: wy,
                label: r("Prio"),
                minPrecision: e === Pd.SOLANA ? 5 : 2,
                suffix: e === Pd.SOLANA ? FH.SOL_ICON : FH.GWEI,
                saveValue: h,
                initialValue: d.prio ?? "",
                max: C
            }), (Od.includes(e) || Ld.includes(e)) && v.jsx(VH, {
                disabled: !d.mevProtection && Ld.includes(e),
                modeKey: u,
                Icon: _k,
                label: r("Tip"),
                minPrecision: 4,
                suffix: e === Pd.SOLANA ? FH.SOL_ICON : FH.BSC_ICON,
                saveValue: m,
                isValidValue: p,
                initialValue: d.tip ?? "",
                max: A
            }), v.jsx(VH, {
                modeKey: u,
                Icon: Uk,
                label: r("Slippage"),
                minPrecision: 2,
                suffix: FH.PERCENT,
                max: 100,
                saveValue: g,
                initialValue: d.slippage ?? ""
            })]
        }), Dd.includes(e) && v.jsx(WH, {
            modeKey: u,
            initialValue: d.mevProtection ?? !1,
            saveValue: x,
            disabled: f
        }), Bd.includes(e) && v.jsx(UH, {
            modeKey: u,
            initialValue: d.customRpcUrl ?? "",
            saveValue: b
        })]
    })
}
))
  , $H = 20
  , GH = .001
  , qH = ({title: e, subtitle: t, children: n}) => v.jsxs(S, {
    p: 2,
    gap: 2,
    sx: KH,
    children: [(e || t) && v.jsxs(S, {
        gap: 1,
        children: [e && v.jsx(k, {
            variant: "h3",
            children: e
        }), t && v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: t
        })]
    }), n]
})
  , KH = e => ({
    backgroundColor: "background.secondary",
    borderRadius: 1,
    border: `1px solid ${e.palette.background.borderMain}`
})
  , YH = y.memo(( () => {
    const {t: e} = we();
    return v.jsx(qH, {
        children: v.jsx(S, {
            gap: 2.5,
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: e("Inferno mode sends your transaction to multiple top-tier Solana builders. Priority fee, tip and slippage are set automatically.")
            })
        })
    })
}
))
  , XH = y.memo(( ({chain: e, initialSide: t, initialPreset: n=zh.NORMAL, setSelectedPreset: r}) => {
    const a = D()
      , {t: s} = we()
      , [o,l] = y.useState(n)
      , i = y.useCallback(( (t, n) => {
        e !== Pd.SOLANA && "Inferno" === n || (l(n),
        r && r(n))
    }
    ), [e, r]);
    return v.jsxs(S, {
        gap: 2,
        children: [v.jsxs(ot, {
            value: o,
            onChange: i,
            children: [v.jsx(lt, {
                label: s("Preset 1"),
                value: zh.NORMAL
            }), v.jsx(lt, {
                label: s("Preset 2"),
                value: zh.FAST
            }), v.jsx(lt, {
                label: s("Preset 3"),
                value: zh.ULTRA
            }), $b.includes(e) && v.jsx(lt, {
                label: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    children: [v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: "Inferno"
                    }), v.jsx(Cf, {
                        color: a.palette.primary.main
                    })]
                }),
                value: "Inferno"
            })]
        }), "Inferno" === o ? v.jsx(S, {
            alignItems: "center",
            pt: 1,
            height: 199,
            children: v.jsx(YH, {})
        }) : v.jsx(zH, {
            chain: e,
            preset: o,
            initialSide: t
        })]
    })
}
))
  , QH = y.memo(( ({onClose: e, chain: t, side: n, preset: r, setSelectedPreset: a}) => {
    const {t: s} = we()
      , {settings: o} = rf();
    return o ? v.jsxs(S, {
        gap: 1.5,
        children: [v.jsxs(S, {
            justifyContent: "space-between",
            alignItems: "center",
            direction: "row",
            children: [v.jsx(k, {
                variant: "h1",
                color: "text.value",
                children: s("Edit {{chain}} Presets", {
                    chain: ez[t]
                })
            }), v.jsx(F, {
                onClick: e,
                sx: JH,
                children: v.jsx(gy, {
                    size: ZH - 4
                })
            })]
        }), v.jsx(XH, {
            chain: t,
            initialSide: n,
            initialPreset: r,
            setSelectedPreset: a
        })]
    }) : v.jsx(S, {
        height: 250,
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(Km, {})
    })
}
))
  , ZH = 24
  , JH = {
    p: .25,
    height: ZH,
    width: ZH
}
  , ez = {
    [Pd.BSC]: "BSC",
    [Pd.ETH_MAINNET]: "Ethereum",
    [Pd.BASE]: "Base",
    [Pd.SOLANA]: "Solana"
}
  , tz = y.memo(( ({isOpen: e, onClose: t, chain: n, side: r, preset: a, setSelectedPreset: s}) => xw() ? e ? v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: nz,
    children: v.jsx(QH, {
        onClose: t,
        chain: n,
        side: r,
        preset: a,
        setSelectedPreset: s
    })
}) : null : v.jsx(_R, {
    "data-testid": "quick-preset-edit-drawer",
    anchor: "bottom",
    open: e,
    onOpen: c.noop,
    onClose: t,
    disableSwipeToOpen: !0,
    keepMounted: !1,
    sx: rz,
    ModalProps: az,
    children: v.jsx(jR, {
        isOpen: e,
        hideHandle: !0,
        children: v.jsx(QH, {
            onClose: t,
            chain: n,
            side: r,
            preset: a,
            setSelectedPreset: s
        })
    })
})))
  , nz = {
    p: 3
}
  , rz = {
    zIndex: 1299
}
  , az = {
    sx: {
        zIndex: Vw
    }
}
  , sz = y.memo(( ({preset: e, presetValues: t}) => {
    const n = D();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        children: [v.jsx(kH, {
            preset: e,
            size: 22,
            iconSize: 16,
            filled: !1
        }), t ? v.jsx(C, {
            display: "flex",
            mt: "-4px",
            children: v.jsx(gM, {
                presetValues: t,
                isTooltip: !1,
                chain: Pd.SOLANA
            })
        }) : v.jsx(k, {
            variant: "paragraph1",
            color: n.palette.originalPrimary.main,
            children: "Inferno" === e ? "Inferno mode" : ""
        })]
    })
}
))
  , oz = y.memo(( ({height: e, useExtra: t=!1, tooltipOffset: n}) => {
    const {setSelectedPreset: r, selectedPreset: a} = uH(t)
      , {t: s} = we()
      , o = D()
      , {settings: l} = rf()
      , [i,c] = y.useState(!1)
      , d = y.useCallback(( () => {
        c(!0)
    }
    ), [])
      , u = y.useCallback(( () => {
        c(!1)
    }
    ), [])
      , p = y.useMemo(( () => (((null == l ? void 0 : l.orderPresets) || Bx)[Pd.SOLANA] || Bx[Pd.SOLANA])[xc.BUY] || Bx[Pd.SOLANA][xc.BUY]), [l])
      , h = y.useMemo(( () => ({
        sx: e => ({
            color: e.palette.background.borderSubtle
        }),
        PaperProps: {
            className: "padre-no-scroll",
            style: {
                backgroundColor: o.palette.background.secondary
            },
            sx: e => ({
                border: `1px solid ${e.palette.background.borderSubtle}`,
                boxShadow: "none",
                py: 0,
                "& .MuiList-padding": {
                    paddingTop: 0,
                    paddingBottom: 0
                }
            })
        }
    })), [o.palette.background.secondary])
      , m = y.useMemo(( () => s("Quick trade preset")), [s])
      , g = y.useCallback(( () => v.jsx(GC, {
        title: m,
        offset: n,
        children: v.jsx(S, {
            width: "100%",
            height: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(kH, {
                preset: a,
                size: e,
                iconSize: 16,
                filled: !1
            })
        })
    })), [a, e, m, n])
      , x = y.useMemo(( () => t => ({
        "& .MuiOutlinedInput-notchedOutline": {
            border: "none"
        },
        "&.Mui-focused": {
            border: "none",
            "& .MuiOutlinedInput-notchedOutline": {
                border: "none"
            }
        },
        "& .MuiOutlinedInput-input": {
            borderRadius: 0,
            p: 0,
            pr: "0px !important",
            "&:hover": {
                background: t.palette.background.buttonHover
            },
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
        },
        width: 1.2 * (e - 2),
        height: e - 2,
        border: "none",
        outline: "none",
        "&.Mui-disabled": {
            border: "none"
        },
        borderRadius: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "transparent"
    })), [e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(it, {
            disabled: !l,
            size: "xsmall",
            sx: x,
            IconComponent: cz,
            MenuProps: h,
            value: a,
            renderValue: g,
            children: [iz.map((e => {
                const t = "Inferno" !== e ? p[e] : null;
                return v.jsx(te, {
                    disableTouchRipple: !0,
                    disableRipple: !0,
                    value: e,
                    sx: lz,
                    onClick: t => {
                        t.stopPropagation(),
                        t.preventDefault(),
                        r(e)
                    }
                    ,
                    children: v.jsx(sz, {
                        presetValues: t,
                        preset: e
                    })
                }, e)
            }
            )), v.jsx(te, {
                disableTouchRipple: !0,
                disableRipple: !0,
                sx: lz,
                onClick: d,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1.5,
                    pl: .25,
                    children: [v.jsx(Ny, {
                        size: 16
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        children: "Edit presets"
                    })]
                })
            })]
        }), v.jsx(tz, {
            isOpen: i,
            onClose: u,
            chain: Pd.SOLANA,
            side: xc.BUY,
            preset: a ?? zh.NORMAL,
            setSelectedPreset: r
        })]
    })
}
))
  , lz = e => ({
    maxWidth: 335,
    px: .75,
    height: 35,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderSubtle}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , iz = [zh.NORMAL, zh.FAST, zh.ULTRA, "Inferno"]
  , cz = () => null
  , dz = y.memo(( ({height: e=pz, useExtra: t=!1, tooltipOffset: n}) => {
    const {t: r} = we()
      , a = y.useMemo(( () => uz(e)), [e]);
    return v.jsxs(S, {
        sx: a,
        direction: "row",
        alignItems: "center",
        height: e,
        children: [v.jsx(GC, {
            title: r("Quick trade amount"),
            offset: n,
            children: v.jsx(S, {
                children: v.jsx(pH, {
                    height: e,
                    useExtra: t
                })
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical"
        }), v.jsx(oz, {
            height: e,
            useExtra: t,
            tooltipOffset: n
        }), v.jsx(xH, {
            height: e,
            useExtra: t,
            extraMargin: e > pz,
            tooltipOffset: n
        })]
    })
}
))
  , uz = e => t => ({
    border: `1px solid ${t.palette.background.borderMain}`,
    borderRadius: e / 2,
    overflow: "hidden"
})
  , pz = 28;
var hz = (e => (e.BEST_MATCH = "BEST_MATCH",
e.LIQUIDITY = "LIQUIDITY",
e.VOLUME = "VOLUME",
e.MARKET_CAP = "MARKET_CAP",
e))(hz || {});
const mz = e => e.info.marketId
  , gz = y.createContext({
    history: [],
    saveInHistory: O,
    removeFromHistory: O,
    searchBarBlurRef: null,
    setSearchBarBlur: O
});
gz.displayName = "SearchHistoryContext";
const xz = ct([e => T(e, "ts", "desc"), e => dt(e, (e => mz(e))), e => ut(e, 15), e => pt(e)])
  , bz = ({children: e}) => {
    const [t,n] = dx("padre-searchHistoryStorageKey", [])
      , r = y.useRef(O)
      , a = y.useCallback((e => {
        r.current = e
    }
    ), [])
      , s = y.useMemo(( () => pt(t.map((e => ({
        ...e.info,
        seenAtTs: e.ts
    }))))), [t])
      , o = y.useCallback((e => {
        n((t => xz([{
            ts: i().unix(),
            info: e
        }, ...t])))
    }
    ), [n])
      , l = y.useCallback((e => {
        n((t => t.filter((t => mz(t) !== e))))
    }
    ), [n])
      , c = y.useMemo(( () => ({
        history: s,
        saveInHistory: o,
        removeFromHistory: l,
        searchBarBlurRef: r,
        setSearchBarBlur: a
    })), [s, o, l, a]);
    return v.jsx(gz.Provider, {
        value: c,
        children: e
    })
}
  , fz = () => y.useContext(gz)
  , vz = (e, t=!1) => {
    if (!e)
        return null;
    switch (e) {
    case Pd.ETH_MAINNET:
        return t ? Yv : sk;
    case Pd.BASE:
        return t ? Xv : nk;
    case Pd.BSC:
        return t ? rk : ak;
    case Pd.ARBITRUM:
        return t ? Zv : lk;
    case Pd.SOLANA:
        return t ? Jv : dk;
    case Pd.ETH_SEPOLIA:
        return t ? Qv : ck
    }
    return null
}
  , Sz = ({chain: e, size: t=yz, chainBorder: n=!1, grayOut: r=!1}) => {
    const a = vz(e, r)
      , s = y.useMemo(( () => ({
        outline: n && e ? `1px solid ${d_(e)}` : "none",
        borderRadius: "50%",
        width: t,
        height: t
    })), [e, n, t]);
    return a ? v.jsx(S, {
        sx: s,
        children: v.jsx(a, {
            size: t
        })
    }) : v.jsx(Ie, {
        variant: "circular",
        width: t,
        height: t
    })
}
  , yz = 16
  , kz = y.memo(( ({chain: e, marketId: t, tokenAddress: n, name: r, symbol: a, onClickCallback: s}) => {
    const o = yT()
      , {removeFromHistory: l} = fz()
      , i = y.useCallback((t => {
        0 !== t.button || t.metaKey || t.ctrlKey || (t.preventDefault(),
        t.stopPropagation(),
        o({
            chain: e,
            tokenAddress: n,
            tradePageOrigin: nT.SEARCH_RECENTS
        }),
        s())
    }
    ), [e, n, o, s])
      , c = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        l(t)
    }
    ), [t, l])
      , d = y.useCallback((e => ({
        gap: 1,
        cursor: "pointer",
        textDecoration: "none",
        color: e.palette.text.value,
        transition: "200ms ease-in-out",
        "&:hover": {
            color: e.palette.text.main
        }
    })), []);
    return v.jsx(S, {
        py: .25,
        sx: Ez,
        children: v.jsxs(S, {
            component: "a",
            href: QE(t, nT.SEARCH_RECENTS),
            direction: "row",
            alignItems: "center",
            onClick: i,
            sx: d,
            children: [v.jsx(b_, {
                url: IE(e, n),
                padreAvatarSize: null,
                name: r ?? a ?? "?",
                size: Az,
                markerIcon: v.jsx(Sz, {
                    chain: e,
                    size: wz
                }),
                markerSize: wz,
                chain: e,
                protocolInfo: null,
                alwaysShowBorder: !0,
                alwaysShowPointer: !0,
                hideHoverAvatar: !0
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .25,
                children: [v.jsx(GC, {
                    title: r,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        color: "inherit",
                        sx: {
                            maxWidth: jz
                        },
                        noWrap: !0,
                        children: a
                    })
                }), v.jsx(F, {
                    onClick: c,
                    sx: Cz,
                    className: Iz,
                    children: v.jsx(wS, {
                        size: Tz
                    })
                })]
            })]
        })
    })
}
))
  , Cz = {
    display: "flex",
    transition: "200ms ease-in-out",
    opacity: R ? 1 : 0,
    p: .25,
    mt: "-1px"
}
  , Az = 18
  , wz = 10
  , jz = 80
  , Tz = 14
  , Iz = "recent-history-item-remove-button"
  , Ez = {
    "&:hover": {
        [`.${Iz}`]: {
            opacity: 1
        }
    }
}
  , Mz = y.memo(( ({selectedChain: e, onClose: t}) => {
    const {history: n} = fz()
      , {t: r} = we()
      , a = y.useMemo(( () => ( (e, t) => e.filter((e => "ALL_NETWORKS" === t || e.chain === t)).map((e => ({
        chain: e.chain,
        marketId: e.marketId,
        tokenAddress: e.baseAddress,
        name: e.baseName,
        symbol: e.baseSymbol
    }))))(n, e)), [n, e]);
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        alignItems: "center",
        sx: Nz,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: r("Recents")
        }), v.jsx(S, {
            className: "padre-no-scroll",
            direction: "row",
            overflow: "scroll",
            sx: Pz,
            children: a.map((e => v.jsx(kz, {
                ...e,
                onClickCallback: t
            }, `${e.marketId}-${e.chain}`)))
        })]
    })
}
))
  , Nz = {
    gap: {
        xs: 1,
        md: 1.5
    },
    height: 22
}
  , Pz = {
    pl: .25,
    gap: {
        xs: 1.75,
        md: .75
    }
}
  , Oz = y.memo(( ({chain: e, setChain: t}) => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    sx: Lz,
    children: Rz.map((n => {
        const r = e === n
          , a = _z(n, r);
        return v.jsx(F, {
            onClick: () => {
                t(n)
            }
            ,
            sx: Bz,
            children: v.jsx(a, {
                size: Dz - (n === Pd.SOLANA || n === Pd.BSC ? 6 : 12),
                color: n === Pd.ETH_MAINNET && r ? d_(n) : void 0
            })
        }, n)
    }
    ))
})))
  , Lz = {
    gap: .5,
    ml: {
        xs: -1.25,
        md: -1
    }
}
  , Rz = [Pd.ETH_MAINNET, Pd.BASE, Pd.SOLANA, Pd.BSC]
  , Dz = 32
  , Bz = {
    p: .25,
    height: Dz,
    width: Dz
}
  , _z = (e, t) => {
    switch (e) {
    case Pd.SOLANA:
        return t ? dk : Jv;
    case Pd.BASE:
        return t ? nk : Xv;
    case Pd.ETH_MAINNET:
        return Df;
    case Pd.BSC:
        return t ? ak : rk;
    default:
        return yk
    }
}
  , Uz = y.memo(( ({selectedSort: e, setSelectedSort: t}) => {
    const {t: n} = we();
    return v.jsx(v.Fragment, {
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .75,
            children: [v.jsx(k, {
                variant: "h2",
                fontWeight: 400,
                color: "text.label",
                children: n("Sort by")
            }), v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                mt: .25,
                children: Wz.map(( ({sort: r, Icon: a, tooltipTitle: s}) => {
                    const o = r === e;
                    return v.jsx(Fz, {
                        isSelected: o,
                        onClick: () => {
                            t(r)
                        }
                        ,
                        tooltipTitle: n(s),
                        Icon: a
                    }, r)
                }
                ))
            })]
        })
    })
}
))
  , Wz = [{
    sort: hz.BEST_MATCH,
    Icon: Nk,
    tooltipTitle: "Best Match"
}, {
    sort: hz.MARKET_CAP,
    Icon: e => v.jsx(mf, {
        icon: La,
        isFill: !0,
        ...e
    }),
    tooltipTitle: "Market Cap"
}, {
    sort: hz.VOLUME,
    Icon: my,
    tooltipTitle: "Volume 1H"
}, {
    sort: hz.LIQUIDITY,
    Icon: Wf,
    tooltipTitle: "Liquidity"
}]
  , Fz = y.memo(( ({isSelected: e, onClick: t, tooltipTitle: n, Icon: r}) => {
    const a = y.useMemo(( () => t => ({
        p: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        border: "none",
        color: e ? t.palette.primary.main : t.palette.text.value,
        background: "transparent",
        "&:hover, &:focus": {
            border: "none",
            background: "transparent",
            color: e ? t.palette.primary.main : t.palette.text.value
        }
    })), [e]);
    return v.jsx(GC, {
        title: n,
        children: v.jsx(C, {
            display: "flex",
            children: v.jsx(V, {
                onClick: t,
                variant: "tertiary",
                size: "xxsmall",
                sx: a,
                children: v.jsx(r, {
                    color: "inherit",
                    size: Vz
                })
            })
        })
    })
}
))
  , Vz = 16
  , Hz = e => {
    switch (e) {
    case "boop":
        return Xk;
    case "fourmeme":
        return ry;
    case "launchlab":
        return Hk;
    case "pumpfun":
        return Lk;
    case "vista":
        return Xy;
    case "wagmi":
        return Ik;
    case "meteora-curve":
        return xC;
    case "bonk":
        return eC;
    case "tvt":
        return fC;
    case "believe":
        return hC;
    case "sugar":
        return rC;
    case "moonit":
        return cC;
    case "heaven":
        return sC;
    case "token-mill":
        return lC;
    case "moonshot":
        return uC;
    case "bags":
        return $k;
    case "jup":
        return Kk;
    default:
        return null
    }
}
  , zz = y.memo(( ({label: e, Icon: t, isSelected: n, color: r, onClick: a, disabled: s}) => {
    const o = y.useMemo(( () => ({
        borderRadius: "12px",
        height: 24,
        dispaly: "flex",
        alignItems: "center",
        py: 0,
        pr: .75,
        pl: .5,
        gap: .25,
        color: r,
        background: !n || s ? "none" : `${r}20`,
        border: `1px solid ${r}80`,
        opacity: !n || s ? .3 : 1,
        ...s ? {} : n ? {
            "&:hover, &:focus": {
                color: Me(r, .05),
                background: `${r}30`,
                border: `1px solid ${r}A0`,
                opacity: 1
            }
        } : {
            "&:hover, &:focus": {
                border: `1px solid ${r}80`,
                background: `${r}10`,
                opacity: .4
            }
        }
    })), [r, s, n]);
    return v.jsx(C, {
        display: "flex",
        children: v.jsxs(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: o,
            onClick: a,
            disabled: s,
            children: [t && v.jsx(C, {
                display: "flex",
                className: Gz,
                children: v.jsx(t, {
                    size: $z
                })
            }), v.jsx(k, {
                color: "inherit",
                variant: "paragraph1",
                noWrap: !0,
                height: 14,
                mt: "1px",
                children: e
            })]
        })
    })
}
))
  , $z = 14
  , Gz = "launchpad-control-button-icon"
  , qz = y.memo(( ({launchpadsOrdered: e, toggleLaunchpad: t, selectedLaunchpads: n, disabled: r=!1}) => {
    const a = D()
      , s = xw()
      , o = y.useMemo(( () => e.map((e => {
        const [t] = RM(!1, e, null, a)
          , n = Hz(e);
        switch (e) {
        case "meteora-curve":
            return {
                label: "Dynamic BC",
                value: e,
                Icon: n,
                color: t
            };
        case "launchlab":
            return {
                label: "LaunchLab",
                value: e,
                Icon: n,
                color: t
            };
        case "believe":
            return {
                label: "Believe",
                value: e,
                Icon: n,
                color: t
            };
        case "bags":
            return {
                label: "Bags",
                value: e,
                Icon: n,
                color: t
            };
        case "jup":
            return {
                label: "Jupiter",
                value: e,
                Icon: n,
                color: t
            };
        case "sugar":
            return {
                label: "Sugar",
                value: e,
                Icon: n,
                color: t
            };
        case "moonit":
            return {
                label: "Moonit",
                value: e,
                Icon: n,
                color: t
            };
        case "heaven":
            return {
                label: "Heaven",
                value: e,
                Icon: n,
                color: t
            };
        case "token-mill":
            return {
                label: "Token Mill",
                value: e,
                Icon: n,
                color: t
            };
        default:
            return {
                label: ht(e),
                value: e,
                Icon: n,
                color: t
            }
        }
    }
    ))), [e, a]);
    return v.jsx(S, {
        display: "grid",
        gridTemplateColumns: s ? "repeat(3, 1fr)" : "repeat(2, 1fr)",
        width: "100%",
        rowGap: 1.25,
        columnGap: .25,
        children: o.map((e => {
            const a = n[e.value] ?? !1;
            return v.jsx(zz, {
                label: e.label,
                isSelected: a,
                onClick: () => {
                    t(e.value)
                }
                ,
                disabled: r,
                Icon: e.Icon ?? void 0,
                color: e.color
            }, e.value)
        }
        ))
    })
}
))
  , Kz = ["pumpfun", "boop", "meteora-curve", "launchlab", "bonk", "believe", "moonshot", "bags", "jup", "moonit", "sugar", "heaven", "token-mill"]
  , Yz = y.memo(( ({selectedLaunchpads: e, setSelectedLaunchpads: t, chain: n, launchpadOnlyFilter: r, toggleLaunchpadOnlyFilter: a, nativeFilter: s, toggleNativeFilter: o, migratedOnlyFilter: l, toggleMigratedOnlyFilter: i}) => {
    const {t: d} = we()
      , u = D()
      , p = xw()
      , {buttonProps: h, popoverProps: m} = Fw({
        id: "search-filter"
    })
      , g = y.useCallback((e => {
        t((t => t.some((t => t === e)) ? [...t].filter((t => t !== e)) : [...t, e]))
    }
    ), [t])
      , x = y.useMemo(( () => c.reduce(e, ( (e, t) => (e[t] = !0,
    e)), {})), [e])
      , b = y.useMemo(( () => e.length === Kz.length), [e])
      , f = y.useCallback(( () => {
        t(b ? [] : Kz)
    }
    ), [b, t])
      , A = y.useMemo(( () => v.jsx(ee, {
        elevation: 0,
        className: "padre-no-scroll",
        sx: e => ({
            background: e.palette.background.secondary,
            width: {
                xs: "100%",
                sm: n === Pd.SOLANA ? n$ : 135
            },
            height: {
                sx: "100%",
                sm: void 0
            },
            maxHeight: "100%",
            overflow: "scroll",
            border: {
                xs: "none",
                sm: `1px solid ${e.palette.background.borderMain}`
            },
            position: "relative",
            px: {
                xs: 2,
                sm: 1.5
            },
            py: 1.25
        }),
        children: v.jsxs(S, {
            gap: p ? .5 : 1,
            width: "100%",
            children: [!p && v.jsxs(C, {
                sx: Xz,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    px: 2,
                    py: 1,
                    height: 48,
                    children: [v.jsx(F, {
                        onClick: m.onClose,
                        sx: Qz,
                        children: v.jsx(ky, {
                            color: u.palette.text.label
                        })
                    }), v.jsx(k, {
                        variant: "h4",
                        children: d("Filters")
                    })]
                }), v.jsx(Ee, {
                    flexItem: !0,
                    sx: {
                        mx: -1.5
                    }
                })]
            }), p && v.jsx(k, {
                variant: "paragraph1",
                mb: .5,
                children: d("Filters")
            }), v.jsx(WR, {
                label: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    mt: "-1px",
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        children: d("Native only")
                    }), v.jsx(C, {
                        display: "flex",
                        children: v.jsx(Sz, {
                            chain: n
                        })
                    })]
                }),
                isChecked: s,
                onClick: o
            }), n === Pd.SOLANA && v.jsx(WR, {
                label: d("Graduated"),
                isChecked: l,
                onClick: i
            }), n === Pd.SOLANA && v.jsx(WR, {
                label: d("Launchpads only"),
                isChecked: r,
                onClick: a
            }), n === Pd.SOLANA ? v.jsxs(v.Fragment, {
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    height: 24,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: d("Launchpads")
                    }), r && v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        onClick: f,
                        sx: a$,
                        children: d(b ? "Unselect All" : "Select All")
                    })]
                }), v.jsx(qz, {
                    launchpadsOrdered: Kz,
                    toggleLaunchpad: g,
                    selectedLaunchpads: x,
                    disabled: !r
                })]
            }) : null]
        })
    })), [p, m.onClose, u.palette.text.label, n, s, o, l, i, r, a, f, b, g, x, d])
      , w = y.useMemo(( () => [s, ...n === Pd.SOLANA ? [r, 0 !== e.length && e.length !== Kz.length] : []].filter(Boolean).length), [n, r, s, e.length]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(C, {
            display: "flex",
            position: "relative",
            children: [v.jsx(F, {
                ...h,
                sx: Zz,
                children: v.jsx(xk, {
                    size: 20
                })
            }), !!w && v.jsx(C, {
                position: "absolute",
                sx: r$
            })]
        }), m.open ? p ? v.jsx(ae, {
            marginThreshold: 0,
            TransitionComponent: Q,
            anchorReference: "anchorEl",
            anchorOrigin: Jz,
            sx: t$,
            ...m,
            children: A
        }) : v.jsx(Sw, {
            open: !0,
            stackSx: e$,
            children: A
        }) : null]
    })
}
))
  , Xz = e => ({
    background: e.palette.background.secondary,
    zIndex: 10,
    mb: 1,
    ml: -2
})
  , Qz = {
    p: 0
}
  , Zz = {
    p: .25,
    height: 32,
    width: 32
}
  , Jz = {
    vertical: "bottom",
    horizontal: "left"
}
  , e$ = {
    p: 0,
    border: "none"
}
  , t$ = {
    zIndex: 1302,
    "& .MuiPopover-paper": {
        mt: 1
    }
}
  , n$ = 345
  , r$ = e => ({
    background: e.palette.primary.main,
    borderRadius: "50%",
    width: 5,
    height: 5,
    top: 4,
    right: 2
})
  , a$ = {
    height: 24,
    fontSize: 12,
    px: .75,
    py: 0,
    borderRadius: 4,
    mr: -.75
}
  , s$ = y.memo(( ({createdAt: e, aggregatorUrl: t, variant: r="paragraph3", color: a="text.value"}) => t ? e && v.jsx(GC, {
    maxWidth: 600,
    title: n.t("View on {{url}}", {
        url: t
    }),
    children: v.jsx(H, {
        href: t,
        target: "_blank",
        rel: "noopener noreferrer",
        underline: "none",
        sx: l$,
        children: v.jsx(mE, {
            ts: e,
            isShort: !0,
            variant: r,
            color: a,
            ...Nu,
            sx: o$
        })
    })
}) : e && v.jsx(GC, {
    title: n.t("Token age"),
    children: v.jsx(mE, {
        ts: e,
        isShort: !0,
        variant: r,
        color: a,
        ...Nu,
        sx: o$
    })
})))
  , o$ = {
    minWidth: 22
}
  , l$ = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center"
}
  , i$ = e => bg(e.chain, e.tokenAddress)
  , c$ = e => {
    const t = y.useRef({})
      , n = y.useCallback((t => e ? gm.onWatchlistUpdate(e, t) : {
        unsubscribe: () => {}
    }), [e])
      , r = y.useMemo(( () => ( (e, t) => (n, r) => {
        if (!t)
            return {};
        if ("init" === r.type)
            return e.current = r.snapshot,
            {
                ...e.current
            };
        switch (r.update.type) {
        case "regular":
            return {
                ...n,
                ...m.keyBy(r.update.entries, i$)
            };
        case "remove":
            {
                const e = {
                    ...n
                };
                return r.update.tokenIds.forEach((t => {
                    delete e[t]
                }
                )),
                e
            }
        default:
            return n ?? {}
        }
    }
    )(t, e)), [t, e]);
    return kx(n, r)
}
  , d$ = y.createContext({
    watched: [],
    isLoading: !0,
    add: () => Promise.resolve(),
    remove: () => Promise.resolve()
})
  , u$ = ({children: e}) => {
    var t;
    const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
      , r = c$(n)
      , [a,s] = y.useState({
        tokens: [],
        show: !1
    })
      , o = y.useCallback((async (e, t) => {
        n && (s({
            tokens: Object.values({
                ...r ?? {},
                [bg(e, t)]: {
                    chain: e,
                    tokenAddress: t,
                    tokenInfo: null,
                    fastStats: null
                }
            }),
            show: !0
        }),
        await gm.addToken(n, {
            chain: e,
            address: t
        }).catch(( () => {}
        )))
    }
    ), [r, n])
      , l = y.useCallback((async (e, t) => {
        n && (s({
            tokens: Object.values(m.pickBy(r, (n => n.chain !== e || n.tokenAddress !== t))),
            show: !0
        }),
        await gm.removeToken(n, e, t).catch(( () => {}
        )))
    }
    ), [r, n]);
    y.useEffect(( () => {
        s((e => e.show ? {
            tokens: [],
            show: !1
        } : e))
    }
    ), [r]);
    const i = y.useMemo(( () => ({
        watched: a.show ? a.tokens : Object.values(r ?? {}),
        isLoading: null === r,
        add: o,
        remove: l
    })), [a.show, a.tokens, r, o, l]);
    return v.jsx(d$.Provider, {
        value: i,
        children: e
    })
}
  , p$ = () => y.useContext(d$)
  , h$ = ({chain: e, tokenAddress: t, triggerActionOnMouseDown: n, muteEvent: r, showBackground: a=!1, showTrashForRemove: s=!1}) => {
    const {watched: o, add: l, remove: i} = p$()
      , c = y.useMemo(( () => o.find(( ({chain: n, tokenAddress: r}) => n === e && r === t))), [o, e, t])
      , d = y.useCallback((async n => {
        r && (n.preventDefault(),
        n.stopPropagation()),
        void 0 !== e && void 0 !== t && await (c ? i(e, t) : l(e, t))
    }
    ), [l, i, e, t, c, r]);
    return v.jsx(F, {
        sx: a ? g$ : m$,
        onMouseDown: n ? d : void 0,
        onClick: n ? void 0 : d,
        children: c ? s ? v.jsx(wS, {}) : v.jsx(py, {}) : v.jsx(dy, {})
    })
}
  , m$ = {
    width: 18,
    height: 18,
    p: 0
}
  , g$ = e => ({
    width: 32,
    height: 32,
    p: 0,
    background: e.palette.background.buttonDefault,
    "&:hover": {
        background: e.palette.background.buttonHover
    }
})
  , x$ = ({chain: e, tokenAddress: t, muteEvent: n}) => {
    const r = D()
      , {t: a} = we()
      , {watched: s, add: o, remove: l} = p$()
      , i = y.useMemo(( () => s.find(( ({chain: n, tokenAddress: r}) => n === e && r === t))), [s, e, t])
      , c = y.useCallback((async r => {
        n && (r.preventDefault(),
        r.stopPropagation()),
        e && t && await (i ? l(e, t) : o(e, t))
    }
    ), [o, l, e, t, i, n]);
    return v.jsx(GC, {
        title: a(i ? "Remove from watchlist" : "Add to watchlist"),
        children: v.jsx(C, {
            display: "flex",
            component: "span",
            children: v.jsx(F, {
                onClick: c,
                sx: f$,
                children: i ? v.jsx(py, {
                    size: b$,
                    color: r.palette.gold.main
                }) : v.jsx(dy, {
                    size: b$,
                    color: "inherit"
                })
            })
        })
    })
}
  , b$ = 18
  , f$ = e => ({
    p: 0,
    mt: "-2px",
    ml: "-2px",
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.primary.main,
        background: "transparent"
    }
})
  , v$ = (e, t, n, r, a, s) => {
    if (n = n ?? ("MOONSHOT_DEV PH" === s ? "moonshot" : null))
        switch (n) {
        case "believe":
            return {
                Icon: a ? mC : hC,
                version: null,
                name: "Believe",
                protocolType: Rc.METEORA_CURVE,
                launchpad: t,
                launchpadAux: "believe",
                chain: r,
                isMigrated: a
            };
        case "bonk":
            return {
                Icon: a ? tC : eC,
                version: null,
                name: "Bonk",
                protocolType: Rc.LAUNCH_LAB,
                launchpad: t,
                launchpadAux: "bonk",
                chain: r,
                isMigrated: a
            };
        case "moonshot":
            return {
                Icon: a ? pC : uC,
                version: null,
                name: "Moonshot",
                protocolType: Rc.METEORA_CURVE,
                launchpad: t,
                launchpadAux: "moonshot",
                chain: r,
                isMigrated: a
            };
        case "jup":
            return {
                Icon: a ? Yk : Kk,
                version: null,
                name: "Jupiter Studio",
                protocolType: Rc.METEORA_CURVE,
                launchpad: t,
                launchpadAux: "jup",
                chain: r,
                isMigrated: a
            };
        case "bags":
            return {
                Icon: a ? qk : $k,
                version: null,
                name: "BAGS",
                protocolType: Rc.METEORA_CURVE,
                launchpad: t,
                launchpadAux: "bags",
                chain: r,
                isMigrated: a
            };
        case "tvt":
            return {
                Icon: a ? vC : fC,
                version: null,
                name: "Token vs Token",
                protocolType: Rc.METEORA_CURVE,
                launchpad: t,
                launchpadAux: "tvt",
                chain: r,
                isMigrated: a
            }
        }
    if ("sugar" === t)
        return {
            Icon: a ? aC : rC,
            version: null,
            name: "Sugar",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    if (!e)
        return {
            Icon: null,
            version: null,
            name: null,
            protocolType: null,
            launchpad: null,
            launchpadAux: null,
            chain: null,
            isMigrated: null
        };
    switch (e) {
    case Lc.FOUR_MEME:
        return {
            Icon: ry,
            version: null,
            name: "Four.Meme",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.VISTA:
        return {
            Icon: Xy,
            version: null,
            name: "EtherVista",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.AERODROME_V2:
        return {
            Icon: Pf,
            version: "CP",
            name: "Aerodrome CP",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.AERODROME_V3:
        return {
            Icon: a ? Pf : Of,
            version: "CL",
            name: "Aerodrome CL",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.UNISWAP_V2:
        return r === Pd.BSC ? {
            Icon: a ? ik : rS,
            version: "v2",
            name: "PancakeSwap V2",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        } : {
            Icon: a ? uk : eS,
            version: "v2",
            name: "Uniswap V2",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.UNISWAP_V3:
        return {
            Icon: a ? uk : iS,
            version: "v3",
            name: "Uniswap V3",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Lc.PANCAKE_V3:
        return {
            Icon: a ? ik : rS,
            version: "v3",
            name: "PancakeSwap V3",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.RAYDIUM:
        return {
            Icon: a ? pk : lS,
            version: null,
            name: "Raydium V4",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.RAYDIUM_CLMM:
        return {
            Icon: a ? pk : lS,
            version: "CLMM",
            name: "Raydium CLMM",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.RAYDIUM_CP:
        return {
            Icon: a ? pk : lS,
            version: "CP",
            name: "Raydium CPMM",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.WHIRLPOOL:
        return {
            Icon: hk,
            version: null,
            name: "Orca WP",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.METEORA_OLD:
        return {
            Icon: a ? nS : mk,
            version: null,
            name: "Meteora DYN",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.METEORA_DLMM:
        return {
            Icon: a ? nS : mk,
            version: null,
            name: "Meteora DLMM",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.METEORA_DAMM_V2:
        return {
            Icon: a ? nS : mk,
            version: null,
            name: "Meteora AMM V2",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.PUMP_FUN:
        return {
            Icon: a ? Rk : Lk,
            version: null,
            name: "PumpFun",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.PUMP_SWAP:
        return {
            Icon: a ? Rk : Lk,
            version: null,
            name: "PumpSwap",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.LAUNCH_LAB:
        return {
            Icon: Hk,
            version: null,
            name: "LaunchLab",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.BOOP:
        return {
            Icon: a ? Qk : Xk,
            version: null,
            name: "Boop",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.METEORA_CURVE:
        return {
            Icon: a ? bC : xC,
            version: null,
            name: "Virtual Curve",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.SUGAR:
        return {
            Icon: a ? aC : rC,
            version: null,
            name: "Sugar",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.MOONIT:
        return {
            Icon: a ? dC : cC,
            version: null,
            name: "Moonit",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.HEAVEN:
        return {
            Icon: a ? oC : sC,
            version: null,
            name: "Heaven",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    case Rc.TOKEN_MILL:
        return {
            Icon: a ? iC : lC,
            version: null,
            name: "Token Mill",
            launchpad: t,
            protocolType: e,
            launchpadAux: null,
            chain: r,
            isMigrated: a
        };
    default:
        return {
            Icon: null,
            version: null,
            name: null,
            protocolType: null,
            launchpad: null,
            launchpadAux: null,
            chain: null,
            isMigrated: null
        }
    }
}
  , S$ = 10
  , y$ = !0
  , k$ = e => {
    y.useEffect(( () => {
        if (!e)
            return;
        let t = !1;
        return (async () => {
            for (; !t; )
                A$(e),
                await Hu(45e3)
        }
        )(),
        () => {
            t = !0
        }
    }
    ), [e])
}
  , C$ = new hg(1e3)
  , A$ = e => {
    (C$.get(e) ?? 0) > i().unix() - 30 || (om.keepMarketContextAlive({
        marketIds: [e]
    }).catch((t => {
        np.warn("Failed to call keepMarketContextAlive", {
            err: t,
            marketId: e
        })
    }
    )),
    C$.set(e, i().unix()))
}
  , w$ = y.memo(( ({chain: e, baseCurrency: t, baseTokenType: n, quoteCurrency: r, baseSymbol: a, quoteSymbol: s, marketId: o, padreAvatarUrl: l, isSelected: i}) => {
    const {performBuy: c} = AD();
    k$(e === Pd.SOLANA ? o : null);
    const {exitStrategies: d} = KR()
      , {settings: u} = rf()
      , {includeExitStrategies: p, selectedPreset: h, buttonValue: m, insufficientBalance: g} = uH()
      , [x,b] = JC(!1, 500)
      , f = y.useMemo(( () => !m || g || x), [m, g, x])
      , k = y.useCallback((async i => {
        np.info("Search result buy button clicked", {
            chain: e,
            buttonValue: m,
            baseCurrency: t
        }),
        i.stopPropagation(),
        i.preventDefault();
        const v = {
            originWidget: Dp.SEARCH,
            buttonValue: m,
            baseCurrency: t,
            poolQuoteCurrency: r,
            baseSymbol: a,
            quoteSymbol: s,
            marketId: o,
            disabled: f,
            insufficientBalance: g,
            recentlyClicked: x
        };
        if (e === Pd.SOLANA && !f && m)
            try {
                ((null == u ? void 0 : u.preventDoubleClick) ?? y$) && b(!0),
                await c({
                    value: m,
                    baseCurrency: t,
                    baseTokenType: n,
                    poolQuoteCurrency: r,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: a,
                    quoteSymbol: s,
                    marketId: o,
                    padreAvatarUrl: l,
                    presetName: h,
                    originWidget: Dp.SEARCH,
                    exitStrategies: p && d.length ? d : null
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing order", {
                    e: fNe,
                    orderInfo: v
                })
            }
        else
            np.warn("Order hasn't been sent - missing value or disabled", {
                orderInfo: v
            })
    }
    ), [e, f, m, b, c, t, n, r, a, s, o, l, h, p, d, null == u ? void 0 : u.preventDoubleClick, g, x])
      , C = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        e.stopPropagation())
    }
    ), [])
      , A = y.useMemo(( () => ({
        right: i ? 15 : 16,
        top: i ? 17 : 18
    })), [i]);
    return e !== Pd.SOLANA ? null : v.jsx(S, {
        position: "absolute",
        sx: A,
        children: v.jsxs(V, {
            tabIndex: -1,
            disabled: f,
            variant: "secondary",
            size: "small",
            color: "success",
            onKeyDown: C,
            sx: T$,
            onClick: k,
            children: [v.jsx(ay, {
                color: "inherit",
                size: j$
            }), m]
        })
    })
}
))
  , j$ = 18
  , T$ = {
    pl: .5,
    pr: 1.25,
    borderRadius: 8,
    display: "flex",
    gap: .5,
    cursor: "pointer",
    minWidth: 90,
    height: 40,
    fontSize: 15
}
  , I$ = y.memo(( ({label: e, valueFormatted: t, valueColor: n, desktopMinWidth: r=E$}) => {
    const a = y.useMemo(( () => ({
        gap: .5,
        minWidth: {
            sm: r
        },
        justifyContent: {
            xs: "center",
            sm: "flex-start"
        }
    })), [r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "flex-end",
        sx: a,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            noWrap: !0,
            children: e
        }), v.jsx(k, {
            variant: "h1",
            color: n ?? "text.value",
            noWrap: !0,
            children: t
        })]
    })
}
))
  , E$ = 70
  , M$ = ({item: {baseToken: e, quoteToken: t, market: n, chain: r, socials: a}, onItemClick: s, isSelected: o}) => {
    const l = D()
      , i = bw()
      , d = xw()
      , u = pT()
      , {marketCapThresholds: p} = bA()
      , h = y.useMemo(( () => {
        const e = Number(n.stats.fdvUsd);
        return isNaN(e) || !e ? l.palette.text.value : IA(e, p, l.palette.text.value)
    }
    ), [n.stats.fdvUsd, p, l.palette.text.value])
      , m = y.useMemo(( () => fg(r, n.address, n.protocol.type === Lc.FOUR_MEME ? {
        type: "fourmeme",
        tokenAddress: e.address
    } : null)), [e.address, r, n.address, n.protocol.type])
      , g = y.useCallback((e => {
        if (0 === e.button && !e.metaKey && !e.ctrlKey)
            return e.preventDefault(),
            e.stopPropagation(),
            u({
                marketId: m,
                tradePageOrigin: nT.SEARCH
            }),
            s(),
            !1
    }
    ), [u, m, s])
      , x = y.useMemo(( () => {
        if (n.stats.volumeInUsd.h1 && !isNaN(Number(n.stats.volumeInUsd.h1))) {
            const e = Number(n.stats.volumeInUsd.h1);
            return e > .01 ? e : 0
        }
        return null
    }
    ), [n.stats.volumeInUsd.h1])
      , b = y.useMemo(( () => e => ({
        gap: {
            xs: 1.5,
            md: 2
        },
        px: o ? "1px" : "2px",
        pt: {
            xs: o ? "7px" : 1,
            md: o ? "11px" : 1.5
        },
        pb: {
            xs: 1,
            md: 1.5
        },
        border: o ? `1px solid ${e.palette.primary.main}99` : "none",
        ...o ? {} : {
            borderBottom: `1px solid ${e.palette.background.borderMain}`
        },
        textDecoration: "none",
        "&:hover": {
            bgcolor: e.palette.background.active
        }
    })), [o])
      , f = y.useMemo(( () => v.jsx(Sz, {
        chain: r,
        size: i ? O$ : L$
    })), [r, i])
      , A = y.useMemo(( () => v.jsx(Ee, {
        flexItem: !0,
        orientation: "vertical",
        sx: {
            my: .75,
            ml: .5
        }
    })), [])
      , [w,j] = y.useMemo(( () => {
        if (!n.stats.liquidityInUsd)
            return [Ud, "text.label"];
        const e = Number(n.stats.liquidityInUsd);
        if (isNaN(e))
            return [Ud, "text.label"];
        return [LI(e, {
            collapseExponent: !0,
            desiredDigits: 3,
            symbol: "$",
            padSymbol: !1,
            symbolPosition: yI.START
        }), e < B$ ? "error.main" : e < _$ ? "warning.main" : "text.value"]
    }
    ), [n.stats.liquidityInUsd])
      , T = y.useMemo(( () => v$(n.protocol.type, c.isNil(n.launchpad) ? null : n.launchpad, c.isNil(n.launchpadAux) ? null : n.launchpadAux, r, n.isMigration ?? !1)), [r, n.isMigration, n.launchpad, n.launchpadAux, n.protocol.type])
      , I = e ? wA(e.address, r) : null;
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        overflow: "hidden",
        onClick: g,
        component: "a",
        href: XE(r, n.address, nT.SEARCH),
        sx: b,
        position: "relative",
        children: [v.jsx(S, {
            direction: "row",
            sx: U$,
            alignItems: "center",
            children: v.jsx(b_, {
                chain: r,
                url: IE(r, e.address),
                padreAvatarUrl: null,
                name: e.name ?? e.symbol ?? "?",
                size: i ? N$ : P$,
                markerIcon: r === Pd.SOLANA ? void 0 : f,
                markerSize: i ? O$ : L$,
                protocolInfo: T,
                useLaunchpadBorderColor: !0,
                alwaysShowBorder: !0,
                alwaysShowPointer: !0,
                markerOverrides: W$,
                borderRadius: "4px",
                hideHoverAvatar: !0,
                protocolMarkerSize: 18,
                protocolMarkerOffset: 8
            })
        }), v.jsxs(S, {
            width: "100%",
            direction: V$,
            children: [!i && v.jsxs(k, {
                variant: "h2",
                color: "text.value",
                children: [iu(e.symbol, 24), v.jsxs("span", {
                    style: {
                        color: l.palette.text.label
                    },
                    children: ["/", iu(t.symbol, 12)]
                })]
            }), v.jsxs(C, {
                display: "grid",
                width: "100%",
                gridTemplateColumns: i ? "2fr 1fr 1fr" : "1.25fr 1fr",
                children: [v.jsxs(S, {
                    gap: .5,
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        sx: F$,
                        divider: A,
                        children: [i && v.jsxs(k, {
                            variant: "paragraph1",
                            color: "text.value",
                            children: [iu(e.symbol, 24), v.jsxs("span", {
                                style: {
                                    color: l.palette.text.label
                                },
                                children: ["/", iu(t.symbol, 12)]
                            })]
                        }), v.jsx(cA, {
                            address: e.address,
                            customName: e.name,
                            stopPropagation: !0,
                            preventDefault: !0,
                            maxWidth: i ? 250 : void 0,
                            hideIcon: d
                        })]
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: [!!(null == e ? void 0 : e.deployedAt) && v.jsx(s$, {
                            createdAt: null == e ? void 0 : e.deployedAt,
                            aggregatorUrl: I ?? void 0
                        }), a && v.jsx(wR, {
                            isPermissioned: null,
                            tokenAddress: e.address,
                            showBoopLink: n.protocol.type === Rc.BOOP,
                            showPumpfunLink: n.protocol.type === Rc.PUMP_FUN,
                            showLaunchlabLink: n.protocol.type === Rc.LAUNCH_LAB,
                            showFourmemeLink: n.protocol.type === Lc.FOUR_MEME,
                            showBelieveLink: "believe" === n.launchpadAux,
                            showBonkLink: "bonk" === n.launchpadAux,
                            showBagsLink: "bags" === n.launchpadAux,
                            showDaosLink: "daos" === n.launchpadAux,
                            tokenSocials: a,
                            deployerAddress: e.deployer,
                            preventDefault: !0,
                            omitTwitterSearch: !0,
                            omitAggregator: !0,
                            isConfirmedBot: !1
                        }), v.jsx(h$, {
                            chain: r,
                            tokenAddress: e.address,
                            muteEvent: !0
                        }), d && v.jsx(cA, {
                            address: e.address,
                            stopPropagation: !0,
                            preventDefault: !0
                        })]
                    })]
                }), v.jsxs(S, {
                    gap: R$,
                    pr: D$,
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "center",
                    children: [v.jsx(I$, {
                        label: "M",
                        valueFormatted: n.stats.fdvUsd && !isNaN(Number(n.stats.fdvUsd)) ? LI(Number(n.stats.fdvUsd), {
                            collapseExponent: !0,
                            desiredDigits: 2,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        }) : Ud,
                        valueColor: h
                    }), v.jsx(I$, {
                        label: i ? "V (1H)" : "V",
                        valueFormatted: null !== x ? LI(x, {
                            collapseExponent: !0,
                            desiredDigits: 2,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        }) : Ud,
                        desktopMinWidth: i ? 80 : void 0
                    }), v.jsx(I$, {
                        label: "L",
                        valueFormatted: w,
                        valueColor: j
                    })]
                })]
            })]
        }), !R && d && v.jsx(w$, {
            chain: r,
            baseCurrency: e.address,
            baseTokenType: e.tokenType,
            quoteCurrency: t.address,
            baseSymbol: e.symbol,
            quoteSymbol: t.symbol,
            marketId: m,
            padreAvatarUrl: null,
            isSelected: o
        })]
    })
}
  , N$ = 52
  , P$ = 38
  , O$ = 24
  , L$ = 18
  , R$ = {
    xs: 1.5,
    md: 2
}
  , D$ = {
    xs: 1,
    md: 0
}
  , B$ = 1
  , _$ = 100
  , U$ = {
    pl: {
        xs: .5,
        md: 1.5
    },
    gap: {
        xs: .75,
        md: 1
    }
}
  , W$ = {
    top: -7,
    left: void 0,
    right: -7
}
  , F$ = {
    gap: .5,
    ml: {
        xs: -.5,
        md: 0
    }
}
  , V$ = {
    xs: "column",
    md: "row"
}
  , H$ = y.memo(( ({items: e, isSearching: t, onClose: n, isInputEmpty: r, selectedIndex: a}) => {
    const s = bw();
    return t ? v.jsx(Km, {}) : e.length ? v.jsx(mt, {
        children: ({height: t, width: r}) => v.jsx(gt, {
            className: "padre-no-scroll",
            height: t,
            width: r,
            rowHeight: s ? z$ : $$,
            rowCount: e.length,
            itemData: e,
            rowRenderer: ({index: t, style: r}) => {
                const s = e[t]
                  , o = a === t;
                return v.jsx("div", {
                    style: r,
                    children: v.jsx(M$, {
                        item: s,
                        onItemClick: n,
                        isSelected: o
                    })
                }, `${s.market.address}-${s.chain}`)
            }
            ,
            overscanRowCount: 3,
            scrollToIndex: a ?? void 0
        })
    }) : v.jsx(S, {
        width: "100%",
        height: "100%",
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(k, {
            textAlign: "center",
            color: "text.label",
            variant: "paragraph3",
            children: r ? "Start typing to search" : "No matches"
        })
    })
}
))
  , z$ = 77
  , $$ = 83
  , G$ = "padreV2-searchPumpfunFilter"
  , q$ = e => {
    switch (e) {
    case hz.BEST_MATCH:
        return zp.DEFAULT;
    case hz.LIQUIDITY:
        return zp.LIQUIDITY;
    case hz.MARKET_CAP:
        return zp.MARKET_CAP;
    case hz.VOLUME:
        return zp.VOLUME_H1
    }
}
  , K$ = async (e, t, n, r, a, s, o) => {
    const l = new Promise(( (e, t) => setTimeout(( () => t([])), 1e4)))
      , i = q$(a)
      , c = lm.getMarketsV2({
        query: e,
        sortBy: i,
        filter: {
            ...s ? {
                chains: [s]
            } : {},
            ...n ? {
                onlyNativeMarkets: n
            } : {},
            ...r ? {
                onlyMigratedMarkets: r
            } : {},
            ...t ? {
                launchpads: o
            } : {}
        }
    });
    try {
        return (await Promise.race([c, l])).hits
    } catch (fNe) {
        return []
    }
}
  , Y$ = e => e.match(/\b0x[a-fA-F0-9]{40}\b/) ?? []
  , X$ = e => e.match(/\b[1-9A-HJ-NP-Za-km-z]{32,44}\b/) ?? []
  , Q$ = (e, t, n) => {
    if (t < 0)
        return null;
    if (null === e)
        return 0;
    const r = e + n;
    return r < 0 ? t : r > t ? 0 : r
}
  , Z$ = e => e
  , J$ = y.memo(( ({initialValue: e, onClose: t}) => {
    const {t: n} = we()
      , r = D()
      , a = xw()
      , s = y.useRef()
      , o = yT()
      , [l,i] = Mx("padreV2-searchSelectedSortV2", hz.VOLUME)
      , [d,u] = Mx("padreV2-searchMigratedOnly", !1)
      , p = y.useCallback(( () => {
        u((e => !e))
    }
    ), [u])
      , [h,m] = Mx("padreV2-searchSelectedLaunchpads", Kz)
      , [g,x] = Mx("padreV2-searchSelectedChainV3", Pd.SOLANA)
      , [b,f] = Mx(G$, !1)
      , k = y.useCallback(( () => {
        f((e => !e))
    }
    ), [f])
      , [C,A] = Mx(G$, !1)
      , w = y.useCallback(( () => {
        A((e => !e))
    }
    ), [A])
      , [j,T] = y.useState(e ?? "")
      , I = y.useMemo(( () => xt(T, 200)), [])
      , [E,M] = y.useState(e ?? "")
      , [N,P] = y.useState(null)
      , [O,L] = y.useState(!1)
      , B = y.useCallback(( () => {
        L(!1)
    }
    ), [])
      , _ = y.useCallback(( () => {
        R || L(!0)
    }
    ), [])
      , U = y.useCallback(( () => {
        L((e => !e))
    }
    ), [])
      , W = y.useCallback(( (e, {clearError: t=!1}={}) => {
        M(e),
        I(e),
        t && P(null)
    }
    ), [M, I, P])
      , V = y.useCallback((async e => {
        if (0 === e.length)
            return void W("", {
                clearError: !0
            });
        const [t,n] = ( (e, t) => {
            const [n] = Y$(e)
              , [r] = X$(e);
            return gg(t) ? n ? [n, t] : r ? [r, Pd.SOLANA] : [null, t] : t === Pd.SOLANA ? r ? [r, t] : n ? [n, t] : [null, t] : [null, t]
        }
        )(e, g)
          , r = t || e;
        n !== g && x(n),
        W(r)
    }
    ), [g, W, x])
      , H = y.useCallback((async ({target: {value: e}}) => {
        await V(e)
    }
    ), [V])
      , $ = y.useCallback(( () => {
        W("", {
            clearError: !0
        })
    }
    ), [W])
      , {results: G, isSearching: q} = ( (e, t, n, r, a, s, o) => {
        const [l,i] = y.useState("" !== e)
          , d = NA(o)
          , u = NA(e)
          , p = NA(t)
          , h = NA(n)
          , m = NA(r)
          , g = NA(a)
          , x = NA(s)
          , b = y.useRef()
          , [f,v] = y.useState(!1)
          , [S,k] = y.useState([])
          , C = y.useCallback((async (e, t, n, r, a, s, o) => {
            if (!e)
                return k([]),
                void v(!1);
            v(!0);
            const l = await K$(e, t, n, r, a, o ?? null, s);
            b.current === e && (k(l),
            v(!1))
        }
        ), []);
        return y.useEffect(( () => {
            e === u && !l && o === d && t === p && n === h && r === m && a === g && c.isEqual(s, x) || (l && i(!1),
            k([]),
            b.current = e,
            C(e, t, n, r, a, s, o))
        }
        ), [e, u, o, d, C, a, t, n, r, p, h, m, g, s, x, l]),
        y.useMemo(( () => ({
            results: c.uniqBy(S.map((e => Z$(e))), (e => `${e.chain}-${e.market.address}`)),
            isSearching: f
        })), [S, f])
    }
    )(j, g === Pd.SOLANA && b, C, d, l, h, g)
      , K = y.useCallback((e => {
        var t;
        "ALL_NETWORKS" !== e && (x(e),
        null == (t = s.current) || t.focus())
    }
    ), [x]);
    y.useEffect(( () => {
        setTimeout(( () => {
            var e;
            return null == (e = s.current) ? void 0 : e.focus()
        }
        ), 50)
    }
    ), []);
    const [Y,X] = y.useState(null);
    y.useEffect(( () => {
        G.length ? X(0) : X(null)
    }
    ), [G]);
    const Q = y.useCallback((e => {
        if ("Enter" === e.key) {
            if (e.preventDefault(),
            null === Y)
                return;
            if (Y < 0 || Y >= G.length)
                return;
            const n = G[Y];
            return o({
                chain: n.chain,
                tokenAddress: n.market.address,
                tradePageOrigin: nT.SEARCH
            }),
            void t()
        }
        if ("ArrowUp" !== e.key)
            if ("ArrowDown" !== e.key)
                ;
            else {
                e.preventDefault();
                const t = Q$(Y, G.length - 1, 1);
                X(t)
            }
        else {
            e.preventDefault();
            const t = Q$(Y, G.length - 1, -1);
            X(t)
        }
    }
    ), [o, t, G, Y]);
    y.useEffect(( () => (document.addEventListener("keydown", Q),
    () => {
        document.removeEventListener("keydown", Q)
    }
    )), [Q]);
    const Z = y.useMemo(( () => ({
        sx: {
            height: nG,
            pr: .5
        },
        endAdornment: v.jsxs(v.Fragment, {
            children: [q && v.jsx(We, {
                position: "end",
                children: v.jsx(GC, {
                    title: n("Searching..."),
                    children: v.jsx(J, {
                        size: 16,
                        color: "inherit"
                    })
                })
            }), N && v.jsx(We, {
                position: "end",
                children: v.jsx(z, {
                    title: N,
                    sx: dG,
                    open: O,
                    children: v.jsx(F, {
                        onClick: U,
                        onMouseEnter: _,
                        onMouseLeave: B,
                        edge: "end",
                        size: "small",
                        children: v.jsx(wk, {
                            color: r.palette.warning.main
                        })
                    })
                })
            }), v.jsx(We, {
                position: "end",
                children: v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: E && v.jsx(z, {
                        title: n("Clear"),
                        children: v.jsx(F, {
                            onClick: $,
                            sx: rG,
                            children: v.jsx(Wy, {})
                        })
                    })
                })
            })]
        })
    })), [N, O, q, $, _, B, E, r.palette.warning.main, U, n]);
    return v.jsx(cH, {
        contextId: "search-modal",
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsxs(S, {
                gap: 1.25,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    mb: -1,
                    justifyContent: "space-between",
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .75,
                        children: [v.jsx(Oz, {
                            chain: g,
                            setChain: K
                        }), a && v.jsx(Ee, {
                            flexItem: !0,
                            orientation: "vertical",
                            sx: cG
                        }), a && v.jsx(Yz, {
                            selectedLaunchpads: h,
                            setSelectedLaunchpads: m,
                            chain: g,
                            launchpadOnlyFilter: b,
                            toggleLaunchpadOnlyFilter: k,
                            nativeFilter: C,
                            toggleNativeFilter: w,
                            migratedOnlyFilter: d,
                            toggleMigratedOnlyFilter: p
                        }), a && g === Pd.SOLANA && v.jsx(FR, {
                            label: "Graduated",
                            isChecked: d,
                            onClick: p,
                            Icon: vf
                        })]
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: 2,
                        children: [!R && g === Pd.SOLANA && v.jsx(dz, {
                            height: 32
                        }), v.jsx(Uz, {
                            selectedSort: l,
                            setSelectedSort: i
                        })]
                    })]
                }), !a && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    ml: -1.25,
                    children: [v.jsx(Yz, {
                        selectedLaunchpads: h,
                        setSelectedLaunchpads: m,
                        chain: g,
                        launchpadOnlyFilter: b,
                        toggleLaunchpadOnlyFilter: k,
                        nativeFilter: C,
                        toggleNativeFilter: w,
                        migratedOnlyFilter: d,
                        toggleMigratedOnlyFilter: p
                    }), v.jsx(FR, {
                        label: n("Graduated"),
                        isChecked: d,
                        onClick: p,
                        Icon: vf
                    })]
                })]
            }), v.jsx(bt, {
                inputRef: s,
                autoComplete: "off",
                value: E,
                onChange: H,
                variant: "outlined",
                error: null !== N,
                placeholder: n("Search by name, ticker, CA or dev..."),
                fullWidth: !0,
                autoFocus: !0,
                sx: lG,
                InputProps: Z
            }), v.jsx(Ee, {
                flexItem: !0,
                sx: iG
            }), v.jsx(S, {
                mr: aG,
                ml: sG,
                children: v.jsx(Mz, {
                    selectedChain: g,
                    onClose: t
                })
            }), v.jsx(Ee, {
                flexItem: !0,
                sx: iG
            }), v.jsx(S, {
                height: a ? eG : tG,
                sx: oG,
                my: -2,
                children: v.jsx(H$, {
                    items: G,
                    isSearching: q,
                    onClose: t,
                    isInputEmpty: "" === j,
                    selectedIndex: R ? null : Y
                })
            })]
        })
    })
}
))
  , eG = 462
  , tG = 350
  , nG = 44
  , rG = {
    width: 24,
    height: 24,
    p: 0
}
  , aG = {
    xs: -1.5,
    md: 0
}
  , sG = {
    xs: -1,
    md: 0
}
  , oG = {
    mx: {
        xs: -1.5,
        md: 0
    }
}
  , lG = {
    ml: {
        xs: -2,
        md: -1.75
    },
    mb: -1.5,
    backgroundColor: "transparent",
    "& .MuiOutlinedInput-root": {
        "& fieldset": {
            border: "none"
        },
        "&:hover fieldset": {
            border: "none"
        },
        "&.Mui-focused fieldset": {
            border: "none"
        },
        backgroundColor: "transparent"
    },
    input: {
        fontSize: 18,
        "&.MuiOutlinedInput-input": {
            fontSize: 18,
            fontWeight: 400
        },
        "&::placeholder": {
            opacity: 1
        }
    }
}
  , iG = {
    mx: -2
}
  , cG = {
    my: .75
}
  , dG = {
    cursor: "pointer"
}
  , uG = y.memo(( ({isOpen: e, initialValue: t, onClose: n, onOpen: r}) => bw() ? v.jsx(Sw, {
    open: e,
    onClose: n,
    stackSx: hG,
    maxDesktopWidth: pG,
    children: v.jsx(J$, {
        initialValue: t,
        onClose: n
    })
}) : v.jsx(_R, {
    anchor: "bottom",
    open: e,
    onOpen: r,
    onClose: n,
    disableSwipeToOpen: !0,
    keepMounted: !1,
    children: v.jsx(jR, {
        isOpen: e,
        noScroll: !0,
        children: v.jsx(J$, {
            initialValue: t,
            onClose: n
        })
    })
})))
  , pG = 800
  , hG = {
    zIndex: 1315,
    p: 2
}
  , mG = (e, t, n) => {
    const r = y.useCallback((r => {
        var a;
        n.isDisabled || n.requireOutsideInput && (null == (a = document.activeElement) ? void 0 : a.matches("input, textarea, [contenteditable]")) || r.key === e && (r.preventDefault(),
        t())
    }
    ), [n, e, t]);
    y.useEffect(( () => (document.addEventListener("keydown", r),
    () => {
        document.removeEventListener("keydown", r)
    }
    )), [r])
}
  , gG = y.createContext({
    openModal: c.noop
})
  , xG = {
    open: !1,
    initialValue: null
}
  , bG = ({isActive: e, children: t}) => {
    const [n,r] = y.useState(xG)
      , a = y.useCallback(( () => {
        r(xG)
    }
    ), [])
      , s = y.useCallback((e => {
        r({
            open: !0,
            initialValue: e ?? null
        })
    }
    ), [])
      , o = y.useMemo(( () => e && n.open), [e, n.open])
      , l = y.useCallback(( () => {
        r(xG)
    }
    ), []);
    mG("Escape", l, {
        isDisabled: !o
    });
    const i = y.useCallback(( () => {
        r({
            open: !0,
            initialValue: null
        })
    }
    ), []);
    mG("/", i, {
        requireOutsideInput: !0
    });
    const c = y.useMemo(( () => ({
        openModal: s
    })), [s]);
    return v.jsxs(gG.Provider, {
        value: c,
        children: [t, o && v.jsx(uG, {
            isOpen: o,
            initialValue: n.initialValue,
            onClose: a,
            onOpen: s
        })]
    })
}
  , fG = () => y.useContext(gG)
  , vG = y.memo(( ({onSearchModalOpenCallback: e}) => {
    const {t: t} = we()
      , n = D()
      , r = xw()
      , a = fw()
      , {openModal: s} = fG()
      , o = y.useCallback(( () => {
        s(),
        e()
    }
    ), [e, s])
      , l = y.useMemo(( () => ({
        display: "flex",
        justifyContent: "space-between",
        py: .5,
        pl: .75,
        pr: .5,
        gap: 1,
        width: a ? kG : r ? yG : SG,
        backgroundColor: "transparent",
        borderRadius: "16px",
        "&:focus": {
            backgroundColor: n.palette.background.buttonDefault
        },
        "&:hover": {
            backgroundColor: n.palette.background.buttonDefault
        }
    })), [a, r, n.palette.background.buttonDefault]);
    return v.jsxs(V, {
        size: "xsmall",
        variant: "tertiary",
        onClick: o,
        sx: l,
        children: [v.jsxs(S, {
            display: "flex",
            direction: "row",
            alignItems: "center",
            justifyContent: "center",
            gap: .5,
            children: [v.jsx(C, {
                display: "flex",
                width: CG,
                height: CG,
                children: v.jsx(cy, {
                    color: n.palette.text.value,
                    size: CG
                })
            }), r && v.jsx(k, {
                color: r ? "text.label" : "text.value",
                variant: "paragraph3",
                noWrap: !0,
                children: t(a ? "Search by name or CA..." : "Search coins...")
            })]
        }), r && v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            sx: AG,
            children: v.jsx(k, {
                color: "text.value",
                variant: "paragraph1",
                fontSize: 14,
                noWrap: !0,
                children: "/"
            })
        })]
    })
}
))
  , SG = 32
  , yG = 160
  , kG = 205
  , CG = 16
  , AG = e => ({
    border: `1px solid ${e.palette.background.borderActive}`,
    background: "transparent",
    borderRadius: "12px",
    width: 24,
    height: 24
})
  , wG = y.memo(( ({address: e, customName: t, maxWidth: n, usePopper: r=!1, firstPartLength: a, finalPartLength: s, hideIcon: o=!1, typographyOverrides: l, forceStopPropagation: i=!1, forcePreventDefault: c=!1, hoverPrimaryColor: d=!1}) => {
    const u = pK()
      , {openModal: p} = fG()
      , h = y.useMemo(( () => ({
        firstPartLength: a,
        finalPartLength: s
    })), [a, s])
      , m = y.useMemo(( () => null !== t ? t : oA(e || "", h)), [t, e, h])
      , g = y.useMemo(( () => e => ({
        maxWidth: "100%",
        px: PG,
        py: 0,
        height: 24,
        border: "none",
        background: "transparent",
        color: d ? e.palette.text.value : e.palette.text.label,
        "&:hover, &:focus": {
            border: "none",
            background: "transparent",
            color: d ? e.palette.primary.main : e.palette.text.value
        }
    })), [d])
      , {buttonProps: x, popoverProps: b} = Fw({
        id: `copy-address-context-${name}`
    })
      , f = y.useCallback(( (e, t) => {
        if (!QC)
            return u({
                message: uu.clipboardEnableAccess,
                snackName: pu.clipboardUnavailable,
                type: "error"
            }, "clipboard-check-failed"),
            void b.onClose();
        ZC(e),
        u({
            message: mu(t),
            type: "success"
        }, "clipboard-save-success"),
        b.onClose()
    }
    ), [u, b])
      , A = y.useCallback((t => {
        c && t.preventDefault(),
        i && t.stopPropagation(),
        f(e, "Address")
    }
    ), [e, f, c, i])
      , w = y.useCallback((e => {
        c && e.preventDefault(),
        i && e.stopPropagation(),
        t && f(t, "Name")
    }
    ), [f, t, c, i])
      , j = y.useCallback((e => {
        c && e.preventDefault(),
        i && e.stopPropagation(),
        t && (window.open(cR(t), "_blank"),
        b.onClose())
    }
    ), [t, c, i, b])
      , T = y.useCallback((e => {
        c && e.preventDefault(),
        i && e.stopPropagation();
        const n = dR(t);
        n && (window.open(n, "_blank"),
        b.onClose())
    }
    ), [t, c, i, b])
      , I = y.useCallback((e => {
        c && e.preventDefault(),
        i && e.stopPropagation(),
        t && (p(t),
        b.onClose())
    }
    ), [t, c, i, p, b])
      , E = y.useMemo(( () => v.jsx(ee, {
        elevation: 1,
        sx: EG,
        className: "padre-no-scroll, no-drag",
        children: v.jsxs(S, {
            children: [v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "address",
                sx: IG,
                onClick: A,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        children: "Copy"
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        ...Nu,
                        children: oA(e)
                    })]
                })
            }), t && v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "customName",
                sx: IG,
                onClick: w,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    width: "100%",
                    gap: .5,
                    ...Nu,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        children: "Copy"
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...Nu,
                        children: iu(t, OG)
                    })]
                })
            }), t && v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "customName",
                sx: IG,
                onClick: j,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        ...Nu,
                        children: "Google for"
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...Nu,
                        children: iu(t, OG)
                    })]
                })
            }), t && v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "customName",
                sx: IG,
                onClick: T,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        ...Nu,
                        children: "X Search for"
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...Nu,
                        children: iu(t, OG)
                    })]
                })
            }), t && v.jsx(te, {
                tabIndex: -1,
                onMouseDown: Uw,
                disableRipple: !0,
                disableTouchRipple: !0,
                value: "customName",
                sx: IG,
                onClick: I,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    width: "100%",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        ...Nu,
                        children: "Search for"
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...Nu,
                        children: iu(t, OG)
                    })]
                })
            })]
        })
    })), [t, e, A, w, j, T, I])
      , M = y.useCallback((e => {
        c && e.preventDefault(),
        i && e.stopPropagation(),
        x.onClick()
    }
    ), [x, c, i]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(GC, {
            disableInteractive: !1,
            title: E,
            noPadding: !0,
            enterDelay: 250,
            enterNextDelay: 250,
            children: v.jsx(C, {
                component: "span",
                display: "flex",
                children: v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    ...x,
                    onClick: R ? M : A,
                    sx: g,
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: NG,
                        children: [v.jsx(k, {
                            variant: "inherit",
                            color: "inherit",
                            maxWidth: n ? n - (NG + 8 * (2 * PG + (o ? 0 : NG)) + (o ? 0 : MG)) : void 0,
                            noWrap: !0,
                            ...Nu,
                            ...l,
                            children: m
                        }), !o && v.jsx(gk, {
                            size: MG,
                            color: "inherit"
                        })]
                    })
                })
            })
        }), R ? r ? v.jsx(ne, {
            ...b,
            children: v.jsx(re, {
                onClickAway: b.onClose,
                children: E
            })
        }) : v.jsx(ae, {
            ...b,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: jG,
            transformOrigin: TG,
            children: E
        }) : null]
    })
}
))
  , jG = {
    vertical: "bottom",
    horizontal: "center"
}
  , TG = {
    vertical: "top",
    horizontal: "center"
}
  , IG = e => ({
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    },
    height: 27
})
  , EG = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , MG = 16
  , NG = .5
  , PG = .5
  , OG = 20
  , LG = ({errorInstanceId: e, message: t, slim: n=!1}) => v.jsxs(S, {
    gap: 1,
    children: [t && v.jsx(k, {
        variant: "paragraph3",
        color: "text.value",
        alignItems: "flex-start",
        children: t
    }), v.jsxs(k, {
        variant: "paragraph3",
        color: "text.value",
        alignItems: "flex-start",
        children: ["Please open a support ticket", n ? v.jsx("br", {}) : " ", "in our", " ", v.jsx($C, {
            label: "discord",
            href: LC,
            sx: {
                mr: .25
            }
        }), e && n ? v.jsx("br", {}) : " ", e ? "and provide error ID below" : ""]
    }), e && v.jsx(S, {
        maxWidth: RG,
        ml: -.5,
        children: v.jsx(tA, {
            label: oA(e, {
                firstPartLength: 6,
                finalPartLength: 6
            }),
            textToCopy: e,
            labelVariant: "paragraph3"
        })
    })]
})
  , RG = 130
  , DG = e => e.code === OC.SLIPPAGE_TOLERANCE_EXCEEDED
  , BG = {
    message: null,
    title: null,
    moreInfoUrl: null
}
  , _G = (e, t, n, r, a) => {
    var s, o;
    if (!e)
        return BG;
    if (e.errorExplanation) {
        const s = {
            code: (o = e.errorExplanation).errorCode,
            details: o.details
        };
        if (s.code === OC.GAS_PRICE_TOO_LOW)
            return {
                message: FC.gasPriceTooLow,
                title: FC.gasPriceTooLowTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.NOT_ENOUGH_FUNDS)(s))
            return {
                message: FC.notEnoughFunds,
                title: FC.notEnoughFundsTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.NOT_ENOUGH_FUNDS_FOR_GAS)(s))
            return {
                message: FC.notEnoughFundsForGas,
                title: FC.notEnoughFundsForGasTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.TOO_LITTLE_RECEIVED)(s))
            return {
                message: FC.slippageTooLow,
                title: FC.slippageTooLowTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.TRANSACTION_DEADLINE_PASSED)(s))
            return {
                message: FC.transactionDeadlinePassed,
                title: FC.transactionDeadlinePassedTitle,
                moreInfoUrl: null
            };
        if (DG(s))
            return {
                message: FC.slippageTooLow,
                title: FC.slippageTooLowTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.OUT_OF_GAS)(s))
            return {
                message: v.jsx(LG, {
                    errorInstanceId: e.errorExplanation.errorInstanceId,
                    message: FC.outOfGas,
                    slim: n
                }),
                title: FC.outOfGasTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.LIKELY_EXCEEDS_MAX)(s))
            return {
                message: FC.likelyExceedsMax,
                title: FC.likelyExceedsMaxTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.FROZEN_ACCOUNT)(s))
            return {
                message: VC(t),
                title: FC.frozenAccountTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.LIKELY_HONEYPOT)(s))
            return {
                message: FC.likelyHoneypot,
                title: FC.likelyHoneypotTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.ORDER_AMOUNT_EXCEEDS_BALANCE)(s))
            return {
                message: r ? `${FC.exceedsBalanceSellInit}${a ? ` on ${iu(a, 16)}` : ""}` : FC.exceedsBalance,
                title: FC.exceedsBalanceTitle,
                moreInfoUrl: UC
            };
        if ((e => e.code === OC.POOL_CLOSED)(s))
            return {
                message: FC.poolMigrated,
                title: FC.poolMigratedTitle,
                moreInfoUrl: null
            };
        if ((e => e.code === OC.UNKNOWN_EXECUTION_ERROR)(s))
            return {
                message: v.jsx(LG, {
                    errorInstanceId: e.errorExplanation.errorInstanceId,
                    slim: n
                }),
                title: FC.unknownErrorTitle,
                moreInfoUrl: null
            }
    }
    if (e.txnState)
        switch (e.txnState.status) {
        case HC.DONE:
            return BG;
        case HC.FAILED:
            return {
                message: v.jsx(LG, {
                    errorInstanceId: e.txnState.explanation.errorInstanceId,
                    slim: n
                }),
                title: "Transaction Failed",
                moreInfoUrl: null
            };
        case HC.EXECUTING:
        case HC.QUEUED:
            return BG;
        case HC.REVERTED:
            {
                const {txnState: t} = e;
                return DG(t.error) ? {
                    message: FC.slippageTooLow,
                    title: FC.slippageTooLowTitle,
                    moreInfoUrl: null
                } : {
                    message: v.jsx(LG, {
                        errorInstanceId: null,
                        slim: n
                    }),
                    title: "Transaction Reverted",
                    moreInfoUrl: null
                }
            }
        case HC.TIMED_OUT:
            return {
                message: FC.transactionDeadlinePassed,
                title: "Transaction Timed Out",
                moreInfoUrl: null
            }
        }
    switch (e.orderStatus) {
    case sc.EXECUTING:
        return BG;
    case sc.EXECUTION_FAILED:
        return {
            message: v.jsx(LG, {
                errorInstanceId: (null == (s = e.errorExplanation) ? void 0 : s.errorInstanceId) ?? null,
                slim: n
            }),
            title: "Execution Failed",
            moreInfoUrl: null
        };
    case sc.FILLED:
    case sc.WAITING:
    case sc.CANCELED:
    default:
        return BG
    }
}
  , UG = y.memo(( ({onClose: e}) => {
    const t = y.useCallback((t => {
        t.stopPropagation(),
        e && e()
    }
    ), [e]);
    return v.jsx(C, {
        display: "flex",
        position: "relative",
        alignItems: "center",
        className: "padre-no-scroll",
        mt: -.25,
        children: v.jsx(F, {
            size: "small",
            "aria-label": "close",
            onClick: t,
            sx: WG,
            children: v.jsx(gy, {})
        })
    })
}
))
  , WG = {
    p: 0,
    mr: -.25,
    zIndex: 1,
    "&:hover": {
        backgroundColor: "transparent",
        color: "inherit"
    }
}
  , FG = (e, t=!1, n=null) => {
    const r = y.useRef(n);
    y.useEffect(( () => {
        r.current = n
    }
    ), [n]);
    const a = y.useRef(!1)
      , s = y.useRef(!1)
      , [o,l] = y.useState({
        status: ox.INITIAL
    })
      , i = y.useMemo(( () => {
        if (t)
            return !1;
        if (o.status !== ox.READY)
            return !1;
        const {orderStatus: e, txnStatus: n} = o.data;
        return !(n !== HC.TIMED_OUT && ![sc.FILLED, sc.EXECUTION_FAILED, sc.CANCELED].includes(e))
    }
    ), [o, t]);
    return y.useEffect(( () => {
        if (e && !i) {
            const t = sm.subscribeSlimOrderStatus(e, {
                onMessage: e => {
                    e && (l({
                        status: ox.READY,
                        data: e
                    }),
                    r.current && (e.orderStatus === sc.EXECUTING && e.isFilledBasedOnProcessed && !a.current && (r.current(!0),
                    a.current = !0),
                    e.orderStatus !== sc.FILLED || a.current || (r.current(!0),
                    a.current = !0),
                    e.txnStatus !== HC.TIMED_OUT || s.current || (r.current(!1),
                    s.current = !0),
                    [sc.EXECUTION_FAILED, sc.CANCELED].includes(e.orderStatus) && !s.current && (r.current(!1),
                    s.current = !0)))
                }
                ,
                close: () => {}
            });
            return () => {
                t.unsubscribe()
            }
        }
    }
    ), [e, i]),
    {
        slimOrderStatus: o,
        skipSub: i
    }
}
  , VG = (e, t) => v.jsxs(k, {
    variant: "paragraph3",
    lineHeight: $G,
    color: "text.value",
    flexWrap: "wrap",
    children: [e.tradeSide === xc.BUY ? "Buy " : `Sell ${e.baseValue} `, v.jsxs(V, {
        disabled: !e.onRedirectClick,
        size: "xxsmall",
        variant: "tertiary",
        sx: {
            height: 14,
            px: .25,
            gap: .5,
            border: "none",
            mt: "-1px",
            fontSize: 12,
            color: "text.value",
            backgroundColor: "transparent",
            "&.Mui-disabled": {
                backgroundColor: "transparent",
                color: "text.value"
            },
            "&:disabled": {
                backgroundColor: "transparent",
                color: "text.value"
            }
        },
        onClick: e.onRedirectClick ? () => {
            e.onRedirectClick && (e.onRedirectClick(),
            t && t())
        }
        : void 0,
        children: [v.jsx(b_, {
            size: zG,
            url: IE(e.chain, e.tokenAddress),
            name: e.baseSymbol,
            chain: e.chain,
            padreAvatarUrl: e.padreAvatarUrl,
            protocolInfo: null,
            hideHoverAvatar: !0
        }), iu(e.baseSymbol, HG)]
    }), e.tradeSide === xc.BUY ? ` for ${e.quoteValue} ${iu(e.quoteSymbol, HG)}` : ""]
})
  , HG = 20
  , zG = 12
  , $G = 1.21
  , GG = y.forwardRef(( ({orderIdPromise: e, orderSnackDetails: t, onOrderResolve: n, onClose: r, onFill: a, onOpenSummary: s, isSellInit: o}, l) => {
    const i = D()
      , c = y.useCallback((e => {
        n(e, t.tradeSide)
    }
    ), [n, t.tradeSide])
      , [d,u] = y.useState(null)
      , [p,h] = y.useState(!1);
    y.useEffect(( () => {
        let t = !1;
        return e.then((e => {
            t || u(e.orderId)
        }
        )).catch((e => {
            t || h(!0)
        }
        )),
        () => {
            t = !0
        }
    }
    ), [e]);
    const {slimOrderStatus: m, skipSub: g} = FG(d, !1, c)
      , [x,b] = y.useState(!1);
    y.useEffect(( () => {
        g && !x && (a(),
        b(!0))
    }
    ), [x, a, g]);
    const f = y.useRef(null);
    y.useEffect(( () => {
        p || g || m.status === ox.ERROR ? f.current = setTimeout(( () => {
            r && r()
        }
        ), t.customAutoTimeoutDuration ?? qG) : f.current && (clearTimeout(f.current),
        f.current = null)
    }
    ), [p, r, g, m.status, t.customAutoTimeoutDuration]);
    const [A,w,j,T,I] = y.useMemo(( () => {
        if (p)
            return [!1, "Connection Error", "Couldn't receive order status", v.jsx(Uy, {
                color: i.palette.error.main
            })];
        if (m.status === ox.ERROR)
            return [!1, "Connection Error", "Couldn't receive order status", v.jsx(Uy, {
                color: i.palette.error.main
            })];
        if (m.status !== ox.READY)
            return [t.showLowBalanceWarning, null, VG(t, r), v.jsx(J, {
                size: 14,
                color: "primary",
                sx: YG
            })];
        if (m.data.txnStatus === HC.TIMED_OUT)
            return [!1, "Order Timeout", "Consider increasing slippage, priority fee or tip", v.jsx(Dy, {
                color: i.palette.error.main
            }), "error.main"];
        const {orderStatus: e, txnHash: n, errorExplanation: a} = m.data
          , s = _G({
            orderStatus: e,
            failedExecutionAttempts: [],
            txnHash: n,
            errorExplanation: a
        }, t.baseSymbol, !0, o, t.walletName);
        if (m.data.isFilledBasedOnProcessed && m.data.orderStatus === sc.EXECUTING)
            return OV({
                orderId: m.data.orderDef.orderId,
                uid: m.data.orderDef.uid,
                clientReceiveProcessedStatusHighResTs: performance.now()
            }),
            [!1, null, VG(t, r), v.jsx(vy, {
                color: i.palette.success.main
            })];
        switch (m.data.orderStatus) {
        case sc.WAITING:
        case sc.EXECUTING:
            return [t.showLowBalanceWarning, null, VG(t, r), v.jsx(J, {
                size: 14,
                color: "primary",
                sx: YG
            })];
        case sc.CANCELED:
        case sc.EXECUTION_FAILED:
            return [!1, "Order Failed", s.message || "Unknown error", v.jsx(Uy, {
                color: i.palette.error.main
            })];
        case sc.FILLED:
            return RV({
                orderId: m.data.orderDef.orderId,
                uid: m.data.orderDef.uid,
                clientReceiveConfirmedStatusHighResTs: performance.now()
            }),
            [!1, null, VG(t, r), v.jsx(vy, {
                color: i.palette.success.main
            })]
        }
    }
    ), [m, i, t, r, o, p])
      , E = y.useCallback(( () => {
        s && d && (s(d, t.orderType, t.tradeSide, null),
        r && r())
    }
    ), [r, s, d, t.orderType, t.tradeSide]);
    return v.jsx(U, {
        ref: l,
        children: v.jsx(W, {
            icon: !1,
            sx: KG,
            onClick: E,
            children: v.jsxs(C, {
                display: "flex",
                flexDirection: "column",
                gap: 1,
                className: "padre-no-scroll",
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                    className: "padre-no-scroll",
                    children: [v.jsx(C, {
                        width: 16,
                        height: 16,
                        children: T
                    }), v.jsxs(S, {
                        width: "100%",
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        pt: .25,
                        pr: .5,
                        minHeight: 20,
                        className: "padre-no-scroll",
                        children: [w ? v.jsx(k, {
                            variant: "paragraph1",
                            lineHeight: IC,
                            color: I ?? "text.label",
                            children: w
                        }) : v.jsx(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: .5,
                            overflow: "clip",
                            children: "string" == typeof j ? v.jsx(k, {
                                variant: "paragraph3",
                                lineHeight: IC,
                                color: "text.primary",
                                gap: 1,
                                children: j
                            }) : j
                        }), v.jsx(UG, {
                            onClose: r
                        })]
                    })]
                }), w && v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: .5,
                    overflow: "clip",
                    children: "string" == typeof j ? v.jsx(k, {
                        variant: "paragraph3",
                        lineHeight: IC,
                        color: "text.primary",
                        gap: 1,
                        children: j
                    }) : j
                }), A && v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    children: [v.jsx(wk, {
                        color: i.palette.warning.main
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "warning.main",
                        children: "Txn will likely fail due to low wallet balance"
                    })]
                })]
            })
        })
    })
}
))
  , qG = 5e3
  , KG = e => ({
    flexWrap: "wrap",
    backgroundColor: e.palette.background.tertiary,
    borderRadius: 1,
    p: 1,
    alignItems: "center",
    width: "100%",
    overflow: "hidden",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0,
        overflow: "hidden"
    },
    maxWidth: {
        xs: EC,
        md: MC
    },
    "&:hover": {
        backgroundColor: e.palette.background.buttonActive,
        cursor: "pointer"
    }
})
  , YG = {
    animationDuration: "500ms"
}
  , XG = () => window.location.reload()
  , QG = y.forwardRef(( ({onClose: e}, t) => {
    const n = D();
    return v.jsx(U, {
        ref: t,
        children: v.jsx(W, {
            icon: !1,
            sx: e => ({
                flexWrap: "wrap",
                backgroundColor: e.palette.background.buttonDefault,
                borderRadius: 1,
                p: 2,
                alignItems: "center",
                width: "100%",
                "& .MuiAlert-action": {
                    p: 0,
                    display: "flex",
                    alignItems: "center",
                    marginRight: "unset"
                },
                "& .MuiAlert-message": {
                    width: "100%",
                    p: 0
                },
                maxWidth: {
                    xs: EC,
                    md: MC
                }
            }),
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                children: [v.jsx(QS, {
                    color: n.palette.success.main
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: "New app version available"
                }), v.jsx(V, {
                    size: "xxsmall",
                    variant: "tertiary",
                    sx: {
                        border: "none",
                        px: .5,
                        py: .5
                    },
                    onClick: XG,
                    endIcon: v.jsx(_S, {
                        color: n.palette.text.label
                    }),
                    children: "Refresh page"
                }), v.jsx(F, {
                    size: "small",
                    "aria-label": "close",
                    onClick: e,
                    sx: {
                        p: 0,
                        ml: "auto"
                    },
                    children: v.jsx(gy, {})
                })]
            })
        })
    })
}
))
  , ZG = y.createContext({
    alphaGroupRefresherRef: {
        current: null
    },
    alphaGroups: null
})
  , JG = () => y.useContext(ZG)
  , eq = ({children: e}) => {
    const t = Ax()
      , n = y.useRef(null)
      , r = mx(( (e, t) => {
        const n = y.useCallback((n => e ? _m.subscribeGroupsInfoV2(e, {
            onMessage: e => {
                t.current && t.current(),
                n.onMessage(e)
            }
            ,
            close: e => {
                n.close && n.close(e)
            }
        }) : {
            unsubscribe: () => {}
        }), [t, e]);
        return yx(n)
    }
    )(t, n))
      , a = y.useMemo(( () => {
        return r ? (e = r) ? c.reduce(Object.entries(e), ( (e, [t,n]) => (e.push({
            ...n,
            id: t
        }),
        e)), []) : [] : null;
        var e
    }
    ), [r])
      , s = y.useMemo(( () => ({
        alphaGroupRefresherRef: n,
        alphaGroups: a
    })), [n, a]);
    return v.jsx(ZG.Provider, {
        value: s,
        children: e
    })
}
  , tq = y.memo(( ({groupIds: e, iconSize: t=nq, gapPx: n=rq, hideTooltip: r=!1}) => {
    const {alphaGroups: a} = JG()
      , [s,o] = y.useMemo(( () => {
        if (!a)
            return [[], 0];
        const t = c.reduce(a, ( (e, t) => (e[t.id] = t,
        e)), {})
          , n = c.reduce(e, ( (e, n) => {
            const r = t[n] ?? null;
            return r && e.push({
                id: r.id,
                name: r.name,
                imageUrl: r.imageUrl,
                priority: r.priority
            }),
            e
        }
        ), []);
        return [n.sort(( (e, t) => e.priority !== t.priority ? t.priority - e.priority : e.name.localeCompare(t.name))).slice(0, aq), n.length]
    }
    ), [a, e])
      , l = v.jsx(S, {
        direction: "row",
        position: "relative",
        alignItems: "center",
        children: s.map(( (e, r) => v.jsx(sq, {
            index: r,
            imageUrl: e.imageUrl,
            zIndex: s.length - r,
            iconSize: t,
            gapPx: n
        }, e.id)))
    });
    return o ? r ? l : v.jsx(GC, {
        title: `${o} group${1 === o ? "" : "s"}`,
        children: l
    }) : null
}
))
  , nq = 16
  , rq = 6
  , aq = 5
  , sq = y.memo(( ({index: e, imageUrl: t, zIndex: n, iconSize: r, gapPx: a}) => {
    const s = y.useMemo(( () => ({
        borderRadius: "50%",
        width: r,
        height: r,
        position: "relative",
        marginLeft: 0 === e ? 0 : `-${a}px`,
        zIndex: n
    })), [a, r, e, n]);
    return v.jsx(C, {
        display: "flex",
        component: "img",
        src: t,
        sx: s
    })
}
))
  , oq = y.memo(( ({borderColor: e, tooltipTitle: t, children: n, overwriteColorsTs: r}) => {
    const a = D()
      , s = y.useRef(null)
      , o = y.useCallback((e => {
        if (!r)
            return;
        if (!s.current)
            return;
        const t = Math.max(0, e.unix() - r)
          , n = hE(t, a);
        s.current.style.color = n,
        s.current.style.borderColor = n
    }
    ), [a, r]);
    _A(o);
    const l = r ? (BA ?? i().unix()) - r : null
      , c = y.useMemo(( () => t => ({
        borderRadius: 3,
        px: "5px",
        gap: .5,
        border: `1px solid ${e ?? t.palette.background.borderMain}`,
        height: lq,
        ...r ? {
            color: hE(l ?? 0, t),
            borderColor: hE(l ?? 0, t)
        } : {}
    })), [e, l, r]);
    return v.jsx(GC, {
        title: t ?? "",
        children: v.jsx(S, {
            ref: s,
            direction: "row",
            alignItems: "center",
            justifyContent: "center",
            sx: c,
            children: n
        })
    })
}
))
  , lq = 24
  , iq = y.memo(( ({onClick: e, onClose: t, chain: n, tokenSymbol: r, tokenAddress: a, mentionGroupName: s, mentionGroupImageUrl: o, mentionedGroupIds: l, firstMentionTs: i, eventTimestamp: c, deployedAt: d, firstMentionImageUrl: u, marketCap: p, vol1h: h, marketCapColorThresholds: m}) => {
    const g = D()
      , x = y.useMemo(( () => IA(p ?? 0, m, g.palette.text.value)), [p, m, g.palette.text.value])
      , b = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        t && t()
    }
    ), [t]);
    return v.jsxs(C, {
        className: "no-drag padre-no-scroll",
        display: "flex",
        flexDirection: "column",
        onClick: e,
        sx: t ? pq : uq,
        height: t ? void 0 : 77,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            gap: fq,
            alignItems: "center",
            children: [v.jsxs(S, {
                direction: "row",
                gap: .5,
                alignItems: "center",
                children: [v.jsx(b_, {
                    url: IE(n, a),
                    size: dq,
                    markerIcon: v.jsx(Sz, {
                        chain: n,
                        size: 10
                    }),
                    name: r,
                    chain: n,
                    padreAvatarUrl: null,
                    protocolInfo: null,
                    hideHoverAvatar: !0
                }), v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    noWrap: !0,
                    children: `${r.slice(0, 10)}${d ? ` ${hM}` : ""}`
                }), !!d && v.jsx(mE, {
                    variant: "h2",
                    color: "text.value",
                    ts: d,
                    noWrap: !0,
                    overwriteColors: !0
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    noWrap: !0,
                    children: " mentioned in "
                }), v.jsx(C, {
                    display: "flex",
                    component: "img",
                    src: o,
                    sx: gq
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    noWrap: !0,
                    children: s
                })]
            }), t ? v.jsx(F, {
                onClick: b,
                sx: mq,
                children: v.jsx(gy, {})
            }) : v.jsx(mE, {
                variant: "paragraph1",
                color: "text.value",
                ts: c,
                noWrap: !0,
                height: bq,
                overwriteColors: !0,
                suffixAdornment: "ago",
                sx: vq
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            gap: .75,
            alignItems: "center",
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [!!i && v.jsx(oq, {
                    overwriteColorsTs: i,
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            color: "inherit",
                            height: bq,
                            noWrap: !0,
                            children: "1st"
                        }), v.jsx(C, {
                            display: "flex",
                            component: "img",
                            src: u ?? cq,
                            sx: xq
                        }), v.jsx(Ee, {
                            flexItem: !0,
                            orientation: "vertical",
                            sx: hq
                        }), v.jsx(mE, {
                            variant: "paragraph1",
                            color: "inherit",
                            ts: i,
                            height: bq,
                            minWidth: 20
                        })]
                    })
                }), v.jsx(oq, {
                    borderColor: l.length >= Sq ? g.palette.gold[500] : void 0,
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .25,
                        children: [v.jsx(tq, {
                            groupIds: l,
                            hideTooltip: !0
                        }), v.jsx(k, {
                            variant: "paragraph1",
                            color: l.length >= Sq ? g.palette.gold[500] : "text.value",
                            height: bq,
                            noWrap: !0,
                            children: `${l.length} group${1 === l.length ? "" : "s"}`
                        })]
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [!!p && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        noWrap: !0,
                        children: "MC"
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: x,
                        noWrap: !0,
                        children: LI(p, {
                            collapseExponent: !0,
                            desiredDigits: 2,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.END
                        })
                    })]
                }), !!h && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        noWrap: !0,
                        children: "V"
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        noWrap: !0,
                        children: LI(h, {
                            collapseExponent: !0,
                            desiredDigits: 2,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.END
                        })
                    })]
                })]
            })]
        })]
    })
}
))
  , cq = "https://content.padre.gg/trading_group_default.png"
  , dq = 20
  , uq = e => ({
    width: "100%",
    pb: 1.5,
    pt: 1.25,
    px: 1,
    gap: 1.25,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        background: e.palette.background.buttonDefault,
        cursor: "pointer"
    }
})
  , pq = {
    width: "100%",
    py: .5,
    gap: .5,
    overflowX: "scroll",
    overflowY: "hidden",
    "&:hover": {
        cursor: "pointer"
    }
}
  , hq = {
    my: .25
}
  , mq = {
    p: .25,
    width: 20,
    height: 20
}
  , gq = {
    borderRadius: "50%",
    width: 18,
    height: 18
}
  , xq = {
    borderRadius: "50%",
    width: 16,
    height: 16,
    mr: .25
}
  , bq = 14
  , fq = 1
  , vq = {
    display: "flex",
    gap: .25
}
  , Sq = 3
  , yq = y.forwardRef(( ({displayData: e, marketCapColorThresholds: t, navigateToMarketPage: n, onClose: r}, a) => {
    const s = y.useCallback((e => {
        0 !== e.button || e.metaKey || e.ctrlKey || e.preventDefault(),
        n()
    }
    ), [n]);
    return v.jsx(U, {
        ref: a,
        children: v.jsx(C, {
            component: "a",
            href: XE(e.chain, e.tokenAddress, nT.SNACK_ALPHA_TRADE) || "#",
            target: "_blank",
            sx: kq,
            onClick: s,
            className: "padre-no-scroll",
            children: v.jsx(W, {
                icon: !1,
                sx: Cq,
                className: "padre-no-scroll",
                children: v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: 1,
                    className: "padre-no-scroll",
                    children: v.jsx(iq, {
                        marketCapColorThresholds: t,
                        ...e,
                        onClose: r
                    })
                })
            })
        })
    })
}
))
  , kq = {
    textDecoration: "none"
}
  , Cq = e => ({
    flexWrap: "wrap",
    backgroundColor: e.palette.background.buttonDefault,
    borderRadius: 1,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    "&:hover": {
        cursor: "pointer",
        backgroundColor: Me(e.palette.background.buttonDefault, .02),
        borderColor: e.palette.background.borderActive
    },
    minWidth: 350,
    maxWidth: {
        xs: EC,
        md: MC
    }
})
  , Aq = y.forwardRef(( ({alertBaseInfo: e, triggeredValue: t, navigateToMarketPage: n, onClose: r}, a) => {
    const s = D()
      , o = y.useCallback((e => {
        0 !== e.button || e.metaKey || e.ctrlKey || e.preventDefault(),
        n()
    }
    ), [n])
      , l = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        r && r()
    }
    ), [r]);
    return v.jsx(U, {
        ref: a,
        children: v.jsx(C, {
            component: "a",
            href: XE(e.token.chain, e.token.address, nT.SNACK_PRICE_ALERT) || "#",
            target: "_blank",
            sx: wq,
            onClick: o,
            className: "padre-no-scroll",
            children: v.jsx(W, {
                icon: !1,
                sx: jq,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: 1,
                    className: "padre-no-scroll",
                    children: [v.jsxs(S, {
                        gap: .75,
                        children: [v.jsx(S, {
                            height: 16,
                            direction: "row",
                            width: "100%",
                            alignItems: "center",
                            justifyContent: "space-between",
                            pl: .25,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: .25,
                                children: [v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    children: "usd-mkt-cap" === e.type ? "MCap" : "Price"
                                }), v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.label",
                                    children: `alert for ${LI(e.targetValue, {
                                        collapseExponent: !0,
                                        symbol: "$",
                                        symbolPosition: yI.START,
                                        padSymbol: !1
                                    })}`
                                })]
                            })
                        }), v.jsxs(S, {
                            height: Iq + 2,
                            direction: "row",
                            alignItems: "center",
                            gap: .25,
                            pl: .25,
                            children: [v.jsx(b_, {
                                url: IE(e.token.chain, e.token.address),
                                padreAvatarUrl: null,
                                name: e.token.symbol,
                                size: Iq,
                                protocolInfo: null,
                                chain: e.token.chain,
                                hideHoverAvatar: !0,
                                markerIcon: v.jsx(Sz, {
                                    chain: e.token.chain,
                                    size: Eq
                                }),
                                markerSize: Eq
                            }), v.jsx(k, {
                                variant: "h1",
                                noWrap: !0,
                                color: "text.label",
                                ml: .75,
                                children: iu(e.token.symbol, 20)
                            }), v.jsx(k, {
                                variant: "h1",
                                fontWeight: 400,
                                noWrap: !0,
                                color: "text.label",
                                children: "is now"
                            }), v.jsx(k, {
                                variant: "h1",
                                noWrap: !0,
                                color: "text.value",
                                children: LI(t, {
                                    collapseExponent: !0,
                                    symbol: "$",
                                    symbolPosition: yI.START,
                                    padSymbol: !1,
                                    removeTrailingZerosPrecision: 1
                                })
                            })]
                        })]
                    }), v.jsxs(S, {
                        gap: 1,
                        children: [v.jsx(F, {
                            onClick: l,
                            sx: Tq,
                            children: v.jsx(gy, {})
                        }), v.jsx(S, {
                            height: 20,
                            justifyContent: "center",
                            children: v.jsx(C, {
                                display: "flex",
                                height: 18,
                                sx: e.direction === nc.GREATER ? Mq : Nq,
                                children: v.jsx(ty, {
                                    size: 18,
                                    color: e.direction === nc.GREATER ? s.palette.success.main : s.palette.error.main
                                })
                            })
                        })]
                    })]
                })
            })
        })
    })
}
))
  , wq = {
    textDecoration: "none",
    mx: -1
}
  , jq = e => ({
    flexWrap: "wrap",
    backgroundColor: e.palette.background.buttonDefault,
    borderRadius: 1,
    alignItems: "center",
    p: 1.5,
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    "&:hover": {
        cursor: "pointer",
        backgroundColor: Me(e.palette.background.buttonDefault, .02),
        borderColor: e.palette.background.borderActive
    },
    minWidth: 300,
    maxWidth: {
        xs: EC,
        md: MC
    }
})
  , Tq = {
    p: 0,
    height: 16,
    width: 16
}
  , Iq = 20
  , Eq = 10
  , Mq = {
    ml: -.5
}
  , Nq = {
    ...Mq,
    transform: "scaleY(-1)"
}
  , Pq = y.forwardRef(( ({claimPromise: e, onClose: t}, n) => {
    const r = D()
      , [a,s] = y.useState({
        status: ox.LOADING
    })
      , o = y.useRef(null);
    y.useEffect(( () => {
        a.status === ox.ERROR || a.status === ox.READY ? o.current = setTimeout(( () => {
            t && t()
        }
        ), Oq) : o.current && (clearTimeout(o.current),
        o.current = null)
    }
    ), [a.status, t]),
    y.useEffect(( () => {
        (async () => {
            try {
                const t = await e;
                s({
                    status: ox.READY,
                    data: t
                })
            } catch (fNe) {
                s({
                    status: ox.ERROR
                })
            }
        }
        )()
    }
    ), [e]);
    const [l,i] = y.useMemo(( () => {
        switch (a.status) {
        case ox.INITIAL:
        case ox.LOADING:
            return ["Claiming rewards", v.jsx(J, {
                size: 16,
                color: "primary"
            })];
        case ox.ERROR:
            return ["Failed to claim rewards", v.jsx(Uy, {
                color: r.palette.error.main
            })];
        case ox.READY:
            return [`Claimed ${a.data.claimedSolUi.toFixed(3)} SOL`, v.jsx(vy, {
                color: r.palette.success.main
            })]
        }
    }
    ), [a, r]);
    return v.jsx(U, {
        ref: n,
        children: v.jsx(W, {
            icon: !1,
            sx: Lq,
            children: v.jsxs(S, {
                gap: .25,
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "flex-start",
                    gap: 1,
                    children: [i, v.jsxs(S, {
                        width: "100%",
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        pt: .25,
                        pr: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.label",
                            children: l
                        }), v.jsx(UG, {
                            onClose: t
                        })]
                    })]
                }), a.status === ox.READY && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: "on"
                    }), v.jsx(cA, {
                        address: a.data.receivingWallet
                    }), v.jsx(tU, {
                        link: AA(a.data.txnHash, Pd.SOLANA),
                        hideBackground: !0,
                        children: v.jsx(tE, {
                            chain: Pd.SOLANA
                        })
                    })]
                })]
            })
        })
    })
}
))
  , Oq = 1e4
  , Lq = {
    flexWrap: "wrap",
    backgroundColor: "background.tertiary",
    borderRadius: 1,
    p: 2,
    pt: 1.5,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    maxWidth: {
        xs: EC,
        md: MC
    }
};
var Rq = (e => (e[e.FAST_SIGN_MISSING_API_STAMPER = 700] = "FAST_SIGN_MISSING_API_STAMPER",
e[e.FAST_SIGN_NULL_DECRYPTED_BUNDLE = 701] = "FAST_SIGN_NULL_DECRYPTED_BUNDLE",
e[e.FAST_SIGN_SERIALIZED_TXN_TOO_LARGE = 702] = "FAST_SIGN_SERIALIZED_TXN_TOO_LARGE",
e))(Rq || {});
const Dq = y.forwardRef(( ({details: e, onClose: t}, r) => {
    const a = D()
      , s = y.useMemo(( () => JSON.stringify({
        ...e,
        errorName: Rq[e.errorCode] ?? "unknown",
        machineTime: i().unix()
    })), [e])
      , o = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        t && t()
    }
    ), [t]);
    return v.jsx(U, {
        ref: r,
        children: v.jsx(C, {
            sx: Bq,
            className: "padre-no-scroll",
            children: v.jsx(W, {
                icon: !1,
                sx: _q,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    children: [v.jsx(Ck, {
                        color: a.palette.error.main,
                        size: 18
                    }), v.jsxs(S, {
                        gap: .5,
                        children: [v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: 1,
                            className: "padre-no-scroll",
                            minHeight: 16,
                            pl: .5,
                            children: [v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.value",
                                children: pu.somethingWentWrong
                            }), v.jsx(F, {
                                onClick: o,
                                sx: Uq,
                                children: v.jsx(gy, {})
                            })]
                        }), v.jsx(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: 1,
                            children: v.jsx(tA, {
                                label: (l = e.errorCode,
                                n.t("Please contact support. Error code {{errorCode}}", {
                                    errorCode: l
                                })),
                                textToCopy: s
                            })
                        })]
                    })]
                })
            })
        })
    });
    var l
}
))
  , Bq = {
    textDecoration: "none",
    mx: -1
}
  , _q = e => ({
    flexWrap: "wrap",
    backgroundColor: e.palette.background.buttonDefault,
    borderRadius: 1,
    alignItems: "center",
    p: 1.5,
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    minWidth: 300,
    maxWidth: {
        xs: EC,
        md: MC
    }
})
  , Uq = {
    p: 0,
    height: 16,
    width: 16
}
  , Wq = (e, t) => v.jsxs(k, {
    variant: "paragraph3",
    lineHeight: Hq,
    color: "text.value",
    flexWrap: "wrap",
    children: [e.tradeSide === xc.BUY ? "Buy " : `Sell ${e.baseValue} `, v.jsxs(V, {
        disabled: !e.onRedirectClick,
        size: "xxsmall",
        variant: "tertiary",
        sx: {
            height: 14,
            px: .25,
            gap: .5,
            border: "none",
            mt: "-1px",
            fontSize: 12,
            color: "text.value",
            backgroundColor: "transparent",
            "&.Mui-disabled": {
                backgroundColor: "transparent",
                color: "text.value"
            },
            "&:disabled": {
                backgroundColor: "transparent",
                color: "text.value"
            }
        },
        onClick: e.onRedirectClick ? () => {
            e.onRedirectClick && (e.onRedirectClick(),
            t && t())
        }
        : void 0,
        children: [v.jsx(b_, {
            size: Vq,
            url: IE(e.chain, e.tokenAddress),
            name: e.baseSymbol,
            chain: e.chain,
            padreAvatarUrl: e.padreAvatarUrl,
            protocolInfo: null,
            hideHoverAvatar: !0
        }), iu(e.baseSymbol, Fq)]
    }), e.tradeSide === xc.BUY ? ` for ${e.quoteValue} ${iu(e.quoteSymbol, Fq)}` : ""]
})
  , Fq = 20
  , Vq = 12
  , Hq = 1.21
  , zq = y.forwardRef(( ({orderIdPromises: e, orderSnackDetails: t, onOrderResolve: n, onClose: r, onFill: a}, s) => {
    const o = D()
      , l = y.useCallback((e => {
        n(e, t.tradeSide)
    }
    ), [n, t.tradeSide])
      , {successCount: i, errorCount: c, totalCount: d} = ( (e, t) => {
        const [n,r] = y.useState(e.length)
          , [a,s] = y.useState(0)
          , [o,l] = y.useState(0)
          , i = y.useRef(t);
        return y.useEffect(( () => {
            let t = !1;
            return r(e.length),
            e.forEach((e => {
                e.then((e => {
                    if (t)
                        return;
                    const n = e.orderId;
                    if (!n)
                        return i.current(!1),
                        void l((e => e + 1));
                    const r = sm.subscribeSlimOrderStatus(n, {
                        onMessage: e => {
                            if (!t && e)
                                switch (e.orderStatus) {
                                case sc.EXECUTING:
                                    e.isFilledBasedOnProcessed && OV({
                                        orderId: n,
                                        uid: e.orderDef.uid,
                                        clientReceiveProcessedStatusHighResTs: performance.now()
                                    });
                                    break;
                                case sc.FILLED:
                                    s((e => e + 1)),
                                    RV({
                                        orderId: n,
                                        uid: e.orderDef.uid,
                                        clientReceiveConfirmedStatusHighResTs: performance.now()
                                    }),
                                    i.current(!0),
                                    r.unsubscribe();
                                    break;
                                case sc.EXECUTION_FAILED:
                                case sc.CANCELED:
                                    l((e => e + 1)),
                                    i.current(!1),
                                    r.unsubscribe()
                                }
                        }
                        ,
                        close: () => {}
                    })
                }
                )).catch((e => {
                    t || l((e => e + 1))
                }
                ))
            }
            )),
            () => {
                t = !0
            }
        }
        ), [e]),
        {
            successCount: a,
            errorCount: o,
            totalCount: n
        }
    }
    )(e, l)
      , [u,p] = y.useState(!1);
    y.useEffect(( () => {
        i + c >= d && !u && (a(),
        p(!0))
    }
    ), [c, u, a, i, d]);
    const h = y.useRef(null);
    return y.useEffect(( () => {
        i + c >= d ? h.current = setTimeout(( () => {
            r && r()
        }
        ), t.customAutoTimeoutDuration ?? Gq) : h.current && (clearTimeout(h.current),
        h.current = null)
    }
    ), [r, t.customAutoTimeoutDuration, i, c, d]),
    v.jsx(U, {
        ref: s,
        children: v.jsx(W, {
            icon: !1,
            sx: qq,
            children: v.jsxs(C, {
                display: "flex",
                flexDirection: "column",
                gap: 2,
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "center",
                    height: 18,
                    gap: 1,
                    children: [c >= d ? v.jsx(Uy, {
                        color: o.palette.error.main
                    }) : c + i < d ? v.jsx(C, {
                        width: 14,
                        height: 14,
                        children: v.jsx(J, {
                            size: 14,
                            color: "primary",
                            sx: Kq
                        })
                    }) : v.jsx(vy, {
                        color: o.palette.grey[200]
                    }), v.jsxs(S, {
                        width: "100%",
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        pt: .25,
                        pr: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            lineHeight: IC,
                            color: c >= d ? "error.main" : "text.label",
                            children: c >= d ? "All orders have failed" : c + i < d ? "Executing orders" : "Orders completed"
                        }), v.jsx(UG, {
                            onClose: r
                        })]
                    })]
                }), v.jsxs(S, {
                    gap: 1,
                    children: [v.jsx(S, {
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        gap: .5,
                        overflow: "clip",
                        children: Wq(t, r)
                    }), v.jsxs(S, {
                        direction: "row",
                        gap: 1.5,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            noWrap: !0,
                            sx: $q,
                            children: `Waiting ${Math.max(0, d - i - c)}`
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: i > 0 ? "success.main" : "text.label",
                            noWrap: !0,
                            sx: $q,
                            children: `Success ${Math.max(0, i)}`
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: c > 0 ? "error.main" : "text.label",
                            noWrap: !0,
                            sx: $q,
                            children: `Error ${Math.max(0, c)}`
                        })]
                    })]
                })]
            })
        })
    })
}
))
  , $q = {
    minWidth: 85
}
  , Gq = 5e3
  , qq = {
    flexWrap: "wrap",
    backgroundColor: "background.tertiary",
    borderRadius: 1,
    p: 1,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    maxWidth: {
        xs: EC,
        md: MC
    }
}
  , Kq = {
    animationDuration: "500ms"
}
  , Yq = y.forwardRef(( ({transferPromises: e, onClose: t}, n) => {
    const r = D()
      , {successCount: a, errorCount: s, totalCount: o} = (e => {
        const [t,n] = y.useState(e.length)
          , [r,a] = y.useState(0)
          , [s,o] = y.useState(0);
        return y.useEffect(( () => {
            let t = !1;
            return n(e.length),
            e.forEach((e => {
                e.then((e => {
                    t || (e.success ? a((e => e + 1)) : o((e => e + 1)))
                }
                )).catch((e => {
                    t || o((e => e + 1))
                }
                ))
            }
            )),
            () => {
                t = !0
            }
        }
        ), [e]),
        {
            successCount: r,
            errorCount: s,
            totalCount: t
        }
    }
    )(e)
      , l = y.useRef(null);
    return y.useEffect(( () => {
        a + s >= o ? l.current = setTimeout(( () => {
            t && t()
        }
        ), Qq) : l.current && (clearTimeout(l.current),
        l.current = null)
    }
    ), [t, a, s, o]),
    v.jsx(U, {
        ref: n,
        children: v.jsx(W, {
            icon: !1,
            sx: Zq,
            children: v.jsxs(C, {
                display: "flex",
                flexDirection: "column",
                gap: 2,
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "center",
                    height: 18,
                    gap: 1,
                    children: [s >= o ? v.jsx(Uy, {
                        color: r.palette.error.main
                    }) : s + a < o ? v.jsx(J, {
                        size: 16,
                        color: "primary"
                    }) : v.jsx(vy, {
                        color: r.palette.grey[200]
                    }), v.jsxs(S, {
                        width: "100%",
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        pt: .25,
                        pr: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            lineHeight: IC,
                            color: s >= o ? "error.main" : "text.label",
                            children: s >= o ? "All transfers have failed" : s + a < o ? "Executing transfers" : "Transfers completed"
                        }), v.jsx(UG, {
                            onClose: t
                        })]
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 1.5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        noWrap: !0,
                        sx: Xq,
                        children: `Waiting ${Math.max(0, o - a - s)}`
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: a > 0 ? "success.main" : "text.label",
                        noWrap: !0,
                        sx: Xq,
                        children: `Success ${Math.max(0, a)}`
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: s > 0 ? "error.main" : "text.label",
                        noWrap: !0,
                        sx: Xq,
                        children: `Error ${Math.max(0, s)}`
                    })]
                })]
            })
        })
    })
}
))
  , Xq = {
    minWidth: 85
}
  , Qq = 5e3
  , Zq = {
    flexWrap: "wrap",
    backgroundColor: "background.tertiary",
    borderRadius: 1,
    p: 1,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    maxWidth: {
        xs: EC,
        md: MC
    }
}
  , Jq = y.forwardRef(( ({tradeSnackDetails: e, navigateToMarketPage: t, onSilenceClick: n, onClose: r}, a) => {
    const {t: s} = we()
      , o = D()
      , l = y.useMemo(( () => e.chain === Pd.SOLANA ? v.jsx(dk, {
        color: "inherit",
        size: 14
    }) : e.chain === Pd.BSC ? v.jsx(ak, {
        color: "inherit",
        size: 12
    }) : v.jsx(Yv, {
        size: 14
    })), [e.chain])
      , i = y.useMemo(( () => e.chain === Pd.SOLANA ? v$(e.marketProtocolType, e.marketLaunchpad, e.marketLaunchpadAux, e.chain, e.isMigration, e.tokenAddress) : null), [e.chain, e.isMigration, e.marketLaunchpad, e.marketLaunchpadAux, e.marketProtocolType, e.tokenAddress])
      , [c,d] = y.useMemo(( () => e.tokenAge > aK ? [null, ""] : [WA(e.tokenAge, !0), hE(e.tokenAge, o)]), [e.tokenAge, o])
      , u = y.useMemo(( () => e => ({
        border: `1px solid ${d}99`,
        borderRadius: "8px",
        height: 15,
        display: "flex",
        alignItems: "center",
        px: .25,
        background: e.palette.background.default,
        bottom: -6,
        left: -6
    })), [d])
      , p = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        r && r()
    }
    ), [r])
      , h = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        n(),
        r && r()
    }
    ), [r, n])
      , m = y.useCallback((e => {
        0 !== e.button || e.metaKey || e.ctrlKey || (e.preventDefault(),
        t())
    }
    ), [t]);
    return v.jsx(U, {
        ref: a,
        children: v.jsx(C, {
            component: "a",
            href: QE(e.marketId, nT.SNACK_TRADE) || "#",
            target: "_blank",
            sx: tK,
            onClick: m,
            className: "padre-no-scroll",
            children: v.jsx(W, {
                icon: !1,
                sx: rK,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: 1,
                    className: "padre-no-scroll",
                    children: [v.jsxs(S, {
                        direction: "row",
                        gap: 1.5,
                        className: "padre-no-scroll",
                        children: [v.jsxs(C, {
                            display: "flex",
                            alignSelf: "center",
                            ml: .75,
                            position: "relative",
                            children: [v.jsx(b_, {
                                url: IE(e.chain, e.tokenAddress),
                                size: 30,
                                markerSize: 12,
                                protocolMarkerSize: 15,
                                protocolMarkerOffset: 6,
                                name: e.tokenSymbol,
                                chain: e.chain,
                                padreAvatarUrl: null,
                                protocolInfo: i,
                                useLaunchpadBorderColor: !0,
                                alwaysShowBorder: !0,
                                hideHoverAvatar: !0,
                                alwaysShowPointer: !0
                            }), c && v.jsx(C, {
                                position: "absolute",
                                sx: u,
                                children: v.jsx(k, {
                                    variant: "paragraph2",
                                    fontSize: 10,
                                    color: d,
                                    children: c
                                })
                            })]
                        }), v.jsxs(S, {
                            gap: .5,
                            children: [v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: .75,
                                height: 14,
                                children: [v.jsxs(v.Fragment, {
                                    children: [v.jsx(ZT, {
                                        emoji: e.customEmoji,
                                        size: 14
                                    }), v.jsx(k, {
                                        ml: -.25,
                                        variant: "paragraph3",
                                        noWrap: !0,
                                        fontWeight: ju,
                                        color: "text.value",
                                        children: e.customName ? iu(e.customName, 20, 2) : oA(e.maker)
                                    })]
                                }), v.jsx(k, {
                                    variant: "paragraph3",
                                    noWrap: !0,
                                    fontWeight: ju,
                                    color: e.side === xc.BUY ? "success.main" : "error.main",
                                    children: s(sK[e.tradeType])
                                }), v.jsx(C, {
                                    display: "flex",
                                    children: v.jsx(k, {
                                        variant: "paragraph3",
                                        noWrap: !0,
                                        fontWeight: ju,
                                        color: "text.value",
                                        children: iu(e.tokenSymbol, 16, 2)
                                    })
                                })]
                            }), v.jsxs(S, {
                                direction: "row",
                                gap: .25,
                                alignItems: "center",
                                children: [l, v.jsx(k, {
                                    variant: "paragraph3",
                                    noWrap: !0,
                                    color: e.side === xc.BUY ? "success.main" : "error.main",
                                    children: `${LI(e.amountInNative, {
                                        collapseExponent: !0,
                                        minPrecision: e.amountInNative >= .1 ? 2 : 3,
                                        maxPrecision: e.amountInNative >= .1 ? 2 : 3,
                                        symbol: "",
                                        padSymbol: !0,
                                        symbolPosition: yI.END,
                                        noTrailingZeros: !0
                                    })}`
                                }), v.jsx(k, {
                                    variant: "paragraph3",
                                    noWrap: !0,
                                    color: "text.label",
                                    children: null === e.marketCapInUsd ? "" : `at${LI(e.marketCapInUsd, {
                                        collapseExponent: !0,
                                        symbol: "$",
                                        symbolPosition: yI.START,
                                        padSymbol: !1,
                                        noTrailingZeros: !0,
                                        desiredDigits: 3
                                    })}MC `
                                })]
                            })]
                        })]
                    }), v.jsxs(S, {
                        className: "padre-no-scroll",
                        height: "100%",
                        justifyContent: "space-between",
                        width: nK + 4,
                        mt: -.5,
                        gap: 1,
                        children: [v.jsx(F, {
                            size: "small",
                            "aria-label": "close",
                            onClick: p,
                            sx: eK,
                            children: v.jsx(gy, {
                                size: nK
                            })
                        }), v.jsx(GC, {
                            title: s("Silence wallet notifications"),
                            children: v.jsx(C, {
                                children: v.jsx(F, {
                                    size: "small",
                                    "aria-label": "close",
                                    onClick: h,
                                    sx: eK,
                                    children: v.jsx(jy, {
                                        color: o.palette.primary.main,
                                        size: nK
                                    })
                                })
                            })
                        })]
                    })]
                })
            })
        })
    })
}
))
  , eK = {
    p: .25,
    display: "flex",
    alignSelf: "flex-start"
}
  , tK = {
    textDecoration: "none"
}
  , nK = 16
  , rK = e => ({
    flexWrap: "wrap",
    backgroundColor: e.palette.background.buttonDefault,
    borderRadius: 1,
    p: .5,
    alignItems: "center",
    width: "100%",
    "& .MuiAlert-action": {
        p: 0,
        display: "flex",
        alignItems: "center",
        marginRight: "unset"
    },
    "& .MuiAlert-message": {
        width: "100%",
        p: 0
    },
    "&:hover": {
        cursor: "pointer",
        backgroundColor: Me(e.palette.background.buttonDefault, .02),
        borderColor: e.palette.background.borderActive
    },
    minWidth: 300,
    maxWidth: {
        xs: EC,
        md: MC
    }
})
  , aK = 31536e4
  , sK = {
    [ph.BUY_FIRST]: "bought",
    [ph.BUY_MORE]: "bought more",
    [ph.SELL_ALL]: "sold all",
    [ph.SELL_PART]: "sold some"
}
  , oK = [];
var lK = (e => (e.DEFAULT = "default",
e.SLIM_ORDER_STATUS = "slimOrderStatus",
e.NEW_APP_VERSION = "newAppVersion",
e.NEW_TRADE = "newTrade",
e.MULTI_ORDER_STATUS = "multiOrderStatus",
e.CLAIM_REWARDS = "claimRewards",
e.ALPHA_TRACK = "alphaTrack",
e.PRICE_ALERT = "priceAlert",
e.MULTI_TRANSFER_STATUS = "multiTransferStatus",
e.CONTACT_SUPPORT = "contactSupport",
e))(lK || {});
const iK = e => "slimOrderStatus" === e.variant
  , cK = e => "multiOrderStatus" === e.variant
  , dK = e => "claimRewards" === e.variant
  , uK = e => "multiTransferStatus" === e.variant
  , pK = () => {
    const {enqueueSnackbar: e, closeSnackbar: t} = ft();
    return y.useCallback(( (n, r, a) => {
        const s = e(r, {
            persist: "string" != typeof n && (iK(n) || cK(n) || uK(n) || dK(n)),
            ...a,
            content: e => "string" == typeof n ? v.jsx(NC, {
                message: n,
                onClose: () => {
                    t(e)
                }
            }) : (e => "default" === e.variant || void 0 === e.variant)(n) ? v.jsx(NC, {
                ...n,
                onClose: () => {
                    var r;
                    null == (r = n.onClose) || r.call(n),
                    t(e)
                }
            }) : iK(n) ? v.jsx(GG, {
                ...n,
                onClose: () => {
                    var r;
                    null == (r = n.onClose) || r.call(n),
                    t(e)
                }
            }) : cK(n) ? v.jsx(zq, {
                ...n,
                onClose: () => {
                    var r;
                    null == (r = n.onClose) || r.call(n),
                    t(e)
                }
            }) : (e => "newAppVersion" === e.variant)(n) ? v.jsx(QG, {
                onClose: () => {
                    t(e)
                }
            }) : (e => "newTrade" === e.variant)(n) ? v.jsx(Jq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : dK(n) ? v.jsx(Pq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : (e => "alphaTrack" === e.variant)(n) ? v.jsx(yq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : (e => "priceAlert" === e.variant)(n) ? v.jsx(Aq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : uK(n) ? v.jsx(Yq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : (e => "contactSupport" === e.variant)(n) ? v.jsx(Dq, {
                ...n,
                onClose: () => {
                    t(e)
                }
            }) : null
        });
        return s && (oK.length >= 4 && t(oK.shift()),
        oK.push(s)),
        s
    }
    ), [t, e])
}
  , hK = {
    width: 362,
    height: 73
}
  , mK = {
    width: 92,
    height: 84
}
  , gK = e => {
    const t = (e => {
        const {getSizeFromWidth: t, getSizeFromHeight: n} = (r = e,
        {
            getSizeFromWidth: e => ({
                width: e,
                height: r.height / r.width * e
            }),
            getSizeFromHeight: e => ({
                height: e,
                width: r.width / r.height * e
            })
        });var r;
        return e => void 0 !== e.width ? t(e.width) : n(e.height)
    }
    )(e.isSmall ? mK : hK);
    return v.jsx("img", {
        src: e.isSmall ? "/favicon.svg" : "/logo.svg",
        alt: "Padre.gg logo",
        ...t(e)
    })
}
  , xK = ({children: e}) => {
    const t = bw()
      , n = y.useMemo(( () => ({
        position: "absolute",
        ...t ? {
            right: "calc(50% - 525px)",
            top: 0
        } : {
            left: "50%",
            top: 15,
            transform: "translateX(-50%)"
        },
        width: t ? 300 : 190,
        height: t ? 700 : 400,
        backgroundColor: "white",
        borderRadius: "50%",
        filter: "blur(80px)",
        opacity: .03,
        pointerEvents: "none",
        zIndex: 2
    })), [t]);
    return v.jsxs(C, {
        height: "100%",
        width: "100%",
        position: "relative",
        overflow: "hidden",
        sx: bK,
        children: [t && v.jsx(C, {
            sx: fK
        }), v.jsx(C, {
            sx: n
        }), v.jsx(C, {
            height: "100%",
            children: e
        })]
    })
}
  , bK = {
    background: "#000000"
}
  , fK = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: 1e3,
    background: "radial-gradient(circle at left, rgba(255,255,255,0.1), transparent 20%)",
    zIndex: 0,
    pointerEvents: "none"
}
  , vK = y.memo(( ({children: e}) => {
    const t = bw()
      , {t: n} = we()
      , r = y.useMemo(( () => v.jsx(C, {
        position: t ? "absolute" : "relative",
        left: t ? 124 : void 0,
        top: t ? 415 : void 0,
        zIndex: 0,
        sx: {
            overflow: "clip",
            width: {
                xs: "100%",
                md: "85%",
                lg: "85%"
            },
            maxWidth: {
                xs: "620px",
                md: "680px",
                lg: "920px"
            }
        },
        children: v.jsxs(C, {
            position: "relative",
            children: [v.jsx(C, {
                position: "absolute",
                sx: {
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    pointerEvents: "none",
                    borderRadius: 1,
                    zIndex: 5,
                    background: (t ? "linear-gradient(to left,\n        rgba(0, 0, 0, 1) 0%,\n        rgba(0, 0, 0, 1) 17%,\n        rgba(0, 0, 0, 0) 40%\n      )," : "") + "\n      \n      linear-gradient(to top,\n        rgba(0, 0, 0, 1) 0%,\n        rgba(0, 0, 0, 1) 17%,\n        rgba(0, 0, 0, 0) 40%\n      )\n    "
                }
            }), v.jsx(C, {
                component: "img",
                src: "/authPageBackground.png",
                alt: n("Background Image"),
                sx: e => ({
                    opacity: .75,
                    maxWidth: t ? "920px" : "min(620px, 100%)",
                    borderRadius: 1,
                    border: `1px solid ${e.palette.background.borderActive}`
                })
            })]
        })
    })), [t, n])
      , a = y.useMemo(( () => t ? {
        position: "absolute",
        top: 200,
        right: 110
    } : {
        alignItems: "center",
        justifyContent: "center"
    }), [t]);
    return v.jsx(xK, {
        children: v.jsx(vt, {
            maxWidth: "xl",
            sx: SK,
            style: yK,
            children: v.jsxs(S, {
                direction: kK,
                sx: CK,
                className: "padre-no-scroll",
                position: "relative",
                children: [v.jsxs(S, {
                    alignSelf: t ? "flex-start" : "center",
                    position: "relative",
                    height: t ? "100%" : void 0,
                    width: 700,
                    children: [v.jsx(S, {
                        component: "a",
                        href: BC,
                        target: "_blank",
                        rel: "noopener nofollow",
                        justifyContent: "flex-start",
                        alignItems: "flex-start",
                        alignSelf: t ? "flex-start" : "center",
                        children: v.jsx(gK, {
                            height: 38,
                            isSmall: !1
                        })
                    }), t && v.jsxs(S, {
                        position: "absolute",
                        left: -20,
                        top: 110,
                        pt: 4,
                        pl: 3,
                        zIndex: 1,
                        children: [v.jsx(k, {
                            fontFamily: Cu.REGULAR,
                            fontSize: 25,
                            lineHeight: "40px",
                            letterSpacing: "-0.2px",
                            whiteSpace: "pre",
                            fontWeight: 400,
                            color: "#FFFFFF",
                            sx: wK,
                            children: n("B U I L T    F O R")
                        }), v.jsxs(C, {
                            sx: jK,
                            children: [v.jsx(k, {
                                fontFamily: Cu.REGULAR,
                                fontSize: 58,
                                lineHeight: "90px",
                                letterSpacing: "-0.6px",
                                fontWeight: 800,
                                width: 600,
                                whiteSpace: "pre",
                                color: "#FFFFFF",
                                sx: AK,
                                children: n("W  I  N  N  I  N  G")
                            }), v.jsx(k, {
                                fontFamily: Cu.REGULAR,
                                fontSize: 58,
                                lineHeight: "90px",
                                letterSpacing: "-0.6px",
                                fontWeight: 800,
                                width: 600,
                                whiteSpace: "pre",
                                color: "#FFFFFF",
                                zIndex: 1,
                                children: n("W  I  N  N  I  N  G")
                            })]
                        })]
                    })]
                }), v.jsx(S, {
                    flexGrow: 1,
                    zIndex: 5,
                    sx: a,
                    children: e
                }), r]
            })
        })
    })
}
))
  , SK = {
    py: 0,
    display: "flex",
    flexDirection: "column",
    maxHeight: "100vh",
    overflow: "auto",
    height: "100%"
}
  , yK = {
    padding: 0
}
  , kK = {
    xs: "column",
    md: "row"
}
  , CK = {
    flexGrow: 1,
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "space-between",
    overflowX: "hidden",
    overflowY: "scroll",
    pl: {
        xs: 2,
        md: "120px"
    },
    pr: {
        xs: 2,
        md: "50px"
    },
    maxHeight: {
        md: "100%"
    },
    gap: {
        xs: 6,
        md: 3
    },
    pt: {
        xs: 4,
        md: "120px"
    }
}
  , AK = {
    filter: "blur(18px)",
    zIndex: 0,
    position: "absolute",
    top: 0,
    left: 0
}
  , wK = {
    color: "white",
    textShadow: "\n      0 0 2px rgba(255, 255, 255, 0.25),\n      0 0 4px rgba(255, 255, 255, 0.25),\n      0 0 7.7px rgba(255, 255, 255, 0.25)\n    "
}
  , jK = {
    position: "relative",
    display: "inline-block"
};
var TK = (e => (e.PASSWORD = "password",
e.GOOGLE = "google.com",
e.PHANTOM = "Phantom",
e.METAMASK = "MetaMask",
e.TELEGRAM = "Telegram",
e.OTP = "OTP",
e))(TK || {});
const IK = () => {
    const [e,t] = dx(EK, !1);
    return y.useMemo(( () => ({
        isReturningUser: e,
        flagAsReturningUser: () => {
            t(!0)
        }
    })), [e, t])
}
  , EK = "padreV2-isReturningUser"
  , MK = {
    initSignOut: () => {}
    ,
    signInWithTelegram: () => new Promise(( () => {}
    )),
    signInWithPhantom: () => new Promise(( () => {}
    )),
    signInWithMetaMask: () => new Promise(( () => {}
    )),
    signInWithStandardProvider: () => new Promise(( () => {}
    )),
    signInWithOtp: () => new Promise(( () => {}
    )),
    signInWithPassword: () => new Promise(( () => ({
        success: !1,
        message: "the context is empty"
    }))),
    resetPassword: () => new Promise(( () => ({
        success: !1,
        message: "the context is empty"
    }))),
    assignToKol: () => new Promise(( () => {}
    )),
    claimMarketingOffer: () => new Promise(( () => {}
    )),
    refreshUser: () => new Promise(( () => {}
    )),
    user: null,
    loading: !1,
    referredByInfo: null
}
  , NK = y.createContext(MK)
  , PK = new Set
  , OK = new Set;
St(Xm).then((e => {
    PK.forEach((t => t.onEvent(e)))
}
)).catch((e => {
    o(e)
}
)),
Xm.onAuthStateChanged((e => {
    OK.forEach((t => t.onEvent(e)))
}
));
const LK = {
    onRedirectResult: e => (PK.add(e),
    () => {
        PK.delete(e)
    }
    ),
    onUserAuthChange: e => (OK.add(e),
    () => {
        OK.delete(e)
    }
    )
}
  , RK = new Map([[TK.GOOGLE, new yt]])
  , DK = e => !!e && i().unix() - BK < i(e).unix()
  , BK = 15
  , _K = e => kt(e, "uid", "displayName", "email", "providerData", "emailVerified", "metadata")
  , UK = 1e4
  , WK = ({children: e}) => {
    const {setUid: t, trackSignedUp: n, trackLoggedIn: r} = hf()
      , [a,s] = y.useState(null)
      , l = pK()
      , [i,c] = y.useState(!1)
      , [d,u] = y.useState(!0)
      , p = (e => {
        const {setReferredBy: t} = hf()
          , [n,r] = y.useState({});
        return y.useEffect(( () => {
            if (!(null == e ? void 0 : e.uid))
                return;
            const r = n[e.uid];
            r && r.referredByKol && t(r.referredByKol)
        }
        ), [e, t, n]),
        y.useEffect(( () => {
            if (!(null == e ? void 0 : e.uid))
                return;
            let t = !1
              , n = null;
            const a = async () => {
                try {
                    const n = await ym.getReferredByInfo(e.uid);
                    t || r({
                        [e.uid]: n
                    })
                } catch (fNe) {
                    t || (n = setTimeout(( () => {
                        a()
                    }
                    ), UK))
                }
            }
            ;
            return a(),
            () => {
                t = !0,
                n && clearTimeout(n)
            }
        }
        ), [e, r]),
        (null == e ? void 0 : e.uid) ? n[e.uid] ?? null : null
    }
    )(a)
      , h = y.useCallback((e => {
        if (e) {
            Ou(e);
            const t = _K(e);
            s(t)
        } else
            s(null)
    }
    ), []);
    y.useEffect(( () => {
        const e = e => {
            if (null === e)
                s(null),
                u(!1);
            else {
                const t = _K(e);
                s(t),
                Ou(e),
                u(!1)
            }
        }
        ;
        return Xm.authStateReady().then(( () => {
            e(Xm.currentUser)
        }
        )).catch((e => {
            o(e)
        }
        )),
        LK.onUserAuthChange({
            onEvent(t) {
                e(t)
            }
        })
    }
    ), []),
    y.useEffect(( () => {
        const e = (null == a ? void 0 : a.uid) ?? null;
        if (t(e),
        e) {
            const t = {
                id: e
            };
            (null == a ? void 0 : a.email) && (t.email = a.email),
            Ct(t),
            At().setUser(t)
        } else
            Ct(null),
            At().setUser(null)
    }
    ), [a, t]);
    const m = y.useCallback((async () => {
        const {currentUser: e} = Xm;
        if (!e)
            return;
        await e.reload();
        const t = _K(e);
        s(t)
    }
    ), [])
      , g = y.useCallback((async e => {
        try {
            const t = (e => {
                const t = RK.get(e);
                if (!t)
                    throw new Error(`missing provider for providerId ${e}`);
                return t
            }
            )(e);
            await wt(Xm, t).then((async e => {
                var t;
                DK(null == (t = null == e ? void 0 : e.user.metadata) ? void 0 : t.creationTime) && n(TK.GOOGLE, null == e ? void 0 : e.user.uid),
                r(TK.GOOGLE, null == e ? void 0 : e.user.uid)
            }
            ))
        } catch (fNe) {}
    }
    ), [n, r])
      , x = y.useCallback((async ({email: e, password: t}) => await jt(Xm, e, t).then((async e => (await h(e.user),
    r(TK.PASSWORD, e.user.uid),
    {
        success: !0
    }))).catch((e => ({
        success: !1,
        message: e.code
    })))), [h, r])
      , b = y.useCallback((async e => {
        try {
            const t = await em.getTelegramToken(e)
              , a = await Tt(Xm, t.token);
            DK(a.user.metadata.creationTime) && n(TK.TELEGRAM, a.user.uid),
            r(TK.TELEGRAM, a.user.uid),
            h(a.user)
        } catch (W$e) {
            o(W$e)
        }
    }
    ), [r, n, h])
      , f = y.useCallback((async e => {
        var t, a;
        if (null == (a = null == (t = window.phantom) ? void 0 : t.solana) ? void 0 : a.isPhantom)
            try {
                try {
                    await window.phantom.solana.connect({
                        onlyIfTrusted: !0
                    })
                } catch (W$e) {
                    (e => "object" == typeof e && e && "code"in e && 4001 === e.code)(W$e) ? await window.phantom.solana.connect() : o(W$e)
                }
                const t = await em.getSolanaSignInInput()
                  , a = (new TextEncoder).encode(Object.values(t).join("\n"))
                  , s = await window.phantom.solana.signMessage(a, "utf8")
                  , l = await em.signInWithPhantom({
                    walletAddress: s.publicKey.toBase58(),
                    signature: It.encode(s.signature),
                    message: t.message,
                    kolName: e.refCode,
                    v1MigrationCode: e.migrationCode || null
                })
                  , i = await Tt(Xm, l.token);
                DK(i.user.metadata.creationTime) && n(TK.PHANTOM, i.user.uid),
                r(TK.PHANTOM, i.user.uid),
                h(i.user)
            } catch (W$e) {
                l({
                    message: "Please connect with Solana account and try again.",
                    type: "error"
                }, "phantom-sign-in-failed"),
                o(W$e)
            }
        else
            l({
                message: pu.phantomNotInstalled,
                type: "error"
            }, "phantom-not-installed")
    }
    ), [l, r, n, h])
      , S = y.useCallback((async e => {
        try {
            const t = await em.getMetaMaskSignInInput()
              , a = await FK(t.message)
              , s = await em.signInWithMetaMask({
                message: t.message,
                signature: a,
                kolName: e.refCode,
                v1MigrationCode: e.migrationCode || null
            })
              , o = await Tt(Xm, s.token);
            DK(o.user.metadata.creationTime) && n(TK.METAMASK, o.user.uid),
            r(TK.METAMASK, o.user.uid),
            h(o.user)
        } catch (W$e) {
            l({
                message: "Make sure MetaMask is installed and try again",
                type: "error"
            }, "meta-mask-sign-up-error")
        }
    }
    ), [l, r, n, h])
      , k = y.useCallback((async ({email: e}) => await Et(Xm, e).then(( () => ({
        success: !0
    }))).catch((e => ({
        success: !1,
        message: e.code
    })))), [])
      , C = y.useCallback((async e => {
        const t = await em.signInWithOtp({
            otp: e
        })
          , n = await Tt(Xm, t.token);
        r(TK.OTP, n.user.uid),
        h(n.user)
    }
    ), [r, h])
      , A = y.useCallback((e => {
        c(!0),
        Xm.signOut().then(( () => {
            e(),
            localStorage.clear(),
            localStorage.setItem(EK, JSON.stringify(!0)),
            XG()
        }
        )).catch((e => {
            c(!1)
        }
        ))
    }
    ), [])
      , w = y.useCallback((async (e, t) => {
        const {uid: n} = Xm.currentUser ?? {};
        if (!n)
            return null;
        try {
            return await tm.assignToKol({
                uid: n,
                kolName: e,
                ...t ? {
                    v1MigrationCode: t
                } : {}
            }),
            h(Xm.currentUser),
            !0
        } catch (W$e) {
            return o(W$e),
            !1
        }
    }
    ), [h])
      , j = y.useCallback((async e => {
        const {uid: t} = Xm.currentUser ?? {};
        if (!t)
            return null;
        try {
            return await Cm.claimMarketingOffer(t, e),
            !0
        } catch (W$e) {
            return o(W$e),
            !1
        }
    }
    ), [])
      , {flagAsReturningUser: T} = IK();
    y.useEffect(( () => {
        (null == a ? void 0 : a.uid) && T()
    }
    ), [null == a ? void 0 : a.uid, T]);
    const I = y.useMemo(( () => ({
        initSignOut: A,
        signInWithPassword: x,
        resetPassword: k,
        signInWithStandardProvider: g,
        assignToKol: w,
        claimMarketingOffer: j,
        refreshUser: m,
        signInWithTelegram: b,
        user: d ? null : a,
        loading: d,
        signInWithPhantom: f,
        signInWithMetaMask: S,
        signInWithOtp: C,
        referredByInfo: p
    })), [A, x, k, g, w, j, m, b, a, d, f, S, C, p]);
    return v.jsx(NK.Provider, {
        value: I,
        children: i ? v.jsx(vK, {
            children: v.jsx(Km, {})
        }) : e
    })
}
  , FK = async e => {
    if (!window.ethereum)
        throw new Error("Make sure MetaMask is installed");
    const [t] = await window.ethereum.request({
        method: "eth_requestAccounts"
    });
    return await window.ethereum.request({
        method: "personal_sign",
        params: [e, t]
    })
}
  , VK = () => y.useContext(NK)
  , HK = {
    session: null,
    isLoadingSessionInfo: !1,
    isSessionActive: !1,
    isUnlocking: !1,
    openNewSession: async () => {}
    ,
    openModal: c.noop
}
  , zK = y.createContext(HK);
zK.displayName = "UserSessionContext";
const $K = () => y.useContext(zK)
  , GK = ({iconSize: e}) => {
    const {user: t} = VK()
      , {hasApiAuthenticator: n, isContextLoading: r} = YT()
      , {isSessionActive: a, session: s, openNewSession: o, isUnlocking: l} = $K()
      , i = pK()
      , c = (null == t ? void 0 : t.uid) ?? null
      , d = Boolean(!c || r || n)
      , u = PA({
        refreshRate: 1e3,
        immediateRunAfterPageBecomesVisible: !0,
        skip: d
    })
      , {state: p} = UD((e => e))
      , h = y.useCallback((async e => {
        e.stopPropagation(),
        e.preventDefault(),
        a || (p === BD.READY ? await o() : i({
            message: uu.unknownError,
            snackName: pu.unknownError,
            type: "error"
        }, "session-lock-early-return-error"))
    }
    ), [a, p, o, i]);
    if (d)
        return null;
    const m = a && !!s && s.expiresAt >= u.unix();
    return v.jsx(z, {
        title: m ? "Trading is unlocked" : "",
        children: v.jsx(C, {
            component: "span",
            children: v.jsx(V, {
                disabled: m || l || p !== BD.READY,
                onClick: h,
                variant: "tertiary",
                size: "small",
                startIcon: l ? v.jsx(J, {
                    size: e,
                    color: "inherit"
                }) : m ? v.jsx(Mt, {
                    sx: {
                        fontSize: e
                    }
                }) : v.jsx(Nt, {
                    sx: {
                        fontSize: e
                    }
                }),
                sx: {
                    width: qK,
                    pl: 1,
                    justifyContent: "flex-start",
                    height: KK
                },
                children: v.jsx(k, {
                    sx: {
                        display: "flex",
                        justifyContent: "flex-end",
                        width: "100%"
                    },
                    variant: m ? "monoLarge" : "labelLarge",
                    ...Nu,
                    children: m ? `${WI(s.expiresAt - u.unix())}` : "Unlock"
                })
            })
        })
    })
}
  , qK = 110
  , KK = bu.XSMALL
  , YK = ({isOpen: e, onClose: t, isSessionActive: n, openNewSession: r}) => {
    const [a,s] = y.useState(!1);
    y.useEffect(( () => {
        e && Ve("User session modal opened")
    }
    ), [e]);
    const o = y.useCallback(( () => {
        a || (s(!0),
        r())
    }
    ), [a, r]);
    return y.useEffect(( () => {
        n && t()
    }
    ), [n, t]),
    v.jsx(Sw, {
        open: e,
        onClose: t,
        desktopWidth: XK,
        minDesktopWidth: XK,
        stackSx: {
            p: 3,
            zIndex: 1305
        },
        children: v.jsxs(S, {
            gap: 1,
            children: [v.jsx(k, {
                variant: "h3",
                children: "Trading locked"
            }), v.jsx(k, {
                variant: "bodyLarge",
                color: "text.meta",
                children: "To start trading, please unlock trading for one hour"
            }), v.jsx(V, {
                sx: {
                    mt: 2
                },
                disabled: n || a,
                onClick: n ? t : o,
                variant: n ? "secondary" : "primary",
                endIcon: v.jsx(rt, {
                    orientation: "horizontal",
                    unmountOnExit: !0,
                    in: !n && a,
                    sx: {
                        minWidth: 16
                    },
                    children: v.jsx(J, {
                        size: 16
                    })
                }),
                children: "Unlock"
            })]
        })
    })
}
  , XK = 400
  , QK = async e => {
    const t = await am.startSession({
        uid: e.uid
    })
      , n = await (async (e, t) => {
        const n = FT(e.credentialIds, e.hasApiAuthenticator, e.apiStamper);
        return await n.stampCreateApiKeys({
            type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
            organizationId: e.ethSubOrgId,
            timestampMs: String(+(await kg())),
            parameters: {
                userId: t.turnkeyUserId,
                apiKeys: [{
                    apiKeyName: t.sessionId,
                    publicKey: t.publicKey,
                    curveType: "API_KEY_CURVE_P256",
                    expirationSeconds: String(604860)
                }]
            }
        })
    }
    )(e, t)
      , {sessionSecret: r, sessionId: a, expiresAt: s} = await am.signSession(t.sessionId, {
        uid: e.uid,
        signedRequest: n
    });
    return {
        uid: e.uid,
        sessionSecret: r,
        sessionId: a,
        expiresAt: s
    }
}
  , ZK = ({children: e}) => {
    const {user: t, loading: n} = VK()
      , r = pK()
      , {credentialIds: a, ethSubOrgId: s, state: l} = UD((e => e))
      , [c,d] = dx("padreV2-session", null)
      , [u,p] = y.useState(!1)
      , h = YT()
      , [m,g] = y.useState(c && c.expiresAt < i().unix())
      , [x,b] = y.useState(!!c && c.expiresAt > i().unix() + JK)
      , S = (null == t ? void 0 : t.uid) ?? null
      , k = h.isContextLoading || n || l !== BD.READY
      , C = !!(S && (a.length > 0 || h.apiStamper) && s && c && c.uid === S && !m && c.expiresAt > i().unix());
    y.useEffect(( () => {
        S && c && c.uid !== S && d(null)
    }
    ), [c, d, S]),
    y.useEffect(( () => {
        S && c && S === c.uid ? Ap(c) : Ap(null)
    }
    ), [c, S]);
    const [A,w] = JC(!1, eY)
      , j = y.useRef(c);
    j.current = c,
    y.useEffect(( () => {
        const e = setInterval(( () => {
            g(!!j.current && j.current.expiresAt < i().unix()),
            b(!!j.current && j.current.expiresAt > i().unix() + JK)
        }
        ), 1e3);
        return () => {
            clearInterval(e)
        }
    }
    ), [g, b]);
    const T = y.useCallback((async e => {
        if (u)
            f({
                message: "openNewSession - early return isUnlocking"
            });
        else if (e && A)
            f({
                message: "openNewSession - early return recentlyAutoUnlocked for automatic"
            });
        else if (k)
            f({
                message: "openNewSession - early return isLoadingSessionInfo"
            });
        else
            try {
                if (f({
                    message: "openNewSession - starting session",
                    data: {
                        uid: S,
                        credentialIdsLength: a.length,
                        apiStamperExists: !!h.apiStamper,
                        ethSubOrgIdExists: !!s,
                        hasApiAuthenticator: !!h.hasApiAuthenticator
                    }
                }),
                S && (a.length > 0 || h.apiStamper) && s) {
                    p(!0);
                    const e = await QK({
                        credentialIds: a,
                        ethSubOrgId: s,
                        hasApiAuthenticator: !!h.hasApiAuthenticator,
                        apiStamper: h.apiStamper,
                        uid: S
                    });
                    d(e),
                    f({
                        message: "openNewSession - newSession has been set",
                        data: {
                            uid: S,
                            newSessionExpiresAt: e.expiresAt,
                            newSessionUid: e.uid
                        }
                    })
                }
            } catch (fNe) {
                o(fNe),
                e || r({
                    message: uu.unlockFailed,
                    snackName: pu.somethingWentWrong,
                    type: "error"
                }, "unlock-trading-error")
            } finally {
                w(!0),
                p(!1)
            }
    }
    ), [u, A, k, S, a, h.apiStamper, h.hasApiAuthenticator, s, d, r, w]);
    y.useEffect(( () => {
        u ? f({
            message: "User session automatic refresh - early return isUnlocking "
        }) : k ? f({
            message: "User session automatic refresh - early return isLoadingSessionInfo "
        }) : h.hasApiAuthenticator ? h.apiStamper ? c && x && c.expiresAt > i().unix() + JK ? f({
            message: "User session automatic refresh - stored session is active",
            data: {
                uid: S,
                storedSessionExists: !!c,
                storedSessionUid: (null == c ? void 0 : c.uid) ?? null,
                storedSessionExpiresAt: (null == c ? void 0 : c.expiresAt) ?? null
            }
        }) : (async () => {
            await T(!0)
        }
        )() : f({
            message: "User session automatic refresh - early return apiStamper doesn't exists"
        }) : f({
            message: "User session automatic refresh - early return hasApiAuthenticator doesn't exists "
        })
    }
    ), [h.hasApiAuthenticator, h.apiStamper, T, u, c, k, x, S]);
    const [I,E] = y.useState(!1)
      , M = y.useCallback(( () => {
        f({
            message: "opening user session modal internal params",
            data: {
                uid: S,
                credentialIdsLength: a.length,
                apiStamperExists: !!h.apiStamper,
                ethSubOrgIdExists: !!s,
                storedSessionExists: !!c,
                storedSessionUid: (null == c ? void 0 : c.uid) ?? null,
                storedSessionExpiresAt: (null == c ? void 0 : c.expiresAt) ?? null,
                isUnlocking: u,
                recentlyAutoUnlocked: A,
                velvetLoading: h.isContextLoading,
                walletsState: l,
                isAuthLoading: n
            }
        }),
        E(!0)
    }
    ), [a.length, s, n, u, A, c, S, h.apiStamper, h.isContextLoading, l])
      , N = y.useCallback(( () => {
        E(!1)
    }
    ), [])
      , P = y.useMemo(( () => ({
        isSessionActive: C,
        session: S && S === (null == c ? void 0 : c.uid) ? c : null,
        isLoadingSessionInfo: k,
        isUnlocking: u,
        openNewSession: T,
        openModal: M
    })), [C, k, u, M, T, c, S]);
    return v.jsxs(zK.Provider, {
        value: P,
        children: [e, v.jsx(YK, {
            isOpen: I,
            onClose: N,
            isSessionActive: C,
            openNewSession: T
        })]
    })
}
  , JK = 518400
  , eY = 1e3
  , tY = "#141517"
  , nY = "ag-theme-quartz-dark";
var rY = (e => (e.LAST_SORTED_ROW = "last-sorted-row",
e))(rY || {})
  , aY = (e => (e.DISABLED_ACTIVE_COLOR = "ag-grid-disabledActiveColor",
e.LIGHTEN_ROW_BORDER = "ag-grid-lightenRowBorder",
e.DISABLE_PADDING = "ag-grid-disablePadding",
e.DISABLE_BORDER = "ag-grid-disableBorder",
e.NO_ZEBRA_ROWS = "ag-grid-noZebraRows",
e.SMALL_PADDING = "ag-grid-smallPadding",
e.INDIGO_ZEBRA_ROWS = "ag-grid-indigoZebraRows",
e))(aY || {});
const sY = 32
  , oY = e => ({
    [`.${nY}`]: {
        "--ag-font-family": `${Cu.REGULAR}, -apple-system, sans-serif`,
        "--ag-font-size": `${Au.REGULAR}px`,
        "--ag-header-font-weight": "medium",
        "--ag-foreground-color": e.palette.text.primary,
        "--ag-background-color": e.palette.background.default,
        "--ag-header-foreground-color": e.palette.text.label,
        "--ag-header-background-color": e.palette.grey[900],
        "--ag-cell-horizontal-padding": "4px",
        "--ag-header-column-resize-handle-color": e.palette.text.value,
        "--ag-icon-font-color-filter": e.palette.text.value,
        "--ag-icon-font-color-desc": e.palette.text.value,
        "--ag-icon-font-color-asc": e.palette.text.value,
        "--ag-grid-size": "8px",
        "--ag-active-color": e.palette.background.tertiary,
        "--ag-wrapper-border-radius": 0,
        "--ag-header-height": `${sY}px`,
        ".ag-header-cell-sorted-asc": {
            color: e.palette.text.value
        },
        ".ag-header-cell-sorted-desc": {
            color: e.palette.text.value
        },
        ".ag-root-wrapper": {
            border: "none"
        },
        ".ag-body-vertical-scroll": {
            display: "none"
        },
        ".ag-header": {
            borderColor: e.palette.background.borderMain
        },
        cursor: "move",
        '.ag-header-cell[aria-sort="descending"], .ag-header-cell[aria-sort="ascending"]': {
            color: e.palette.text.label
        },
        ".ag-header-row": {
            fontWeight: 500,
            fontSize: `${pY}px`
        },
        ".ag-cell": {
            WebkitFontSmoothing: "antialiased",
            paddingLeft: 0,
            paddingRight: 0,
            border: "none"
        },
        ".ag-cell:first-of-type, .ag-header-cell:first-of-type": {
            paddingLeft: uY
        },
        ".ag-cell:last-child, .ag-header-cell:last-child": {
            paddingRight: uY
        },
        "& .ag-root .ag-pinned-left-header, & .ag-root .ag-pinned-right-header, & .ag-root .ag-pinned-left-cols-container, & .ag-root .ag-pinned-right-cols-container": {
            borderRight: "none",
            borderLeft: "none"
        },
        "& .ag-root .ag-header-cell": {
            borderRightColor: "transparent"
        },
        "& .ag-root .ag-pinned-left-cols-container .ag-cell, & .ag-root .ag-pinned-right-cols-container .ag-cell": {
            borderRight: "none",
            borderLeft: "none"
        },
        ".ag-ltr": {
            ".ag-sort-indicator-icon": {
                paddingLeft: 4
            },
            ".ag-header-cell:not(.ag-right-aligned-header) .ag-header-label-icon": {
                marginLeft: 4
            }
        },
        ".ag-row": {
            borderBottom: "none !important"
        },
        [`.${iY}`]: {
            cursor: "move"
        },
        "&.ag-grid-disabledActiveColor": {
            "--ag-active-color": "transparent"
        },
        "&.ag-grid-disablePadding": {
            ".ag-cell:first-of-type, .ag-header-cell:first-of-type": {
                paddingLeft: 0
            },
            ".ag-cell:last-child, .ag-header-cell:last-child": {
                paddingRight: 0
            }
        },
        "&.ag-grid-smallPadding": {
            ".ag-cell:first-of-type, .ag-header-cell:first-of-type": {
                paddingLeft: 8
            },
            ".ag-cell:last-child, .ag-header-cell:last-child": {
                paddingRight: 8
            }
        },
        ".ag-row-odd": {
            backgroundColor: e.palette.background.secondary
        },
        "&.ag-grid-noZebraRows": {
            ".ag-row-odd": {
                backgroundColor: e.palette.background.primary
            }
        },
        "&.ag-grid-indigoZebraRows": {
            ".ag-row-odd": {
                backgroundColor: tY
            }
        }
    },
    ".last-sorted-row": {
        borderBottom: `1px solid ${e.palette.background.borderStandard}`
    }
})
  , lY = "ag-right-aligned-header"
  , iY = "ag-header-moveable-header"
  , cY = {
    minWidth: 85
}
  , dY = {
    flex: 1.2
}
  , uY = 16
  , pY = 12
  , hY = {
    root: () => ({
        backgroundImage: "none"
    })
}
  , mY = {
    root: ({theme: e}) => ({
        border: `1px solid ${e.palette.background.borderMain}`
    })
}
  , gY = wu.MEDIUM
  , xY = {
    root: ({ownerState: {color: e, variant: t, size: n}, theme: r}) => {
        const a = e ?? "primary"
          , s = r.palette[a]
          , o = s.main ? s : r.palette.primary
          , {backgroundColor: l, hoverBackgroundColor: i, color: c, borderColor: d, hoverBorderColor: u} = vY(t, o, "primary" === a, r);
        return {
            height: bY(n),
            minWidth: bY(n),
            fontSize: fY(n),
            fontWeight: gY,
            textTransform: "none",
            backgroundColor: l,
            color: c,
            border: `1px solid ${d}`,
            transition: "none",
            "&:hover": {
                backgroundColor: i,
                borderColor: u
            },
            "&:disabled": {
                backgroundColor: r.palette.background.disabled,
                borderColor: r.palette.background.disabled,
                color: r.palette.text.label
            },
            "&:focus": {
                backgroundColor: i,
                borderColor: r.palette.background.borderActive
            }
        }
    }
}
  , bY = e => {
    switch (e) {
    case "auto":
        return;
    case "xxsmall":
        return bu.XXSMALL;
    case "xsmall":
        return bu.XSMALL;
    case "small":
        return bu.SMALL;
    case "large":
        return bu.LARGE;
    default:
        return bu.MEDIUM
    }
}
  , fY = e => {
    switch (e) {
    case "xsmall":
    case "small":
        return Au.REGULAR;
    default:
        return Au.LARGE
    }
}
  , vY = (e, t, n, r) => {
    if (!e)
        return {
            backgroundColor: "transparent",
            hoverBackgroundColor: "transparent",
            color: t[500],
            borderColor: "transparent",
            hoverBorderColor: "transparent"
        };
    switch (e) {
    case "text":
    case "primary":
    case "secondary":
        return "secondary" === e && n ? {
            backgroundColor: (n ? t[800] : t[900]) || "red",
            hoverBackgroundColor: n ? t[700] : t[600],
            color: t[500],
            borderColor: n ? t[800] : t[700],
            hoverBorderColor: t[700]
        } : {
            backgroundColor: t[500],
            hoverBackgroundColor: t[400] ?? Me(t[500], .15),
            color: t.contrastText,
            borderColor: t[500],
            hoverBorderColor: t[500]
        };
    case "tertiary":
        return {
            backgroundColor: r.palette.background.buttonDefault,
            hoverBackgroundColor: r.palette.background.buttonActive,
            color: r.palette.text.value,
            borderColor: r.palette.background.borderMain,
            hoverBorderColor: r.palette.background.borderSecondary
        }
    }
}
  , SY = [{
    props: {
        size: "small"
    },
    style: {
        "& .MuiSvgIcon-root": {
            fontSize: 20
        },
        width: 18,
        height: 18,
        borderRadius: 0
    }
}, {
    props: {
        size: "medium"
    },
    style: {
        "& .MuiSvgIcon-root": {
            fontSize: 22
        },
        width: 19,
        height: 19,
        borderRadius: 0
    }
}, {
    props: {
        size: "large"
    },
    style: {
        "& .MuiSvgIcon-root": {
            fontSize: 24
        },
        width: 21,
        height: 21,
        borderRadius: 0
    }
}]
  , yY = {
    root: {
        "@media (min-width: 0px)": {
            paddingLeft: 16,
            paddingRight: 16
        }
    }
}
  , kY = {
    root: ({theme: e}) => ({
        borderColor: e.palette.background.borderMain
    })
}
  , CY = {
    paper: ({theme: e}) => ({
        backgroundColor: e.palette.background.secondary,
        backgroundImage: "none"
    })
}
  , AY = {
    root: ({theme: e}) => ({
        "&:hover": {
            backgroundColor: e.palette.background.buttonDefault
        },
        "&:active": {
            backgroundColor: e.palette.background.buttonDefault
        }
    })
}
  , wY = {
    paper: ({theme: e}) => ({
        backgroundColor: e.palette.background.tertiary,
        backgroundImage: "none"
    }),
    list: ({theme: e}) => ({
        color: e.palette.text.meta
    })
}
  , jY = {
    root: ({theme: e}) => ({
        ...e.typography.labelRegular,
        "&:hover": {
            backgroundColor: e.palette.background.buttonActive
        },
        [`&.${Pt.selected}`]: {
            color: e.palette.text.value,
            backgroundColor: "transparent"
        },
        [`&:hover, &:focus, &.${Pt.focusVisible}`]: {
            [`&, &.${Pt.selected}`]: {
                backgroundColor: e.palette.background.buttonActive
            }
        }
    })
}
  , TY = {
    root: ({theme: e, ownerState: {size: t}}) => {
        const n = IY(t);
        return {
            height: n,
            borderRadius: n / 2,
            verticalAlign: "middle",
            background: e.palette.background.default,
            overflow: "hidden",
            [`.${Ot.notchedOutline}`]: {
                border: `1px solid ${EY({
                    theme: e
                })}`
            },
            [`.${Lt.icon}`]: {
                color: EY({
                    theme: e
                })
            },
            [`.${Ot.input}, .${Rt.root}`]: {
                fontSize: e.typography.bodyLarge.fontSize,
                fontWeight: e.typography.fontWeightMedium
            },
            [`.${Ot.input}::placeholder`]: {
                color: e.palette.text.label
            },
            "&:hover": {
                [`.${Ot.notchedOutline}`]: {
                    borderColor: EY({
                        theme: e,
                        hovered: !0
                    })
                },
                [`.${Lt.icon}`]: {
                    color: EY({
                        theme: e,
                        hovered: !0
                    })
                }
            },
            [`&.${Ot.focused}`]: {
                [`.${Ot.notchedOutline}`]: {
                    border: `1px solid ${EY({
                        theme: e,
                        focused: !0
                    })}`
                },
                [`.${Lt.icon}`]: {
                    color: EY({
                        theme: e,
                        focused: !0
                    })
                }
            },
            [`&.${Ot.error}`]: {
                [`.${Ot.notchedOutline}`]: {
                    borderColor: EY({
                        theme: e,
                        error: !0
                    })
                },
                [`.${Ot.input}, .${Ot.input}::placeholder, .${Rt.root}`]: {
                    color: e.palette.negative[500]
                }
            },
            [`&.${Ot.disabled}`]: {
                backgroundColor: e.palette.background.default,
                [`.${Ot.notchedOutline}`]: {
                    borderColor: EY({
                        theme: e,
                        disabled: !0
                    }),
                    backgroundColor: e.palette.background.default,
                    zIndex: -1
                },
                [`.${Lt.icon}`]: {
                    color: EY({
                        theme: e,
                        disabled: !0
                    })
                },
                [`.${Rt.root}`]: {
                    color: e.palette.text.label
                },
                [`.${Ot.input}`]: {
                    WebkitTextFillColor: e.palette.text.label
                },
                [`.${Ot.input}::placeholder`]: {
                    color: e.palette.text.disabled
                }
            }
        }
    }
}
  , IY = e => {
    switch (e) {
    case "xsmall":
        return bu.XSMALL;
    case "xlarge":
        return bu.XLARGE;
    default:
        return bu.MEDIUM
    }
}
  , EY = ({disabled: e, hovered: t, focused: n, error: r, theme: a}) => e ? a.palette.background.borderMain : r ? a.palette.negative[500] : t || n ? a.palette.background.borderSecondary : a.palette.background.borderMain
  , MY = {
    root: ({theme: e}) => ({
        backgroundColor: e.palette.background.buttonDefault
    })
}
  , NY = {
    root: {
        padding: 0,
        borderRadius: 16,
        "& .MuiSwitch-track": {
            opacity: 1,
            transition: "none"
        },
        "& .MuiSwitch-thumb": {
            transition: "none"
        }
    },
    sizeSmall: ({theme: e, ownerState: {color: t}}) => PY(e.palette[t ?? "primary"], e.palette.grey),
    sizeMedium: ({theme: e, ownerState: {color: t}}) => OY(e.palette[t ?? "primary"], e.palette.grey)
}
  , PY = (e, t) => LY(e, t, {
    width: RY,
    height: DY,
    thumbSize: BY,
    transformLength: _Y
})
  , OY = (e, t) => LY(e, t, {
    width: UY,
    height: WY,
    thumbSize: FY,
    transformLength: VY
})
  , LY = (e, t, n) => ({
    width: n.width,
    height: n.height,
    "& .MuiSwitch-switchBase": {
        padding: 0,
        margin: zY,
        transition: "none",
        "& .MuiSwitch-input": {
            position: "absolute",
            top: -zY,
            left: -zY,
            width: n.width,
            height: n.height,
            margin: 0,
            padding: 0
        },
        "&.Mui-checked .MuiSwitch-input": {
            left: `calc(-${zY}px - ${n.transformLength}px)`
        },
        "& .MuiTouchRipple-root": {
            transform: HY
        },
        ".MuiTouchRipple-child": {
            backgroundColor: "transparent",
            border: `${$Y}px solid white`
        },
        "&:hover": {
            backgroundColor: "transparent"
        },
        "& .MuiSwitch-thumb": {
            boxSizing: "border-box",
            width: n.thumbSize,
            height: n.thumbSize,
            transform: HY,
            color: e.main
        },
        "& + .MuiSwitch-track": {
            backgroundColor: e.background,
            opacity: 1
        },
        "&.Mui-checked": {
            transform: `translateX(${n.transformLength}px)`
        },
        "&.Mui-disabled .MuiSwitch-thumb": {
            opacity: .5
        },
        "&.Mui-disabled + .MuiSwitch-track": {
            opacity: .5
        }
    },
    "& .MuiSwitch-track": {
        backgroundColor: t[700]
    }
})
  , RY = 32
  , DY = 20
  , BY = 12
  , _Y = 12
  , UY = 44
  , WY = 24
  , FY = 16
  , VY = 20
  , HY = "translateY(2px) translateX(2px)"
  , zY = 2
  , $Y = 2
  , GY = {
    root: ({theme: e}) => ({
        minHeight: KY - YY,
        borderBottom: `${YY}px solid ${e.palette.background.borderSubtle}`,
        "& .MuiTabs-indicator": {
            transition: "none"
        }
    })
}
  , qY = {
    root: ({theme: e}) => ({
        whiteSpace: "nowrap",
        textTransform: "none",
        flex: 1,
        fontSize: Au.LARGE,
        fontWeight: wu.MEDIUM,
        maxWidth: "initial",
        minWidth: 0,
        minHeight: KY,
        maxHeight: KY,
        px: 0,
        color: e.palette.text.value,
        "&:hover": {
            backgroundColor: e.palette.background.buttonDefault,
            borderTopLeftRadius: "4px",
            borderTopRightRadius: "4px"
        }
    })
}
  , KY = bu.SMALL
  , YY = 1
  , XY = {
    tooltip: ({theme: e}) => ({
        backgroundColor: e.palette.background.buttonDefault,
        color: e.palette.text.value
    })
}
  , QY = "orange"
  , ZY = "grey"
  , JY = {
    [Xh.DARK]: hb,
    [Xh.GREY]: gb,
    [Xh.GREEN]: cb,
    [Xh.PURPLE]: ub,
    [Xh.MONOKAI]: vb,
    [Xh.VIOLET]: Cb,
    [Xh.INDIGO]: bb,
    [Xh.NOIR]: yb,
    [Xh.TERMINAL]: wb
}
  , eX = e => {
    if (!e.useSpecific || !e.specific)
        return hb;
    const t = e.defaultSkin ? JY[e.defaultSkin] : hb;
    return e.useSpecific && e.specific ? {
        ...t,
        yellow: {
            ...t.yellow,
            ...jb(e.specific.yellow)
        },
        purple: {
            ...t.purple,
            ...jb(e.specific.purple)
        },
        blue: {
            ...t.blue,
            ...jb(e.specific.blue)
        },
        lavender: {
            ...t.lavender,
            ...jb(e.specific.lavender)
        },
        gold: {
            ...t.gold,
            ...jb(e.specific.gold)
        },
        silver: {
            ...t.silver,
            ...jb(e.specific.silver)
        },
        bronze: {
            ...t.bronze,
            ...jb(e.specific.bronze)
        }
    } : t
}
  , tX = (e, t, n) => {
    const r = ( (e, t, n) => {
        switch (e) {
        case rg.DARK:
            return pb;
        case rg.GREY:
            return mb;
        case rg.GREEN:
            return ib;
        case rg.PURPLE:
            return db;
        case rg.VIOLET:
            return kb;
        case rg.MONOKAI:
            return fb;
        case rg.INDIGO:
            return xb;
        case rg.CUSTOM:
            return Pb(t);
        case rg.NOIR:
            return Sb;
        case rg.TERMINAL:
            return Ab;
        case rg.CUSTOM_2:
            return Pb(n)
        }
    }
    )(e, t, n)
      , a = ( (e, t, n) => {
        switch (e) {
        case rg.DARK:
            return hb;
        case rg.GREY:
            return gb;
        case rg.GREEN:
            return cb;
        case rg.PURPLE:
            return ub;
        case rg.VIOLET:
            return Cb;
        case rg.MONOKAI:
            return vb;
        case rg.INDIGO:
            return bb;
        case rg.CUSTOM:
            return eX(t);
        case rg.NOIR:
            return yb;
        case rg.TERMINAL:
            return wb;
        case rg.CUSTOM_2:
            return eX(n)
        }
    }
    )(e, t, n)
      , s = e => ({
        ...r[e],
        main: r[e][500],
        background: r[e][900]
    })
      , o = e => ({
        ...a[e],
        main: a[e][500]
    });
    return {
        mode: "dark",
        divider: r.grey[800],
        primary: {
            ...r[QY],
            main: r[QY][500],
            background: r[QY][800]
        },
        error: s("red"),
        warning: {
            main: a.yellow[500]
        },
        success: s("green"),
        positive: s("green"),
        negative: s("red"),
        neutral: {
            ...r[ZY],
            main: r[ZY][300],
            background: r[ZY][800]
        },
        ...r,
        ...a,
        gold: o("gold"),
        silver: o("silver"),
        bronze: o("bronze"),
        text: {
            main: r.grey[50],
            value: r.grey[100],
            label: r.grey[200],
            primary: r.grey[100],
            disabled: r.grey[400],
            meta: r.grey[200],
            placeholder: r.grey[200]
        },
        background: {
            default: r.grey[950],
            primary: r.grey[950],
            secondary: r.grey[900],
            scrim: a.black[700],
            hover: r.grey[600],
            borderMain: r.grey[500],
            borderSecondary: r.grey[300],
            buttonDefault: r.grey[800],
            buttonHover: r.grey[400],
            buttonActive: r.grey[700],
            tertiary: r.grey[800],
            disabled: r.grey[800],
            active: r.grey[700],
            borderActive: r.grey[300],
            borderStandard: r.grey[500],
            borderSubtle: r.grey[500]
        },
        originalPrimary: {
            ...pb.orange,
            main: pb.orange[500],
            background: pb.orange[800]
        },
        originalGreen: {
            ...pb.green,
            main: pb.green[500],
            background: pb.green[900]
        }
    }
}
  , nX = e => {
    const t = Mu(e);
    return {
        breakpoints: {
            values: {
                xs: 0,
                sm: 724,
                md: 1024,
                lg: 1440,
                xl: 1535
            }
        },
        typography: {
            fontFamily: Iu(e),
            ...t
        },
        shape: {
            borderRadius: 4
        },
        spacing: 8,
        components: {
            MuiButton: {
                defaultProps: {
                    disableRipple: !0,
                    disableFocusRipple: !0,
                    disableTouchRipple: !0
                },
                styleOverrides: xY
            },
            MuiIconButton: {
                styleOverrides: AY,
                defaultProps: {
                    disableRipple: !0,
                    disableFocusRipple: !0,
                    disableTouchRipple: !0
                }
            },
            MuiTextField: {
                defaultProps: {
                    size: "medium",
                    ...yu
                }
            },
            MuiOutlinedInput: {
                defaultProps: {
                    size: "medium",
                    ...yu
                },
                styleOverrides: TY
            },
            MuiDrawer: {
                styleOverrides: CY
            },
            MuiAccordion: {
                styleOverrides: hY
            },
            MuiMenu: {
                styleOverrides: wY
            },
            MuiMenuItem: {
                styleOverrides: jY
            },
            MuiSelect: {
                defaultProps: {
                    IconComponent: Sy
                },
                styleOverrides: MY
            },
            MuiContainer: {
                styleOverrides: yY
            },
            MuiCircularProgress: {
                defaultProps: {
                    disableShrink: !0
                }
            },
            MuiSwitch: {
                styleOverrides: NY
            },
            MuiTabs: {
                styleOverrides: GY
            },
            MuiAlert: {
                styleOverrides: mY
            },
            MuiTab: {
                defaultProps: {
                    disableRipple: !0,
                    disableFocusRipple: !0,
                    disableTouchRipple: !0
                },
                styleOverrides: qY
            },
            MuiCheckbox: {
                variants: SY
            },
            MuiTooltip: {
                defaultProps: {
                    disableInteractive: !0,
                    placement: "top"
                },
                styleOverrides: XY
            },
            MuiDivider: {
                styleOverrides: kY
            }
        }
    }
}
  , rX = (e, t, n, r) => {
    const a = Dt({
        ...nX(r),
        palette: tX(e, t, n)
    });
    return Dt(a, {
        palette: {
            positive: a.palette.augmentColor({
                color: {
                    main: a.palette.positive.main
                },
                name: "positive"
            }),
            negative: a.palette.augmentColor({
                color: {
                    main: a.palette.negative.main
                },
                name: "negative"
            })
        }
    })
}
  , aX = y.createContext({
    showBackdrop: c.noop,
    hideBackdrop: c.noop
})
  , sX = ({children: e}) => {
    const [t,n] = y.useState(!1)
      , [r,a] = y.useState()
      , s = y.useCallback((e => {
        a(( () => e)),
        n(!0)
    }
    ), [])
      , o = y.useCallback(( () => {
        n(!1),
        a(void 0)
    }
    ), [])
      , l = y.useMemo(( () => ({
        showBackdrop: s,
        hideBackdrop: o
    })), [s, o]);
    return v.jsxs(aX.Provider, {
        value: l,
        children: [e, t && v.jsx(Bt, {
            open: !0,
            sx: oX,
            onClick: r
        })]
    })
}
  , oX = {
    zIndex: 1395
}
  , lX = y.createContext({
    candlesSettings: null,
    saveCandlesSettings: O,
    deleteCandlesSettings: O
})
  , iX = ({children: e}) => {
    const {colorSkin: t} = y.useContext(Wb)
      , n = y.useRef(t);
    n.current = t;
    const [r,a] = Mx(Wg, null)
      , s = y.useMemo(( () => (null == r ? void 0 : r[t]) ?? {}), [r, t])
      , o = y.useCallback((e => {
        t === n.current && a((n => {
            const r = n ?? {
                dark: {},
                medium: {},
                green: {},
                monokai: {},
                purple: {},
                violet: {},
                indigo: {},
                custom: {},
                noir: {},
                custom2: {},
                terminal: {}
            };
            return r[t] = e,
            r
        }
        ))
    }
    ), [a, t])
      , l = y.useCallback(( (e, r) => {
        if (t !== n.current)
            return;
        const a = r
          , l = null === s ? {} : s;
        l[e] = a,
        o(l)
    }
    ), [s, o, t])
      , i = y.useCallback((e => {
        null !== s && t === n.current && (delete s[e],
        o(s))
    }
    ), [s, o, t])
      , c = y.useMemo(( () => ({
        candlesSettings: s,
        saveCandlesSettings: l,
        deleteCandlesSettings: i
    })), [s, l, i]);
    return v.jsx(lX.Provider, {
        value: c,
        children: e
    })
}
  , cX = y.createContext({
    ensMaps: {
        [Pd.ETH_MAINNET]: new Map,
        [Pd.ETH_SEPOLIA]: new Map,
        [Pd.BASE]: new Map,
        [Pd.BSC]: new Map,
        [Pd.ARBITRUM]: new Map,
        [Pd.ARBITRUM_SEPOLIA]: new Map,
        [Pd.SOLANA]: new Map
    },
    enqueueRequest: O
})
  , dX = ({children: e}) => {
    const t = VK()
      , n = null == t ? void 0 : t.user
      , [r,a] = y.useState({
        [Pd.ETH_MAINNET]: new Map,
        [Pd.ETH_SEPOLIA]: new Map,
        [Pd.BASE]: new Map,
        [Pd.BSC]: new Map,
        [Pd.ARBITRUM]: new Map,
        [Pd.ARBITRUM_SEPOLIA]: new Map,
        [Pd.SOLANA]: new Map
    })
      , s = y.useRef(r);
    s.current = r;
    const o = y.useCallback((e => async (t, r) => {
        if (!n)
            return;
        const s = Array.from(t.values());
        a((n => {
            const a = n[e];
            return r.forEach((e => {
                const t = a.get(e);
                void 0 !== t && (a.delete(e),
                a.set(e, t))
            }
            )),
            t.forEach((e => {
                void 0 === a.get(e) && (a.set(e, null),
                a.size > 5e3 && uX(a))
            }
            )),
            {
                ...n,
                [e]: new Map(a)
            }
        }
        ));
        const o = gg(e) ? await Am.getEns({
            chain: e,
            addresses: s
        }) : {};
        a((t => {
            const n = t[e];
            return c.forEach(o, ( (e, t) => {
                n.set(t, e),
                n.size > 5e3 && uX(n)
            }
            )),
            {
                ...t,
                [e]: new Map(n)
            }
        }
        ))
    }
    ), [n])
      , l = y.useMemo(( () => (e, t) => {
        e.forEach((e => XB(o(e), {
            alreadyExists: t => void 0 !== s.current[e].get(t),
            getItemKey: e => e,
            debounceTime: 250,
            bucketSize: 250
        }))(t))
    }
    ), [o])
      , i = y.useMemo(( () => ({
        ensMaps: r,
        enqueueRequest: l
    })), [r, l]);
    return v.jsx(cX.Provider, {
        value: i,
        children: e
    })
}
  , uX = e => {
    const t = e.keys().next().value;
    e.delete(t)
}
  , pX = (e, t) => {
    const {ensMaps: n, enqueueRequest: r} = y.useContext(cX);
    return y.useEffect(( () => {
        e.length && t && gg(t) && r(e, t)
    }
    ), [r, e, t]),
    y.useMemo(( () => {
        if (!e.length || !t || !gg(t))
            return null;
        const r = n[t];
        return new Map(e.filter((e => r.has(e))).map((e => [e, r.get(e)])))
    }
    ), [e, n, t])
}
;
const hX = (e, t) => {
    if (!e || e.length % 2 != 0 || !/^[0-9A-Fa-f]+$/.test(e))
        throw new Error(`cannot create uint8array from invalid hex string: "${e}"`);
    const n = new Uint8Array(e.match(/../g).map((e => parseInt(e, 16))));
    if (!t)
        return n;
    if (e.length / 2 > t)
        throw new Error("hex value cannot fit in a buffer of " + t + " byte(s)");
    const r = new Uint8Array(t);
    return r.set(n, t - n.length),
    r
}
  , mX = async (e, t, n, r) => {
    var a;
    const s = FT(e, !!t.hasApiAuthenticator, t.apiStamper)
      , o = _t({
        client: s,
        requestFn: async () => {
            return s.exportWalletAccount({
                type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT",
                timestampMs: String(+(await kg())),
                organizationId: r.subOrgId,
                parameters: {
                    address: (e = r.publicAddress,
                    e && e.startsWith("0x") ? j(e) : e),
                    targetPublicKey: n
                }
            });
            var e
        }
    });
    return null == (a = (await o({})).result.exportWalletAccountResult) ? void 0 : a.exportBundle
}
  , gX = async (e, t, n, r) => {
    var a;
    const s = FT(e, !!t.hasApiAuthenticator, t.apiStamper)
      , o = _t({
        client: s,
        requestFn: async () => s.exportPrivateKey({
            type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY",
            timestampMs: String(+(await kg())),
            organizationId: r.subOrgId,
            parameters: {
                privateKeyId: r.walletId,
                targetPublicKey: n
            }
        })
    });
    return null == (a = (await o({})).result.exportPrivateKeyResult) ? void 0 : a.exportBundle
}
  , xX = 500
  , bX = 1e4
  , fX = ({children: e}) => {
    const t = ( () => {
        const e = Ax()
          , t = pK()
          , n = y.useRef({});
        return y.useCallback((r => {
            const a = i()
              , s = n.current[r];
            (!s || a.diff(s, "millisecond") > xX) && (t({
                variant: lK.CONTACT_SUPPORT,
                details: {
                    errorCode: r,
                    additionalContext: {
                        uid: e
                    }
                }
            }, "fast-sign-contact-support", {
                autoHideDuration: bX
            }),
            n.current[r] = a)
        }
        ), [t, e])
    }
    )()
      , n = YT()
      , r = UD((e => e.wallets))
      , a = y.useMemo(( () => r ? r.filter((e => e.walletType === pc.SOL)) : null), [r])
      , [s,l] = dx("padre-v2-bundles-store-v2", {
        bundles: {}
    })
      , c = y.useRef(s);
    c.current = s;
    const {apiStamper: d, _velvetBundleVersion: u} = n;
    y.useEffect(( () => {
        if (!a || !(null == d ? void 0 : d.apiPublicKey))
            return;
        const e = Ut(hX(d.apiPublicKey)).reduce(( (e, t) => e + t.toString(16).padStart(2, "0")), "");
        let t = 0;
        Promise.all(a.map((async r => {
            var a;
            if (!r.isHidden && (null == (a = s.bundles[r.publicAddress]) ? void 0 : a._velvetBundleVersion) !== u)
                try {
                    await Hu(1e3 * t),
                    t += 1;
                    const a = r.isImported ? await gX(null, n, e, r) : await mX(null, n, e, r);
                    a && l((e => ({
                        ...e,
                        bundles: {
                            ...e.bundles,
                            [r.publicAddress]: {
                                exportBundle: a,
                                subOrgId: r.subOrgId,
                                _velvetBundleVersion: u
                            }
                        }
                    })))
                } catch (i) {
                    const e = new PT(i);
                    o(e),
                    np.error("Failed to export wallet bundle inner", {
                        wallet: r,
                        safeError: e
                    })
                }
        }
        ))).catch((e => {
            const t = new PT(e);
            o(t),
            np.error("Failed to export wallet bundle", {
                solWallets: a,
                safeError: t
            })
        }
        ))
    }
    ), [a, s, null == d ? void 0 : d.apiPublicKey, l, n, u]);
    const p = y.useCallback((async (e, n) => {
        var r;
        const a = (null == (r = c.current) ? void 0 : r.bundles[e]) ?? null;
        if (!(null == d ? void 0 : d.apiPrivateKey) || !a) {
            const e = !!(null == d ? void 0 : d.apiPrivateKey)
              , n = !!a;
            return np.warn("missing api stamper data", {
                hasKey: e,
                hasBundle: n
            }),
            t(Rq.FAST_SIGN_MISSING_API_STAMPER),
            null
        }
        try {
            const r = await Wt({
                exportBundle: a.exportBundle,
                embeddedKey: d.apiPrivateKey,
                organizationId: a.subOrgId,
                returnMnemonic: !1
            });
            if (!r)
                return np.warn("decryptExportBundle returned null"),
                t(Rq.FAST_SIGN_NULL_DECRYPTED_BUNDLE),
                null;
            const s = (e => {
                const {feePayer: t, blockhash: n, instructions: r, lookupTableAccounts: a} = e
                  , s = new oe({
                    payerKey: new se(t),
                    recentBlockhash: n,
                    instructions: r
                }).compileToV0Message(a);
                return new le(s)
            }
            )(n)
              , o = hX(r);
            s.sign([{
                publicKey: mj(e),
                secretKey: o
            }]);
            const l = It.encode(s.signatures[0])
              , i = s.serialize();
            if (!(i.length <= 1232))
                throw np.error(`Serialized transaction has ${i.length} bytes, which is too large`, {
                    walletAddress: e,
                    addresses: m.uniq(n.instructions.flatMap((e => e.keys)).map((e => e.pubkey.toString())))
                }),
                t(Rq.FAST_SIGN_SERIALIZED_TXN_TOO_LARGE),
                new Error(`Serialized transaction is too large: ${i.length} bytes`);
            return np.info(`Serialized transaction has ${i.length} bytes`),
            {
                signedTxnBase64: Buffer.from(i).toString("base64"),
                txnHash: l
            }
        } catch (s) {
            const t = new PT(s);
            return o(t),
            np.error("Failed to sign a transaction", {
                walletAddress: e,
                addresses: m.uniq(n.instructions.flatMap((e => e.keys)).map((e => e.pubkey.toString()))),
                safeError: t
            }),
            null
        }
    }
    ), [null == d ? void 0 : d.apiPrivateKey, t])
      , h = y.useMemo(( () => ({
        getTxnSign: p
    })), [p]);
    return v.jsx(bU.Provider, {
        value: h,
        children: e
    })
}
  , vX = y.createContext({
    hiddenPairs: null,
    hiddenMigratedPairs: null,
    showPair: O,
    hidePair: O,
    clearAll: O
})
  , SX = () => y.useContext(vX)
  , yX = 1e3
  , kX = (e, t) => `${ng(e)}-${t}`
  , CX = e => {
    const [t,n] = e.split("-");
    return {
        tokenAddress: t,
        chain: n
    }
}
  , AX = e => {
    const t = CX(e).tokenAddress;
    return ru(t) || t === Fd
}
  , wX = (e, t) => e.filter((e => e !== t && !AX(e)))
  , jX = ({children: e}) => {
    const {settings: t, updateHiddenPairs: n} = rf()
      , r = pK()
      , [a,s] = JC(null, TX)
      , [o,l] = JC(null, TX)
      , i = y.useMemo(( () => t ? IX(t.hiddenMigratedPairs ?? []) : null), [t])
      , d = y.useMemo(( () => t ? IX(t.hiddenPairs ?? [], i ?? {}) : null), [i, t])
      , u = y.useCallback(( (e, r) => {
        if (!t)
            return;
        const i = a ?? t.hiddenPairs ?? []
          , c = o ?? t.hiddenMigratedPairs ?? []
          , d = kX(e, r)
          , u = i.includes(d) ? wX(i, d) : null
          , p = c.includes(d) ? wX(c, d) : null;
        s(u),
        l(p),
        n(u, p)
    }
    ), [t, a, o, s, l, n])
      , p = y.useCallback(( (e, i, d=!1) => {
        if (!t)
            return;
        const u = a ?? t.hiddenPairs ?? []
          , p = o ?? t.hiddenMigratedPairs ?? []
          , h = kX(e, i)
          , m = (!d || !u.includes(h)) && u.length + p.length >= yX
          , g = m && (!p || u.length >= (p.length ?? 0))
          , x = m && !(u.length >= ((null == p ? void 0 : p.length) ?? 0))
          , b = d && u.includes(h) ? wX(u, h) : d ? c.uniq([...u]) : c.uniq([...u, h])
          , f = d ? c.uniq([...p, h]) : x ? c.uniq([...p]) : null
          , v = g ? [...b].slice(1) : b
          , S = x && f ? [...f].slice(1) : f;
        s(c.uniq([...v, ...null === S ? p : S])),
        S && l(S),
        n(v, S),
        r({
            message: pu.hiddenTokenSuccess,
            type: "success"
        }, "hidden-pair-success")
    }
    ), [t, a, o, s, l, n, r])
      , h = y.useCallback(( () => {
        t && (s([]),
        l([]),
        n([], []),
        r({
            message: pu.hiddenTokensDeletedSuccess,
            type: "success"
        }, "clear-hidden-success"))
    }
    ), [r, t, l, s, n])
      , m = y.useMemo(( () => a ? IX(a) : d), [a, d])
      , g = y.useMemo(( () => o ? IX(o) : i), [o, i])
      , x = y.useMemo(( () => ({
        hiddenPairs: m,
        hiddenMigratedPairs: g,
        showPair: u,
        hidePair: p,
        clearAll: h
    })), [m, g, u, p, h]);
    return v.jsx(vX.Provider, {
        value: x,
        children: e
    })
}
  , TX = 1e3
  , IX = (e, t={}) => c.reduce(e, ( (e, t) => (AX(t) || (e[t] = !0),
e)), {
    ...t
})
  , EX = y.createContext({
    latestOrderUpdate: null
})
  , MX = ({children: e}) => {
    var t;
    const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
      , r = y.useCallback((e => n ? sm.subscribeOrders(n, null, null, 1, e) : {
        unsubscribe: () => {}
    }), [n])
      , a = yx(r)
      , s = y.useMemo(( () => a && a.length > 0 ? a[0] : null), [a]);
    return v.jsx(EX.Provider, {
        value: {
            latestOrderUpdate: s
        },
        children: e
    })
}
;
var NX = (e => (e.WATCHLIST = "WATCHLIST",
e.RECENT = "RECENT",
e.POSITIONS = "POSITIONS",
e.TRENDING = "TRENDING",
e.NEW_PAIRS = "NEW_PAIRS",
e))(NX || {});
const PX = [NX.TRENDING, NX.RECENT, NX.POSITIONS, NX.WATCHLIST, NX.NEW_PAIRS]
  , OX = [{
    section: NX.TRENDING,
    disabled: !1
}, {
    section: NX.RECENT,
    disabled: !1
}, {
    section: NX.POSITIONS,
    disabled: !0
}, {
    section: NX.WATCHLIST,
    disabled: !0
}, {
    section: NX.NEW_PAIRS,
    disabled: !1
}]
  , LX = y.createContext({
    sidebarSections: OX,
    hideSidebar: !0,
    isSidebarRight: !1,
    disableSidebar: c.noop,
    enableSidebar: c.noop,
    toggleSection: c.noop,
    saveSectionsOrder: c.noop
})
  , RX = e => e.filter((e => !e.disabled)).map((e => e.section))
  , DX = e => {
    const t = c.reduce(OX, ( (e, t) => (e[t.section] = t,
    e)), {});
    return e.forEach((e => {
        PX.includes(e.section) && (t[e.section] = e)
    }
    )),
    Object.values(t)
}
  , BX = ({children: e}) => {
    const {settings: t, updateBooleanSetting: n, updateSidebarVisibleSections: r} = rf()
      , [a,s] = Mx("padreV2-sidebarSectionsSettings", {
        configItems: OX,
        hideSidebar: !0,
        isDefault: !0,
        isSidebarRight: !1
    });
    y.useEffect(( () => {
        var e;
        a.isDefault && (t && s({
            configItems: t.sidebarVisibleSections ? (e = t.sidebarVisibleSections.filter((e => PX.includes(e))),
            [...e.map((e => ({
                section: e,
                disabled: !1
            }))), ...c.difference(PX, e).map((e => ({
                section: e,
                disabled: !0
            })))]) : OX,
            hideSidebar: t.hideSidebar ?? !0,
            isDefault: !1,
            isSidebarRight: t.isSidebarRight ?? !1
        }))
    }
    ), [a.isDefault, s, t]);
    const o = y.useCallback(( () => {
        s((e => ({
            ...e,
            hideSidebar: !0,
            isDefault: !1
        }))),
        n("hideSidebar", !0)
    }
    ), [s, n])
      , l = y.useCallback((e => {
        s((t => ({
            ...t,
            hideSidebar: !1,
            isDefault: !1,
            isSidebarRight: e
        }))),
        n("hideSidebar", !1),
        n("isSidebarRight", e)
    }
    ), [s, n])
      , i = y.useCallback((e => {
        s((t => ({
            ...t,
            configItems: e,
            isDefault: !1
        }))),
        r(RX(e))
    }
    ), [s, r])
      , d = y.useCallback((e => {
        const t = a.configItems.map((t => ({
            section: t.section,
            disabled: t.section === e ? !t.disabled : t.disabled
        })));
        i(t)
    }
    ), [a.configItems, i])
      , u = y.useMemo(( () => ({
        sidebarSections: DX(a.configItems),
        hideSidebar: a.hideSidebar ?? !0,
        isSidebarRight: a.isSidebarRight ?? !1,
        disableSidebar: o,
        enableSidebar: l,
        toggleSection: d,
        saveSectionsOrder: i
    })), [o, l, a.configItems, a.hideSidebar, a.isSidebarRight, i, d]);
    return v.jsx(LX.Provider, {
        value: u,
        children: e
    })
}
  , _X = () => y.useContext(LX)
  , UX = N((e => ({
    entries: new Map,
    setEntry: (t, n) => e((e => {
        const r = new Map(e.entries)
          , a = e.entries.get(t) ?? {
            status: ox.INITIAL
        };
        return r.set(t, n(a)),
        {
            ...e,
            entries: r
        }
    }
    )),
    resetEntry: t => e((e => {
        if (!e.entries.has(t))
            return e;
        const n = new Map(e.entries);
        return n.delete(t),
        {
            ...e,
            entries: n
        }
    }
    )),
    resetAll: () => e((e => 0 === e.entries.size ? e : {
        ...e,
        entries: new Map
    }))
})))
  , WX = y.createContext(null)
  , FX = ({children: e}) => {
    const t = UX((e => e.entries))
      , n = UX((e => e.setEntry))
      , r = y.useRef(new Map);
    y.useEffect(( () => () => {
        r.current.forEach(( ({timeoutId: e}) => {
            e && clearTimeout(e)
        }
        )),
        r.current.clear()
    }
    ), []);
    const a = y.useCallback((e => {
        const t = r.current
          , s = t.get(e) ?? {
            attempt: 0,
            timeoutId: null,
            inFlight: !1
        };
        s.inFlight || (s.inFlight = !0,
        s.attempt += 1,
        t.set(e, s),
        Hm.getTrackedKols(e).then((r => {
            const a = ( (e, t) => {
                const n = new Map;
                return t ? (Object.entries(t).forEach(( ([t,r]) => {
                    var a;
                    if (!t)
                        return;
                    const s = ng(t);
                    if (!s)
                        return;
                    const [o] = r ?? []
                      , l = (null == (a = null == o ? void 0 : o.trim()) ? void 0 : a.length) ? o.trim() : s;
                    n.set(s, {
                        name: l,
                        chain: e,
                        walletAddress: s
                    })
                }
                )),
                n) : n
            }
            )(e, r ?? null);
            s.inFlight = !1,
            s.timeoutId && clearTimeout(s.timeoutId),
            t.delete(e),
            n(e, ( () => ({
                status: ox.READY,
                data: a
            })))
        }
        )).catch((n => {
            s.inFlight = !1;
            const r = Math.min(1e3 * 2 ** Math.max(s.attempt - 1, 0), 3e4);
            s.timeoutId && clearTimeout(s.timeoutId),
            s.timeoutId = setTimeout(( () => {
                s.timeoutId = null,
                a(e)
            }
            ), r),
            t.set(e, s)
        }
        )))
    }
    ), [n])
      , s = y.useCallback((e => {
        if (!$p.has(e))
            return;
        UX.getState().entries.get(e) || (n(e, ( () => ({
            status: ox.LOADING
        }))),
        r.current.has(e) || r.current.set(e, {
            attempt: 0,
            timeoutId: null,
            inFlight: !1
        }),
        a(e))
    }
    ), [a, n])
      , o = y.useCallback((e => {
        const n = t.get(e);
        return n ? n.status === ox.READY || n.status === ox.ERROR ? n : {
            status: n.status
        } : {
            status: ox.INITIAL
        }
    }
    ), [t])
      , l = y.useMemo(( () => ({
        ensureTrackedKols: s,
        getTrackedKolsEntry: o
    })), [s, o]);
    return v.jsx(WX.Provider, {
        value: l,
        children: e
    })
}
  , VX = new Map;
var HX = (e => (e.COMPACT = "COMPACT",
e.SPACED = "SPACED",
e))(HX || {})
  , zX = (e => (e.NORMAL = "NORMAL",
e.LARGE = "LARGE",
e.MEGA = "MEGA",
e))(zX || {})
  , $X = (e => (e.NORMAL = "NORMAL",
e.LARGE_IMPORTANT_STATS = "LARGE_IMPORTANT_STATS",
e))($X || {})
  , GX = (e => (e.ROUNDED = "ROUNDED",
e.SQUARE = "SQUARE",
e))(GX || {})
  , qX = (e => (e.ORIGINAL = "ORIGINAL",
e.MOXIA = "MOXIA",
e))(qX || {})
  , KX = (e => (e.NONE = "NONE",
e.OPEN_MARKET = "OPEN_MARKET",
e.NEW_TAB_OPEN_MARKET = "NEW_TAB_OPEN_MARKET",
e))(KX || {})
  , YX = (e => (e.CURVE = "CURVE",
e.M_CAP = "M_CAP",
e))(YX || {});
const XX = {
    [Qh.TICKERS]: [],
    [Qh.EXCLUDE_KEYWORDS]: [],
    [Qh.HAS_SOCIALS]: !1,
    [Qh.NO_SOCIALS_REUSE]: !1,
    [Qh.NO_PERMISSIONED]: !1,
    [Qh.DEV_HOLDING]: !1,
    [Qh.NO_CONFIRMED_BOTS]: !1,
    [Qh.PUMP_LIVE]: !1,
    [Qh.IS_ACTIVE_MAYHEM]: !1,
    [Qh.HAS_ORIGINAL_AVATAR]: !1,
    [Qh.DEXSCREENER_BOOSTED]: !1,
    [Qh.CURVE_PROGRESS]: {
        from: null,
        to: null
    },
    [Qh.TOP_10_HOLDERS_PCNT]: {
        from: null,
        to: null
    },
    [Qh.TOP_INSIDERS_HOLDING_PCNT]: {
        from: null,
        to: null
    },
    [Qh.SNIPERS_HOLDINGS_PCNT]: {
        from: null,
        to: null
    },
    [Qh.VOLUME]: {
        from: null,
        to: null
    },
    [Qh.MARKET_CAP]: {
        from: null,
        to: null
    },
    [Qh.BUYS]: {
        from: null,
        to: null
    },
    [Qh.SELLS]: {
        from: null,
        to: null
    },
    [Qh.TOKEN_AGE_IN_MINUTES]: {
        from: null,
        to: null
    },
    [Qh.HOLDERS_COUNT]: {
        from: null,
        to: null
    },
    [Qh.BUNDLES_HOLDING_PCNT]: {
        from: null,
        to: null
    },
    [Qh.PERCENTAGE_DEV_HOLDING]: {
        from: null,
        to: null
    },
    [Qh.DEV_BONDED]: {
        from: null,
        to: null
    },
    [Qh.LAUNCHPADS]: null,
    [Qh.LIQUIDITY]: {
        from: null,
        to: null
    },
    [Qh.FRESH_WALLETS_BUYS]: {
        from: null,
        to: null
    },
    [Qh.ALPHA_GROUP_MENTIONS]: {
        from: null,
        to: null
    },
    [Qh.PRO_HOLDERS_COUNT]: {
        from: null,
        to: null
    },
    [Qh.TOTAL_SOL_FEES]: {
        from: null,
        to: null
    }
}
  , QX = {
    [Zh.NEW]: XX,
    [Zh.ALMOST_BONDED]: XX,
    [Zh.RECENTLY_BONDED]: XX
}
  , ZX = y.createContext({
    solFilters: QX,
    setSolFilter: c.noop,
    bscFilters: QX,
    setBscFilter: c.noop,
    trendingSolFilters: XX,
    setTrendingSolFilters: c.noop,
    trendingBscFilters: XX,
    setTrendingBscFilters: c.noop,
    solDexFilters: XX,
    setSolDexFilters: c.noop,
    bscDexFilters: XX,
    setBscDexFilters: c.noop,
    trendingSolNewFilters: XX,
    setTrendingSolNewFilters: c.noop,
    trendingBscNewFilters: XX,
    setTrendingBscNewFilters: c.noop,
    livePumpFilters: XX,
    setLivePumpFilters: c.noop,
    savedSolFilters: [],
    saveSolFilter: c.noop,
    removeSolFilter: c.noop,
    savedBscFilters: [],
    saveBscFilter: c.noop,
    removeBscFilter: c.noop,
    selectedSoundEffects: {
        [Zh.NEW]: Xw,
        [Zh.ALMOST_BONDED]: Xw,
        [Zh.RECENTLY_BONDED]: Xw
    },
    setSelectedSoundEffect: c.noop,
    soundEffectsEnabled: {
        [Zh.NEW]: !1,
        [Zh.ALMOST_BONDED]: !1,
        [Zh.RECENTLY_BONDED]: !1
    },
    setSoundEffectEnabled: c.noop,
    selectedBscSoundEffects: {
        [Zh.NEW]: Xw,
        [Zh.ALMOST_BONDED]: Xw,
        [Zh.RECENTLY_BONDED]: Xw
    },
    setSelectedBscSoundEffect: c.noop,
    bscSoundEffectsEnabled: {
        [Zh.NEW]: !1,
        [Zh.ALMOST_BONDED]: !1,
        [Zh.RECENTLY_BONDED]: !1
    },
    setBscSoundEffectEnabled: c.noop
});
ZX.displayName = "TrenchesSettingsContext";
const JX = () => y.useContext(ZX)
  , eQ = ({children: e}) => {
    const t = Ax()
      , n = ( () => {
        const e = Ax()
          , t = y.useCallback((t => e ? ym.onTrenchesSettingsUpdated(e, t) : {
            unsubscribe: () => {}
        }), [e]);
        return mx(yx(t))
    }
    )()
      , r = y.useCallback(( (e, r) => {
        if (!t || !n)
            return;
        const a = {
            ...n.solFilters ?? QX,
            [e]: r
        };
        ym.updateTrenchesSettings(t, {
            solFilters: a
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , a = y.useCallback(( (e, r) => {
        if (!t || !n)
            return;
        const a = {
            ...n.bscV2Filters ?? QX,
            [e]: r
        };
        ym.updateTrenchesSettings(t, {
            bscV2Filters: a
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , s = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , o = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingBscFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , l = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingDexFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , c = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingBscDexFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , d = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingNewFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , u = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            trendingBscNewFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , p = y.useCallback((e => {
        t && n && ym.updateTrenchesSettings(t, {
            livePumpFilters: e
        }).catch((e => {}
        ))
    }
    ), [t, n])
      , h = y.useCallback((e => {
        t && ym.updateTrenchesSettings(t, {
            solSavedFilters: e
        }).catch((e => {}
        ))
    }
    ), [t])
      , m = y.useCallback((e => {
        t && ym.updateTrenchesSettings(t, {
            bscV2SavedFilters: e
        }).catch((e => {}
        ))
    }
    ), [t])
      , g = pK()
      , [x,b] = dx("padreV2-trenchesFilters", QX)
      , f = y.useCallback(( (e, t) => {
        b((n => ({
            ...n,
            [e]: t
        }))),
        r(e, t)
    }
    ), [b, r])
      , [S,k] = dx("padreV2-trenchesBscV2Filters", QX)
      , C = y.useCallback(( (e, t) => {
        k((n => ({
            ...n,
            [e]: t
        }))),
        a(e, t)
    }
    ), [k, a])
      , [A,w] = dx("padreV2-trenchesTrendingFilters", XX)
      , j = y.useCallback((e => {
        w(e),
        s(e)
    }
    ), [w, s])
      , [T,I] = dx("padreV2-trenchesTrendingBscFilters", XX)
      , E = y.useCallback((e => {
        I(e),
        o(e)
    }
    ), [I, o])
      , [M,N] = dx("padreV2-trenchesTrendingDexFilters", XX)
      , P = y.useCallback((e => {
        N(e),
        l(e)
    }
    ), [N, l])
      , [O,L] = dx("padreV2-trenchesTrendingBscDexFilters", XX)
      , R = y.useCallback((e => {
        L(e),
        c(e)
    }
    ), [L, c])
      , [D,B] = dx("padreV2-trenchesTrendingNewFilters", XX)
      , _ = y.useCallback((e => {
        B(e),
        d(e)
    }
    ), [B, d])
      , [U,W] = dx("padreV2-trenchesTrendingBscNewFilters", XX)
      , F = y.useCallback((e => {
        W(e),
        u(e)
    }
    ), [W, u])
      , [V,H] = dx("padreV2-trenchesLivePumpFilters", XX)
      , z = y.useCallback((e => {
        H(e),
        p(e)
    }
    ), [H, p])
      , [$,G] = dx("padreV2-trenchesSavedFilters", [])
      , q = y.useCallback((e => {
        if ($.length >= 10)
            return;
        const t = i().unix()
          , n = {
            addedAt: t,
            id: Math.random().toString() + t.toString(),
            filter: e
        }
          , r = [...$, n];
        G(r),
        h(r),
        g({
            message: uu.filterSaveSuccess,
            type: "success"
        }, "save-trenches-filter-success")
    }
    ), [$, G, h, g])
      , K = y.useCallback((e => {
        const t = $.filter((t => t.id !== e));
        G(t),
        h(t)
    }
    ), [$, G, h])
      , [Y,X] = dx("padreV2-trenchesBscV2SavedFilters", [])
      , Q = y.useCallback((e => {
        if (Y.length >= 10)
            return;
        const t = i().unix()
          , n = {
            addedAt: t,
            id: Math.random().toString() + t.toString(),
            filter: e
        }
          , r = [...Y, n];
        X(r),
        m(r),
        g({
            message: uu.filterSaveSuccess,
            type: "success"
        }, "save-trenches-filter-success")
    }
    ), [Y, X, m, g])
      , Z = y.useCallback((e => {
        const t = Y.filter((t => t.id !== e));
        X(t),
        m(t)
    }
    ), [Y, X, m])
      , [J,ee] = y.useState(!1);
    y.useEffect(( () => {
        if (J || !n || !t)
            return;
        const e = {};
        n.solFilters ? b(n.solFilters) : e.solFilters = x,
        n.solSavedFilters ? G(n.solSavedFilters) : e.solSavedFilters = $,
        n.trendingFilters ? j(n.trendingFilters) : e.trendingFilters = A,
        n.trendingBscFilters ? E(n.trendingBscFilters) : e.trendingBscFilters = T,
        n.trendingDexFilters ? P(n.trendingDexFilters) : e.trendingDexFilters = M,
        n.trendingBscDexFilters ? R(n.trendingBscDexFilters) : e.trendingBscDexFilters = O,
        n.trendingNewFilters ? _(n.trendingNewFilters) : e.trendingNewFilters = D,
        n.trendingBscNewFilters ? F(n.trendingBscNewFilters) : e.trendingBscNewFilters = U,
        n.livePumpFilters ? z(n.livePumpFilters) : e.livePumpFilters = V,
        Object.keys(e).length && ym.updateTrenchesSettings(t, e).catch((e => {}
        )),
        ee(!0)
    }
    ), [t, x, J, $, b, G, n, j, A, E, T, P, M, R, O, _, D, F, U, z, V]);
    const [te,ne] = Mx(`padreV2-trenches${Zh.NEW}SoundEffect`, Xw)
      , [re,ae] = Mx(`padreV2-trenches${Zh.ALMOST_BONDED}SoundEffect`, Xw)
      , [se,oe] = Mx(`padreV2-trenches${Zh.RECENTLY_BONDED}SoundEffect`, Xw)
      , le = y.useMemo(( () => ({
        [Zh.NEW]: te,
        [Zh.ALMOST_BONDED]: re,
        [Zh.RECENTLY_BONDED]: se
    })), [se, te, re])
      , ie = y.useCallback(( (e, t) => {
        switch (t) {
        case Zh.NEW:
            ne(e);
            break;
        case Zh.ALMOST_BONDED:
            ae(e);
            break;
        case Zh.RECENTLY_BONDED:
            oe(e)
        }
    }
    ), [oe, ne, ae])
      , [ce,de] = Mx(`padreV2-trenches${Zh.NEW}SoundEnabled`, !1)
      , [ue,pe] = Mx(`padreV2-trenches${Zh.ALMOST_BONDED}SoundEnabled`, !1)
      , [he,me] = Mx(`padreV2-trenches${Zh.RECENTLY_BONDED}SoundEnabled`, !1)
      , ge = y.useMemo(( () => ({
        [Zh.NEW]: ce,
        [Zh.ALMOST_BONDED]: ue,
        [Zh.RECENTLY_BONDED]: he
    })), [he, ce, ue])
      , xe = y.useCallback(( (e, t) => {
        switch (t) {
        case Zh.NEW:
            de(e);
            break;
        case Zh.ALMOST_BONDED:
            pe(e);
            break;
        case Zh.RECENTLY_BONDED:
            me(e)
        }
    }
    ), [me, de, pe])
      , [be,fe] = Mx(`padreV2-trenchesBsc${Zh.NEW}SoundEffect`, Xw)
      , [ve,Se] = Mx(`padreV2-trenchesBsc${Zh.ALMOST_BONDED}SoundEffect`, Xw)
      , [ye,ke] = Mx(`padreV2-trenchesBsc${Zh.RECENTLY_BONDED}SoundEffect`, Xw)
      , Ce = y.useMemo(( () => ({
        [Zh.NEW]: be,
        [Zh.ALMOST_BONDED]: ve,
        [Zh.RECENTLY_BONDED]: ye
    })), [ye, be, ve])
      , Ae = y.useCallback(( (e, t) => {
        switch (t) {
        case Zh.NEW:
            fe(e);
            break;
        case Zh.ALMOST_BONDED:
            Se(e);
            break;
        case Zh.RECENTLY_BONDED:
            ke(e)
        }
    }
    ), [ke, fe, Se])
      , [we,je] = Mx(`padreV2-trenchesBsc${Zh.NEW}SoundEnabled`, !1)
      , [Te,Ie] = Mx(`padreV2-trenchesBsc${Zh.ALMOST_BONDED}SoundEnabled`, !1)
      , [Ee,Me] = Mx(`padreV2-trenchesBsc${Zh.RECENTLY_BONDED}SoundEnabled`, !1)
      , Ne = y.useMemo(( () => ({
        [Zh.NEW]: we,
        [Zh.ALMOST_BONDED]: Te,
        [Zh.RECENTLY_BONDED]: Ee
    })), [Ee, we, Te])
      , Pe = y.useCallback(( (e, t) => {
        switch (t) {
        case Zh.NEW:
            je(e);
            break;
        case Zh.ALMOST_BONDED:
            Ie(e);
            break;
        case Zh.RECENTLY_BONDED:
            Me(e)
        }
    }
    ), [Me, je, Ie])
      , Oe = y.useMemo(( () => ({
        solFilters: x,
        setSolFilter: f,
        bscFilters: S,
        setBscFilter: C,
        trendingSolFilters: A,
        setTrendingSolFilters: j,
        trendingBscFilters: T,
        setTrendingBscFilters: E,
        solDexFilters: M,
        setSolDexFilters: P,
        bscDexFilters: O,
        setBscDexFilters: R,
        trendingSolNewFilters: D,
        setTrendingSolNewFilters: _,
        trendingBscNewFilters: U,
        setTrendingBscNewFilters: F,
        livePumpFilters: V,
        setLivePumpFilters: z,
        savedSolFilters: $,
        saveSolFilter: q,
        removeSolFilter: K,
        savedBscFilters: Y,
        saveBscFilter: Q,
        removeBscFilter: Z,
        selectedSoundEffects: le,
        setSelectedSoundEffect: ie,
        soundEffectsEnabled: ge,
        setSoundEffectEnabled: xe,
        selectedBscSoundEffects: Ce,
        setSelectedBscSoundEffect: Ae,
        bscSoundEffectsEnabled: Ne,
        setBscSoundEffectEnabled: Pe
    })), [x, f, S, C, A, j, T, E, M, P, O, R, D, _, U, F, V, z, $, q, K, Y, Q, Z, le, ie, ge, xe, Ce, Ae, Ne, Pe]);
    return v.jsx(ZX.Provider, {
        value: Oe,
        children: e
    })
}
  , tQ = y.createContext({
    evmWalletsOrder: [],
    setEvmWalletsOrder: c.noop,
    solWalletsOrder: [],
    setSolWalletsOrder: c.noop
})
  , nQ = ({children: e}) => {
    const [t,n] = Mx("padreV2-evmWalletsCustomOrder", [])
      , [r,a] = Mx("padreV2-solWalletsCustomOrder", [])
      , s = y.useMemo(( () => ({
        evmWalletsOrder: t,
        setEvmWalletsOrder: n,
        solWalletsOrder: r,
        setSolWalletsOrder: a
    })), [t, n, a, r]);
    return v.jsx(tQ.Provider, {
        value: s,
        children: e
    })
}
  , rQ = () => y.useContext(tQ)
  , aQ = "min(calc(100vh - 60px), 800px)"
  , sQ = (e, t) => "init" === t.type ? t.snapshot.overview : t.update.update
  , oQ = y.memo(( ({search: e, setSearch: t, placeholder: n}) => {
    const {t: r} = we()
      , a = y.useCallback(( ({target: {value: e}}) => {
        t(e)
    }
    ), [t])
      , s = y.useCallback(( () => {
        t("")
    }
    ), [t]);
    return v.jsx(je, {
        className: "no-drag",
        value: e,
        fullWidth: !0,
        onChange: a,
        placeholder: n ?? r("Search by name or address"),
        sx: dQ,
        inputProps: uQ,
        size: "xsmall",
        endAdornment: !!e && v.jsx(We, {
            position: "end",
            sx: iQ,
            children: v.jsx(F, {
                onClick: s,
                sx: cQ,
                children: v.jsx(gy, {
                    size: lQ
                })
            })
        })
    })
}
))
  , lQ = 14
  , iQ = {
    mr: -.75
}
  , cQ = {
    p: .25
}
  , dQ = {
    height: 30,
    maxWidth: 630,
    "& .MuiInputBase-input::placeholder": {
        opacity: 1
    }
}
  , uQ = {
    style: {
        fontWeight: 400
    },
    inputMode: "text",
    [vu]: "true"
}
  , pQ = ({message: e}) => v.jsx(S, {
    p: 1,
    justifyContent: "center",
    height: "100%",
    children: v.jsx(k, {
        noWrap: !0,
        color: "text.label",
        variant: "paragraph1",
        textAlign: "center",
        children: e
    })
})
  , hQ = ({message: e}) => v.jsx(S, {
    p: 1,
    mt: 4,
    justifyContent: "center",
    height: "100%",
    children: v.jsx(k, {
        noWrap: !0,
        color: "text.label",
        variant: "paragraph1",
        textAlign: "center",
        children: e
    })
});
var mQ = (e => (e[e.MINI = 36] = "MINI",
e[e.COMPACT = 42] = "COMPACT",
e[e.MOBILE = 52] = "MOBILE",
e[e.DESKTOP_SMALL = 56] = "DESKTOP_SMALL",
e[e.MOBILE_BIG = 60] = "MOBILE_BIG",
e[e.DEKSTOP = 69] = "DEKSTOP",
e))(mQ || {});
const gQ = mQ.MINI
  , xQ = (e, t) => {
    if (e.length !== t.length)
        return !1;
    const n = [...e].sort()
      , r = [...t].sort();
    return n.every(( (e, t) => e === r[t]))
}
  , bQ = (e, t, n) => {
    const r = c.reduce(t, ( (t, r, a) => (e.includes(n(r)) || (t[a] = r),
    t)), {})
      , a = t.filter((t => e.includes(n(t)))).sort(( (t, r) => e.indexOf(n(t)) - e.indexOf(n(r))))
      , s = [];
    let o = 0;
    for (let l = 0; l < t.length; l++)
        r[l] ? s.push(r[l]) : (s.push(a[o]),
        o++);
    return s
}
  , fQ = {
    message: "No data to show"
}
  , vQ = {
    message: "Loading..."
}
  , SQ = {
    height: "100%",
    position: "relative"
}
  , yQ = y.memo(( ({rowData: e, isImmutable: t, isLoading: n, columnDefs: r, getRowUniqueId: a, onRowClick: s, onRowHover: o, rowHeight: l=gQ, classesOverrides: i=[], getPostSortOrder: d, suppressRowHoverHighlight: u=!1, columnsConfigStorageKey: p, resizableHeaders: h, onBodyScrollCallback: m, allowReordering: g=!1, onResetOrderRef: x, OnHoverButtonComponent: b}) => {
    const {colorSkin: f} = Vb()
      , S = y.useRef(null)
      , [k,C] = y.useState(!1)
      , [A,w] = y.useState(!1)
      , {onSortChanged: j, onColumnMoved: T, onGridReadyConfigLoad: I} = ( ({gridApiRef: e, columnsConfigStorageKey: t, allowReordering: n}) => {
        const r = y.useCallback(( () => {
            var n;
            if (!t)
                return;
            const r = null == (n = e.current) ? void 0 : n.getColumnState();
            r && localStorage.setItem(t, JSON.stringify(r))
        }
        ), [t, e])
          , a = y.useCallback((t => {
            r(),
            t.finished && e.current && (e.current.redrawRows(),
            e.current.refreshHeader())
        }
        ), [e, r])
          , s = y.useCallback(( () => {
            if (e.current && t) {
                const r = localStorage.getItem(t);
                if (r) {
                    const t = JSON.parse(r)
                      , a = e.current.getColumnState()
                      , s = t.map((e => e.colId))
                      , o = a.map((e => e.colId))
                      , l = xQ(s, o) ? t : bQ(s, a, (e => e.colId));
                    e.current.applyColumnState({
                        state: l,
                        applyOrder: n
                    })
                }
            }
        }
        ), [t, e, n]);
        return {
            onSortChanged: r,
            onColumnMoved: a,
            onGridReadyConfigLoad: s
        }
    }
    )({
        gridApiRef: S,
        columnsConfigStorageKey: p,
        allowReordering: g
    })
      , E = y.useCallback((e => {
        S.current = e.api,
        S.current.setGridOption("columnDefs", r),
        I(),
        C(!0)
    }
    ), [C, r, I])
      , M = y.useCallback(( () => l), [l])
      , N = y.useMemo(( () => {
        if (s)
            return e => {
                var t;
                (null == (t = e.event) ? void 0 : t.defaultPrevented) || s(e.data)
            }
    }
    ), [s])
      , O = y.useRef(e);
    O.current = e;
    const L = y.useRef(null)
      , R = y.useRef(null)
      , [D,B] = y.useState(null)
      , [_,U] = y.useState(null)
      , W = y.useMemo(( () => {
        if (o || b)
            return e => {
                var t;
                if (o) {
                    const n = e.rowIndex ? null == (t = O.current) ? void 0 : t[e.rowIndex] : null;
                    n && o(n)
                }
                if (b && L.current) {
                    const t = e.node
                      , n = L.current.querySelector(".ag-body-viewport")
                      , r = L.current.querySelector(`[row-id="${t.id}"]`);
                    if (r && n) {
                        const e = n.getBoundingClientRect().top
                          , a = r.getBoundingClientRect().top - e;
                        B(t.data ?? null),
                        U(a)
                    }
                }
            }
    }
    ), [b, o])
      , F = y.useMemo(( () => {
        if (b)
            return () => {
                B(null),
                U(null)
            }
    }
    ), [b])
      , V = y.useMemo(( () => b && D && null !== _ ? v.jsx("div", {
        ref: R,
        style: {
            position: "absolute",
            right: 12,
            top: _ + l + 2,
            zIndex: 10,
            pointerEvents: "auto",
            cursor: "pointer"
        },
        children: v.jsx(b, {
            displayData: D
        })
    }) : null), [b, D, _, l])
      , H = y.useCallback(( () => ({
        cursor: s ? "pointer" : "default"
    })), [s])
      , z = y.useCallback((e => a(e.data)), [a])
      , $ = NA(n);
    y.useEffect(( () => {
        if (!S.current)
            return;
        if (!k)
            return;
        if (n && A)
            return;
        if (n && (!e || !e.length))
            return;
        if (!e || !e.length) {
            const t = [];
            return S.current.forEachNode((e => {
                e.data && t.push(e.data)
            }
            )),
            (t.length || !A || $) && S.current.applyTransaction({
                remove: t
            }),
            void (A || null === e || n || w(!0))
        }
        const r = [];
        S.current.forEachNode((e => {
            e.data && e.id && r.push([e.id, e.data])
        }
        )),
        S.current.applyTransaction(( ({newData: e, oldData: t, getRowUniqueId: n, isImmutable: r}) => {
            const a = e.reduce(( (e, t) => (e[n(t)] = t,
            e)), {})
              , s = {}
              , o = []
              , l = [];
            t.forEach(( ([e,t]) => {
                s[e] = !0,
                a[e] ? r || a[e] === t || P(a[e], t) || l.push(a[e]) : o.push(t)
            }
            ));
            const i = e.reduce(( (e, t) => {
                const r = n(t);
                return s[r] || e.push(t),
                e
            }
            ), []);
            return {
                remove: o,
                add: i,
                update: l
            }
        }
        )({
            newData: e,
            oldData: r,
            getRowUniqueId: a,
            isImmutable: t
        })),
        A || n || w(!0)
    }
    ), [t, e, n, a, k, A, $]);
    const G = y.useCallback(( () => {
        var e, t;
        if (S.current)
            try {
                const n = S.current.getColumnState()
                  , a = r.map((e => e.field ?? ""))
                  , s = n.map((e => e.colId));
                if (t = s,
                (e = a).length === t.length && e.every(( (e, n) => e === t[n])))
                    return;
                const o = bQ(a, n, (e => e.colId));
                S.current.applyColumnState({
                    state: o,
                    applyOrder: !0
                })
            } catch (fNe) {}
    }
    ), [r]);
    y.useEffect(( () => {
        x && (x.current = G)
    }
    ), [x, G]),
    y.useEffect(( () => {
        if (S.current)
            try {
                const e = S.current.getColumnState()
                  , t = r.map((e => e.field))
                  , n = e.map((e => e.colId))
                  , a = xQ(t, n) || !g ? r : bQ(n, r, (e => e.field));
                S.current.setGridOption("columnDefs", a),
                g || G()
            } catch (fNe) {}
    }
    ), [r, g, G]),
    y.useEffect(( () => {
        S.current && h && S.current.autoSizeColumns(h)
    }
    ), [h, r]),
    y.useEffect(( () => {
        S.current && S.current.resetRowHeights()
    }
    ), [M]);
    const q = y.useMemo(( () => ({
        suppressDragLeaveHidesColumns: !0
    })), [])
      , [K,Y] = y.useState(null)
      , X = y.useCallback((e => {
        if (!d)
            return;
        const {nodes: t} = e
          , n = []
          , r = [];
        for (let o = 0; o < t.length; o++) {
            const e = t[o].data
              , a = e ? d(e) : null;
            null !== a ? n.push({
                node: t[o],
                order: a
            }) : r.push(t[o])
        }
        const a = c.sortBy(n, ["order", "node.id"]);
        Y(a.length && a[a.length - 1].node.id || null);
        const s = [...a.map((e => e.node)), ...r];
        for (let o = 0; o < s.length; o++)
            t[o] = s[o]
    }
    ), [d])
      , Q = y.useCallback((e => d && e.data && K && e.node.id === K ? rY.LAST_SORTED_ROW : ""), [d, K])
      , Z = y.useCallback((e => {
        m && m(e)
    }
    ), [m])
      , J = y.useMemo(( () => {
        const e = c.uniq([...i, ...f !== rg.INDIGO || i.includes(aY.NO_ZEBRA_ROWS) ? [] : [aY.INDIGO_ZEBRA_ROWS]]);
        return `${nY}${e.length ? e.map((e => ` ${e}`)).join("") : ""}`
    }
    ), [i, f]);
    return v.jsxs("div", {
        ref: L,
        className: J,
        style: SQ,
        onMouseLeave: F,
        children: [v.jsx(Ft, {
            suppressMultiSort: !0,
            onBodyScroll: Z,
            rowBuffer: 5,
            onGridReady: E,
            getRowHeight: M,
            onRowClicked: N,
            onCellMouseOver: W,
            getRowStyle: H,
            suppressHorizontalScroll: !0,
            gridOptions: q,
            getRowId: z,
            suppressRowHoverHighlight: u,
            animateRows: !1,
            suppressFocusAfterRefresh: !0,
            suppressCellFocus: !0,
            suppressScrollOnNewData: !0,
            maintainColumnOrder: !0,
            noRowsOverlayComponent: pQ,
            noRowsOverlayComponentParams: fQ,
            loadingOverlayComponent: hQ,
            loadingOverlayComponentParams: vQ,
            postSortRows: X,
            getRowClass: Q,
            onSortChanged: j,
            onColumnMoved: T,
            loading: n,
            suppressColumnMoveAnimation: !0
        }), D && null !== _ && b && V]
    })
}
))
  , kQ = y.memo(( ({sxProps: e={}, stackRef: t, children: n, ...r}) => {
    const a = me()
      , s = y.useCallback((e => {
        if (!r.onRowClick || e.metaKey || e.ctrlKey || r.onRowClick(),
        r.href && 0 === e.button && !e.metaKey && !e.ctrlKey) {
            e.preventDefault(),
            e.stopPropagation();
            const t = new URL(r.href);
            return a({
                pathname: t.pathname,
                search: t.search
            }),
            !1
        }
    }
    ), [r, a])
      , o = v.jsx(S, {
        ref: t,
        height: "100%",
        direction: "row",
        style: {
            marginTop: 0,
            paddingTop: 8,
            paddingBottom: 8,
            paddingLeft: "3px",
            paddingRight: "3px",
            border: "1px solid transparent",
            cursor: r.onRowClick || r.href ? "pointer" : void 0
        },
        sx: e,
        onClick: r.onRowClick,
        children: v.jsx(k, {
            variant: "monospace2",
            color: "text.value",
            ...r.typographyOverrides,
            ...Nu,
            children: n
        })
    });
    return r.href ? v.jsx(C, {
        component: "a",
        onClick: s,
        href: r.href,
        sx: {
            textDecoration: "none"
        },
        children: o
    }) : o
}
))
  , CQ = () => v.jsx(S, {
    justifyContent: "center",
    height: "100%",
    children: v.jsx(Ie, {
        variant: "rounded",
        width: "100%"
    })
})
  , AQ = y.memo(( ({price: e, symbol: t, showSubscriptSymbol: n=!1, useSubscript: r=!1, collapseExponent: a=!1, collapseThreshold: s, isLoading: o=!1, typographyVariant: l, isSmall: i=!1, forcedPrecision: c, ...d}) => {
    const u = y.useMemo(( () => e ? r && e < .01 ? `${n ? t : ""}${EI(e, {
        precision: void 0 !== c ? c : e > 10 ? 2 : i ? 3 : 4
    })}` : OI(e, {
        symbol: t,
        collapseExponent: !!a && (void 0 === s || e > s),
        precision: c ?? (e > 1 ? 2 : i ? 3 : 4),
        removeTrailingZerosPrecision: c ?? 2
    }) : Ud), [e, t, r, n, a, i, s, c]);
    return o ? v.jsx(CQ, {}) : v.jsx(kQ, {
        ...d,
        sxProps: {
            ...null === e ? {
                color: "text.value"
            } : {},
            ...d.sxProps
        },
        typographyOverrides: l ? {
            variant: l,
            ...d.typographyOverrides
        } : d.typographyOverrides,
        children: u
    })
}
))
  , wQ = y.memo(( ({date: e, isShort: t=!0, ...n}) => v.jsx(kQ, {
    ...n,
    children: v.jsx(xE, {
        ts: e,
        isShort: t,
        sx: {
            cursor: "help"
        }
    })
})))
  , jQ = "ALL_NETWORKS"
  , TQ = ["ALL_NETWORKS", Pd.ETH_MAINNET, Pd.BASE, Pd.BSC, Pd.SOLANA]
  , IQ = {
    ALL_NETWORKS: "All",
    [Pd.ETH_MAINNET]: "Eth",
    [Pd.ETH_SEPOLIA]: "Sepolia",
    [Pd.BASE]: "Base",
    [Pd.BSC]: "Bsc",
    [Pd.ARBITRUM]: "Arbitrum",
    [Pd.ARBITRUM_SEPOLIA]: "Sepolia Arbitrum",
    [Pd.SOLANA]: "Sol"
}
  , EQ = y.memo(( ({tokenAddress: e, tokenSymbol: t, chain: n, skipSocials: r, tokenName: a, deployer: s, protocol: o, launchpad: l, createdAt: i, forceSmall: c=!1, tokenSocials: d, shrinked: u, showName: p, padreAvatarUrl: h, ...m}) => {
    const g = bw();
    if (!e)
        return v.jsx(CQ, {});
    const x = !g || c ? 20 : 40;
    return v.jsx(kQ, {
        ...m,
        sxProps: {
            ...m.sxProps,
            alignItems: "center"
        },
        children: v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            children: [v.jsx(z, {
                title: u && t ? `${a}${ru(e) ? ` on ${IQ[n]}` : ""}` : "",
                children: v.jsx(C, {
                    component: "span",
                    children: ru(e) ? v.jsx(Sz, {
                        size: x,
                        chain: n,
                        chainBorder: !0
                    }) : v.jsx(b_, {
                        url: IE(n, e),
                        padreAvatarUrl: h ?? (null == d ? void 0 : d.padreAvatarUrl) ?? null,
                        hideHoverAvatar: !h && !(null == d ? void 0 : d.padreAvatarUrl),
                        name: a ?? t ?? "?",
                        size: x,
                        markerIcon: v.jsx(Sz, {
                            chain: n,
                            size: !g || c ? 10 : 16
                        }),
                        markerSize: !g || c ? 10 : 16,
                        protocolInfo: null,
                        chain: n
                    })
                })
            }), !u && v.jsx(S, {
                gap: .5,
                height: "100%",
                children: null !== t ? v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    width: "100%",
                    children: [v.jsxs(S, {
                        gap: c ? 0 : .5,
                        children: [v.jsx(z, {
                            title: t ? `${a}${ru(e) ? ` on ${IQ[n]}` : ""}` : "",
                            children: v.jsx(k, {
                                sx: {
                                    flex: "initial",
                                    textOverflow: "ellipsis",
                                    overflow: "hidden",
                                    whiteSpace: "nowrap"
                                },
                                variant: "paragraph3",
                                children: iu(t || a || "", MQ)
                            })
                        }), v.jsx(s$, {
                            createdAt: i || null,
                            variant: c ? "paragraph3" : void 0
                        })]
                    }), p && a && !u && v.jsx(cA, {
                        maxWidth: 75,
                        customName: a,
                        address: e,
                        preventDefault: !0,
                        stopPropagation: !0
                    }), d && !r && v.jsx(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        flexGrow: 1,
                        children: v.jsx(wR, {
                            isPermissioned: null,
                            tokenAddress: e,
                            showBoopLink: "boop" === l || o === Rc.BOOP,
                            showPumpfunLink: "pumpfun" === l || o === Rc.PUMP_FUN,
                            showFourmemeLink: "fourmeme" === l || o === Lc.FOUR_MEME,
                            showBagsLink: !1,
                            showBelieveLink: !1,
                            showLaunchlabLink: "launchlab" === l || o === Rc.LAUNCH_LAB,
                            showBonkLink: !1,
                            showDaosLink: !1,
                            tokenSocials: d,
                            deployerAddress: s,
                            omitAggregator: !0,
                            preventDefault: !0
                        })
                    })]
                }) : v.jsx(Ie, {
                    width: 50,
                    variant: "rounded"
                })
            })]
        })
    })
}
))
  , MQ = 14
  , NQ = y.memo(( ({chain: e, walletAddress: t, labelColor: n="text.value", ...r}) => {
    const a = UD((e => e.wallets))
      , s = y.useMemo(( () => i_(a || null, t)), [a, t]);
    return t ? v.jsx(kQ, {
        ...r,
        sxProps: {
            position: "relative",
            overflow: "hidden",
            alignItems: "center",
            ...r.sxProps || {}
        },
        typographyOverrides: {
            sx: {
                maxWidth: "100%"
            }
        },
        children: v.jsxs(S, {
            gap: OQ,
            direction: "row",
            alignItems: "center",
            flex: "1 1 0",
            children: [e && v.jsx(S, {
                height: PQ,
                minWidth: PQ,
                children: v.jsx(Sz, {
                    chain: e,
                    size: PQ
                })
            }), v.jsx(S, {
                width: `calc(100% - ${PQ + 8 * OQ}px)`,
                children: v.jsx(cA, {
                    address: t,
                    labelVariant: "paragraph2",
                    maxWidth: "100%",
                    labelSx: {
                        color: n
                    },
                    stopPropagation: !0,
                    preventDefault: !0,
                    ...s ? {
                        customName: s
                    } : {}
                })
            })]
        })
    }) : v.jsx(CQ, {})
}
))
  , PQ = 16
  , OQ = .5;
y.memo(( ({chain: e, txnHash: t, ...n}) => e && t ? v.jsx(kQ, {
    ...n,
    children: v.jsx(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        mr: -.5,
        children: v.jsx(tU, {
            link: AA(t, e),
            hideBackground: !0,
            children: v.jsx(tE, {
                chain: e
            })
        })
    })
}) : v.jsx(CQ, {})));
const LQ = y.memo(( ({progress: e, width: t}) => {
    const n = y.useMemo(( () => e => ({
        width: t,
        height: RQ,
        position: "relative",
        backgroundColor: e.palette.background.borderMain,
        borderRadius: "2px"
    })), [t])
      , r = y.useMemo(( () => t => ({
        position: "absolute",
        zIndex: 2,
        width: null === e ? 0 : `${Math.min(e, 100)}%`,
        height: "100%",
        backgroundColor: t.palette.success.main,
        borderRadius: "2px"
    })), [e]);
    return v.jsx(C, {
        sx: n,
        children: null !== e && v.jsx(C, {
            sx: r
        })
    })
}
))
  , RQ = 4
  , DQ = y.memo(( ({typographyVariant: e, remainingPcntFormatted: t}) => v.jsx(k, {
    variant: e ?? "paragraph2",
    color: "success.main",
    children: t
})))
  , BQ = y.memo(y.forwardRef((function({remainingAmountFormatted: e, remainingFormatted: t, remainingPcntFormatted: n, fixedRemainingPercentage: r, typographyVariant: a, showValue: s, showAmount: o, showProgressBar: l, chainIcon: i, ...c}, d) {
    const u = y.useMemo(( () => ({
        justifyContent: "flex-end",
        alignItems: "center",
        ...c.sxProps
    })), [c.sxProps])
      , p = y.useMemo(( () => _Q(i ?? null)), [i]);
    return v.jsx(kQ, {
        ...c,
        sxProps: u,
        children: v.jsxs(S, {
            direction: "column",
            justifyContent: "flex-end",
            alignItems: "flex-end",
            children: [v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "center",
                divider: VQ,
                children: [s && v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    height: 15,
                    children: [p, v.jsx(k, {
                        variant: a ?? "paragraph2",
                        ref: d,
                        children: t
                    })]
                }), n && v.jsx(DQ, {
                    remainingPcntFormatted: n,
                    typographyVariant: a
                })]
            }), (l || o) && v.jsx(UQ, {
                remainingAmountFormatted: e,
                fixedRemainingPercentage: r,
                showAmount: o,
                showProgressBar: l
            })]
        })
    })
}
)))
  , _Q = e => {
    switch (e) {
    case Pd.BASE:
    case Pd.ETH_MAINNET:
        return v.jsx(Df, {
            size: 12
        });
    case Pd.SOLANA:
        return v.jsx(dk, {
            size: 15
        });
    case Pd.BSC:
        return v.jsx(rk, {
            size: 14
        })
    }
}
  , UQ = y.memo(( ({remainingAmountFormatted: e, fixedRemainingPercentage: t, showAmount: n, showProgressBar: r}) => v.jsxs(S, {
    direction: "row",
    gap: .5,
    alignItems: "center",
    height: 16,
    children: [n && v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        textAlign: "end",
        children: e
    }), r && v.jsx(LQ, {
        progress: t,
        width: n ? WQ : FQ
    })]
})))
  , WQ = 55
  , FQ = 85
  , VQ = v.jsx(Ee, {
    flexItem: !0,
    orientation: "vertical",
    sx: {
        my: .25
    }
})
  , HQ = y.memo(y.forwardRef(( ({remaining: e, remainingAmount: t, remainingPercentage: n, isLoading: r, isUsd: a=!0, typographyVariant: s, showValue: o=!0, showAmount: l=!0, showProgressBar: i=!0, chainIcon: c, ...d}, u) => {
    if (r)
        return v.jsx(CQ, {});
    const p = null === e ? Ud : LI(e, {
        collapseExponent: !0,
        symbol: a ? "$" : "",
        symbolPosition: yI.START,
        ...e >= 1e3 ? {
            desiredDigits: 3
        } : {
            maxPrecision: 2,
            minPrecision: 2
        }
    })
      , h = null !== n ? jI(n, {
        omitSign: !0,
        precision: n >= 10 || 0 === n ? 0 : 1
    }) : null
      , m = null !== t ? LI(t, {
        collapseExponent: !0,
        symbol: "",
        maxPrecision: 0,
        minPrecision: 0
    }) : null
      , g = null === n ? null : 0 === n ? 0 : Math.max(1, Number(n.toFixed(0)));
    return v.jsx(BQ, {
        ref: u,
        remainingFormatted: p,
        remainingAmountFormatted: m,
        remainingPcntFormatted: h,
        typographyVariant: s,
        fixedRemainingPercentage: g,
        showValue: o,
        showAmount: l,
        showProgressBar: i,
        chainIcon: c,
        ...d
    })
}
)))
  , zQ = y.memo(( ({date: e, ...t}) => v.jsx(kQ, {
    ...t,
    sxProps: {
        alignItems: "center",
        justifyContent: "flex-end",
        ...t.sxProps
    },
    children: v.jsx(mE, {
        ts: e ?? null,
        variant: "paragraph2"
    })
})))
  , $Q = ({onClick: e, nextLabel: t, displayName: n, showIcon: r=!0, alignRight: a=!0, grayOut: s=!1}) => v.jsx(GC, {
    title: `Switch to ${t}`,
    children: v.jsx(C, {
        component: "span",
        width: "100%",
        sx: {
            cursor: "pointer"
        },
        children: v.jsxs(C, {
            onClick: e,
            display: "flex",
            alignItems: "center",
            justifyContent: a ? "flex-end" : "flex-start",
            width: "100%",
            sx: {
                cursor: "pointer",
                gap: .25
            },
            children: [v.jsx(k, {
                variant: "paragraph3",
                sx: {
                    ...$_(200, !1)
                },
                children: n
            }), r && v.jsx(C, {
                mt: "3px",
                sx: e => ({
                    color: s ? e.palette.text.label : e.palette.positive.main,
                    ...s ? {
                        "&:hover": {
                            color: e.palette.text.value
                        }
                    } : {}
                }),
                children: v.jsx(gS, {
                    animateColor: !0,
                    color: "inherit",
                    size: GQ
                })
            })]
        })
    })
})
  , GQ = 14
  , qQ = ({tooltipTitle: e, displayName: t, progressSort: n, column: r, api: a}) => {
    const [s,o] = y.useState(r.getSort())
      , l = y.useMemo(( () => r.isSortable()), [r])
      , i = y.useCallback(( () => {
        n(!1)
    }
    ), [n]);
    y.useEffect(( () => {
        const e = () => {
            const e = r.getSort();
            e !== s && o(e)
        }
        ;
        return a.addEventListener("sortChanged", e),
        () => {
            a.isDestroyed() || a.removeEventListener("sortChanged", e)
        }
    }
    ), [a, r, s]);
    const c = y.useMemo(( () => ({
        display: "flex",
        gap: .5,
        width: "100%",
        justifyContent: "flex-end",
        ...l ? {
            "&:hover": {
                cursor: "pointer"
            }
        } : {
            "&:hover": {
                cursor: "help"
            }
        }
    })), [l]);
    return v.jsx(GC, {
        title: e,
        children: v.jsx(C, {
            component: "span",
            width: "100%",
            justifyContent: "flex-end",
            height: 12,
            children: v.jsxs(C, {
                sx: c,
                onClick: l ? i : void 0,
                children: ["desc" === s ? v.jsx(C, {
                    className: "ag-icon ag-icon-desc",
                    sx: KQ
                }) : "asc" === s ? v.jsx(C, {
                    className: "ag-icon ag-icon-asc",
                    sx: KQ
                }) : null, v.jsx(k, {
                    variant: "paragraph3",
                    color: s ? "text.value" : "text.label",
                    display: "flex",
                    justifyContent: "flex-end",
                    children: t
                })]
            })
        })
    })
}
  , KQ = {
    width: 12,
    mt: "-2px"
}
  , YQ = ({onClick: e, displayName: t, isShrinked: n}) => v.jsx(C, {
    component: "span",
    width: "100%",
    sx: {
        cursor: "pointer"
    },
    children: v.jsxs(C, {
        onClick: e,
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        width: "100%",
        sx: {
            cursor: "pointer",
            gap: .25
        },
        children: [!n && v.jsx(k, {
            variant: "paragraph3",
            sx: {
                ...$_(200, !1)
            },
            children: t
        }), v.jsx(C, {
            mt: "2px",
            children: n ? v.jsx(Cy, {
                size: XQ
            }) : v.jsx(ky, {
                size: XQ
            })
        })]
    })
})
  , XQ = 14
  , QQ = y.memo(( ({onClear: e, onApply: t, minWidth: n=JQ, applyDisabled: r=!1, children: a}) => v.jsxs(S, {
    minWidth: n,
    gap: 1.5,
    p: 1,
    children: [a, v.jsxs(S, {
        width: "100%",
        alignItems: "center",
        direction: "row",
        justifyContent: "space-between",
        gap: 1,
        children: [v.jsx(V, {
            ...ZQ,
            variant: "tertiary",
            onClick: e,
            children: "Clear"
        }), v.jsx(V, {
            ...ZQ,
            sx: e => ({
                "&.Mui-disabled": {
                    border: `1px solid ${e.palette.background.borderMain}`
                },
                width: 75,
                px: 1
            }),
            disabled: r,
            variant: "primary",
            onClick: t,
            children: "Apply"
        })]
    })]
})))
  , ZQ = {
    size: "xxsmall",
    sx: {
        width: 75,
        px: 1
    }
}
  , JQ = 220
  , eZ = ({onClick: e, displayName: t, showIcon: n=!0, alignRight: r=!0}) => v.jsx(C, {
    component: "span",
    width: "100%",
    sx: nZ,
    children: v.jsxs(C, {
        onClick: e,
        display: "flex",
        alignItems: "center",
        justifyContent: r ? "flex-end" : "flex-start",
        width: "100%",
        gap: .25,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            children: t
        }), n && v.jsx(C, {
            mt: "4px",
            children: v.jsx(Ny, {
                animateColor: !0,
                color: "inherit",
                size: tZ
            })
        })]
    })
})
  , tZ = 14
  , nZ = e => ({
    cursor: "pointer",
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.value
    }
})
  , rZ = (e, t=aZ) => e.length > t ? e.slice(0, t) : `${"#".repeat(t - e.length)}${e}`
  , aZ = 24
  , sZ = e => ({
    field: e,
    sortable: !0,
    editable: !1,
    filter: !1,
    resizable: !1,
    suppressHeaderMenuButton: !0,
    suppressMovable: !0,
    flex: 1,
    sortingOrder: ["desc", "asc", null]
})
  , oZ = (e, t) => ({
    columnsConfigStorageKey: `padreV2-${e}${void 0 === t ? "" : t ? "Desktop" : "Mobile"}TableColumnsStorageKey`
})
  , lZ = e => (t, n, r, a, s) => {
    const o = r.data ? e(r.data) : null
      , l = a.data ? e(a.data) : null;
    return null === o && null === l ? 0 : null === o ? s ? -1 : 1 : null === l ? s ? 1 : -1 : o - l
}
;
var iZ = (e => (e.BEGINNING = "BEGINNING",
e.SHORTENED = "SHORTENED",
e.END = "END",
e))(iZ || {});
const cZ = y.memo(( ({tableAddressMode: e, setTableAddressMode: t}) => {
    const {t: n} = we()
      , r = y.useCallback(( (e, n) => {
        t(n)
    }
    ), [t]);
    return v.jsxs(S, {
        gap: .75,
        pt: 1,
        px: .5,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: n("Wallet address display")
        }), v.jsx(IH, {
            items: dZ,
            size: "xxsmall",
            value: e,
            onChange: r
        })]
    })
}
))
  , dZ = [{
    value: iZ.BEGINNING,
    label: "Start"
}, {
    value: iZ.SHORTENED,
    label: "Compact"
}, {
    value: iZ.END,
    label: "End"
}];
var uZ = (e => (e.USD = "USD",
e.NATIVE = "NATIVE",
e))(uZ || {});
const pZ = (e, t) => t.map((t => ({
    ...t,
    label: "string" == typeof t.label ? e(t.label) : t.label
})))
  , hZ = y.memo(( ({currencyMode: e, setCurrencyMode: t}) => {
    const {t: n} = we()
      , r = y.useCallback(( (e, n) => {
        t(n)
    }
    ), [t])
      , a = y.useMemo(( () => pZ(n, mZ)), [n]);
    return v.jsxs(S, {
        gap: .75,
        pt: 1,
        px: .5,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: "Stats currency"
        }), v.jsx(IH, {
            items: a,
            size: "xxsmall",
            value: e,
            onChange: r
        })]
    })
}
))
  , mZ = [{
    value: uZ.USD,
    label: "USD"
}, {
    value: uZ.NATIVE,
    label: "Native"
}]
  , gZ = y.memo(( ({dispalyLabel: e, onClick: t, isSelected: n, columnCustomFlags: r, activeFlags: a, toggleCustomFlags: s, onlyFlags: o}) => v.jsxs(S, {
    gap: .25,
    width: "100%",
    children: [!o && v.jsx(te, {
        onClick: t,
        sx: xZ,
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            py: .25,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: n ? "text.value" : "text.label",
                children: e
            }), v.jsx(UR, {
                checked: n
            })]
        })
    }), r && r.length && r.map((e => {
        const t = a.includes(e.flagKey);
        return v.jsx(te, {
            onClick: () => {
                s(e.flagKey)
            }
            ,
            sx: xZ,
            disabled: !n,
            children: v.jsxs(S, {
                width: "100%",
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                py: .25,
                gap: 2,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: t || !n ? "text.value" : "text.label",
                    children: e.label
                }), v.jsx(UR, {
                    checked: t,
                    disabled: !n
                })]
            })
        }, e.flagKey)
    }
    ))]
})))
  , xZ = {
    width: "100%",
    px: .5
}
  , bZ = y.memo(( ({pauseOnHover: e, setPauseOnHover: t}) => {
    const n = y.useCallback(( () => {
        t((e => !e))
    }
    ), [t])
      , {t: r} = we();
    return v.jsx(te, {
        onClick: n,
        sx: fZ,
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            py: .25,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: e ? "text.value" : "text.label",
                children: r(R ? "Pause on scroll" : "Pause on hover")
            }), v.jsx(UR, {
                checked: e
            })]
        })
    })
}
))
  , fZ = {
    width: "100%",
    px: .5,
    mt: 1
}
  , vZ = y.memo(( ({customizableColumnsKeys: e, hiddenColumnsKeys: t, closeModal: n, setHiddenColumnsKeys: r, keysLabelsLookup: a, resetOrder: s, label: o, customFlagsConfig: l, customFlags: i, setCustomFlags: d, extraFlagColumns: u, tableAddressMode: p, setTableAddressMode: h, pauseOnHover: m, setPauseOnHover: g, currencyMode: x, setCurrencyMode: b}) => {
    const f = xw()
      , {t: C} = we()
      , [A,w] = y.useState(t)
      , [j,T] = y.useState(Object.entries(i ?? {}).filter((e => !!e[1])).map((e => e[0])))
      , I = y.useCallback((e => {
        T((t => t.includes(e) ? t.filter((t => t !== e)) : [...t, e]))
    }
    ), [])
      , E = y.useCallback(( () => {
        r(A),
        d && d(c.reduce(j, ( (e, t) => (e[t] = !0,
        e)), {})),
        n()
    }
    ), [r, A, d, n, j]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsxs(S, {
            direction: "row",
            sx: yZ,
            justifyContent: f ? "space-between" : "flex-start",
            height: f ? void 0 : SZ,
            children: [!f && v.jsx(F, {
                sx: kZ,
                onClick: n,
                children: v.jsx(ky, {})
            }), v.jsx(k, {
                variant: "h2",
                children: o
            }), f && v.jsx(F, {
                sx: kZ,
                onClick: n,
                children: v.jsx(kS, {})
            })]
        }), !f && v.jsx(Ee, {}), v.jsxs(S, {
            sx: CZ,
            height: "100%",
            children: [[...e, ...u ?? []].map((e => {
                const t = !A.includes(e)
                  , n = l ? l[e] ?? null : null;
                return v.jsx(gZ, {
                    dispalyLabel: a[e] ?? e,
                    onClick: () => {
                        w((t => t.includes(e) ? t.filter((t => t !== e)) : [...t, e]))
                    }
                    ,
                    isSelected: t,
                    columnCustomFlags: n,
                    activeFlags: j,
                    toggleCustomFlags: I,
                    onlyFlags: !!(null == u ? void 0 : u.includes(e))
                }, e)
            }
            )), p && h && v.jsx(cZ, {
                tableAddressMode: p,
                setTableAddressMode: h
            }), void 0 !== m && g && v.jsx(bZ, {
                pauseOnHover: m,
                setPauseOnHover: g
            }), x && b && v.jsx(hZ, {
                currencyMode: x,
                setCurrencyMode: b
            })]
        }), s && v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            mb: 1,
            px: .25,
            children: [v.jsx(k, {
                variant: "paragraph1",
                children: "Custom order"
            }), v.jsx(V, {
                onClick: s,
                size: "small",
                variant: "secondary",
                color: "primary",
                sx: AZ,
                children: C("Reset")
            })]
        }), v.jsx(V, {
            variant: "primary",
            fullWidth: !0,
            size: "xxsmall",
            onClick: E,
            sx: wZ,
            children: C("Save")
        })]
    })
}
))
  , SZ = 48
  , yZ = {
    px: .5,
    gap: 1,
    backgroundColor: "background.secondary",
    alignItems: "center"
}
  , kZ = {
    px: 0,
    width: 16,
    height: 16
}
  , CZ = {
    py: 1
}
  , AZ = {
    borderRadius: "16px"
}
  , wZ = {
    width: "calc(100% - 4px)",
    alignSelf: "center",
    borderRadius: "16px"
}
  , jZ = y.memo(( ({customizableColumnsKeys: e, hiddenColumnsKeys: t, isModalOpen: n, closeModal: r, setHiddenColumnsKeys: a, keysLabelsLookup: s, resetOrder: o, label: l, customFlagsConfig: i, customFlags: c, setCustomFlags: d, extraFlagColumns: u, tableAddressMode: p, setTableAddressMode: h, pauseOnHover: m, setPauseOnHover: g, currencyMode: x, setCurrencyMode: b}) => n ? v.jsx(Sw, {
    className: "no-drag",
    open: n,
    onClose: r,
    stackSx: {
        zIndex: 1308,
        p: 2
    },
    maxDesktopWidth: TZ,
    minDesktopWidth: TZ,
    children: v.jsx(vZ, {
        customizableColumnsKeys: e,
        hiddenColumnsKeys: t,
        closeModal: r,
        setHiddenColumnsKeys: a,
        keysLabelsLookup: s,
        resetOrder: o,
        label: l,
        customFlagsConfig: i,
        customFlags: c,
        setCustomFlags: d,
        extraFlagColumns: u,
        tableAddressMode: p,
        setTableAddressMode: h,
        pauseOnHover: m,
        setPauseOnHover: g,
        currencyMode: x,
        setCurrencyMode: b
    })
}) : null))
  , TZ = 260
  , IZ = e => `padreV2-dataGridHiddenColumns${e}`
  , EZ = e => {
    const [t,n] = Mx(e, [])
      , [r,a] = y.useState(!1)
      , s = y.useCallback(( () => {
        a(!0)
    }
    ), [])
      , o = y.useCallback(( () => {
        a(!1)
    }
    ), [])
      , l = y.useRef(c.noop)
      , i = y.useCallback(( () => {
        l.current && l.current()
    }
    ), []);
    return {
        hiddenColumnsKeys: t,
        isModalOpen: r,
        openModal: s,
        closeModal: o,
        setHiddenColumnsKeys: n,
        onResetOrderRef: l,
        onResetOrderClick: i
    }
}
  , MZ = ({sortKey: e, sortConfig: t, updateSortConfig: n, displayName: r, alignEnd: a=!1}) => {
    const s = y.useCallback(( () => {
        e === t.column ? n({
            direction: "asc" === t.direction ? "desc" : "asc",
            column: e
        }) : n({
            direction: "desc",
            column: e
        })
    }
    ), [t.column, t.direction, e, n])
      , o = y.useMemo(( () => e !== t.column ? null : t.direction), [t.column, t.direction, e])
      , l = y.useMemo(( () => ({
        display: "flex",
        gap: .5,
        width: "100%",
        justifyContent: a ? "flex-end" : "flex-start",
        alignItems: "center",
        height: 16,
        "&:hover": {
            cursor: "pointer"
        }
    })), [a])
      , i = y.useMemo(( () => v.jsx(k, {
        variant: "paragraph3",
        color: o ? "text.value" : "text.label",
        sx: {
            display: "flex",
            justifyContent: "flex-end"
        },
        children: r
    })), [o, r]);
    return v.jsx(C, {
        component: "span",
        width: "100%",
        justifyContent: "flex-end",
        children: v.jsxs(C, {
            sx: l,
            onClick: s,
            children: [!a && i, "desc" === o ? v.jsx(C, {
                className: "ag-icon ag-icon-desc",
                sx: NZ
            }) : "asc" === o ? v.jsx(C, {
                className: "ag-icon ag-icon-asc",
                sx: NZ
            }) : null, !!a && i]
        })
    })
}
  , NZ = {
    width: 12
}
  , PZ = ({devTokenData: e, ...t}) => {
    if (!e)
        return v.jsx(CQ, {});
    const n = v$(e.protocolType, e.marketLaunchpad, e.marketLaunchpadAux, e.chain, !1);
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            ...t.sxProps,
            alignItems: "center",
            justifyContent: "flex-start"
        },
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(b_, {
                url: IE(e.chain, e.tokenAddress),
                padreAvatarUrl: (null == e ? void 0 : e.padreAvatarUrl) ?? null,
                name: e.name ?? e.symbol ?? "?",
                size: OZ,
                chain: e.chain,
                protocolInfo: n,
                hideBorder: !0
            }), v.jsx(cA, {
                maxWidth: 65,
                customName: e.symbol,
                address: e.tokenAddress,
                preventDefault: !0,
                stopPropagation: !0,
                tooltipTitle: `${e.name} ${oA(e.tokenAddress)}`,
                labelSx: LZ
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                mr: .25,
                children: hM
            }), v.jsx(mE, {
                variant: "paragraph3",
                ts: e.createdAt,
                overwriteColors: !0
            })]
        })
    })
}
  , OZ = 20
  , LZ = {
    color: "text.value"
}
  , RZ = ({value: e, formattedDisplay: t, defaultColor: n, ...r}) => v.jsx(k, {
    variant: r.variant ?? "paragraph1",
    color: 0 === e ? n ?? "text.value" : e > 0 ? "positive.main" : "negative.main",
    ...r,
    children: void 0 !== t ? t : e
})
  , DZ = ({devTokenData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        alignItems: "center",
        ...t.sxProps
    },
    children: v.jsx(RZ, {
        formattedDisplay: e.pnl ? `${e.pnl > 0 ? "+" : e.pnl < 0 ? "-" : ""}${LI(Math.abs(e.pnl), {
            collapseExponent: !0,
            symbol: "$",
            padSymbol: !1,
            symbolPosition: yI.START
        })}` : Ud,
        value: e.pnl ?? 0
    })
}) : v.jsx(CQ, {})
  , BZ = ({devTokenData: e, ...t}) => {
    const n = D();
    if (!e)
        return v.jsx(CQ, {});
    const r = e.curveProgress < e.curveProgressAth;
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            alignItems: "center",
            ...t.sxProps
        },
        children: e.bondedAt ? v.jsx(k, {
            sx: {
                mr: -.75
            },
            variant: "paragraph2",
            color: "success.main",
            children: "Migrated"
        }) : v.jsxs(S, {
            width: _Z,
            mr: -1,
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1,
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: jI(e.curveProgress, {
                        omitSign: !0,
                        precision: 1
                    })
                }), r && v.jsxs(k, {
                    variant: "paragraph3",
                    fontWeight: 400,
                    color: "text.value",
                    children: [v.jsx("span", {
                        style: {
                            color: n.palette.text.label
                        },
                        children: "ATH"
                    }), " ", `${jI(e.curveProgressAth, {
                        omitSign: !0,
                        precision: 1
                    })}`]
                })]
            }), v.jsxs(S, {
                position: "relative",
                children: [v.jsx(Z, {
                    value: e.curveProgress,
                    max: 100,
                    sx: UZ(n.palette.positive.main, n.palette.text.disabled)
                }), r && v.jsx(C, {
                    sx: t => ({
                        position: "absolute",
                        left: e.curveProgressAth / 100 * _Z,
                        top: 4,
                        width: 2,
                        height: 4,
                        backgroundColor: `${t.palette.green[500]}AA`
                    })
                })]
            })]
        })
    })
}
  , _Z = 150
  , UZ = (e, t) => ({
    "&.MuiSlider-root": {
        paddingY: .5
    },
    "& .MuiSlider-thumb": {
        display: "none"
    },
    "& .MuiSlider-rail": {
        color: t,
        height: "5px"
    },
    "& .MuiSlider-track": {
        color: e,
        height: "4px",
        border: "none",
        transitionProperty: "left, bottom, width, height, color"
    },
    "&:hover": {
        cursor: "auto"
    }
})
  , WZ = {
    justifyContent: "flex-end",
    alignItems: "center"
}
  , FZ = e => ({
    ...sZ(e),
    headerClass: lY,
    minWidth: 70,
    sortable: !1,
    sort: null
})
  , VZ = ({key: e, sortKey: t, sortConfig: n, updateSortConfig: r, t: a}) => {
    switch (e) {
    case "createdAt":
        return {
            ...FZ(e),
            headerName: a("Token"),
            headerClass: void 0,
            minWidth: 176,
            maxWidth: 176,
            ...t && n && r ? {
                sortable: !0,
                sort: t === n.column ? n.direction : void 0,
                sortingOrder: t === n.column ? [n.direction] : [],
                headerComponent: MZ,
                headerComponentParams: {
                    sortKey: t,
                    sortConfig: n,
                    updateSortConfig: r
                }
            } : {},
            cellRenderer: e => v.jsx(PZ, {
                devTokenData: e.data,
                ...e,
                sxProps: WZ,
                href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
            }),
            comparator: lZ((e => e.createdAt ?? null)),
            valueGetter: ({data: e}) => e ? `${e.tokenAddress}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}-${e.name}-${e.symbol}-${e.padreAvatarUrl}-${e.createdAt}` : void 0
        };
    case "fdvInUsd":
        return {
            ...FZ(e),
            headerName: a("Market Cap"),
            minWidth: 80,
            flex: 1.2,
            ...t && n && r ? {
                sortable: !0,
                sort: t === n.column ? n.direction : void 0,
                sortingOrder: t === n.column ? [n.direction] : [],
                headerComponent: MZ,
                headerComponentParams: {
                    sortKey: t,
                    sortConfig: n,
                    updateSortConfig: r,
                    alignEnd: !0
                }
            } : {},
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    symbol: "$",
                    price: (null == (t = e.data) ? void 0 : t.fdvInUsd) || null,
                    ...e,
                    sxProps: WZ,
                    collapseExponent: !0,
                    typographyOverrides: {
                        variant: "monospace2",
                        color: "text.value"
                    },
                    href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.fdvInUsd}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.fdvInUsd ?? null))
        };
    case "liquidity":
        return {
            ...FZ(e),
            headerName: a("Liquidity"),
            minWidth: 80,
            flex: 1.4,
            headerClass: void 0,
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    symbol: "$",
                    price: (null == (t = e.data) ? void 0 : t.fdvInUsd) || null,
                    ...e,
                    sxProps: {
                        ...WZ,
                        justifyContent: "flex-start"
                    },
                    collapseExponent: !0,
                    typographyOverrides: {
                        variant: "monospace2",
                        color: "text.value"
                    },
                    href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.liquidity}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.liquidity ?? null))
        };
    case "remaining":
        return {
            ...FZ(e),
            headerName: a("Remaining"),
            minWidth: 140,
            flex: 1.4,
            cellRenderer: e => {
                var t, n;
                return v.jsx(HQ, {
                    ...e,
                    remaining: (null == (t = e.data) ? void 0 : t.remaining) ?? null,
                    remainingAmount: null,
                    remainingPercentage: (null == (n = e.data) ? void 0 : n.remainingPercentage) ?? null,
                    isLoading: !e.data,
                    isUsd: !1,
                    sxProps: WZ,
                    href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.remaining}-${e.remainingPercentage}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.remaining ?? null))
        };
    case "totalHolders":
        return {
            ...FZ(e),
            headerName: a("Holders"),
            minWidth: 80,
            flex: 1.4,
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    symbol: "",
                    price: (null == (t = e.data) ? void 0 : t.totalHolders) || null,
                    ...e,
                    sxProps: WZ,
                    forcedPrecision: 0,
                    typographyOverrides: {
                        variant: "monospace2",
                        color: "text.value"
                    },
                    href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.totalHolders}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.totalHolders ?? null))
        };
    case "pnl":
        return {
            ...FZ(e),
            headerName: a("Dev PNL"),
            minWidth: 78,
            flex: 1.4,
            cellRenderer: e => v.jsx(DZ, {
                devTokenData: e.data,
                ...e,
                sxProps: WZ
            }),
            valueGetter: ({data: e}) => e ? `${e.pnl}-${e.chain}-${e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.pnl ?? null))
        };
    case "curveProgress":
        return {
            ...FZ(e),
            headerName: a("Bonding curve progress"),
            minWidth: 190,
            maxWidth: 190,
            ...t && n && r ? {
                sortable: !0,
                sort: t === n.column ? n.direction : void 0,
                sortingOrder: t === n.column ? [n.direction] : [],
                headerComponent: MZ,
                headerComponentParams: {
                    sortKey: t,
                    sortConfig: n,
                    updateSortConfig: r,
                    alignEnd: !0
                }
            } : {},
            cellRenderer: e => v.jsx(BZ, {
                devTokenData: e.data,
                ...e,
                sxProps: WZ,
                href: e.data ? QE(fg(e.data.chain, e.data.meteoraAddress ?? e.data.pumpSwapAddress ?? e.data.raydiumAddress ?? e.data.pumpfunAddress, null), nT.DEV_TOKENS) : void 0
            }),
            valueGetter: ({data: e}) => e ? `${e.curveProgress}-${e.curveProgressAth}-${e.chain}-${e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress}-${e.pumpfunAddress}` : void 0,
            comparator: lZ((e => e.bondedAt ?? null))
        };
    default:
        return {}
    }
}
  , HZ = {
    direction: "desc",
    column: "createdAt"
}
  , zZ = 240
  , $Z = (e, t) => {
    var n, r, a, s, o, l;
    if ("init" === t.type) {
        return {
            tokens: t.snapshot.tokens,
            richHoldingInfo: t.snapshot.richHoldingInfo
        }
    }
    return e || (e = {
        tokens: {},
        richHoldingInfo: {}
    }),
    (null == (n = t.update.adds) ? void 0 : n.length) && (e.tokens = {
        ...e.tokens,
        ...Vt(t.update.adds, "tokenAddress")
    }),
    (null == (r = t.update.deletes) ? void 0 : r.length) && (e.tokens = Ht(e.tokens, t.update.deletes)),
    (null == (a = t.update.updates) ? void 0 : a.length) && (null == (s = t.update.updates) || s.forEach((t => {
        e.tokens[t.tokenAddress] && (e.tokens[t.tokenAddress] = {
            ...e.tokens[t.tokenAddress],
            ...t
        })
    }
    )),
    e.tokens = {
        ...e.tokens
    }),
    {
        tokens: e.tokens,
        richHoldingInfo: t.update.richHoldingInfo ? (o = e.richHoldingInfo,
        l = t.update.richHoldingInfo,
        zt(l, ( (e, t) => (e[xg(t[9], t[10], t[1])] = t,
        e)), o)) : e.richHoldingInfo
    }
}
  , GZ = e => e.tokenAddress
  , qZ = (e, t, n) => Object.values(t.tokens).map((n => {
    const {createdAt: r, bondedAt: a, raydiumCreatedAt: s, pumpSwapCreatedAt: o, meteoraCreatedAt: l, devHolding: i, symbol: c, name: d, tokenAddress: u, m5VolumeInUsdUi: p, pumpfunAddress: h, meteoraAddress: g, raydiumAddress: x, pumpSwapAddress: b, curveProgress: f, curveProgressAth: v, fdvInUsd: S, totalHolders: y, padreAvatarUrl: k, totalSupply: C, decimals: A, protocolType: w, marketLaunchpad: j, marketLaunchpadAux: T} = n
      , I = t.richHoldingInfo[xg(Pd.SOLANA, ng(u), ng(e))];
    return {
        createdAt: r,
        bondedAt: a,
        raydiumCreatedAt: s,
        pumpSwapCreatedAt: o,
        meteoraCreatedAt: l,
        symbol: c,
        name: d,
        tokenAddress: u,
        m5VolumeInUsdUi: p,
        pumpfunAddress: h,
        raydiumAddress: x,
        meteoraAddress: g,
        pumpSwapAddress: b,
        curveProgress: f,
        curveProgressAth: v,
        fdvInUsd: S,
        totalHolders: y,
        padreAvatarUrl: k,
        remaining: A ? i / 10 ** A : null,
        remainingPercentage: C ? i / C * 100 : null,
        liquidity: 0,
        pnl: I ? (e => {
            const t = e[5]
              , n = e[6];
            return m.isNil(t) || m.isNil(n) ? null : n - t
        }
        )(I) : null,
        chain: Pd.SOLANA,
        protocolType: w,
        marketLaunchpad: j,
        marketLaunchpadAux: T
    }
}
)).sort(( (e, t) => {
    const r = KZ(e, n.column)
      , a = KZ(t, n.column);
    return "desc" === n.direction ? a - r : r - a
}
))
  , KZ = (e, t) => {
    switch (t) {
    case "createdAt":
        return e.createdAt;
    case "fdvInUsd":
        return e.fdvInUsd;
    case "bondedAt":
        return e.bondedAt ?? 0
    }
}
  , YZ = y.memo(( ({devAddress: e, chain: t, isVisible: n, sortStorageName: r}) => {
    const {t: a} = we()
      , [s,o] = Mx(`padreV2-devTokens${r}Sort`, HZ)
      , l = ( (e, t, n, r, a) => {
        const s = Ax()
          , o = y.useCallback((o => !s || ke(t) || ke(e) || !a ? {
            unsubscribe: () => {}
        } : wm.subscribeDevTokensSmartFeedV2(e, t, n, r, o)), [s, a, e, t, n, r]);
        return kx(o, $Z)
    }
    )(t ?? null, e, s.column, s.direction, t === Pd.SOLANA)
      , i = y.useMemo(( () => l && e ? qZ(e, l, s) : null), [e, l, s])
      , c = NA(n)
      , [d,u] = JC(!1, 50)
      , p = y.useMemo(( () => ( (e, t, n) => [VZ({
        key: "createdAt",
        sortKey: "createdAt",
        sortConfig: e,
        updateSortConfig: t,
        t: n
    }), VZ({
        key: "fdvInUsd",
        sortKey: "fdvInUsd",
        sortConfig: e,
        updateSortConfig: t,
        t: n
    }), VZ({
        key: "remaining",
        t: n
    }), VZ({
        key: "totalHolders",
        t: n
    }), VZ({
        key: "pnl",
        t: n
    }), VZ({
        key: "curveProgress",
        sortKey: "bondedAt",
        sortConfig: e,
        updateSortConfig: t,
        t: n
    })])(s, o, a)), [s, o, a]);
    if (y.useEffect(( () => {
        c !== n && 0 === (null == i ? void 0 : i.length) && u(!0)
    }
    ), [n, c, u, i]),
    n)
        return v.jsx(yQ, {
            rowData: i,
            isLoading: !i || d,
            columnDefs: p,
            getRowUniqueId: GZ,
            rowHeight: 44
        })
}
))
  , XZ = y.createContext({
    tokensBonded: null,
    tokensCreated: null,
    highestMcap: null,
    mostRecent: null
});
XZ.displayName = "DevStatsContext";
const QZ = () => y.useContext(XZ)
  , ZZ = y.memo(( ({tokensBonded: e, tokensCreated: t}) => {
    const n = D()
      , r = y.useMemo(( () => t ? e / t * 100 : 0), [e, t]);
    return t ? v.jsxs(C, {
        width: zZ,
        height: zZ,
        position: "relative",
        children: [v.jsxs("svg", {
            width: zZ,
            height: zZ,
            children: [v.jsx("circle", {
                cx: 120,
                cy: 120,
                r: tJ,
                stroke: n.palette.error.main,
                strokeWidth: eJ,
                fill: "none"
            }), v.jsx("circle", {
                cx: 120,
                cy: 120,
                r: tJ,
                stroke: n.palette.success.main,
                strokeWidth: eJ,
                fill: "none",
                strokeDasharray: nJ,
                strokeDashoffset: nJ - r / 100 * nJ,
                style: rJ
            })]
        }), v.jsxs(S, {
            sx: JZ,
            children: [v.jsx(k, {
                variant: "h1",
                fontSize: 26,
                color: "text.value",
                children: `${r.toFixed(0)}%`
            }), v.jsx(k, {
                variant: "h1",
                fontWeight: 400,
                color: "text.label",
                children: "Migrated"
            })]
        })]
    }) : null
}
))
  , JZ = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    gap: 1,
    alignItems: "center",
    justifyContent: "center"
}
  , eJ = 20
  , tJ = (zZ - eJ) / 2
  , nJ = 2 * Math.PI * tJ
  , rJ = {
    transform: "rotate(-90deg)",
    transformOrigin: "50% 50%"
}
  , aJ = y.memo(( () => {
    const {t: e} = we()
      , {tokensCreated: t, tokensBonded: n, highestMcap: r, mostRecent: a} = QZ();
    return v.jsxs(S, {
        width: "100%",
        px: 2,
        pt: 2,
        gap: 2,
        direction: "row",
        flexWrap: "wrap",
        columnGap: 2,
        rowGap: 2,
        justifyContent: "center",
        children: [v.jsxs(S, {
            minWidth: sJ,
            flex: "1 1 auto",
            gap: 1.5,
            children: [v.jsxs(C, {
                sx: oJ,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    fontWeight: 400,
                    children: e("Token Stats")
                }), v.jsxs(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    fontWeight: 400,
                    display: "flex",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(C, {
                        sx: lJ
                    }), `Migrated: ${n ?? Ud}`]
                }), v.jsxs(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    fontWeight: 400,
                    display: "flex",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(C, {
                        sx: iJ
                    }), `Non-migrated: ${null === t ? Ud : Math.max(0, t - (n ?? 0))}`]
                })]
            }), v.jsxs(C, {
                sx: oJ,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    fontWeight: 400,
                    children: e("Highlights")
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    fontWeight: 400,
                    children: `Top MCAP: ${r ? `${iu(r.symbol, 20)} (${LI(r.fdvInUsd, {
                        collapseExponent: !0,
                        desiredDigits: 2,
                        symbol: "$",
                        symbolPosition: yI.START,
                        padSymbol: !1
                    })})` : Ud}`
                }), v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        fontWeight: 400,
                        children: `${e("Last Token Launched")}: ${a ? "" : Ud}`
                    }), a && v.jsx(mE, {
                        ts: null == a ? void 0 : a.createdAt,
                        variant: "paragraph3",
                        color: "text.label",
                        fontWeight: 400,
                        isShort: !1
                    })]
                })]
            })]
        }), null !== n && !!t && v.jsx(S, {
            minWidth: zZ,
            height: zZ,
            flex: "0 0 auto",
            position: "relative",
            children: v.jsx(ZZ, {
                tokensBonded: n,
                tokensCreated: t
            })
        })]
    })
}
))
  , sJ = 280
  , oJ = e => ({
    display: "flex",
    flexDirection: "column",
    gap: 1,
    p: 1.75,
    borderRadius: .5,
    background: e.palette.background.secondary
})
  , lJ = e => ({
    width: 8,
    height: 8,
    borderRadius: "1px",
    background: e.palette.success.main
})
  , iJ = e => ({
    width: 8,
    height: 8,
    borderRadius: "1px",
    background: e.palette.error.main
})
  , cJ = y.memo(( ({devAddress: e, chain: t, isVisible: n, forceHideChart: r=!1}) => {
    const [a,s] = Mx("padreV2-devStatsChartOpen", !0)
      , o = y.useCallback(( () => {
        s((e => !e))
    }
    ), [s])
      , l = y.useMemo(( () => v.jsx(YZ, {
        devAddress: e,
        chain: t,
        isVisible: n,
        sortStorageName: "ActivityTab"
    })), [t, e, n]);
    return v.jsxs(S, {
        direction: a && !r ? "row" : void 0,
        height: "100%",
        width: "100%",
        position: "relative",
        children: [a && !r ? v.jsxs(v.Fragment, {
            children: [v.jsx(C, {
                flex: 1,
                children: l
            }), v.jsxs(C, {
                flex: 1,
                position: "relative",
                sx: uJ,
                maxWidth: dJ,
                children: [v.jsx(aJ, {}), v.jsx(C, {
                    position: "absolute",
                    onClick: o,
                    top: pJ,
                    sx: mJ,
                    left: -12,
                    children: v.jsx(Cy, {})
                })]
            })]
        }) : l, !a && !r && v.jsx(C, {
            position: "absolute",
            zIndex: 1,
            onClick: o,
            top: pJ,
            right: 0,
            sx: hJ,
            children: v.jsx(sy, {})
        })]
    })
}
))
  , dJ = 580
  , uJ = e => ({
    borderLeft: `1px solid ${e.palette.background.borderMain}`
})
  , pJ = 60
  , hJ = e => ({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: e.palette.background.buttonDefault,
    borderTopLeftRadius: 6,
    borderBottomLeftRadius: 6,
    width: 20,
    height: 38,
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonHover
    }
})
  , mJ = e => ({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: e.palette.background.buttonDefault,
    borderRadius: 1,
    width: 20,
    height: 38,
    pointerEvents: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonHover
    }
})
  , gJ = y.memo(( ({selectedGroupsIds: e, items: t, onGroupClick: n, disabledGroupIds: r=kJ, isDocked: a=!1}) => {
    const {t: s} = we()
      , o = D()
      , l = y.useMemo(( () => ({
        selected: o.palette.primary.main,
        unselected: o.palette.text.label
    })), [o.palette.primary.main, o.palette.text.label])
      , i = s("Unnamed group", {
        defaultValue: "Unnamed group"
    })
      , [c,d] = y.useMemo(( () => [e.length, 1 === e.length ? t.find((t => t.groupId === e[0])) ?? null : null]), [t, e])
      , u = y.useMemo(( () => e => ({
        display: "flex",
        alignItems: "center",
        justifyContent: 1 === c ? "flex-start" : "center",
        px: 1,
        height: xJ,
        width: bJ,
        fontSize: 12,
        gap: .5,
        color: c ? "text.value" : "warning.main",
        background: "transparent",
        borderRadius: "16px",
        "&:focus": {
            background: "transparent"
        },
        "&:hover": {
            background: e.palette.background.secondary
        }
    })), [c])
      , {buttonProps: p, popoverProps: h} = Fw({
        id: "wallet-groups-popover"
    })
      , m = y.useMemo(( () => [...t].sort(( (e, t) => e.createdAt - t.createdAt))), [t])
      , g = y.useMemo(( () => new Set(r)), [r])
      , x = y.useMemo(( () => m.length ? m.map(( ({groupId: t, name: r, icon: a, emoji: s}) => {
        const o = g.has(t)
          , c = e.includes(t)
          , d = iu(r || i, wJ);
        return v.jsx(V, {
            value: t,
            variant: "tertiary",
            size: "xxsmall",
            sx: yJ(c ? l.selected : l.unselected, c, o),
            onClick: r => {
                if (!o)
                    if (r.metaKey || r.ctrlKey) {
                        if (1 === e.length && e[0] === t)
                            return;
                        n(t, !0)
                    } else
                        n(t, !1)
            }
            ,
            disabled: o,
            "aria-pressed": c,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                flexGrow: 1,
                minWidth: 0,
                children: [v.jsx(ZT, {
                    emoji: $j(a, s)
                }), v.jsx(k, {
                    variant: "paragraph3",
                    noWrap: !0,
                    color: o ? "text.disabled" : c ? "text.main" : "text.value",
                    lineHeight: 1.2,
                    maxWidth: IJ,
                    children: d
                })]
            })
        }, t)
    }
    )) : []), [m, g, e, i, l.selected, l.unselected, n])
      , b = x.length > 0;
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...p,
            variant: "tertiary",
            size: "xxsmall",
            sx: u,
            children: v.jsxs(S, {
                width: "100%",
                direction: "row",
                alignItems: "center",
                gap: .5,
                justifyContent: "space-between",
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [d && v.jsx(ZT, {
                        emoji: $j(d.icon, d.emoji)
                    }), v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        noWrap: !0,
                        mt: a ? "1px" : 0,
                        children: 0 === c ? s("No groups") : 1 === c ? d ? iu(d.name, 8) : "" : `${c} groups`
                    })]
                }), v.jsx(Sy, {
                    size: EJ
                })]
            })
        }), v.jsx(ae, {
            ...h,
            onClick: Ww,
            sx: vJ,
            anchorOrigin: jJ,
            transformOrigin: TJ,
            children: v.jsx(ee, {
                elevation: 1,
                sx: fJ,
                className: "padre-decorative-scroll no-drag",
                children: b ? v.jsx(C, {
                    sx: SJ,
                    children: x
                }) : v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    px: 1.5,
                    py: 1,
                    children: s("No groups yet")
                })
            })
        })]
    })
}
))
  , xJ = 28
  , bJ = 98
  , fJ = e => ({
    p: .5,
    pr: 0,
    background: e.palette.background.secondary,
    border: `1px solid ${e.palette.background.borderMain}`,
    maxWidth: 360,
    maxHeight: 320,
    overflowY: "auto"
})
  , vJ = {
    zIndex: 1299
}
  , SJ = e => ({
    display: "grid",
    gridTemplateColumns: `repeat(${CJ}, minmax(0, 1fr))`,
    gap: 1,
    padding: e.spacing(1),
    justifyItems: "flex-start"
})
  , yJ = (e, t, n) => {
    const r = t ? .32 : .12
      , a = t ? .32 : .2
      , s = n ? .2 : t ? .85 : .35
      , o = n ? s : t ? .85 : .5;
    return l => ({
        borderRadius: "12px",
        height: AJ,
        minWidth: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        px: .75,
        textTransform: "none",
        justifySelf: "flex-start",
        backgroundColor: $t(e, n ? .04 : r),
        border: `1px solid ${$t(e, s)}`,
        color: n ? l.palette.text.disabled : t ? l.palette.text.main : l.palette.text.value,
        overflow: "visible",
        opacity: n ? .45 : 1,
        pointerEvents: n ? "none" : "auto",
        "&:hover": {
            backgroundColor: $t(e, a),
            border: `1px solid ${$t(e, o)}`
        },
        "&:focus, &:focus-visible": {
            backgroundColor: $t(e, a),
            border: `1px solid ${$t(e, o)}`,
            outline: "none"
        }
    })
}
  , kJ = []
  , CJ = 2
  , AJ = 24
  , wJ = 16
  , jJ = {
    vertical: "bottom",
    horizontal: "center"
}
  , TJ = {
    vertical: "top",
    horizontal: "center"
}
  , IJ = 65
  , EJ = 14
  , MJ = y.memo(( ({isLive: e, onResumeClick: t}) => e ? null : v.jsx(S, {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%",
    height: PJ,
    sx: LJ,
    children: v.jsxs(k, {
        sx: OJ,
        variant: "paragraph3",
        color: "warning.main",
        children: ["Feed is paused", R && v.jsx(V, {
            onClick: t,
            variant: "tertiary",
            size: "xxsmall",
            sx: NJ,
            children: "Resume"
        })]
    })
})))
  , NJ = {
    height: 26,
    px: .5,
    display: "flex",
    justifyContent: "center"
}
  , PJ = 44
  , OJ = {
    display: "flex",
    gap: .5,
    alignItems: "center",
    mt: R ? -1.5 : -.75,
    mr: R ? -3 : 0
}
  , LJ = e => ({
    backgroundColor: `${e.palette.background.secondary}A0`,
    justifyContent: "center",
    alignItems: "center",
    zIndex: 10
})
  , RJ = y.createContext({
    availableWallets: null,
    hasAnyWallet: null,
    selectedWalletsAddresses: [],
    toggleSelectedWalletAddress: c.noop,
    performBuy: async () => !1
})
  , DJ = () => y.useContext(RJ)
  , BJ = ({chainId: e, walletAddresses: t, tokenAddresses: n}) => {
    var r;
    const a = y.useContext(EX).latestOrderUpdate
      , [s,l] = y.useState({})
      , i = y.useCallback((async () => {
        if (!e || !n.length)
            return;
        const r = e === Pd.SOLANA ? "1" : null
          , a = await Promise.all(t.map((t => dm.batchGetTokenBalances({
            chain: e,
            walletAddress: t,
            tokenAddresses: n
        }, r))));
        l((e => {
            const n = t.reduce(( (e, t, n) => (e[t] = a[n].tokenBalances,
            e)), {});
            return c.isEqual(e, n) ? e : n
        }
        ))
    }
    ), [e, n, t])
      , d = y.useCallback((async () => {
        try {
            await ( (e, t) => {
                const n = (null == t ? void 0 : t.retries) ?? 3
                  , r = (null == t ? void 0 : t.sleepDelta) ?? 2e3;
                return async (...t) => {
                    for (let a = 0; a < n - 1; a++)
                        try {
                            return await e(...t)
                        } catch (fNe) {
                            await Hu(a * r)
                        }
                    return e(...t)
                }
            }
            )(i, {
                retries: 4,
                sleepDelta: 2e3
            })()
        } catch (fNe) {
            o(fNe, {
                extra: {
               chainId: e,
                    walletAddresses: t,
                    tokenAddresses: n
                }
            })
        }
    }
    ), [i, e, n, t]);
    return y.useEffect(( () => {
        let r = !0;
        if (e && n.length)
            return (async () => {
                const a = e === Pd.SOLANA ? "1" : null;
                try {
                    const s = await Promise.all(t.map((t => dm.batchGetTokenBalances({
                        chain: e,
                        walletAddress: t,
                        tokenAddresses: n
                    }, a))));
                    r && l((e => {
                        const n = t.reduce(( (e, t, n) => (e[t] = s[n].tokenBalances,
                        e)), {});
                        return c.isEqual(e, n) ? e : n
                    }
                    ))
                } catch (fNe) {
                    o(fNe, {
                        extra: {
                            chainId: e,
                            walletAddresses: t,
                            tokenAddresses: n
                        }
                    }),
                    r && l({})
                }
            }
            )(),
            () => {
                r = !1
            }
    }
    ), [e, n, t, null == (r = null == a ? void 0 : a.currentStateData) ? void 0 : r.status]),
    {
        tokenBalances: s,
        refresh: d
    }
}
  , _J = y.createContext({
    bscBalances: null
})
  , UJ = ({children: e}) => {
    const t = UD((e => e.wallets))
      , n = y.useMemo(( () => (t || []).filter((e => e.walletType === ED(Pd.BSC))).map((e => e.publicAddress))), [t])
      , {tokenBalances: r} = BJ({
        chainId: Pd.BSC,
        walletAddresses: n,
        tokenAddresses: [Wd]
    })
      , a = y.useMemo(( () => n.length ? n.reduce(( (e, t) => {
        var n, a;
        const s = ng(t)
          , o = (null == (a = null == (n = null == r ? void 0 : r[t]) ? void 0 : n[Wd]) ? void 0 : a.rawAmount) ?? "0";
        return e[s] = o,
        e
    }
    ), {}) : null), [n, r])
      , s = y.useMemo(( () => ({
        bscBalances: a
    })), [a]);
    return v.jsx(_J.Provider, {
        value: s,
        children: e
    })
}
  , WJ = () => y.useContext(_J)
  , FJ = (e, t, n) => {
    if (!t)
        return null;
    if (zb(e))
        return null;
    return (((t.orderPresets || Bx)[Pd.BSC] || Bx[Pd.BSC])[n] || Bx[Pd.BSC][n])[e] || Bx[Pd.BSC][n][e]
}
  , VJ = 100
  , HJ = (e, t, n, r, a, s, o, l, i) => {
    const c = sB.fromFractionalAmount({
        decimals: yU
    }, t.toString()).getRawAmount().toString()
      , d = vU()
      , u = s ? OB(s, YR.has(Pd.BSC)) : []
      , {tipLimit: p} = EB(Pd.BSC);
    return {
        type: rc.MARKET,
        tradeParams: {
            pair: {
                baseCurrency: n,
                quoteCurrency: r
            },
            side: xc.BUY,
            quantity: {
                unit: bc.QUOTE,
                value: c
            },
            slippage: (null == e ? void 0 : e.slippage) ? {
                type: "MANUAL",
                valueBps: Number((100 * Number(e.slippage)).toFixed(0))
            } : {
                type: "AUTO"
            },
            routingFilters: {
                marketIds: [a]
            }
        },
        executionOptions: {
            gasSettings: (null == e ? void 0 : e.customRpcUrl) && (null == e ? void 0 : e.tip) && "0" !== e.tip ? {
                type: "EVM_WITH_TIP",
                prioInGweiUi: (null == e ? void 0 : e.prio) ?? "0",
                tipInNativeUi: TB((null == e ? void 0 : e.tip) ?? "0", p)
            } : {
                type: "EVM",
                prioInGweiUi: (null == e ? void 0 : e.prio) ?? "0"
            },
            useMevProtection: !(null == e ? void 0 : e.customRpcUrl) && ((null == e ? void 0 : e.mevProtection) ?? void 0)
        },
        context: {
            displayedBasePriceInUsd: "",
            displayedBasePriceInQuote: "",
            displayedQuoteToken: r,
            multiWalletId: o,
            multiWalletCount: l,
            rev: Du.SENTRY_RELEASE_HASH,
            selectedPresetName: i
        },
        attribution: {
            clientSentPerf: performance.now()
        },
        ...u.length ? {
            postSuccessHook: {
                orderTriggers: u
            }
        } : {},
        idemp: d
    }
}
  , zJ = ({children: e}) => {
    const {wallets: t} = UD((e => e))
      , {bscBalances: n} = WJ()
      , r = y.useMemo(( () => ( (e, t) => e && t ? c.reduce(t, ( (t, n) => {
        const {walletName: r, walletId: a, walletType: s, publicAddress: o} = n;
        if (s !== pc.ETH)
            return t;
        const l = ng(o)
          , i = e[l];
        if (!i)
            return t;
        const c = Number(i) / 10 ** yU;
        return t[l] = {
            address: l,
            name: r,
            walletId: a,
            totalBscBalanceInNative: c
        },
        t
    }
    ), {}) : null)(n, t)), [t, n])
      , a = y.useMemo(( () => r ? !c.isEmpty(r) : null), [r])
      , {selectedWalletsAddresses: s, toggleSelectedWalletAddress: o} = FD(Pd.BSC)
      , l = (e => {
        const t = Ax()
          , n = pK()
          , {trackCreatedOrder: r} = hf()
          , a = VV(Pd.BSC)
          , s = y.useRef(a);
        y.useEffect(( () => {
            s.current = a
        }
        ), [a]);
        const {bscBalances: o} = WJ()
          , {showModal: l} = gU()
          , {settings: i} = rf()
          , c = zV()
          , d = qV()
          , u = yT()
          , {setLastSelectedWalletsPerChain: p} = OD()
          , m = y.useCallback((t => {
            e && p((t => ({
                ...t,
                [Pd.BSC]: e
            }))),
            u({
                chain: Pd.BSC,
                tokenAddress: t,
                tradePageOrigin: nT.SNACK_TRADE
            })
        }
        ), [u, p, e]);
        return y.useCallback((async ({value: a, baseCurrency: u, poolQuoteCurrency: p, baseSymbol: g, quoteSymbol: x, marketId: b, padreAvatarUrl: f, presetName: v, originWidget: S, exitStrategies: y}) => {
            const k = FJ(v, i, xc.BUY)
              , C = {
                value: a,
                baseCurrency: u,
                poolQuoteCurrency: p,
                baseSymbol: g,
                quoteSymbol: x,
                marketId: b,
                originWidget: S,
                selectedWalletsAddressesAmount: e.length,
                presetValues: k
            };
            if (!t || !e || !k && !zb(v) || !i)
                return np.warn("Order hasn't been sent - loading state", {
                    orderInfo: C
                }),
                !1;
            if (a < 0)
                return np.warn("Order hasn't been sent - zero or negative value", {
                    orderInfo: C
                }),
                !1;
            if (!e.length)
                return np.warn("Order hasn't been sent - no wallet selected", {
                    orderInfo: C
                }),
                n({
                    message: pu.noWalletSelected,
                    type: "warning"
                }, "no-wallet-selected"),
                !1;
            try {
                const A = h()
                  , w = e.length
                  , j = e.map(( (r, s) => (async () => {
                    i.multiWalletsTradeDelay && s && await Hu(1e3 * i.multiWalletsTradeDelay * s);
                    const h = _V(a, e.length, s, i.multiWalletsTradeSpread ?? 2, Pd.BSC)
                      , j = HJ(k, h, u, p, b, y, A, w, v);
                    try {
                        const s = DV({
                            uid: t,
                            chainId: Pd.BSC,
                            walletAddress: r,
                            request: j,
                            origin: S,
                            marketQuoteToken: p
                        })
                          , i = () => {
                            m(u)
                        }
                        ;
                        if (1 === e.length) {
                            const t = (null == k ? void 0 : k.mevProtection) && k && !isNaN(Number(k.tip)) ? Number(k.tip) : 0
                              , r = k && !isNaN(Number(k.prio)) ? 1e-9 * Number(k.prio) * fB : 0
                              , p = o ? o[ng(e[0])] : null
                              , m = p ? Number(p) / 10 ** yU : null
                              , b = null !== m && jU({
                                balanceNative: m,
                                amountInNative: a,
                                tipInNative: t,
                                prioInNative: r
                            });
                            n({
                                onOrderResolve: c,
                                onFill: () => {}
                                ,
                                onOpenSummary: l,
                                orderIdPromise: s,
                                variant: lK.SLIM_ORDER_STATUS,
                                orderSnackDetails: {
                                    customAutoTimeoutDuration: d,
                                    orderType: rc.MARKET,
                                    tradeSide: xc.BUY,
                                    baseSymbol: g,
                                    baseValue: "",
                                    quoteSymbol: x,
                                    quoteValue: isNaN(h) ? "" : UI(LI(h, {
                                        collapseExponent: !0,
                                        symbol: ""
                                    })),
                                    tokenAddress: u,
                                    padreAvatarUrl: f,
                                    chain: Pd.BSC,
                                    onRedirectClick: i,
                                    showLowBalanceWarning: b
                                }
                            }, "order-slim-status")
                        }
                        return await s
                    } catch (T) {
                        return np.error("Order hasn't been sent - exception thrown during processing order", {
                            err: T,
                            orderInfo: C
                        }),
                        n({
                            message: uu.unknownError,
                            snackName: pu.createFail,
                            type: "error"
                        }, "error-create-order"),
                        {
                            orderId: ""
                        }
                    }
                }
                )()));
                return e.length > 1 && n({
                    onOrderResolve: c,
                    onFill: () => {}
                    ,
                    orderIdPromises: j,
                    variant: lK.MULTI_ORDER_STATUS,
                    orderSnackDetails: {
                        customAutoTimeoutDuration: d,
                        orderType: rc.MARKET,
                        tradeSide: xc.BUY,
                        baseSymbol: g,
                        baseValue: "",
                        quoteSymbol: x,
                        quoteValue: isNaN(a) ? "" : UI(LI(a, {
                            collapseExponent: !0,
                            symbol: ""
                        })),
                        tokenAddress: u,
                        padreAvatarUrl: f,
                        chain: Pd.BSC
                    }
                }, "order-multi-status"),
                r({
                    chain: Pd.BSC,
                    specificType: ic.MARKET_BUY,
                    originWidget: S,
                    isMultiWallet: e.length > 1,
                    estimatedUsd: wU({
                        nativePrice: s.current,
                        orderValue: a
                    }),
                    tradePageOrigin: null
                }),
                await Promise.allSettled(j),
                await Hu(VJ),
                !0
            } catch (A) {
                np.error("Order hasn't been sent - exception thrown during processing orders", {
                    err: A,
                    orderInfo: C
                }),
                n({
                    message: uu.unknownError,
                    snackName: pu.unknownError,
                    type: "error"
                }, "error-create-unknown-error")
            }
            return !1
        }
        ), [i, t, e, n, r, m, o, c, l, d])
    }
    )(s)
      , i = y.useMemo(( () => ({
        availableWallets: r,
        hasAnyWallet: a,
        selectedWalletsAddresses: s,
        toggleSelectedWalletAddress: o,
        performBuy: l
    })), [r, a, l, s, o]);
    return v.jsx(RJ.Provider, {
        value: i,
        children: e
    })
}
  , $J = (e, t, n) => {
    const r = new Map(e.map((e => [t(e), e])));
    return [...n.map((e => r.get(e))).filter((e => void 0 !== e)), ...e.filter((e => !n.includes(t(e))))]
}
  , GJ = zh.NORMAL
  , qJ = y.createContext({
    selectedPreset: GJ,
    setSelectedPreset: c.noop,
    buttonValue: null,
    buttonDisplayValue: 0,
    setButtonValue: c.noop,
    insufficientBalance: null,
    includeExitStrategies: !1,
    toggleIncludeExitStrategies: c.noop
})
  , KJ = y.createContext({
    selectedPreset: GJ,
    setSelectedPreset: c.noop,
    buttonValue: null,
    buttonDisplayValue: 0,
    setButtonValue: c.noop,
    insufficientBalance: null,
    includeExitStrategies: !1,
    toggleIncludeExitStrategies: c.noop
})
  , YJ = e => {
    const {openModal: t} = KR()
      , [n,r] = Mx(`padreV2-${e}BscIncludeExitStrategies`, !1)
      , a = y.useCallback(( () => {
        n || t(),
        r((e => !e))
    }
    ), [n, t, r])
      , [s,o] = Mx(`padreV2-bscTradePreset-${e}`, GJ)
      , {settings: l} = rf()
      , i = y.useMemo(( () => FJ(s, l, xc.BUY)), [s, l])
      , [c,d] = Mx(`padreV2-bscTradeButtonValue-${e}`, 0)
      , u = y.useMemo(( () => Number((c ?? 0).toFixed(6))), [c])
      , {selectedWalletsAddresses: p, availableWallets: h} = DJ()
      , {userStats: m} = rH()
      , g = y.useMemo(( () => m.status !== ox.READY ? null : m.data.feeBps), [m])
      , x = y.useMemo(( () => {
        if (p.length > 1)
            return !1;
        if (!(h && p && c && i && null !== g))
            return null;
        const e = 1 === p.length ? h[p[0]] : null;
        if (!e)
            return null;
        const t = ( ({selectedBuyPresetValues: e, buttonValue: t, padreFeeBps: n}) => {
            const r = Number((null == e ? void 0 : e.tip) ?? "0")
              , a = Number((null == e ? void 0 : e.prio) ?? "0");
            return t * (1 + n / 1e4) + gB[Pd.BSC] + r + 1e-9 * a * fB
        }
        )({
            selectedBuyPresetValues: i,
            buttonValue: c,
            padreFeeBps: g
        });
        return e.totalBscBalanceInNative < t
    }
    ), [h, c, p, i, g]);
    return y.useMemo(( () => ({
        selectedPreset: s,
        setSelectedPreset: o,
        buttonValue: c,
        buttonDisplayValue: u,
        setButtonValue: d,
        insufficientBalance: x,
        includeExitStrategies: n,
        toggleIncludeExitStrategies: a
    })), [u, c, n, x, s, d, o, a])
}
  , XJ = ({contextId: e, children: t}) => {
    const n = YJ(e);
    return v.jsx(qJ.Provider, {
        value: n,
        children: t
    })
}
  , QJ = ({contextId: e, children: t}) => {
    const n = YJ(e);
    return v.jsx(KJ.Provider, {
        value: n,
        children: t
    })
}
  , ZJ = (e=!1) => {
    const t = y.useContext(qJ)
      , n = y.useContext(KJ);
    return y.useMemo(( () => e ? n : t), [e, n, t])
}
  , JJ = y.memo(( ({height: e, useExtra: t=!1}) => {
    const {insufficientBalance: n, buttonValue: r, setButtonValue: a} = ZJ(t)
      , [s,o] = y.useState(null === r ? "" : r.toString());
    y.useEffect(( () => {
        null !== r && o(r.toString())
    }
    ), [r]);
    const l = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e)
          , n = XR(t, e0, null);
        o(n)
    }
    ), [])
      , i = y.useCallback(( () => {
        const e = Number(s);
        isNaN(e) || a(e)
    }
    ), [a, s])
      , c = y.useMemo(( () => v.jsx(We, {
        position: "start",
        children: v.jsx(S, {
            alignItems: "center",
            children: v.jsx(ay, {
                size: 14
            })
        })
    })), [])
      , d = y.useMemo(( () => v.jsx(We, {
        position: "end",
        sx: {
            width: 10
        },
        children: v.jsx(S, {
            alignItems: "center",
            children: v.jsx(ak, {
                size: 15
            })
        })
    })), [])
      , u = y.useMemo(( () => ({
        height: e,
        minWidth: t0,
        maxWidth: t0,
        borderRadius: 1,
        pl: 1,
        border: "none",
        outline: "none",
        "& .MuiOutlinedInput-notchedOutline": {
            display: "none"
        },
        background: "transparent"
    })), [e]);
    return v.jsx(je, {
        error: !!n,
        value: s,
        onChange: l,
        onBlur: i,
        disabled: null === r,
        size: "xsmall",
        placeholder: "0",
        inputProps: n0,
        "data-pseudotype": "numberLike",
        inputMode: "decimal",
        sx: u,
        startAdornment: c,
        endAdornment: d
    })
}
))
  , e0 = 3
  , t0 = 84
  , n0 = {
    style: {
        textAlign: "right"
    },
    inputMode: "decimal",
    sx: {
        mr: -.5,
        ml: -.75,
        mt: "1px"
    }
}
  , r0 = y.memo(( ({height: e, useExtra: t=!1, extraMargin: n=!1, tooltipOffset: r}) => {
    const a = D()
      , {exitStrategies: s, isModalOpen: o} = KR()
      , {toggleIncludeExitStrategies: l, includeExitStrategies: i} = ZJ(t)
      , {t: c} = we()
      , d = y.useMemo(( () => t => ({
        height: e,
        width: 1.15 * e,
        p: 0,
        pb: "1px",
        pr: "15%",
        zIndex: 2,
        transition: "none",
        mt: n ? .25 : "1px",
        minWidth: a0,
        border: "none",
        borderRadius: 0,
        backgroundColor: "transparent",
        "&:focus": {
            border: "none",
            backgroundColor: t.palette.background.buttonDefault
        },
        "&:hover": {
            border: "none",
            backgroundColor: t.palette.background.buttonHover
        }
    })), [e, n])
      , u = y.useMemo(( () => s.filter((e => !gD(e)))), [s]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(GC, {
            offset: r,
            title: o ? "" : i && s.length ? v.jsxs(S, {
                gap: .75,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: c("Exit strategies")
                }), v.jsx(S, {
                    gap: .25,
                    children: u.length ? u.map(( (e, t) => v.jsxs(S, {
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        gap: 2,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: bD[e.type]
                        }), v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            children: [mD(e) && v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.value",
                                children: `${e.changePct || Ud}%`
                            }), v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.value",
                                children: `${e.amountPct || Ud}%`
                            })]
                        })]
                    }, t))) : c("No supported exit strategies")
                })]
            }) : c("Exit strategies"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    className: "no-drag",
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: l,
                    sx: d,
                    children: v.jsx(C, {
                        display: "flex",
                        children: v.jsx(yS, {
                            color: i ? a.palette.primary.main : a.palette.text.label
                        })
                    })
                })
            })
        })
    })
}
))
  , a0 = 22
  , s0 = y.memo(( ({preset: e, presetValues: t}) => v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    gap: 1,
    children: [v.jsx(kH, {
        preset: e,
        size: 22,
        iconSize: 16,
        filled: !1
    }), t && v.jsx(C, {
        display: "flex",
        mt: "-4px",
        children: v.jsx(gM, {
            presetValues: t,
            isTooltip: !1,
            chain: Pd.BSC
        })
    })]
})))
  , o0 = y.memo(( ({height: e, useExtra: t=!1, tooltipOffset: n}) => {
    const r = D()
      , {t: a} = we()
      , {settings: s} = rf()
      , {setSelectedPreset: o, selectedPreset: l} = ZJ(t)
      , i = y.useCallback((e => {
        if ("Inferno" === e)
            ;
        else
            o(e)
    }
    ), [o])
      , [c,d] = y.useState(!1)
      , u = y.useCallback(( () => {
        d(!0)
    }
    ), [])
      , p = y.useCallback(( () => {
        d(!1)
    }
    ), [])
      , h = y.useMemo(( () => (((null == s ? void 0 : s.orderPresets) || Bx)[Pd.BSC] || Bx[Pd.BSC])[xc.BUY] || Bx[Pd.BSC][xc.BUY]), [s])
      , m = y.useMemo(( () => ({
        sx: e => ({
            color: e.palette.background.borderSubtle
        }),
        PaperProps: {
            className: "padre-no-scroll",
            style: {
                backgroundColor: r.palette.background.secondary
            },
            sx: e => ({
                border: `1px solid ${e.palette.background.borderSubtle}`,
                boxShadow: "none",
                py: 0,
                "& .MuiList-padding": {
                    paddingTop: 0,
                    paddingBottom: 0
                }
            })
        }
    })), [r.palette.background.secondary])
      , g = y.useMemo(( () => a("Quick trade preset")), [a])
      , x = y.useCallback(( () => v.jsx(GC, {
        title: g,
        offset: n,
        children: v.jsx(S, {
            width: "100%",
            height: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(kH, {
                preset: l,
                size: e,
                iconSize: 16,
                filled: !1
            })
        })
    })), [l, e, g, n])
      , b = y.useMemo(( () => t => ({
        "& .MuiOutlinedInput-notchedOutline": {
            border: "none"
        },
        "&.Mui-focused": {
            border: "none",
            "& .MuiOutlinedInput-notchedOutline": {
                border: "none"
            }
        },
        "& .MuiOutlinedInput-input": {
            borderRadius: 0,
            p: 0,
            pr: "0px !important",
            "&:hover": {
                background: t.palette.background.buttonHover
            },
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
        },
        width: 1.2 * (e - 2),
        height: e - 2,
        border: "none",
        outline: "none",
        "&.Mui-disabled": {
            border: "none"
        },
        borderRadius: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "transparent"
    })), [e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(it, {
            disabled: !s,
            size: "xsmall",
            sx: b,
            IconComponent: c0,
            MenuProps: m,
            value: l,
            renderValue: x,
            children: [i0.map((e => {
                const t = h[e] ?? null;
                return v.jsx(te, {
                    disableTouchRipple: !0,
                    disableRipple: !0,
                    value: e,
                    sx: l0,
                    onClick: t => {
                        t.stopPropagation(),
                        t.preventDefault(),
                        i(e)
                    }
                    ,
                    children: v.jsx(s0, {
                        presetValues: t,
                        preset: e
                    })
                }, e)
            }
            )), v.jsx(te, {
                disableTouchRipple: !0,
                disableRipple: !0,
                sx: l0,
                onClick: u,
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1.5,
                    pl: .25,
                    children: [v.jsx(Ny, {
                        size: 16
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        children: "Edit presets"
                    })]
                })
            })]
        }), v.jsx(tz, {
            isOpen: c,
            onClose: p,
            chain: Pd.BSC,
            side: xc.BUY,
            preset: l,
            setSelectedPreset: i
        })]
    })
}
))
  , l0 = e => ({
    maxWidth: 335,
    px: .75,
    height: 35,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderSubtle}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , i0 = [zh.NORMAL, zh.FAST, zh.ULTRA]
  , c0 = () => null
  , d0 = y.memo(( ({height: e=p0, useExtra: t=!1, tooltipOffset: n}) => {
    const {t: r} = we();
    return v.jsxs(S, {
        sx: u0(e),
        direction: "row",
        alignItems: "center",
        height: e,
        children: [v.jsx(GC, {
            title: r("Quick trade amount"),
            offset: n,
            children: v.jsx(S, {
                children: v.jsx(JJ, {
                    height: e,
                    useExtra: t
                })
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical"
        }), v.jsx(o0, {
            height: e,
            useExtra: t,
            tooltipOffset: n
        }), v.jsx(r0, {
            height: e,
            useExtra: t,
            extraMargin: e > p0,
            tooltipOffset: n
        })]
    })
}
))
  , u0 = e => t => ({
    border: `1px solid ${t.palette.background.borderMain}`,
    borderRadius: e / 2,
    overflow: "hidden"
})
  , p0 = 28
  , h0 = y.memo(( ({isSelected: e, name: t, address: n, balanceInNative: r, chain: a, height: s=x0}) => v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    gap: .5,
    minHeight: s,
    width: "100%",
    justifyContent: "space-between",
    children: [v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        children: [v.jsx(UR, {
            checked: e
        }), v.jsxs(S, {
            gap: .25,
            children: [v.jsx(k, {
                variant: "paragraph3",
                noWrap: !0,
                sx: m0,
                color: r ? "text.value" : "text.label",
                ...Nu,
                children: t
            }), v.jsx(cA, {
                address: n,
                stopPropagation: !0,
                preventDefault: !0,
                customName: n.slice(0, 4),
                labelSx: b0
            })]
        })]
    }), v.jsxs(S, {
        direction: "row",
        gap: .25,
        alignItems: "center",
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: r ? "text.value" : "text.label",
            sx: g0,
            children: null === r ? v.jsx(Ie, {
                width: 40,
                variant: "rounded",
                height: 16
            }) : LI(r, {
                collapseExponent: !0,
                symbol: "",
                padSymbol: !0,
                maxPrecision: 3
            })
        }), v.jsx(Sz, {
            size: 14,
            chain: a
        })]
    })]
})))
  , m0 = {
    maxWidth: 170
}
  , g0 = {
    whiteSpace: "nowrap",
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    height: 16,
    gap: .25,
    minWidth: 40
}
  , x0 = 52
  , b0 = {
    ml: "-3px"
}
  , f0 = y.memo(( ({compact: e=!1, hideSettings: t=!1, usePopper: r=!1, isHeader: a=!1, chain: s}) => {
    const {t: o} = we()
      , l = D()
      , i = xw()
      , {selectedWalletsAddresses: d, availableWallets: u, toggleSelectedWalletAddress: p} = AD()
      , {selectedWalletsAddresses: h, availableWallets: m, toggleSelectedWalletAddress: g} = DJ()
      , x = y.useCallback(( (e, t) => {
        switch (s) {
        case Pd.BSC:
            g(e, t);
            break;
        case Pd.SOLANA:
            p(e, t)
        }
    }
    ), [g, p, s])
      , b = y.useMemo(( () => {
        switch (s) {
        case Pd.BSC:
            return h;
        case Pd.SOLANA:
            return d
        }
    }
    ), [h, d, s])
      , {solWalletsOrder: f, evmWalletsOrder: A} = rQ()
      , w = y.useMemo(( () => {
        const [e,t] = ( (e, t, n, r, a) => {
            switch (e) {
            case Pd.BSC:
                return [n ? Object.values(n).map((e => ({
                    address: e.address,
                    name: e.name,
                    walletId: e.walletId,
                    walletType: pc.ETH,
                    balanceInNative: e.totalBscBalanceInNative
                }))) : null, a];
            case Pd.SOLANA:
                return [t ? Object.values(t).map((e => ({
                    address: e.address,
                    name: e.name,
                    walletId: e.walletId,
                    walletType: pc.SOL,
                    balanceInNative: e.totalSolBalanceInNative
                }))) : null, r]
            }
        }
        )(s, u, m, f, A);
        return e ? e.length ? $J(e, R0, t) : e.sort(( (e, t) => t.balanceInNative - e.balanceInNative)) : null
    }
    ), [u, m, A, f, s])
      , j = y.useMemo(( () => {
        if (!w)
            return null;
        const e = new Set(b);
        return ( (e, t) => c.reduce(e, ( (e, t) => (e.balanceInNative += t.balanceInNative,
        e)), {
            address: "multi",
            name: 1 === e.length ? e[0].name : n.t("{{count}} Wallets Selected", {
                count: e.length
            }),
            walletId: "multi",
            balanceInNative: 0,
            walletType: ED(t)
        }))(w.filter((t => e.has(ng(t.address)))), s)
    }
    ), [b, w, s])
      , T = y.useMemo(( () => w ? Object.values(w).map(( ({address: e, name: t, walletId: n, balanceInNative: r}) => {
        const a = ng(e)
          , o = b.includes(a);
        return v.jsx(te, {
            value: a,
            sx: T0,
            onClick: t => {
                if (!("click" !== t.type && t.nativeEvent instanceof KeyboardEvent && "Space" === t.nativeEvent.code))
                    if (t.metaKey || t.ctrlKey) {
                        if (1 === b.length && b[0] === e)
                            return;
                        x(e, !0)
                    } else
                        x(e)
            }
            ,
            disableTouchRipple: !0,
            disableRipple: !0,
            children: v.jsx(h0, {
                isSelected: o,
                name: t,
                address: a,
                balanceInNative: r,
                chain: s
            })
        }, n)
    }
    )) : null), [b, w, x, s])
      , I = dT()
      , E = y.useCallback(( () => {
        I({})
    }
    ), [I])
      , {buttonProps: M, popoverProps: N} = Fw({
        id: "solana-global-wallet-select"
    })
      , P = y.useMemo(( () => t => ({
        minWidth: a ? P0 : N0,
        width: a ? P0 : N0,
        height: e ? L0 : O0,
        px: a ? 1.25 : .75,
        borderRadius: "16px",
        background: t.palette.background.buttonDefault,
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        ...a ? {
            borderColor: "transparent",
            "&:hover": {
                borderColor: "transparent"
            }
        } : {
            background: "transparent",
            "&:hover": {
                background: t.palette.background.buttonDefault
            }
        }
    })), [e, a]);
    return w ? v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...M,
            onClick: N.open ? N.onClose : M.onClick,
            variant: "tertiary",
            size: "xxsmall",
            tabIndex: -1,
            onMouseDown: Uw,
            sx: P,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                justifyContent: "space-between",
                width: "100%",
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    justifyContent: "space-between",
                    width: "100%",
                    children: [v.jsx(C, {
                        display: "flex",
                        children: v.jsx(iy, {
                            size: a ? S0 : v0,
                            color: l.palette.text.value
                        })
                    }), j ? v.jsxs(S, {
                        width: "100%",
                        direction: "row",
                        gap: .25,
                        justifyContent: "space-between",
                        alignItems: "center",
                        children: [v.jsx(k, {
                            variant: a ? "h2" : "paragraph3",
                            color: "inherit",
                            noWrap: !0,
                            children: `${b.length}`
                        }), v.jsx(Ee, {
                            flexItem: !0,
                            orientation: "vertical",
                            sx: M0
                        }), v.jsx(k, {
                            variant: a ? "h2" : "paragraph3",
                            color: "inherit",
                            noWrap: !0,
                            children: LI(j.balanceInNative, {
                                collapseExponent: !0,
                                maxPrecision: 3,
                                desiredDigits: j.balanceInNative >= 1e3 ? 3 : 4
                            })
                        })]
                    }) : v.jsx(Ie, {
                        width: 40,
                        height: y0,
                        variant: "rounded"
                    })]
                }), v.jsx(C, {
                    display: "flex",
                    mt: a ? 0 : -.25,
                    children: v.jsx(Sz, {
                        chain: s,
                        size: a ? j0 : w0
                    })
                }), a && v.jsx(C, {
                    display: "flex",
                    children: v.jsx(Sy, {})
                })]
            })
        }), r ? v.jsx(ne, {
            ...N,
            onClick: Ww,
            sx: k0,
            children: v.jsx(re, {
                onClickAway: N.onClose,
                children: v.jsx(ee, {
                    elevation: 1,
                    sx: A0,
                    className: "padre-decorative-scroll no-drag",
                    children: v.jsx(S, {
                        sx: E0,
                        className: "padre-decorative-scroll",
                        children: T
                    })
                })
            })
        }) : v.jsx(ae, {
            ...N,
            onClick: Ww,
            sx: C0,
            anchorOrigin: D0,
            transformOrigin: B0,
            children: v.jsxs(ee, {
                elevation: 1,
                sx: A0,
                className: "padre-decorative-scroll no-drag",
                children: [v.jsx(S, {
                    sx: E0,
                    className: "padre-decorative-scroll",
                    children: T
                }), i && !t && v.jsxs(S, {
                    direction: "row",
                    sx: I0,
                    justifyContent: "space-between",
                    alignItems: "flex-end",
                    children: [v.jsxs(S, {
                        gap: .75,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: o("Clipboard quick buy settings")
                        }), v.jsxs(C, {
                            display: "flex",
                            children: [s === Pd.SOLANA && v.jsx(dz, {}), s === Pd.BSC && v.jsx(d0, {})]
                        })]
                    }), v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        onClick: E,
                        children: o("Manage")
                    })]
                })]
            })
        })]
    }) : null
}
))
  , v0 = 14
  , S0 = 18
  , y0 = 16
  , k0 = {
    zIndex: 1299
}
  , C0 = {
    zIndex: 1202
}
  , A0 = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    maxWidth: 350,
    gap: 1
})
  , w0 = 16
  , j0 = 18
  , T0 = {
    height: 52,
    maxHeight: 52,
    px: 1,
    py: 0
}
  , I0 = e => ({
    px: 1,
    py: .75,
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    bgcolor: e.palette.background.secondary
})
  , E0 = {
    maxHeight: 336,
    overflowY: "scroll"
}
  , M0 = {
    my: 0,
    opacity: .75
}
  , N0 = 112
  , P0 = 148
  , O0 = 32
  , L0 = 28
  , R0 = e => e.walletId
  , D0 = {
    vertical: "bottom",
    horizontal: "left"
}
  , B0 = {
    vertical: "top",
    horizontal: "left"
}
  , _0 = y.memo(( ({label: e, currency: t, filter: n, setFitler: r}) => {
    var a, s;
    const {t: o} = we()
      , l = y.useCallback((e => {
        const t = QR(e.target.value);
        r((e => ({
            ...e ?? {},
            min: t
        })))
    }
    ), [r])
      , i = y.useCallback((e => {
        const t = QR(e.target.value);
        r((e => ({
            ...e ?? {},
            max: t
        })))
    }
    ), [r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        width: "100%",
        justifyContent: "space-between",
        gap: .5,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            minWidth: 105,
            children: e
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            children: [v.jsx(je, {
                ...U0,
                placeholder: o("Min"),
                value: (null == (a = n.min) ? void 0 : a.toString()) ?? "",
                onChange: l,
                endAdornment: t && v.jsx(We, {
                    position: "end",
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        children: t
                    })
                })
            }), v.jsx(je, {
                ...U0,
                placeholder: o("Max"),
                value: (null == (s = n.max) ? void 0 : s.toString()) ?? "",
                onChange: i,
                endAdornment: t && v.jsx(We, {
                    position: "end",
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        children: t
                    })
                })
            })]
        })]
    })
}
))
  , U0 = {
    sx: {
        flexGrow: 1,
        borderWidth: 1
    },
    size: "xsmall",
    inputProps: {
        inputMode: "decimal",
        "data-pseudotype": "numberLike",
        style: {
            fontWeight: 500
        },
        sx: {
            textAlign: "left",
            pl: 1,
            pr: 0,
            py: 1.5
        }
    }
}
  , W0 = y.memo(( ({tradeTypes: e, setTradeTypes: t}) => {
    const {t: n} = we()
      , r = y.useCallback((n => {
        e.includes(n) ? t(e.filter((e => e !== n))) : t([...e, n])
    }
    ), [t, e]);
    return v.jsxs(S, {
        gap: .5,
        width: "100%",
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: n("Trade categories")
        }), v.jsx(S, {
            display: "grid",
            gridTemplateColumns: "repeat(2, 1fr)",
            width: "100%",
            rowGap: F0,
            columnGap: 1,
            children: V0.map((t => {
                const a = e.includes(t.value) ?? !1;
                return v.jsx(WR, {
                    label: n(t.label),
                    isChecked: a,
                    onClick: () => {
                        r(t.value)
                    }
                }, t.value)
            }
            ))
        })]
    })
}
))
  , F0 = {
    xs: 1,
    sm: .5
}
  , V0 = [{
    label: "First buy",
    value: ph.BUY_FIRST
}, {
    label: "Bought more",
    value: ph.BUY_MORE
}, {
    label: "Sold part",
    value: ph.SELL_PART
}, {
    label: "Sold all",
    value: ph.SELL_ALL
}]
  , H0 = y.memo(( ({initialFilters: e, handleClose: t, setFilters: n, width: r}) => {
    var a, s, o, l, i, c;
    const {t: d} = we()
      , u = xw()
      , [p,h] = y.useState(e.tradeType ?? eT)
      , [m,g] = y.useState(e.amountInUsd ? {
        min: (null == (a = e.amountInUsd.min) ? void 0 : a.toString()) ?? void 0,
        max: (null == (s = e.amountInUsd.max) ? void 0 : s.toString()) ?? void 0
    } : {})
      , [x,b] = y.useState(e.mcapInUsd ? {
        min: (null == (o = e.mcapInUsd.min) ? void 0 : o.toString()) ?? void 0,
        max: (null == (l = e.mcapInUsd.max) ? void 0 : l.toString()) ?? void 0
    } : {})
      , [f,C] = y.useState(e.tokenAgeSeconds ? {
        min: (null == (i = e.tokenAgeSeconds.min) ? void 0 : i.toString()) ?? void 0,
        max: (null == (c = e.tokenAgeSeconds.max) ? void 0 : c.toString()) ?? void 0
    } : {})
      , A = y.useCallback(( () => {
        n({
            tradeType: p ?? eT,
            amountInUsd: m ? {
                min: m.min ? isNaN(Number(m.min)) ? void 0 : Number(m.min) : void 0,
                max: m.max ? isNaN(Number(m.max)) ? void 0 : Number(m.max) : void 0
            } : {},
            mcapInUsd: x ? {
                min: x.min ? isNaN(Number(x.min)) ? void 0 : Number(x.min) : void 0,
                max: x.max ? isNaN(Number(x.max)) ? void 0 : Number(x.max) : void 0
            } : {},
            tokenAgeSeconds: f ? {
                min: f.min ? isNaN(Number(f.min)) ? void 0 : Number(f.min) : void 0,
                max: f.max ? isNaN(Number(f.max)) ? void 0 : Number(f.max) : void 0
            } : {}
        }),
        t()
    }
    ), [n, p, m, x, f, t])
      , w = y.useCallback(( () => {
        n(MT),
        t()
    }
    ), [n, t]);
    return v.jsxs(S, {
        gap: z0,
        p: 1.5,
        height: "100%",
        justifyContent: "space-between",
        width: r,
        children: [v.jsxs(S, {
            gap: z0,
            children: [!u && v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: d("Filters")
                }), v.jsx(F, {
                    onClick: t,
                    children: v.jsx(kS, {})
                })]
            }), v.jsxs(S, {
                gap: 1.5,
                children: [v.jsx(W0, {
                    tradeTypes: p,
                    setTradeTypes: h
                }), v.jsx(_0, {
                    label: d("Token age (mins)"),
                    currency: "",
                    filter: f,
                    setFitler: C
                }), v.jsx(_0, {
                    label: d("Amount"),
                    currency: "$",
                    filter: m,
                    setFitler: g
                }), v.jsx(_0, {
                    label: d("Market Cap"),
                    currency: "$",
                    filter: x,
                    setFitler: b
                })]
            })]
        }), v.jsxs(S, {
            gap: z0,
            children: [v.jsx(Ee, {
                flexItem: !0
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsx(V, {
                    size: "xsmall",
                    variant: "tertiary",
                    onClick: w,
                    children: d("Reset")
                }), v.jsx(V, {
                    size: "xsmall",
                    variant: "primary",
                    onClick: A,
                    children: d("Apply")
                })]
            })]
        })]
    })
}
))
  , z0 = 2
  , $0 = y.memo(( ({id: e, initialFilters: t, isFeed: n, isOpen: r, anchorEl: a, setFilters: s, onClose: o, compact: l=!1}) => xw() ? l ? v.jsx(ne, {
    id: e,
    className: "no-drag",
    open: r,
    anchorEl: a,
    onClick: Z0,
    sx: X0,
    children: v.jsx(re, {
        onClickAway: o,
        children: v.jsx(ee, {
            elevation: 1,
            sx: Q0,
            className: "padre-no-scroll, no-drag",
            children: v.jsx(H0, {
                initialFilters: t,
                isFeed: n,
                handleClose: o,
                setFilters: s,
                width: q0
            })
        })
    })
}) : v.jsx(ae, {
    id: e,
    className: "no-drag",
    open: r,
    anchorEl: a,
    onClose: o,
    marginThreshold: 0,
    TransitionComponent: Q,
    anchorReference: "anchorEl",
    anchorOrigin: Y0,
    container: () => (null == a ? void 0 : a.parentElement) ?? null,
    sx: K0,
    elevation: 1,
    children: v.jsx(H0, {
        initialFilters: t,
        isFeed: n,
        handleClose: o,
        setFilters: s,
        width: q0
    })
}) : v.jsx(Sw, {
    open: r,
    stackSx: G0,
    children: v.jsx(H0, {
        initialFilters: t,
        isFeed: n,
        handleClose: o,
        setFilters: s
    })
})))
  , G0 = {
    p: 0,
    border: "none"
}
  , q0 = 330
  , K0 = {
    zIndex: 10,
    "& .MuiPopover-paper": {
        mt: 1
    }
}
  , Y0 = {
    vertical: "bottom",
    horizontal: "left"
}
  , X0 = {
    zIndex: 1299
}
  , Q0 = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    cursor: "auto",
    p: 0
})
  , Z0 = e => {
    e.stopPropagation()
}
  , J0 = y.memo(( () => {
    const e = D()
      , {filters: t, setFilters: n, filtersCount: r} = uI()
      , {buttonProps: a, popoverProps: s} = Fw({
        id: "tracker-filters"
    });
    return v.jsxs(C, {
        children: [v.jsx(F, {
            ...a,
            tabIndex: -1,
            onMouseDown: n1,
            onClick: s.open ? s.onClose : a.onClick,
            sx: t1,
            children: v.jsx(bk, {
                size: e1,
                color: r ? e.palette.primary.main : e.palette.text.label
            })
        }), s.open && v.jsx($0, {
            compact: !0,
            isOpen: !0,
            initialFilters: t,
            isFeed: !0,
            setFilters: n,
            ...s
        })]
    })
}
))
  , e1 = 16
  , t1 = {
    display: "flex",
    alignItems: "center",
    px: 0,
    width: 28,
    height: 28,
    background: "transparent"
}
  , n1 = e => {
    e.preventDefault()
}
  , r1 = y.memo(( ({isFloating: e}) => v.jsxs(S, {
    position: "relative",
    flexGrow: 1,
    direction: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    minHeight: 28,
    className: "no-drag padre-no-scroll",
    sx: a1,
    gap: .5,
    children: [v.jsx(J0, {}), v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: .5,
        children: [v.jsx(f0, {
            compact: !0,
            hideSettings: !0,
            usePopper: e,
            chain: Pd.SOLANA
        }), v.jsx(dz, {})]
    })]
})))
  , a1 = {
    cursor: "auto",
    overflowY: "none",
    overflowX: "visible"
}
  , s1 = y.memo(( ({resetFilters: e}) => {
    const {t: t} = we();
    return v.jsxs(S, {
        width: "100%",
        height: "100%",
        alignItems: "center",
        justifyContent: "center",
        gap: .75,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            textAlign: "center",
            children: t("No data matches filters")
        }), v.jsxs(V, {
            variant: "tertiary",
            sx: o1,
            onClick: e,
            className: "no-drag",
            children: [t("Reset filters"), v.jsx(C, {
                display: "flex",
                mt: "-1px",
                children: v.jsx(_S, {
                    color: "inherit",
                    size: 14
                })
            })]
        })]
    })
}
))
  , o1 = {
    border: "none",
    display: "flex",
    alignItems: "center",
    p: 0,
    height: 16,
    gap: .5,
    color: "primary.main",
    backgroundColor: "transparent",
    "&:hover": {
        backgroundColor: "transparent"
    },
    "&:focus": {
        backgroundColor: "transparent"
    }
}
  , l1 = "live-trades-content-class"
  , i1 = y.memo(( ({displayData: e}) => {
    const {performBuy: t} = AD();
    k$(e.chain === Pd.SOLANA ? e.marketId : null);
    const {exitStrategies: n} = KR()
      , {settings: r} = rf()
      , {includeExitStrategies: a, selectedPreset: s, buttonValue: o, insufficientBalance: l} = uH()
      , [i,c] = JC(!1, 500)
      , d = y.useMemo(( () => !o || !!l), [o, l])
      , u = y.useCallback((async () => {
        np.info("Live trades buy button clicked", {
            buttonValue: o,
            tokenAddress: e.tokenAddress
        });
        const l = {
            value: o,
            baseCurrency: e.tokenAddress,
            baseTokenType: e.tokenType,
            poolQuoteCurrency: e.quoteAddress,
            baseSymbol: e.tokenSymbol,
            marketId: e.marketId,
            originWidget: Dp.WALLET_TRACKER
        };
        if (e.chain === Pd.SOLANA && null !== o)
            try {
                ((null == r ? void 0 : r.preventDoubleClick) ?? y$) && c(!0),
                await t({
                    value: o,
                    baseCurrency: e.tokenAddress,
                    baseTokenType: e.tokenType,
                    poolQuoteCurrency: e.quoteAddress,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: e.tokenSymbol,
                    quoteSymbol: "SOL",
                    marketId: e.marketId,
                    padreAvatarUrl: e.padreAvatarUrl,
                    presetName: s,
                    originWidget: Dp.WALLET_TRACKER,
                    exitStrategies: a && n.length ? n : null
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing order", {
                    e: fNe,
                    orderInfo: l
                })
            }
        else
            np.warn("Order hasn't been sent - live trades unsupported", {
                orderInfo: l
            })
    }
    ), [o, e.chain, e.marketId, e.padreAvatarUrl, e.tokenAddress, e.tokenSymbol, e.quoteAddress, e.tokenType, n, a, t, s, c, null == r ? void 0 : r.preventDoubleClick]);
    return v.jsxs(V, {
        className: "no-drag",
        disabled: d || i,
        onClick: u,
        size: "xxsmall",
        sx: c1,
        color: "success",
        children: [v.jsx(ay, {
            color: "inherit"
        }), o]
    })
}
))
  , c1 = {
    pl: .5,
    pr: 1,
    borderRadius: 4,
    display: "flex",
    gap: .5,
    cursor: "pointer"
}
  , d1 = ({onClick: e}) => v.jsx(C, {
    onClick: e,
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-start",
    width: "100%",
    sx: p1,
    children: v.jsx(Ny, {
        animateColor: !0,
        color: "inherit",
        size: u1
    })
})
  , u1 = 14
  , p1 = e => ({
    cursor: "pointer",
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.value
    }
})
  , h1 = ["timestamp", "makerAddress", "tokenAddress", "amountInNative", "marketCapInUsd"]
  , m1 = ["timestamp", "tokenAddress", "amountInNative", "marketCapInUsd"]
  , g1 = ["makerAddress", "tokenAddress", "amountInNative", "marketCapInUsd"]
  , x1 = {
    makerAddress: n.t("Maker"),
    tokenAddress: n.t("Token"),
    amountInNative: n.t("Amount"),
    marketCapInUsd: n.t("Market Cap")
}
  , b1 = 1.75
  , f1 = "tokenCreatedAt"
  , v1 = "makerEmoji"
  , S1 = {
    [f1]: !0,
    [v1]: !0
}
  , y1 = {
    tokenAddress: [{
        flagKey: f1,
        label: n.t("Token created at")
    }],
    makerAddress: [{
        flagKey: v1,
        label: n.t("Maker emoji")
    }]
}
  , k1 = (e, t) => e ? m1 : h1.filter(t)
  , C1 = y.memo(( ({isWalletLookup: e, gridTemplateColumns: t, isColumnVisible: n, openSettings: r}) => {
    const {t: a} = we()
      , s = y.useMemo(( () => k1(e, n)), [e, n])
      , o = y.useCallback((t => {
        const n = w1(t, e, a);
        return "timestamp" !== t || e ? v.jsx(j1, {
            label: n,
            justifyContent: "timestamp" === t || "makerAddress" === t || "tokenAddress" === t ? "flex-start" : "flex-end"
        }, t) : v.jsx(d1, {
            onClick: r
        }, t)
    }
    ), [e, r, a]);
    return v.jsx(C, {
        position: "sticky",
        top: 0,
        zIndex: 3,
        display: "grid",
        gridTemplateColumns: t,
        alignItems: "center",
        sx: A1,
        children: s.map(o)
    })
}
))
  , A1 = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    px: b1,
    height: 34,
    minHeight: 34,
    gap: 1.5,
    background: e.palette.background.secondary
})
  , w1 = (e, t, n) => {
    switch (e) {
    case "timestamp":
        return t ? n("Age") : "";
    case "makerAddress":
        return n("Name");
    case "tokenAddress":
        return n("Token");
    case "amountInNative":
        return n("Amount");
    case "marketCapInUsd":
        return n("MCap");
    default:
        return ""
    }
}
  , j1 = y.memo(( ({label: e, justifyContent: t="flex-end"}) => v.jsx(k, {
    variant: "paragraph3",
    color: "text.label",
    display: "flex",
    alignItems: "center",
    justifyContent: t,
    noWrap: !0,
    children: e
})))
  , T1 = e => {
    3 === (e = e.replace("#", "")).length && (e = e.split("").map((e => e + e)).join(""));
    const t = parseInt(e, 16);
    return {
        r: t >> 16 & 255,
        g: t >> 8 & 255,
        b: 255 & t
    }
}
  , I1 = (e, t=.75, n="#171717") => {
    const r = T1(e)
      , a = T1(n)
      , s = {
        r: r.r * t + a.r * (1 - t),
        g: r.g * t + a.g * (1 - t),
        b: r.b * t + a.b * (1 - t)
    };
    return ( (e, t, n) => {
        const r = e => Math.round(e).toString(16).padStart(2, "0");
        return `#${r(e)}${r(t)}${r(n)}`
    }
    )(s.r, s.g, s.b)
}
  , E1 = (e, t, n) => {
    switch (n) {
    case rg.DARK:
        return e === xc.BUY ? "#1A241F" : "#261C1C";
    case rg.GREY:
        return e === xc.BUY ? "#273630" : "#3A2B2D";
    default:
        {
            const [r,a] = (e => {
                switch (e) {
                case rg.DARK:
                    return [.778, .73];
                case rg.GREY:
                    return [.646, .697];
                case rg.GREEN:
                    return [.75, .75];
                case rg.MONOKAI:
                    return [.77, .74];
                case rg.PURPLE:
                    return [.58, .74];
                case rg.VIOLET:
                    return [.72, .7];
                default:
                    return [.8, .8]
                }
            }
            )(n)
              , s = e === xc.BUY ? t.palette.success.main : t.palette.negative.main
              , o = e === xc.BUY ? r : a;
            return [rg.CUSTOM, rg.CUSTOM_2].includes(n) ? I1(I1(s, .9), .2, t.palette.background.default) : (e => {
                const t = e.match(/rgb\((\d+), (\d+), (\d+)\)/);
                if (!t)
                    return e;
                const [,n,r,a] = t;
                return "#" + [n, r, a].map((e => {
                    const t = parseInt(e).toString(16);
                    return 1 === t.length ? "0" + t : t
                }
                )).join("")
            }
            )(Gt(s, o))
        }
    }
}
  , M1 = e => `linear-gradient(90deg, ${e}33, ${e})`
  , N1 = y.memo(( ({useUsdPrice: e, liveTradeData: t}) => {
    const n = D()
      , {colorSkin: r} = Vb()
      , a = y.useMemo(( () => {
        const e = O1(t.amountInUsd)
          , a = E1(t.side, n, r);
        return {
            position: "absolute",
            right: P1 - e - 6,
            top: -7,
            bottom: -7,
            width: `${e}px`,
            zIndex: 1,
            background: M1(a)
        }
    }
    ), [r, t, n])
      , s = y.useMemo(( () => {
        switch (t.chain) {
        case Pd.SOLANA:
            return v.jsx(dk, {
                size: L1
            });
        case Pd.BSC:
            return v.jsx(rk, {
                size: L1
            });
        case Pd.ETH_MAINNET:
        case Pd.BASE:
            return v.jsx(Df, {
                size: L1 - 1
            });
        default:
            return null
        }
    }
    ), [t.chain]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: .25,
        position: "relative",
        children: [v.jsx(C, {
            sx: a
        }), !e && v.jsx(C, {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 2,
            children: s
        }), v.jsx(k, {
            variant: "monospace2",
            color: t.side === xc.BUY ? "success.main" : "error.main",
            sx: {
                zIndex: 2
            },
            children: (e ? t.amountInUsd : t.amountInNative) < .01 ? `<${e ? "$" : ""}0.01` : LI(e ? t.amountInUsd : t.amountInNative, {
                symbol: e ? "$" : "",
                padSymbol: !1,
                symbolPosition: yI.START,
                collapseExponent: !0,
                maxPrecision: 2,
                minPrecision: 2
            })
        })]
    })
}
))
  , P1 = 90
  , O1 = e => Math.max(1, Number(Math.min(Math.abs(e) / (1e3 / P1), P1).toFixed(0)))
  , L1 = 15
  , R1 = ({liveTradeData: e}) => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    children: v.jsx(xE, {
        ts: e.timestamp ?? null,
        isShort: !0,
        sx: D1,
        variant: "paragraph3"
    })
})
  , D1 = {
    cursor: "help"
}
  , B1 = e => ({
    lastActivityTs: e[0],
    walletAddress: e[1],
    amountString: e[2],
    incomplete: e[3],
    insider: e[4],
    totalBoughtUsd: e[5],
    totalSoldUsd: e[6],
    buyTxns: e[7],
    sellTxns: e[8],
    activationTimestamp: e[9],
    tradingApp: e[10],
    nativeBalanceUi: e[12],
    amountBought: e[13] ?? null,
    amountSold: e[14] ?? null,
    isBundler: e[15] ?? null,
    holdingSince: e[16] ?? null,
    fundHash: e[17] ?? null,
    fundFrom: e[18] ?? null,
    fundAmountNativeUi: e[19] ?? null,
    fundTs: e[20] ?? null,
    fundExchange: e[21] ?? null
})
  , _1 = new Set(["Gygj9QQby4j2jryqyqBHvLP7ctv2SaANgh4sCb69BUpA", "GUYCUEpxSkm1ccDo3LSKMR4Xpe5bgMnEZaFygWUSEVH3", "BwWK17cbHxwWBKZkUYvzxLcNQ1YVyaFezduWbtm2de6s"]);
var U1 = (e => (e.FISH = "FISH",
e.SHRIMP = "SHRIMP",
e.DOLPHIN = "DOLPHIN",
e.WHALE = "WHALE",
e))(U1 || {});
const W1 = e => e < 250 ? U1.FISH : e < 1e3 ? U1.SHRIMP : e < 1e4 ? U1.DOLPHIN : U1.WHALE
  , F1 = y.memo(( ({volume: e, useColors: t, size: n=V1}) => {
    const r = D()
      , {Icon: a, color: s} = H1(e, r);
    return v.jsx(a, {
        color: t ? s : void 0,
        size: n
    })
}
))
  , V1 = 14
  , H1 = (e, t) => {
    switch (W1(e)) {
    case U1.FISH:
        return {
            Icon: jf,
            color: t.palette.green[200]
        };
    case U1.SHRIMP:
        return {
            Icon: Tf,
            color: t.palette.yellow[500]
        };
    case U1.DOLPHIN:
        return {
            Icon: If,
            color: t.palette.blue[500]
        };
    case U1.WHALE:
        return {
            Icon: Ef,
            color: t.palette.blue[200]
        }
    }
}
  , z1 = ({totalUsd: e, totalAmount: t, totalSupply: n, decimals: r}) => 0 === t || !e || c.isNil(r) || c.isNil(t) || c.isNil(n) ? null : Number(n) * e / t
  , $1 = {
    direction: "row",
    justifyContent: "space-between",
    height: 14
}
  , G1 = {
    variant: "paragraph2",
    color: "text.label"
}
  , q1 = y.memo(( ({label: e, isLoading: t, value: n, isDollarValue: r, useColors: a, forcedColorValue: s, additionalValue: o, additionalValueSymbol: l, additionalValuePrecision: i=0, chain: c, isNative: d, nativePrice: u}) => {
    const p = y.useMemo(( () => {
        if (null === n)
            return null;
        if (r && !d)
            return OI(n, {
                collapseExponent: !0
            });
        if (d && r) {
            if (!u)
                return null;
            return LI(n / u, {
                collapseExponent: !0,
                symbol: "",
                desiredDigits: 3,
                noTrailingZeros: !0
            })
        }
        return LI(n, {
            collapseExponent: !0,
            symbol: "",
            maxPrecision: 0,
            minPrecision: 0
        })
    }
    ), [r, d, u, n]);
    return v.jsxs(S, {
        ...$1,
        children: [v.jsxs(S, {
            ...$1,
            width: K1,
            children: [v.jsx(k, {
                ...G1,
                children: e
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: c === Pd.BASE ? .5 : .25,
                children: [d && v.jsx(Sz, {
                    grayOut: c === Pd.ETH_MAINNET,
                    chain: c,
                    size: 15
                }), t ? v.jsx(Ie, {
                    variant: "rounded",
                    width: d ? 35 : 65,
                    height: 13
                }) : v.jsx(RZ, {
                    value: a ? s ?? n ?? 0 : 0,
                    formattedDisplay: null === p ? Ud : p,
                    variant: "paragraph1"
                })]
            })]
        }), void 0 !== o && void 0 !== l && v.jsx(k, {
            color: "text.label",
            variant: "paragraph3",
            textAlign: "end",
            noWrap: !0,
            maxWidth: 90,
            mt: "1px",
            children: LI(o, {
                collapseExponent: !0,
                minPrecision: i,
                maxPrecision: i,
                padSymbol: !0,
                symbolPosition: yI.END,
                symbol: iu(l, 6, 2)
            })
        })]
    })
}
))
  , K1 = 165
  , Y1 = e => {
    switch (W1(e)) {
    case U1.FISH:
        return "Fish: <$250 bought or sold";
    case U1.SHRIMP:
        return "Shrimp: $250 - $1k bought or sold";
    case U1.DOLPHIN:
        return "Dolphin: $1k - $10k bought or sold";
    case U1.WHALE:
        return "Whale +$10k bought or sold"
    }
}
  , X1 = y.memo(( ({chain: e, isLoading: t, buyTxns: n, sellTxns: r, isIncomplete: a, walletAddress: s, basePriceInUsdUi: o, deployedAt: l, amountBought: i, totalBoughtUsd: d, amountSold: u, totalSoldUsd: p, tradeAmountInUsd: h, holdingAmount: m, totalSupply: g, decimals: x, symbol: b, isQuote: f, tooltipNativeValues: A, toggleTooltipNativeValues: w}) => {
    const {t: j} = we()
      , T = D()
      , I = ( (e, t, n) => "number" == typeof e || "number" == typeof t ? (t ?? 0) + (e ?? 0) : isNaN(Number(n)) ? null : Number(n))(d, p, h)
      , E = y.useMemo(( () => {
        if (c.isNil(x) || "string" != typeof b)
            return null;
        const t = Number(m) / 10 ** x
          , a = e !== Pd.SOLANA
          , s = null == u ? null : a ? u * 10 ** x : u;
        return {
            avgBuyMc: z1({
                totalUsd: d ?? null,
                totalAmount: null == i ? null : a ? i * 10 ** x : i,
                totalSupply: g,
                decimals: x
            }),
            avgSellMc: z1({
                totalUsd: p ?? null,
                totalAmount: s,
                totalSupply: g,
                decimals: x
            }),
            boughtValue: d ?? 0,
            soldValue: p ?? 0,
            pnlValue: (p ?? 0) - (d ?? 0),
            amount: t,
            remainingValue: (o ?? 0) * t,
            buyTxns: n ?? 0,
            sellTxns: r ?? 0
        }
    }
    ), [x, b, m, e, i, u, d, g, p, o, n, r])
      , M = y.useMemo(( () => (l ?? 0) < 1727733600), [l])
      , N = y.useMemo(( () => f ? [] : [{
        label: j("Bought"),
        value: (null == E ? void 0 : E.boughtValue) ?? null,
        isDollarValue: !0,
        useColors: !0,
        forcedColorValue: 1,
        additionalValue: null == E ? void 0 : E.buyTxns,
        additionalValueSymbol: ((null == E ? void 0 : E.buyTxns) ?? 0) > 1 ? j("txns") : j("txn"),
        additionalValuePrecision: 0
    }, {
        label: j("Avg buy MC"),
        value: (null == E ? void 0 : E.avgBuyMc) ?? null,
        isDollarValue: !0,
        useColors: !0,
        forcedColorValue: 1,
        marginBelow: !0,
        forceDollars: !0
    }, {
        label: j("Sold"),
        value: (null == E ? void 0 : E.soldValue) ?? null,
        isDollarValue: !0,
        useColors: !0,
        forcedColorValue: -1,
        additionalValue: null == E ? void 0 : E.sellTxns,
        additionalValueSymbol: ((null == E ? void 0 : E.sellTxns) ?? 0) > 1 ? j("txns") : j("txn"),
        additionalValuePrecision: 0
    }, {
        label: j("Avg sell MC"),
        value: (null == E ? void 0 : E.avgSellMc) ?? null,
        isDollarValue: !0,
        useColors: !0,
        forcedColorValue: -1,
        marginBelow: !0,
        forceDollars: !0
    }, {
        label: j("PnL"),
        value: (null == E ? void 0 : E.pnlValue) ?? null,
        isDollarValue: !0,
        useColors: !0
    }, {
        label: j("Remaining"),
        value: (null == E ? void 0 : E.remainingValue) ?? null,
        isDollarValue: !0,
        useColors: !1,
        additionalValue: b ? null == E ? void 0 : E.amount : void 0,
        additionalValueSymbol: b ?? void 0,
        additionalValuePrecision: 2
    }]), [null == E ? void 0 : E.boughtValue, null == E ? void 0 : E.pnlValue, null == E ? void 0 : E.remainingValue, null == E ? void 0 : E.soldValue, null == E ? void 0 : E.buyTxns, null == E ? void 0 : E.sellTxns, null == E ? void 0 : E.amount, null == E ? void 0 : E.avgBuyMc, null == E ? void 0 : E.avgSellMc, b, f, j])
      , P = VV(e)
      , O = y.useCallback((e => {
        e.stopPropagation(),
        w()
    }
    ), [w]);
    return v.jsxs(S, {
        width: 280,
        pt: .5,
        px: 1,
        gap: 1,
        className: "no-drag",
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            mx: -.5,
            children: [v.jsx(cA, {
                address: s,
                customName: _1.has(s) ? "MAYHEM" : oA(s, {
                    firstPartLength: 14,
                    finalPartLength: 5
                }),
                maxWidth: 200,
                stopPropagation: !0,
                preventDefault: !0,
                isInTooltip: !0
            }), v.jsxs(V, {
                variant: "tertiary",
                size: "small",
                onMouseDown: Uw,
                onClick: O,
                sx: Q1,
                children: [v.jsx(gS, {}), v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    pt: .25,
                    children: A ? e === Pd.SOLANA ? "SOL" : "ETH" : "USD"
                })]
            })]
        }), v.jsx(Ee, {
            flexItem: !0
        }), v.jsx(S, {
            width: "100%",
            gap: .5,
            children: N.map(( ({label: n, value: r, isDollarValue: a, useColors: s, forcedColorValue: o, additionalValue: l, additionalValueSymbol: i, additionalValuePrecision: c, marginBelow: d, forceDollars: u}) => v.jsx(C, {
                pb: d ? 2 : 0,
                children: v.jsx(q1, {
                    label: n,
                    value: r,
                    isLoading: t || null === E,
                    isDollarValue: a,
                    useColors: s,
                    forcedColorValue: o,
                    additionalValue: l,
                    additionalValueSymbol: i,
                    additionalValuePrecision: c,
                    chain: e,
                    isNative: A && !u,
                    nativePrice: P
                })
            }, n)))
        }), f ? v.jsx(S, {
            direction: "row",
            alignItems: "center",
            mb: 1,
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "Not available for stable and native currencies"
            })
        }) : (a || M) && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1.5,
            children: [v.jsx(C, {
                width: 18,
                children: v.jsx(wk, {
                    size: 18,
                    color: T.palette.warning.main
                })
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: a ? "Data for bots with over 10k transactions might be incomplete" : M ? "Trades before Oct 2024 are not included" : "Data for this trader is being backfilled"
            })]
        }), v.jsx(Ee, {}), null !== I && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1.5,
            children: [v.jsx(C, {
                width: 38,
                children: v.jsx(F1, {
                    size: 38,
                    volume: I,
                    useColors: !0
                })
            }), v.jsx(S, {
                gap: .5,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: Y1(I)
                })
            })]
        })]
    })
}
))
  , Q1 = {
    display: "flex",
    alignItems: "center",
    gap: .5,
    px: 0,
    py: 0,
    width: 56,
    height: 26,
    mr: -.25,
    border: "none",
    background: "transparent"
}
  , Z1 = e => (t, n) => {
    if ("init" === n.type) {
        const a = (r = n.snapshot,
        bg(r.chain, r.tokenAddress));
        e.current[a] = n.snapshot;
        const s = t ? {
            ...t
        } : {
            ...e.current
        };
        return s[a] = n.snapshot,
        s
    }
    return t ?? {};
    var r
}
  , J1 = e => {
    const t = y.useRef({});
    y.useEffect(( () => {
        const n = Object.keys(t.current);
        for (const r of n)
            e.includes(r) || delete t.current[r]
    }
    ), [e]);
    const n = y.useMemo(( () => (e => e.join("_"))(c.orderBy(e, (e => e)))), [e])
      , r = y.useCallback((e => n ? um.onFastStatsUpdate(n, e) : {
        unsubscribe: () => {}
    }), [n])
      , a = y.useMemo(( () => Z1(t)), [t])
      , s = y.useMemo(( () => c.pick({
        ...t.current
    }, e)), [e]);
    return kx(r, a) ?? s
}
  , e2 = y.memo(( ({chain: e, walletAddress: t, tokenAddress: n, decimals: r, deployedAt: a, symbol: s}) => {
    var o, l;
    const i = Ax()
      , [d,u] = y.useState(null)
      , p = bg(e, n)
      , h = y.useMemo(( () => [p]), [p])
      , m = J1(h)
      , [g,x] = Mx("padreV2-makerTooltipNativeMode", !1)
      , b = y.useCallback(( () => {
        x((e => !e))
    }
    ), [x]);
    return y.useEffect(( () => {
        if (!i || c.isNil(e) || c.isNil(t) || c.isNil(n))
            return;
        let r = !1;
        return (async () => {
            try {
                const a = await Tm.fetchHoldingMulti(i, {
                    chain: e,
                    token: ng(n),
                    wallets: [ng(t)]
                });
                r || (1 === a.entries.length ? u(B1(a.entries[0])) : u(null))
            } catch (W$e) {
                if (r)
                    return
            }
        }
        )(),
        () => {
            r = !0
        }
    }
    ), [e, t, n, i]),
    v.jsx(X1, {
        isLoading: !d || !m,
        chain: e,
        walletAddress: ng(t),
        tokenAddress: ng(n),
        amountBought: (null == d ? void 0 : d.amountBought) ?? null,
        totalBoughtUsd: (null == d ? void 0 : d.totalBoughtUsd) ?? null,
        amountSold: (null == d ? void 0 : d.amountSold) ?? null,
        totalSoldUsd: (null == d ? void 0 : d.totalSoldUsd) ?? null,
        tradeAmountInUsd: "0",
        holdingAmount: (null == d ? void 0 : d.amountString) ?? null,
        decimals: r,
        totalSupply: null == (o = m[p]) ? void 0 : o.totalSupply,
        basePriceInUsdUi: (null == (l = m[p]) ? void 0 : l.priceInUsdUi) ?? null,
        buyTxns: (null == d ? void 0 : d.buyTxns) ?? 0,
        sellTxns: (null == d ? void 0 : d.sellTxns) ?? 0,
        symbol: s,
        isIncomplete: (null == d ? void 0 : d.incomplete) ?? !1,
        deployedAt: a,
        isQuote: tu(ng(n), e),
        tooltipNativeValues: g,
        toggleTooltipNativeValues: b
    })
}
))
  , t2 = (e, t, n=a2) => {
    switch (t) {
    case iZ.BEGINNING:
        return e.slice(0, Math.max(n2, n));
    case iZ.SHORTENED:
        return oA(e, {
            firstPartLength: Math.max(r2, Number(((n - 2) / 2).toFixed(0))) + 1,
            finalPartLength: Math.max(r2, Number(((n - 2) / 2).toFixed(0)))
        });
    case iZ.END:
        return e.slice(-Math.max(n2, n))
    }
}
  , n2 = 2
  , r2 = 1
  , a2 = 8
  , s2 = ({liveTradeData: e, showEmoji: t, tableAddressMode: n, onTooltipOpen: r, onTooltipClose: a}) => {
    const {openModal: s} = r6()
      , o = y.useCallback(( () => {
        s(e.makerAddress)
    }
    ), [e, s])
      , l = y.useMemo(( () => t => ({
        "&:hover": {
            cursor: "pointer",
            filter: "brightness(1.2)"
        },
        color: e.side === xc.BUY ? t.palette.success.main : t.palette.error.main
    })), [e.side]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        overflow: "hidden",
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .75,
            children: [t && v.jsx(S, {
                width: o2,
                children: null !== e.walletGroupEmoji && v.jsx(z, {
                    title: e.walletGroupName ?? "",
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(ZT, {
                            emoji: e.makerCustomEmoji ?? e.walletGroupEmoji
                        })
                    })
                })
            }), v.jsx(S, {
                direction: "row",
                alignItems: "center",
                onClick: o,
                children: v.jsx(GC, {
                    enterDelay: 250,
                    enterNextDelay: 250,
                    disableInteractive: !1,
                    onOpen: r,
                    onClose: a,
                    title: v.jsx(e2, {
                        chain: e.chain,
                        walletAddress: ng(e.makerAddress),
                        tokenAddress: ng(e.tokenAddress),
                        decimals: e.tokenDecimals,
                        symbol: e.tokenSymbol,
                        deployedAt: e.tokenDeployedAt,
                        quoteTokenAddress: e.quoteAddress ?? null
                    }),
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        noWrap: !0,
                        sx: l,
                        children: e.makerCustomName ?? t2(e.makerAddress, n)
                    })
                })
            })]
        })
    })
}
  , o2 = 14
  , l2 = ({liveTradeData: e}) => {
    const t = y.useMemo(( () => null === e.marketCapInUsd ? null : LI(e.marketCapInUsd, {
        symbol: "$",
        symbolPosition: yI.START,
        desiredDigits: 3,
        collapseExponent: !0,
        padSymbol: !1
    })), [e]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "flex-end",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            children: t ?? Ud
        })
    })
}
  , i2 = ({liveTradeData: e, showCreatedAt: t}) => {
    const n = yT()
      , r = pT()
      , a = y.useMemo(( () => e.chain === Pd.SOLANA ? v$(e.marketProtocolType, e.marketLaunchpad, e.marketLaunchpadAux, e.chain, e.isMigration, e.tokenAddress) : null), [e.chain, e.isMigration, e.marketLaunchpad, e.marketLaunchpadAux, e.marketProtocolType, e.tokenAddress])
      , s = y.useCallback((t => {
        if (0 === t.button && !t.metaKey && !t.ctrlKey) {
            if (t.preventDefault(),
            !e)
                return;
            const o = e.timestamp + 10 > ZA();
            o && !c.isNil(e.marketProtocolType) && (s = e.marketProtocolType,
            Rp[s]) || o && !c.isNil(e.marketProtocolType) && Lp(e.marketProtocolType) && e.marketLaunchpadAux || (null == a ? void 0 : a.isMigrated) ? r({
                marketId: e.marketId,
                tradePageOrigin: nT.LIVE_TRADES
            }) : n({
                chain: e.chain,
                tokenAddress: e.tokenAddress,
                tradePageOrigin: nT.LIVE_TRADES
            })
        }
        var s
    }
    ), [e, a, n, r]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        children: v.jsxs(S, {
            component: "a",
            href: QE(e.marketId, nT.LIVE_TRADES),
            direction: "row",
            alignItems: "center",
            gap: 1.25,
            onClick: s,
            sx: c2,
            children: [v.jsx(b_, {
                url: IE(e.chain, e.tokenAddress),
                name: e.tokenName,
                chain: e.chain,
                padreAvatarUrl: e.padreAvatarUrl,
                size: 20,
                markerIcon: e.chain === Pd.SOLANA ? void 0 : v.jsx(Sz, {
                    chain: e.chain,
                    size: 10
                }),
                protocolInfo: a,
                markerSize: 8,
                alwaysShowPointer: !0,
                hideHoverAvatar: !0
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                sx: d2,
                divider: v.jsx(v.Fragment, {
                    children: ""
                }),
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: iu(e.tokenSymbol)
                }), t && e.tokenDeployedAt && v.jsx(mE, {
                    variant: "paragraph3",
                    isShort: !0,
                    ts: (null == e ? void 0 : e.tokenDeployedAt) ?? null
                })]
            })]
        })
    })
}
  , c2 = {
    textDecoration: "none",
    color: "text.value"
}
  , d2 = {
    "&:hover": {
        cursor: "pointer",
        filter: "brightness(1.2)"
    }
}
  , u2 = y.memo(( ({isWalletLookup: e, gridTemplateColumns: t, isColumnVisible: n, showTokenCreatedAt: r, showMakerEmoji: a, tableAddressMode: s, showQuickBuyButton: o, useUsdPrices: l, onMouseOverRef: i, onTooltipOpen: c, onTooltipClose: d, ...u}) => {
    const p = y.useMemo(( () => k1(e, n)), [e, n])
      , {colorSkin: h} = Vb()
      , m = y.useMemo(( () => t => ({
        px: b1,
        gap: 1.5,
        "&:nth-of-type(odd)": {
            backgroundColor: h === rg.INDIGO ? tY : e ? t.palette.background.default : t.palette.background.secondary
        }
    })), [h, e])
      , g = y.useCallback((t => {
        switch (t) {
        case "timestamp":
            return v.jsx(R1, {
                liveTradeData: u
            }, t);
        case "makerAddress":
            return v.jsx(s2, {
                liveTradeData: u,
                showEmoji: a,
                tableAddressMode: s,
                onTooltipOpen: c,
                onTooltipClose: d
            }, t);
        case "tokenAddress":
            return v.jsx(i2, {
                liveTradeData: u,
                showCreatedAt: e || r
            }, t);
        case "amountInNative":
            return v.jsx(N1, {
                liveTradeData: u,
                useUsdPrice: l
            }, t);
        case "marketCapInUsd":
            return v.jsx(l2, {
                liveTradeData: u
            }, t);
        default:
            return v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: t.slice(0, 3)
            }, t)
        }
    }
    ), [u, e, a, r, s, l, c, d])
      , x = y.useCallback(( () => {
        o && u.chain === Pd.SOLANA && (null == i ? void 0 : i.current) && i.current(u)
    }
    ), [o, u, i]);
    return v.jsx(C, {
        display: "grid",
        gridTemplateColumns: t,
        alignItems: "center",
        height: 34,
        minHeight: 34,
        sx: m,
        onMouseEnter: x,
        children: p.map(g)
    })
}
))
  , p2 = y.memo(( ({rowData: e, isLoading: t, isWalletLookup: n=!1, useUsdPrices: r=!1, containerRef: a, showQuickBuyButton: s=!1, pauseOnHover: o=!1, setPauseOnHover: l, onTooltipOpen: i, onTooltipClose: d}) => {
    const {t: u} = we()
      , p = bw()
      , {hiddenColumnsKeys: h, isModalOpen: m, openModal: g, closeModal: x, setHiddenColumnsKeys: b} = EZ(IZ("LiveTrades"))
      , f = y.useMemo(( () => n ? [] : g1), [n])
      , C = y.useMemo(( () => new Set(f)), [f])
      , A = y.useMemo(( () => new Set(h)), [h])
      , w = y.useCallback((e => !C.has(e) || !A.has(e)), [C, A])
      , [j,T] = Mx("padreV2-liveTradesCustomFlags", S1)
      , [I,E] = y.useMemo(( () => [!!j[f1], !!j[v1]]), [j])
      , [M,N] = Mx("padreV2-liveTradesAddressMode", iZ.END)
      , [P,O] = y.useMemo(( () => {
        if (n)
            return ["34px minmax(100px, 0.75fr) minmax(125px, 0.25fr) minmax(84px, 0.75fr) minmax(84px, 0.75fr)", 503];
        const e = (n ? m1 : h1).filter(w)
          , {templates: t, width: r} = c.reduce(e, ( (e, t) => {
            const [n,r] = ( (e, t, n) => {
                switch (e) {
                case "timestamp":
                    return ["22px", 22];
                case "makerAddress":
                    {
                        const e = 65 - (n ? 0 : 16);
                        return [`minmax(${e}px, 0.75fr)`, e]
                    }
                case "tokenAddress":
                    {
                        const e = 125 - (t ? 0 : 26);
                        return [`minmax(${e}px, 0.25fr)`, e]
                    }
                case "amountInNative":
                    return ["minmax(62px, 0.5fr)", 62];
                case "marketCapInUsd":
                    return ["minmax(60px, 0.5fr)", 60];
                default:
                    return ["0px", 0]
                }
            }
            )(t, I, E);
            return e.templates.push(n ?? "0px"),
            e.width += r,
            e
        }
        ), {
            templates: [],
            width: 0
        })
          , a = r + 8 * (3.5 + 1.5 * (e.length - 1));
        return [t.join(" "), a]
    }
    ), [n, w, I, E])
      , L = y.useMemo(( () => v.jsx(C1, {
        isWalletLookup: n,
        gridTemplateColumns: P,
        isColumnVisible: w,
        openSettings: g
    })), [n, P, w, g])
      , R = y.useMemo(( () => e ? [...e].sort(( (e, t) => e.timestamp !== t.timestamp ? t.timestamp - e.timestamp : (t.tradeIndex ?? 0) - (e.tradeIndex ?? 0))) : null), [e])
      , {filtersCount: D, setFilters: B} = uI()
      , _ = y.useMemo(( () => D > 0), [D])
      , U = y.useCallback(( () => {
        B(MT)
    }
    ), [B])
      , W = y.useRef(null)
      , [F,V] = y.useState(null)
      , [H,z] = y.useState(null)
      , $ = y.useCallback(( () => {
        V(null),
        z(null)
    }
    ), [])
      , G = y.useCallback((e => {
        if (!R)
            return V(null),
            void z(null);
        const t = R.findIndex((t => h2(e) === h2(t)));
        if (-1 === t)
            return V(null),
            void z(null);
        V(e),
        z(34 * t)
    }
    ), [R])
      , q = y.useRef(G);
    y.useEffect(( () => {
        q.current = G
    }
    ), [G]);
    const [K,Y] = y.useState(0);
    y.useLayoutEffect(( () => {
        const e = () => {
            (null == a ? void 0 : a.current) && Y(a.current.clientWidth)
        }
        ;
        e();
        const t = new ResizeObserver(e);
        return (null == a ? void 0 : a.current) && t.observe(a.current),
        () => t.disconnect()
    }
    ), [a]);
    const X = y.useMemo(( () => F && null !== H ? v.jsx("div", {
        ref: W,
        style: {
            position: "absolute",
            right: O > K ? O - K + 12 : 12,
            top: H + 3,
            zIndex: 10,
            pointerEvents: "auto",
            cursor: "pointer"
        },
        children: v.jsx(i1, {
            displayData: F
        })
    }) : null), [K, F, O, H]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(S, {
            sx: m2,
            className: "padre-no-scroll",
            position: "relative",
            ref: a,
            children: v.jsxs(S, {
                width: O,
                minWidth: "100%",
                height: t || !(null == R ? void 0 : R.length) ? "100%" : void 0,
                children: [L, v.jsxs(S, {
                    className: l1,
                    height: t || !(null == R ? void 0 : R.length) ? "100%" : void 0,
                    position: "relative",
                    onMouseLeave: $,
                    children: [t || null === R || !R.length ? v.jsx(S, {
                        alignItems: "center",
                        justifyContent: "center",
                        width: "100%",
                        flexGrow: 1,
                        minHeight: p ? void 0 : 100,
                        children: t ? v.jsx(Km, {}) : _ ? v.jsx(s1, {
                            resetFilters: U
                        }) : v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.label",
                            children: u("No data to show")
                        })
                    }) : R.map((e => {
                        const t = h2(e);
                        return v.jsx(u2, {
                            isWalletLookup: n,
                            gridTemplateColumns: P,
                            isColumnVisible: w,
                            showTokenCreatedAt: I,
                            showMakerEmoji: E,
                            tableAddressMode: M,
                            showQuickBuyButton: s,
                            useUsdPrices: r,
                            onMouseOverRef: q,
                            onTooltipOpen: i,
                            onTooltipClose: d,
                            ...e
                        }, t)
                    }
                    )), F && null !== H && X]
                })]
            })
        }), v.jsx(jZ, {
            customizableColumnsKeys: g1,
            hiddenColumnsKeys: h,
            isModalOpen: m,
            closeModal: x,
            setHiddenColumnsKeys: b,
            keysLabelsLookup: x1,
            label: u("Customize live trades"),
            customFlagsConfig: y1,
            customFlags: j,
            setCustomFlags: T,
            tableAddressMode: M,
            setTableAddressMode: N,
            pauseOnHover: o,
            setPauseOnHover: l
        })]
    })
}
))
  , h2 = e => `${e.txnHash}-${e.tradeIndex}-${e.makerAddress}`
  , m2 = {
    overflow: "scroll",
    height: "100%"
}
  , g2 = y.memo(( ({isDocked: e=!1, isInTracker: t=!1, isFloating: n=!1}) => {
    const {t: r} = we()
      , {walletGroups: a, customWalletNames: s, customWalletEmojis: o} = rf()
      , [l] = Mx(jT, null)
      , [i,c] = Mx("padreV2-lastSelectedWalletGRoupsIds", null)
      , d = y.useRef(null)
      , [u,p] = Mx("padreV2-liveTradesPuaseOnHover", !0)
      , [h,m] = y.useState(!0)
      , g = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        m(!0)
    }
    ), [m])
      , x = y.useCallback(( () => {
        m(!1)
    }
    ), [m])
      , b = y.useCallback(( () => {
        m(!0)
    }
    ), [m])
      , [f,C] = y.useState(!1)
      , A = y.useCallback(( () => {
        C(!0)
    }
    ), [])
      , w = y.useCallback(( () => {
        C(!1)
    }
    ), [])
      , j = y.useMemo(( () => !f && (!u || h)), [h, u, f]);
    pM({
        target: d,
        onInteractionStart: x,
        onInteractionStop: b,
        child: `.${l1}`
    }),
    y.useEffect(( () => {
        if (!(null == a ? void 0 : a.length))
            return;
        if (null === i)
            return void (l && a.some((e => e.groupId === l)) ? c([l]) : c(a.length ? [a[0].groupId] : []));
        const e = a.filter((e => i.includes(e.groupId)));
        e.length !== i.length && c(e.map((e => e.groupId)))
    }
    ), [l, i, c, a]);
    const {liveTrades: T} = uI()
      , I = y.useMemo(( () => (null == i ? void 0 : i.length) ? Zj(i, T) : null), [T, i])
      , E = y.useMemo(( () => Xj(a)), [a])
      , M = y.useCallback(( (e, t) => {
        if (!a)
            return;
        a.find((t => t.groupId === e)) && c(t ? [e] : t => null === t ? [e] : t.includes(e) ? t.filter((t => t !== e)) : [...t, e])
    }
    ), [c, a])
      , N = y.useMemo(( () => I ? Jj({
        feedState: I,
        customWalletNames: s,
        customWalletEmojis: o,
        walletGroupsLookup: E,
        search: null
    }) : []), [o, s, I, E])
      , P = y.useRef([]);
    y.useEffect(( () => {
        !j && P.current.length || (P.current = N || [])
    }
    ), [j, N]);
    const O = y.useMemo(( () => j || !P.current.length ? N : P.current), [j, N])
      , L = y.useMemo(( () => ({
        width: "100%",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "flex-start",
        overflowX: "scroll",
        overflowY: "hidden",
        minHeight: n ? 40 : 45,
        gap: .5,
        pt: t ? .5 : {
            xs: 0,
            sm: .75
        },
        pb: 0,
        px: t ? {
            xs: .5,
            sm: 2
        } : {
            xs: 1,
            sm: e ? .75 : 0
        }
    })), [e, t, n])
      , R = y.useMemo(( () => i ?? []), [i]);
    return v.jsx(cH, {
        contextId: "liveTrades",
        children: v.jsxs(S, {
            gap: 0,
            height: "100%",
            className: "no-drag",
            sx: x2,
            mt: e || n ? "1px" : 0,
            children: [v.jsxs(S, {
                direction: "row",
                position: "relative",
                width: "100%",
                children: [v.jsxs(S, {
                    sx: L,
                    direction: "row",
                    className: "padre-no-scroll",
                    children: [v.jsx(S, {
                        direction: "row",
                        flexGrow: 1,
                        children: a && a.length && l ? v.jsx(gJ, {
                            selectedGroupsIds: R,
                            items: a,
                            onGroupClick: M,
                            isDocked: e
                        }) : v.jsx(Ie, {
                            width: 86,
                            height: 28,
                            variant: "rounded"
                        })
                    }), v.jsx(r1, {
                        isFloating: n
                    })]
                }), v.jsx(MJ, {
                    isLive: j,
                    onResumeClick: g
                })]
            }), (null == i ? void 0 : i.length) ? v.jsx(p2, {
                rowData: O,
                isLoading: null === I || !a,
                containerRef: d,
                showQuickBuyButton: !!u,
                pauseOnHover: u,
                setPauseOnHover: p,
                onTooltipOpen: A,
                onTooltipClose: w
            }) : v.jsx(S, {
                height: "100%",
                width: "100%",
                justifyContent: "center",
                alignItems: "center",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: r("Select wallet groups to view live trades")
                })
            })]
        })
    })
}
))
  , x2 = {
    cursor: "auto"
}
  , b2 = Hj(null)
  , f2 = y.memo(( ({walletAddress: e, isVisible: t, search: n, currencyMode: r}) => {
    const {walletGroups: a, customWalletNames: s, customWalletEmojis: o} = rf()
      , l = (e => {
        const t = Ax()
          , n = y.useCallback((n => !t || ke(e) ? {
            unsubscribe: () => {}
        } : fm.subscribeWallet(e, null, n)), [t, e]);
        return kx(n, b2)
    }
    )(e)
      , i = y.useMemo(( () => Xj(a)), [a])
      , c = y.useMemo(( () => l ? Jj({
        feedState: l,
        customWalletNames: s,
        customWalletEmojis: o,
        walletGroupsLookup: i,
        search: n
    }) : []), [l, s, o, i, n])
      , d = NA(t)
      , [u,p] = JC(!1, 50);
    if (y.useEffect(( () => {
        d !== t && 0 === (null == c ? void 0 : c.length) && p(!0)
    }
    ), [t, d, p, c]),
    t)
        return v.jsx(p2, {
            rowData: c,
            isLoading: null === l || u,
            isWalletLookup: !0,
            useUsdPrices: r === uZ.USD
        })
}
))
  , v2 = ({overviewPositionsDisplayData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    children: v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1.25,
        children: [v.jsx(b_, {
            url: IE(e.chain, e.tokenAddress),
            name: e.tokenName ?? "",
            chain: e.chain,
            padreAvatarUrl: null,
            size: 20,
            markerIcon: v.jsx(Sz, {
                chain: e.chain,
                size: 10
            }),
            markerSize: 10,
            protocolInfo: null,
            hideHoverAvatar: !0,
            borderRadius: "4px"
        }), v.jsx(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: null !== e.tokenSymbol ? v.jsx(GC, {
                title: e.tokenName,
                children: v.jsx(k, {
                    variant: "paragraph2",
                    children: iu(e.tokenSymbol, 20)
                })
            }) : v.jsx(Ie, {
                variant: "rounded",
                width: 70,
                height: 15
            })
        })]
    })
}) : v.jsx(CQ, {})
  , S2 = y.memo(( ({currencyMode: e, overviewPositionsDisplayData: t, ...n}) => {
    if (!t)
        return v.jsx(CQ, {});
    const r = e === uZ.USD ? t.pnl : t.pnlNative;
    return v.jsx(kQ, {
        ...n,
        children: v.jsxs(k, {
            variant: "monospace1",
            color: r ? r > 0 ? "success.main" : "error.main" : "text.value",
            display: "flex",
            alignItems: "center",
            gap: .25,
            children: [null !== r && e === uZ.NATIVE && v.jsx(Sz, {
                chain: t.chain,
                size: 15
            }), null == r ? Ud : `${r > 0 ? "+" : r < 0 ? "-" : ""}${LI(Math.abs(r), {
                collapseExponent: !0,
                symbol: e === uZ.USD ? "$" : "",
                symbolPosition: yI.START,
                padSymbol: !1,
                desiredDigits: 3
            })}`]
        })
    })
}
))
  , y2 = y.memo(( ({overviewPositionsDisplayData: e, tradeSide: t, currencyMode: n, ...r}) => {
    if (!e)
        return v.jsx(CQ, {});
    const a = t === xc.BUY ? n === uZ.USD ? e.totalBoughtUsd : e.totalBoughtNative : n === uZ.USD ? e.totalSoldUsd : e.totalSoldNative
      , s = t === xc.BUY ? e.buyTxns : e.sellTxns;
    return v.jsx(kQ, {
        ...r,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...r.sxProps
        },
        children: v.jsxs(S, {
            children: [v.jsxs(k, {
                textAlign: "end",
                variant: "monospace1",
                color: t === xc.BUY ? "success.main" : "error.main",
                display: "flex",
                alignItems: "center",
                alignSelf: "flex-end",
                gap: .25,
                children: [null !== a && n === uZ.NATIVE && v.jsx(Sz, {
                    chain: e.chain,
                    size: 13
                }), null === a ? Ud : LI(a, {
                    collapseExponent: !0,
                    padSymbol: !1,
                    symbol: n === uZ.USD ? "$" : "",
                    symbolPosition: yI.START,
                    desiredDigits: 3
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                textAlign: "end",
                children: null === s ? Ud : LI(s, {
                    collapseExponent: !0,
                    padSymbol: !0,
                    maxPrecision: 0,
                    minPrecision: 0,
                    symbol: s > 1 ? "txns" : "txn",
                    symbolPosition: yI.END
                })
            })]
        })
    })
}
))
  , k2 = {
    justifyContent: "flex-end",
    alignItems: "center"
}
  , C2 = e => ({
    ...sZ(e),
    headerClass: lY,
    minWidth: cY.minWidth,
    sortable: !0
})
  , A2 = ({key: e, currencyMode: t=uZ.USD}) => {
    switch (e) {
    case "tokenAddress":
        return {
            ...C2(e),
            headerName: n.t("Token"),
            headerClass: void 0,
            sortable: !1,
            cellRenderer: e => v.jsx(v2, {
                overviewPositionsDisplayData: e.data,
                ...e,
                sxProps: {
                    ...k2,
                    justifyContent: "flex-start"
                },
                href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
            }),
            minWidth: 135,
            flex: 1.5,
            valueGetter: ({data: e}) => e ? `${e.tokenAddress}-${e.tokenName}-${e.chain}-${e.tokenSymbol}-${e.insider}` : void 0
        };
    case "remaining":
        return {
            ...C2(e),
            headerName: n.t("Remaining"),
            minWidth: 100,
            cellRenderer: e => {
                var n, r, a;
                return c.isNil(null == (n = e.data) ? void 0 : n.remaining) ? v.jsx(CQ, {}) : v.jsx(HQ, {
                    ...e,
                    remaining: t === uZ.USD ? (null == (r = e.data) ? void 0 : r.remainingUsd) ?? null : e.data.remainingNative ?? null,
                    remainingAmount: null,
                    remainingPercentage: (null == (a = e.data) ? void 0 : a.remainingPct) ?? null,
                    isLoading: !e.data,
                    isUsd: t === uZ.USD,
                    sxProps: k2,
                    chainIcon: t === uZ.USD ? void 0 : e.data.chain,
                    href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.remaining}-${e.remainingPct}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.remainingUsd ?? null))
        };
    case "pnl":
        return {
            ...C2(e),
            headerName: n.t("PNL"),
            minWidth: 90,
            cellRenderer: e => v.jsx(S2, {
                overviewPositionsDisplayData: e.data,
                ...e,
                sxProps: k2,
                currencyMode: t,
                href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
            }),
            valueGetter: ({data: e}) => e ? `${e.pnl}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.pnl ?? null))
        };
    case "buyTxns":
        return {
            ...C2(e),
            headerName: n.t("Buys"),
            minWidth: 75,
            cellRenderer: e => v.jsx(y2, {
                tradeSide: xc.BUY,
                overviewPositionsDisplayData: e.data,
                currencyMode: t,
                ...e,
                sxProps: k2,
                href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
            }),
            valueGetter: ({data: e}) => e ? `${e.buyTxns}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.totalBoughtUsd ?? null))
        };
    case "sellTxns":
        return {
            ...C2(e),
            headerName: n.t("Sells"),
            minWidth: 90,
            cellRenderer: e => v.jsx(y2, {
                tradeSide: xc.SELL,
                overviewPositionsDisplayData: e.data,
                currencyMode: t,
                ...e,
                sxProps: k2,
                href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
            }),
            valueGetter: ({data: e}) => e ? `${e.sellTxns}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.totalSoldUsd ?? null))
        };
    case "lastActivityTs":
        return {
            ...C2(e),
            headerName: n.t("Activity"),
            cellRenderer: e => {
                var t;
                return v.jsx(zQ, {
                    date: (null == (t = e.data) ? void 0 : t.lastActivityTs) ?? null,
                    ...e,
                    sxProps: k2,
                    href: e.data ? XE(e.data.chain, e.data.tokenAddress, nT.WALLET_OVERVIEW_POSITIONS) : void 0
                })
            }
            ,
            minWidth: 95,
            maxWidth: 95,
            valueGetter: ({data: e}) => e ? `${e.comparator}-${e.lastActivityTs}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.lastActivityTs ?? null))
        };
    default:
        return {}
    }
}
;
var w2 = (e => (e.ACTIVE_POSITIONS = "ACTIVE_POSITIONS",
e.MOST_PROFITABLE = "MOST_PROFITABLE",
e.RECENT_TRADES = "RECENT_TRADES",
e.DEV_TOKENS = "DEV_TOKENS",
e))(w2 || {});
const j2 = {
    [w2.MOST_PROFITABLE]: n.t("Most Profitable"),
    [w2.RECENT_TRADES]: n.t("Trades History"),
    [w2.ACTIVE_POSITIONS]: n.t("Active Positions"),
    [w2.DEV_TOKENS]: n.t("Dev Tokens")
}
  , T2 = {
    [w2.MOST_PROFITABLE]: n.t("Profitable"),
    [w2.RECENT_TRADES]: n.t("Trades"),
    [w2.ACTIVE_POSITIONS]: n.t("Positions"),
    [w2.DEV_TOKENS]: n.t("Dev")
}
  , I2 = (e, t) => [{
    label: t ? T2[w2.RECENT_TRADES] : j2[w2.RECENT_TRADES],
    value: w2.RECENT_TRADES
}, {
    label: t ? T2[w2.MOST_PROFITABLE] : j2[w2.MOST_PROFITABLE],
    value: w2.MOST_PROFITABLE
}, {
    label: t ? T2[w2.ACTIVE_POSITIONS] : j2[w2.ACTIVE_POSITIONS],
    value: w2.ACTIVE_POSITIONS
}, ...e ? [{
    label: j2[w2.DEV_TOKENS],
    value: w2.DEV_TOKENS
}] : []]
  , E2 = e => ({
    lastActivityTs: e[0],
    walletAddress: e[1],
    amountString: e[2],
    incomplete: e[3],
    insider: e[4],
    totalBoughtUsd: e[5],
    totalSoldUsd: e[6],
    buyTxns: e[7],
    sellTxns: e[8],
    chain: e[9],
    tokenAddress: e[10],
    activationTimestamp: e[11]
})
  , M2 = e => bg(e[9], e[10])
  , N2 = (e, t) => null !== e && t ? e / t : null
  , P2 = e => `${e.tokenAddress}-${e.chain}`
  , O2 = y.memo(( ({infos: e, tokenInfos: t, usdPrices: n, totalSupplies: r, isVisible: a, skipNoPrice: s, currencyMode: o, chain: l, pnlOrder: i=!1}) => {
    const d = VV(l)
      , u = y.useMemo(( () => a ? ( (e, t, n, r, a, s, o) => e ? c.reduce(e, ( (e, l) => {
        const {lastActivityTs: i, chain: d, tokenAddress: u, amountString: p, incomplete: h, insider: m, totalBoughtUsd: g, totalSoldUsd: x, buyTxns: b, sellTxns: f, activationTimestamp: v} = l
          , S = bg(d, u)
          , y = t ? t[S] ?? null : null
          , k = r ? r[S] : null
          , C = n ? n[S] : null
          , A = y ? isNaN(Number(p)) ? null : Number(p) / 10 ** y.decimals : null
          , w = c.isNil(C) || c.isNil(A) || isNaN(Number(C)) ? null : C * A
          , j = c.isNil(x) || c.isNil(g) ? null : x + (w ?? 0) - g
          , T = a ? j : i
          , I = k ? isNaN(Number(p)) || isNaN(Number(k.totalSupply)) || !Number(k.totalSupply) ? null : Number(p) / Number(k.totalSupply) * 100 : null
          , E = (null == y ? void 0 : y.symbol) ?? null
          , M = (null == y ? void 0 : y.name) ?? null;
        return !C && s || e.push({
            lastActivityTs: i,
            chain: d,
            tokenAddress: u,
            remaining: A,
            remainingPct: I,
            incomplete: h,
            insider: m,
            buyTxns: b,
            sellTxns: f,
            remainingUsd: w,
            pnl: j,
            totalBoughtUsd: g,
            totalSoldUsd: x,
            remainingNative: N2(w, o),
            pnlNative: N2(j, o),
            totalBoughtNative: N2(g, o),
            totalSoldNative: N2(x, o),
            activationTimestamp: v,
            comparator: T,
            tokenSymbol: E,
            tokenName: M
        }),
        e
    }
    ), []) : null)(e, t, n, r, i, s, d) : null), [e, t, r, n, i, a, s, d])
      , p = y.useMemo(( () => (e => [A2({
        key: "tokenAddress"
    }), A2({
        key: "remaining",
        currencyMode: e
    }), A2({
        key: "pnl",
        currencyMode: e
    }), A2({
        key: "buyTxns",
        currencyMode: e
    }), A2({
        key: "sellTxns",
        currencyMode: e
    }), A2({
        key: "lastActivityTs"
    })])(o)), [o])
      , h = NA(a)
      , [m,g] = JC(!1, 50);
    if (y.useEffect(( () => {
        h !== a && 0 === (null == u ? void 0 : u.length) && g(!0)
    }
    ), [a, h, g, u]),
    a)
        return v.jsx(yQ, {
            rowData: u,
            isLoading: !u || m,
            columnDefs: p,
            getRowUniqueId: P2,
            rowHeight: L2
        })
}
))
  , L2 = 44
  , R2 = y.createContext({
    recentActivePositions: null,
    totalValueUsd: null,
    unrealizedPnlUsd: null
})
  , D2 = () => y.useContext(R2)
  , B2 = (e, t) => {
    if ("init" === t.type) {
        const e = t.snapshot.allEntries.map(E2);
        return {
            totalSupplies: t.snapshot.totalSupplies,
            usdPrices: t.snapshot.usdPrices,
            tokenInfos: t.snapshot.tokenInfos,
            lookup: Vt(e, (e => bg(e.chain, e.tokenAddress))),
            ordering: T(e, (e => e.lastActivityTs), "desc")
        }
    }
    const n = new Set(t.update.deleted.map(M2))
      , r = t.update.updated.map(E2)
      , a = T(dt([...r, ...(null == e ? void 0 : e.ordering) ?? []], (e => bg(e.chain, e.tokenAddress))).filter((e => !n.has(bg(e.chain, e.tokenAddress)) && "0" !== e.amountString)), (e => e.lastActivityTs), "desc").slice(0, 50)
      , s = kt({
        ...null == e ? void 0 : e.lookup,
        ...Vt(r, (e => bg(e.chain, e.tokenAddress)))
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , o = kt({
        ...null == e ? void 0 : e.usdPrices,
        ...t.update.usdPrices
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , l = kt({
        ...null == e ? void 0 : e.tokenInfos,
        ...t.update.tokenInfos
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , i = kt({
        ...null == e ? void 0 : e.totalSupplies,
        ...t.update.totalSupplies
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))));
    return {
        lookup: s,
        ordering: a,
        tokenInfos: l,
        usdPrices: o,
        totalSupplies: i
    }
}
  , _2 = ({walletAddress: e, children: t}) => {
    const n = (e => {
        const t = y.useCallback((t => ke(e) ? {
            unsubscribe: () => {}
        } : Rm.subscribeActivePositions(e, t)), [e]);
        return kx(t, B2, {
            debounceDuration: 100
        })
    }
    )(e)
      , [r,a] = y.useMemo(( () => {
        if (!n)
            return [null, null];
        const e = c.reduce(n.ordering, ( (e, t) => {
            const {tokenAddress: r, chain: a, amountString: s, totalSoldUsd: o, totalBoughtUsd: l} = t
              , i = bg(a, r)
              , d = n.tokenInfos[i] ?? null
              , u = n.usdPrices[i] ?? null
              , p = d ? isNaN(Number(s)) ? null : Number(s) / 10 ** d.decimals : null
              , h = c.isNil(u) || c.isNil(p) || isNaN(Number(u)) ? null : u * p;
            e.totalValueUsd = e.totalValueUsd + (h ?? 0);
            const m = ng(r);
            if (!tu(m, a) && !ru(m)) {
                const t = c.isNil(o) || c.isNil(l) ? null : o + (h ?? 0) - l;
                e.unrealizedPnlUsd = e.unrealizedPnlUsd + (t ?? 0)
            }
            return e
        }
        ), {
            totalValueUsd: 0,
            unrealizedPnlUsd: 0
        });
        return [e.totalValueUsd, e.unrealizedPnlUsd]
    }
    ), [n])
      , s = y.useMemo(( () => ({
        recentActivePositions: n,
        totalValueUsd: r,
        unrealizedPnlUsd: a
    })), [n, r, a]);
    return v.jsx(R2.Provider, {
        value: s,
        children: t
    })
}
  , U2 = ({state: e, search: t, chain: n}) => {
    const r = y.useMemo(( () => {
        const r = (null == e ? void 0 : e.ordering) ?? null
          , a = (null == e ? void 0 : e.tokenInfos) ?? null;
        if (!r)
            return null;
        const s = t.trim().toLowerCase();
        return r.filter((e => {
            var t, r;
            if (n && e.chain !== n)
                return !1;
            if (!s)
                return !0;
            const o = a ? a[bg(e.chain, e.tokenAddress)] ?? null : null
              , l = (null == (t = null == o ? void 0 : o.symbol) ? void 0 : t.toLowerCase()) ?? ""
              , i = (null == (r = null == o ? void 0 : o.name) ? void 0 : r.toLowerCase()) ?? ""
              , c = e.tokenAddress.toLowerCase();
            return lj(l, s) || lj(i, s) || lj(c, s)
        }
        )).filter((e => {
            const t = ng(e.tokenAddress);
            return !tu(t, e.chain) && !ru(t)
        }
        ))
    }
    ), [n, t, null == e ? void 0 : e.ordering, null == e ? void 0 : e.tokenInfos])
      , a = y.useMemo(( () => r ? r.map((e => bg(e.chain, e.tokenAddress))) : null), [r])
      , s = y.useMemo(( () => a ? kt((null == e ? void 0 : e.tokenInfos) ?? {}, a) : null), [a, null == e ? void 0 : e.tokenInfos])
      , o = y.useMemo(( () => a ? kt((null == e ? void 0 : e.totalSupplies) ?? {}, a) : null), [a, null == e ? void 0 : e.totalSupplies])
      , l = y.useMemo(( () => a ? kt((null == e ? void 0 : e.usdPrices) ?? {}, a) : null), [a, null == e ? void 0 : e.usdPrices]);
    return y.useMemo(( () => ({
        infos: r,
        tokenInfos: s,
        totalSupplies: o,
        usdPrices: l
    })), [r, s, o, l])
}
  , W2 = y.memo(( ({isVisible: e, search: t, currencyMode: n, chain: r}) => {
    const {recentActivePositions: a} = D2()
      , {infos: s, tokenInfos: o, totalSupplies: l, usdPrices: i} = U2({
        state: a,
        search: t,
        chain: r
    });
    return v.jsx(O2, {
        infos: s,
        tokenInfos: o,
        totalSupplies: l,
        usdPrices: i,
        isVisible: e,
        skipNoPrice: !0,
        currencyMode: n,
        chain: r
    })
}
))
  , F2 = (e, t) => {
    if ("init" === t.type) {
        const e = t.snapshot.allEntries.map(E2);
        return {
            totalSupplies: t.snapshot.totalSupplies,
            usdPrices: t.snapshot.usdPrices,
            tokenInfos: t.snapshot.tokenInfos,
            lookup: Vt(e, (e => bg(e.chain, e.tokenAddress))),
            ordering: T(e, (e => (e.totalSoldUsd ?? 0) - (e.totalBoughtUsd ?? 0)), "desc")
        }
    }
    const n = new Set(t.update.deleted.map(M2))
      , r = t.update.updated.map(E2)
      , a = T(dt([...r, ...(null == e ? void 0 : e.ordering) ?? []], (e => bg(e.chain, e.tokenAddress))).filter((e => !n.has(bg(e.chain, e.tokenAddress)))), (e => (e.totalSoldUsd ?? 0) - (e.totalBoughtUsd ?? 0)), "desc").slice(0, 50)
      , s = kt({
        ...null == e ? void 0 : e.lookup,
        ...Vt(r, (e => bg(e.chain, e.tokenAddress)))
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , o = kt({
        ...null == e ? void 0 : e.usdPrices,
        ...t.update.usdPrices
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , l = kt({
        ...null == e ? void 0 : e.tokenInfos,
        ...t.update.tokenInfos
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))))
      , i = kt({
        ...null == e ? void 0 : e.totalSupplies,
        ...t.update.totalSupplies
    }, qt(a.map((e => bg(e.chain, e.tokenAddress)))));
    return {
        lookup: s,
        ordering: a,
        tokenInfos: l,
        usdPrices: o,
        totalSupplies: i
    }
}
  , V2 = y.memo(( ({walletAddress: e, isVisible: t, search: n, currencyMode: r, chain: a}) => {
    const s = (e => {
        const t = y.useCallback((t => ke(e) ? {
            unsubscribe: () => {}
        } : Rm.subscribeMostProfitable(e, t)), [e]);
        return kx(t, F2, {
            debounceDuration: 100
        })
    }
    )(e)
      , {infos: o, tokenInfos: l, totalSupplies: i, usdPrices: c} = U2({
        state: s,
        search: n,
        chain: a
    });
    return v.jsx(O2, {
        infos: o,
        tokenInfos: l,
        totalSupplies: i,
        usdPrices: c,
        isVisible: t,
        skipNoPrice: !1,
        pnlOrder: !0,
        currencyMode: r,
        chain: a
    })
}
))
  , H2 = w2.RECENT_TRADES
  , z2 = y.memo(( ({walletAddress: e, chain: t}) => {
    const n = xw()
      , r = bw()
      , [a,s] = dx("padreV2-walletOverviewTabTimespan", H2)
      , o = y.useMemo(( () => su.test(e)), [e])
      , l = y.useCallback(( (e, t) => {
        s(t)
    }
    ), [s])
      , [i,c] = Mx("padreV2-walletOverviewCurrencyMode", uZ.USD)
      , d = y.useCallback(( () => {
        c((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [c])
      , [u,p] = y.useState("");
    return v.jsxs(S, {
        sx: Y2,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsx(ot, {
                className: "padre-no-scroll",
                variant: r ? "fullWidth" : "scrollable",
                value: a !== w2.DEV_TOKENS || o ? a : H2,
                onChange: l,
                sx: $2,
                children: I2(o, !n).map(( ({label: e, value: t}) => v.jsx(lt, {
                    value: t,
                    sx: K2,
                    label: v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: e
                    })
                }, t)))
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [n && t && a !== w2.DEV_TOKENS && v.jsx(S, {
                    maxWidth: q2,
                    minWidth: q2,
                    children: v.jsx(oQ, {
                        search: u,
                        setSearch: p
                    })
                }), t && v.jsxs(V, {
                    variant: "tertiary",
                    size: "small",
                    onClick: d,
                    sx: G2,
                    children: [v.jsx(gS, {}), v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        pt: .25,
                        children: i === uZ.NATIVE ? t === Pd.SOLANA ? "SOL" : "ETH" : "USD"
                    })]
                })]
            })]
        }), v.jsx(Ee, {
            flexItem: !0
        }), v.jsxs(S, {
            width: "100%",
            height: "100%",
            minHeight: n ? void 0 : "calc(100vh - 238px)",
            mb: -1,
            children: [v.jsx(f2, {
                walletAddress: e,
                isVisible: a === w2.RECENT_TRADES,
                search: u,
                currencyMode: i
            }), v.jsx(V2, {
                walletAddress: e,
                isVisible: a === w2.MOST_PROFITABLE,
                search: u,
                currencyMode: i,
                chain: t
            }), v.jsx(W2, {
                isVisible: a === w2.ACTIVE_POSITIONS,
                search: u,
                currencyMode: i,
                chain: t
            }), o && v.jsx(YZ, {
                chain: Pd.SOLANA,
                devAddress: e,
                isVisible: a === w2.DEV_TOKENS,
                sortStorageName: "WalletOverview"
            })]
        })]
    })
}
))
  , $2 = {
    borderBottom: 0,
    "& .MuiTabs-scrollButtons": {
        width: 24
    }
}
  , G2 = {
    display: "flex",
    alignItems: "center",
    gap: .5,
    px: 0,
    py: 0,
    width: 56,
    height: 26,
    mr: .5,
    border: "none",
    background: "transparent"
}
  , q2 = 200
  , K2 = {
    maxWidth: 150,
    minHeight: 0,
    height: 34
}
  , Y2 = {
    mx: -1,
    minHeight: 160,
    height: {
        xs: "100%",
        sm: `calc(${aQ} - 336px)`
    }
}
  , X2 = y.memo(( ({onClick: e, isSelected: t, disabled: n, emoji: r, name: a}) => v.jsx(te, {
    disableRipple: !0,
    disableGutters: !0,
    onClick: e,
    sx: Z2,
    children: v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        gap: 1,
        width: "100%",
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(ZT, {
                emoji: r
            }), v.jsx(k, {
                variant: "paragraph3",
                color: n ? "text.disabled" : t ? "text.value" : "text.label",
                children: iu(a, 24)
            })]
        }), v.jsx(C, {
            width: Q2,
            height: Q2,
            children: t && v.jsx(xy, {
                size: Q2
            })
        })]
    })
})))
  , Q2 = 16
  , Z2 = e => ({
    width: "100%",
    px: 1,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderSubtle}`,
    "&:focus": {
        bgcolor: e.palette.background.secondary
    },
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , J2 = y.memo(( ({walletAddress: e, compact: t, currentWalletGroupId: n}) => {
    const r = Ax()
      , a = xw()
      , {walletGroups: s} = rf()
      , {buttonProps: o, popoverProps: l} = Fw({
        id: `wallet-track-select-${e}`,
        stopPropagation: t
    })
      , [i,c] = y.useState(null);
    y.useEffect(( () => {
        s && (i && i.length === (null == s ? void 0 : s.length) || c(s.map((t => ({
            name: t.name,
            emoji: $j(t.icon, t.emoji),
            isSelected: t.addresses.includes(e),
            addressesCount: t.addresses.length,
            groupId: t.groupId
        })))))
    }
    ), [s, i, e, n]);
    const [d,u] = y.useMemo(( () => {
        if (!i)
            return [null, null];
        const e = i.filter((e => e.isSelected));
        return 1 !== e.length ? [e.length, null] : [e.length, e[0]]
    }
    ), [i])
      , p = y.useCallback((async t => {
        if (!r || !i)
            return;
        const n = [...i]
          , a = n.findIndex((e => e.groupId === t));
        -1 !== a && (n[a] = {
            ...n[a],
            isSelected: !n[a].isSelected,
            addressesCount: n[a].isSelected ? n[a].addressesCount - 1 : n[a].addressesCount + 1
        },
        c(n),
        await ym.updateWalletGroup(r, t, n[a].isSelected ? {
            add: [e]
        } : {
            remove: [e]
        }))
    }
    ), [r, e, i])
      , h = y.useMemo(( () => ({
        display: "flex",
        alignItems: "center",
        px: .75,
        height: t ? e5 : t5,
        gap: .5,
        color: d ? "text.value" : "text.primary",
        border: "none",
        background: "transparent",
        ...t ? {
            width: e5,
            minWidth: e5,
            px: 0
        } : {}
    })), [d, t])
      , m = y.useMemo(( () => i ? i.filter((e => e.groupId !== n)) : null), [n, i]);
    if (null == m ? void 0 : m.length)
        return v.jsxs(S, {
            children: [v.jsx(GC, {
                title: n ? "Add this wallet to another group" : "",
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsxs(V, {
                        ...o,
                        variant: "tertiary",
                        size: "xxsmall",
                        sx: h,
                        children: [t ? null : d ? d > 1 ? "Tracked " + (a ? `in ${d} groups` : `${d}`) : "Tracked" + (a ? " in" : "") : "Track wallet", u && !t && v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            children: [v.jsx(ZT, {
                                emoji: u.emoji
                            }), a && v.jsx(k, {
                                variant: "inherit",
                                color: "inherit",
                                children: iu(u.name, 24)
                            })]
                        }), t && v.jsx(XS, {})]
                    })
                })
            }), v.jsx(ae, {
                ...l,
                onClick: Ww,
                anchorOrigin: n5,
                transformOrigin: r5,
                children: v.jsx(ee, {
                    elevation: 1,
                    sx: a5,
                    className: "padre-no-scroll",
                    children: m.map((e => v.jsx(X2, {
                        onClick: () => {
                            p(e.groupId)
                        }
                        ,
                        isSelected: e.isSelected,
                        disabled: e.addressesCount >= wT,
                        emoji: e.emoji,
                        name: e.name
                    }, e.groupId)))
                })
            })]
        })
}
))
  , e5 = 22
  , t5 = 24
  , n5 = {
    vertical: "bottom",
    horizontal: "center"
}
  , r5 = {
    vertical: "top",
    horizontal: "center"
}
  , a5 = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderSubtle}`,
    boxShadow: "none"
})
  , s5 = y.memo(( ({address: e}) => {
    const t = D()
      , n = Ax()
      , {t: r} = we()
      , {customWalletSilenced: a, customWalletOnChart: s, customWalletOnLiveTrades: o} = rf()
      , l = y.useMemo(( () => {
        const t = ng(e);
        return !a[t]
    }
    ), [e, a])
      , i = y.useCallback((async () => {
        const t = ng(e);
        if (n)
            try {
                ym.updateCustomWalletSilenced(n, {
                    [t]: l
                })
            } catch (fNe) {}
    }
    ), [e, l, n])
      , c = y.useMemo(( () => {
        const t = ng(e);
        return s[t] ?? !0
    }
    ), [e, s])
      , d = y.useCallback((async () => {
        const t = ng(e);
        if (n)
            try {
                ym.updateCustomWalletOnChart(n, {
                    [t]: !c
                })
            } catch (fNe) {}
    }
    ), [e, c, n])
      , u = y.useMemo(( () => {
        const t = ng(e);
        return o[t] ?? !0
    }
    ), [e, o])
      , p = y.useCallback((async () => {
        const t = ng(e);
        if (n)
            try {
                ym.updateCustomWalletOnLiveTrades(n, {
                    [t]: !u
                })
            } catch (fNe) {}
    }
    ), [e, u, n]);
    return v.jsxs(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        children: [v.jsx(GC, {
            title: r(u ? l ? "Disable notifications" : "Enable notifications" : "Enable on live trades to show notifications"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    onClick: i,
                    size: "xxsmall",
                    variant: "tertiary",
                    sx: o5,
                    disabled: !u,
                    children: l && u ? v.jsx(jy, {
                        size: l5,
                        color: t.palette.primary.main
                    }) : v.jsx(Ey, {
                        size: l5
                    })
                })
            })
        }), v.jsx(GC, {
            title: r(c ? "Hide on Chart" : "Show on Chart"),
            children: v.jsx(C, {
                display: "flex",
                component: "span",
                children: v.jsx(V, {
                    onClick: d,
                    size: "xxsmall",
                    variant: "tertiary",
                    sx: o5,
                    children: v.jsx(my, {
                        size: l5,
                        color: c ? t.palette.primary.main : t.palette.text.label
                    })
                })
            })
        }), v.jsx(GC, {
            title: r(u ? "Hide on Live Trades" : "Show on Live Trades"),
            children: v.jsx(C, {
                display: "flex",
                component: "span",
                children: v.jsx(V, {
                    onClick: p,
                    size: "xxsmall",
                    variant: "tertiary",
                    sx: o5,
                    children: v.jsx(Vk, {
                        size: l5,
                        color: u ? t.palette.primary.main : t.palette.text.label
                    })
                })
            })
        })]
    })
}
))
  , o5 = e => ({
    px: 0,
    width: 24,
    minWidth: 24,
    height: 24,
    color: e.palette.text.label,
    border: "none",
    background: "transparent"
})
  , l5 = 16
  , i5 = y.memo(( ({perfTimespan: e, setPerfTimespan: t}) => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    gap: 1,
    mt: .25,
    children: c5.map((n => {
        const r = n === e;
        return v.jsx(u5, {
            isSelected: r,
            onClick: () => {
                r || t(n)
            }
            ,
            label: d5[n]
        }, n)
    }
    ))
})))
  , c5 = ["day", "week", "month"]
  , d5 = {
    day: "1d",
    week: "7d",
    month: "30d"
}
  , u5 = y.memo(( ({isSelected: e, onClick: t, label: n}) => {
    const r = y.useMemo(( () => t => ({
        py: 0,
        px: .75,
        height: 24,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        border: "none",
        color: e ? t.palette.primary.main : t.palette.text.value,
        background: "transparent",
        "&:hover, &:focus": {
            border: "none",
            background: t.palette.primary.background,
            color: e ? t.palette.primary.main : t.palette.text.value
        }
    })), [e]);
    return v.jsx(V, {
        onClick: t,
        variant: "tertiary",
        size: "xxsmall",
        sx: r,
        children: n
    })
}
))
  , p5 = y.memo(( ({walletAddress: e, chain: t, perfTimespan: n, setPerfTimespan: r, onClose: a}) => {
    const s = D()
      , o = xw()
      , l = bw()
      , {walletGroups: i} = rf()
      , c = y.useMemo(( () => !!i && i.some((t => t.addresses.includes(e)))), [e, i])
      , {customWalletNames: d, customWalletEmojis: u} = rf();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "flex-start",
        justifyContent: "space-between",
        gap: 2,
        px: o ? 1 : 0,
        height: o ? 36 : 50,
        pt: .25,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [c && v.jsx(aI, {
                address: e,
                customName: d[e] ?? null,
                customEmoji: u[e] ?? null,
                omitSaveIndicator: !0
            }), v.jsx(J2, {
                walletAddress: e
            }), o && c && v.jsx(s5, {
                address: e
            }), o && v.jsx(cA, {
                address: e,
                customName: l ? e : void 0,
                maxWidth: l ? 500 : 150
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignSelf: "flex-start",
            gap: .5,
            divider: m5,
            mt: -.25,
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1.5,
                alignItems: "center",
                children: [v.jsx(aE, {
                    Icon: ff,
                    link: (p = e,
                    `https://app.cielo.finance/profile/${p}`),
                    showTooltip: !1,
                    iconSize: h5,
                    disableHover: !0
                }), t && v.jsx(aE, {
                    chain: t,
                    link: jA(e, t),
                    showTooltip: !1,
                    iconSize: h5
                }), v.jsx(aE, {
                    Icon: cy,
                    link: lR(e, null),
                    showTooltip: !1,
                    iconSize: h5
                })]
            }), o && v.jsx(i5, {
                perfTimespan: n,
                setPerfTimespan: r
            }), v.jsx(F, {
                onClick: a,
                sx: g5,
                children: v.jsx(gy, {
                    size: 20,
                    color: s.palette.text.label
                })
            })]
        })]
    });
    var p
}
))
  , h5 = 16
  , m5 = v.jsx(Ee, {
    flexItem: !0,
    orientation: "vertical",
    sx: {
        my: .75,
        ml: .75
    }
})
  , g5 = {
    p: .5
};
var x5 = (e => (e.BINANCE = "BINANCE",
e.BYBIT = "BYBIT",
e.KRAKEN = "KRAKEN",
e.MEXC = "MEXC",
e.KUCOIN = "KUCOIN",
e.COINBASE = "COINBASE",
e.GATE_IO = "GATE_IO",
e.BITFINEX = "BITFINEX",
e.CRYPTO_COM = "CRYPTO_COM",
e.BITSTAMP = "BITSTAMP",
e.BITGET = "BITGET",
e.UPBIT = "UPBIT",
e.HTX = "HTX",
e.FTX = "FTX",
e.OKX = "OKX",
e.WINTERMUTE = "WINTERMUTE",
e.WORMHOLE = "WORMHOLE",
e.ALLBRIDGE = "ALLBRIDGE",
e.LAYER_ZERO = "LAYER_ZERO",
e.CIRCLE = "CIRCLE",
e.ALAMEDA_RESEARCH = "ALAMEDA_RESEARCH",
e.ASCENDEX = "ASCENDEX",
e.BACKPACK_EXCHANGE = "BACKPACK_EXCHANGE",
e.BINANCE_US = "BINANCE_US",
e.BITKUB = "BITKUB",
e.BITMART = "BITMART",
e.BITRUE = "BITRUE",
e.CEFFU = "CEFFU",
e.CHAINUP_CUSTODY = "CHAINUP_CUSTODY",
e.CHANGENOW = "CHANGENOW",
e.COINEX = "COINEX",
e.COINLIST = "COINLIST",
e.CUMBERLAND_DRW = "CUMBERLAND_DRW",
e.DEBRIDGE = "DEBRIDGE",
e.DEX_TRADE = "DEX_TRADE",
e.DIGIFINEX = "DIGIFINEX",
e.FASEX = "FASEX",
e.FIXEDFLOAT = "FIXEDFLOAT",
e.JUMP_CRYPTO = "JUMP_CRYPTO",
e.LBANK = "LBANK",
e.MAYAN_BRIDGE = "MAYAN_BRIDGE",
e.PHANTOM = "PHANTOM",
e.PRIVACY_CASH = "PRIVACY_CASH",
e.POLONIEX = "POLONIEX",
e.REVOLUT = "REVOLUT",
e.ROBINHOOD = "ROBINHOOD",
e.SOLANA_NAME_SERVICE = "SOLANA_NAME_SERVICE",
e.SOLLET = "SOLLET",
e.SWISS_BORG = "SWISS_BORG",
e.SQUADS_PROTOCOL = "SQUADS_PROTOCOL",
e.TRANSAK = "TRANSAK",
e.UPHOLD = "UPHOLD",
e.WOO_NETWORK = "WOO_NETWORK",
e))(x5 || {});
const b5 = e => {
    switch (e) {
    case x5.BINANCE:
        return "Binance";
    case x5.BYBIT:
        return "Bybit";
    case x5.GATE_IO:
        return "Gate.io";
    case x5.BITFINEX:
        return "Bitfinex";
    case x5.CRYPTO_COM:
        return "Crypto.com";
    case x5.BITSTAMP:
        return "Bitstamp";
    case x5.BITGET:
        return "Bitget";
    case x5.KRAKEN:
        return "Kraken";
    case x5.MEXC:
        return "MEXC";
    case x5.KUCOIN:
        return "KuCoin";
    case x5.COINBASE:
        return "Coinbase";
    case x5.UPBIT:
        return "Upbit";
    case x5.HTX:
        return "HTX";
    case x5.FTX:
        return "FTX";
    case x5.OKX:
        return "OKX";
    case x5.WINTERMUTE:
        return "Wintermute";
    case x5.WORMHOLE:
        return "Wormhole";
    case x5.ALLBRIDGE:
        return "Allbridge";
    case x5.LAYER_ZERO:
        return "LayerZero";
    case x5.CIRCLE:
        return "Circle";
    case x5.ALAMEDA_RESEARCH:
        return "Alameda Research";
    case x5.ASCENDEX:
        return "AscendEX";
    case x5.BACKPACK_EXCHANGE:
        return "Backpack Exchange";
    case x5.BINANCE_US:
        return "Binance US";
    case x5.BITKUB:
        return "Bitkub";
    case x5.BITMART:
        return "BitMart";
    case x5.BITRUE:
        return "Bitrue";
    case x5.CEFFU:
        return "Ceffu";
    case x5.CHAINUP_CUSTODY:
        return "ChainUp Custody";
    case x5.CHANGENOW:
        return "ChangeNOW";
    case x5.COINEX:
        return "CoinEx";
    case x5.COINLIST:
        return "CoinList";
    case x5.CUMBERLAND_DRW:
        return "Cumberland DRW";
    case x5.DEBRIDGE:
        return "deBridge";
    case x5.DEX_TRADE:
        return "DEX Trade";
    case x5.DIGIFINEX:
        return "DigiFinex";
    case x5.FASEX:
        return "FASEX";
    case x5.FIXEDFLOAT:
        return "FixedFloat";
    case x5.JUMP_CRYPTO:
        return "Jump Crypto";
    case x5.LBANK:
        return "LBank";
    case x5.MAYAN_BRIDGE:
        return "Mayan Bridge";
    case x5.PHANTOM:
        return "Phantom";
    case x5.POLONIEX:
        return "Poloniex";
    case x5.REVOLUT:
        return "Revolut";
    case x5.ROBINHOOD:
        return "Robinhood";
    case x5.SOLANA_NAME_SERVICE:
        return "Solana Name Service";
    case x5.SOLLET:
        return "Sollet";
    case x5.SQUADS_PROTOCOL:
        return "Squads Protocol";
    case x5.TRANSAK:
        return "Transak";
    case x5.UPHOLD:
        return "Uphold";
    case x5.WOO_NETWORK:
        return "WOO Network";
    default:
        return String(e).toLowerCase().split("_").map((e => e.charAt(0).toUpperCase() + e.slice(1))).join(" ")
    }
}
  , f5 = y.memo(( ({exchange: e, size: t=v5}) => {
    const n = (e => {
        switch (e) {
        case x5.BINANCE_US:
        case x5.BINANCE:
            return Vf;
        case x5.BYBIT:
            return Lf;
        case x5.GATE_IO:
            return Gf;
        case x5.BITFINEX:
            return qf;
        case x5.CRYPTO_COM:
            return Qf;
        case x5.BITSTAMP:
            return Yf;
        case x5.BITGET:
            return Kf;
        case x5.KRAKEN:
            return zf;
        case x5.MEXC:
            return Hf;
        case x5.KUCOIN:
            return Ff;
        case x5.COINBASE:
            return $f;
        case x5.UPBIT:
            return ev;
        case x5.HTX:
            return Jf;
        case x5.FTX:
            return Zf;
        case x5.WINTERMUTE:
            return Ev;
        case x5.WORMHOLE:
            return Mv;
        case x5.ALLBRIDGE:
            return Nv;
        case x5.LAYER_ZERO:
            return Pv;
        case x5.CIRCLE:
            return Xf;
        case x5.OKX:
            return tv;
        case x5.ALAMEDA_RESEARCH:
            return nv;
        case x5.ASCENDEX:
            return rv;
        case x5.BACKPACK_EXCHANGE:
            return av;
        case x5.BITKUB:
            return sv;
        case x5.BITMART:
            return ov;
        case x5.BITRUE:
            return lv;
        case x5.CEFFU:
            return iv;
        case x5.CHAINUP_CUSTODY:
            return cv;
        case x5.CHANGENOW:
            return dv;
        case x5.COINEX:
            return uv;
        case x5.COINLIST:
            return pv;
        case x5.CUMBERLAND_DRW:
            return hv;
        case x5.DEBRIDGE:
            return mv;
        case x5.DEX_TRADE:
            return gv;
        case x5.DIGIFINEX:
            return xv;
        case x5.FIXEDFLOAT:
            return bv;
        case x5.JUMP_CRYPTO:
            return fv;
        case x5.LBANK:
            return vv;
        case x5.MAYAN_BRIDGE:
            return Sv;
        case x5.PHANTOM:
            return DS;
        case x5.POLONIEX:
            return yv;
        case x5.REVOLUT:
            return kv;
        case x5.ROBINHOOD:
            return Cv;
        case x5.SOLANA_NAME_SERVICE:
            return Jy;
        case x5.SOLLET:
            return Av;
        case x5.SQUADS_PROTOCOL:
            return Jy;
        case x5.TRANSAK:
            return jv;
        case x5.UPHOLD:
            return Tv;
        case x5.SWISS_BORG:
            return wv;
        case x5.PRIVACY_CASH:
            return Jy;
        case x5.WOO_NETWORK:
            return Iv;
        case x5.FASEX:
        default:
            return Jy
        }
    }
    )(e);
    return v.jsx(n, {
        size: t
    })
}
))
  , v5 = 16
  , S5 = y.memo(( ({chain: e, fundHash: t, fundFrom: n, fundAmountNativeUi: r, fundTs: a, fundExchange: s, fundedGroupCount: o, hideIcon: l=!1, hideStatsTooltip: i=!1}) => {
    const c = D()
      , d = y.useCallback(( () => {
        if (e && t) {
            const n = AA(t, e);
            n && window.open(n, "_blank")
        }
    }
    ), [t, e])
      , u = y.useMemo(( () => s ? "Funded from CEX or Bridge" : i ? "" : v.jsx(C5, {
        count: o ?? 1,
        ts: a ?? null
    })), [s, a, o, i])
      , p = y.useMemo(( () => s || !o || o < 2 ? null : 2 === o ? "warning.main" : "error.main"), [s, o]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        onClick: d,
        sx: k5,
        children: [v.jsxs(S, {
            direction: "column",
            gap: .5,
            children: [v.jsx(GC, {
                title: u,
                maxWidth: 500,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    textAlign: "end",
                    color: p ?? "text.value",
                    className: y5,
                    children: s ? b5(s) : oA(n)
                })
            }), v.jsxs(S, {
                direction: "row",
                gap: .5,
                alignItems: "center",
                justifyContent: "flex-end",
                width: "100%",
                children: [v.jsx(mE, {
                    ts: a,
                    variant: "paragraph3",
                    color: p ?? "text.label",
                    textAlign: "end",
                    fontWeight: 400,
                    fontSize: 11
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: hM
                }), v.jsxs(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    display: "flex",
                    justifyContent: "flex-end",
                    alignItems: "flex-end",
                    gap: .25,
                    fontWeight: 400,
                    fontSize: 11,
                    children: [LI(r, {
                        collapseExponent: !0,
                        symbol: "",
                        desiredDigits: 3,
                        noTrailingZeros: !0
                    }), v.jsx(Sz, {
                        chain: e,
                        size: 12
                    })]
                })]
            })]
        }), l ? null : s ? v.jsx(f5, {
            exchange: s
        }) : v.jsx(JS, {
            color: c.palette.text.value
        })]
    })
}
))
  , y5 = "fund_addr"
  , k5 = e => ({
    gap: .75,
    "&:hover": {
        cursor: "pointer",
        [`.${y5}`]: {
            color: e.palette.text.main
        }
    }
})
  , C5 = y.memo(( ({count: e, ts: t}) => v.jsxs(k, {
    variant: "inherit",
    color: "inherit",
    component: "span",
    children: [`${e} top holder${1 === e ? "" : "s"} funded within the same 20 minutes `, !!t && v.jsx(mE, {
        variant: "inherit",
        color: "inherit",
        ts: t,
        isShort: !1,
        component: "span"
    })]
})))
  , A5 = y.memo(( ({chain: e, mode: t, toggleMode: n}) => {
    const r = D()
      , {t: a} = we();
    return v.jsx(GC, {
        title: a("Switch currency to {{currency}}", {
            currency: t === uZ.USD ? GD(e) : "USD"
        }),
        children: v.jsx(C, {
            display: "flex",
            children: v.jsx(F, {
                onClick: n,
                sx: w5,
                children: v.jsx(gS, {
                    color: t === uZ.USD ? r.palette.success.main : r.palette.text.label
                })
            })
        })
    })
}
))
  , w5 = {
    p: .25
}
  , j5 = uZ.USD
  , T5 = y.memo(( ({chain: e, exchange: t, fundedTs: n, fundedAmount: r, fundedTxnHash: a, fundedFrom: s, nativeBalance: o}) => {
    const l = xw()
      , {t: i} = we()
      , [c,d] = Mx("padreV2-walletOverviewStatsBalanceCurrencyMode", j5)
      , u = y.useCallback(( () => {
        d((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [d])
      , p = VV(e)
      , {totalValueUsd: h, unrealizedPnlUsd: m} = D2()
      , g = y.useMemo(( () => c === uZ.USD ? h : p && null !== h ? h / p : null), [c, p, h])
      , x = y.useMemo(( () => c === uZ.USD ? m : p && null !== m ? m / p : null), [c, p, m])
      , b = y.useMemo(( () => {
        if (null === e)
            return null;
        const t = SU(ED(e));
        return c === uZ.NATIVE ? null === o ? null : o / 10 ** t : null === o || null === p ? null : p * o / 10 ** t
    }
    ), [c, o, p, e])
      , f = y.useMemo(( () => v.jsx(C, {
        display: "flex",
        mt: e === Pd.SOLANA ? -.25 : 0,
        children: v.jsx(Sz, {
            chain: e,
            grayOut: e !== Pd.SOLANA,
            size: M5 + (e === Pd.SOLANA ? 3 : e === Pd.BASE ? -2 : 0)
        })
    })), [e]);
    return v.jsxs(S, {
        flex: 1,
        gap: 4.5,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            pl: 1.5,
            pr: l ? 2 : 1.5,
            pt: 1.75,
            height: 40,
            children: [v.jsx(k, {
                variant: "h2",
                fontWeight: 400,
                children: i("Balance")
            }), e && v.jsx(A5, {
                chain: e,
                mode: c,
                toggleMode: u
            })]
        }), v.jsxs(S, {
            gap: 2.5,
            children: [v.jsxs(S, {
                gap: E5,
                pl: 1.5,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    fontWeight: 400,
                    color: "text.label",
                    children: i("Total Value")
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: e === Pd.BASE ? .5 : .25,
                    height: M5,
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        fontSize: M5,
                        color: "text.value",
                        fontWeight: 400,
                        children: null === g ? Ud : LI(g, {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            noTrailingZeros: !0,
                            symbol: c === uZ.NATIVE ? "" : "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    }), e && null !== g && c === uZ.NATIVE && f]
                })]
            }), v.jsxs(S, {
                gap: E5,
                pl: 1.5,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    fontWeight: 400,
                    color: "text.label",
                    children: i("Unrealized PNL")
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: e === Pd.BASE ? .5 : .25,
                    height: M5,
                    children: [v.jsx(RZ, {
                        variant: "paragraph1",
                        fontSize: M5,
                        fontWeight: 400,
                        value: x ?? 0,
                        formattedDisplay: null === x ? Ud : `${x < 0 ? "-" : ""}${LI(Math.abs(x), {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            noTrailingZeros: !0,
                            symbol: c === uZ.NATIVE ? "" : "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })}`
                    }), e && null !== x && c === uZ.NATIVE && f]
                })]
            }), v.jsx(Ee, {
                flexItem: !0,
                sx: l ? I5 : void 0
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsxs(S, {
                    gap: E5,
                    pl: 1.5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        fontWeight: 400,
                        color: "text.label",
                        children: i("Current balance")
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: e === Pd.BASE ? .5 : .25,
                        height: M5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            fontSize: M5,
                            color: "text.value",
                            fontWeight: 400,
                            children: null === b ? Ud : LI(b, {
                                collapseExponent: !0,
                                desiredDigits: 3,
                                noTrailingZeros: !0,
                                removeTrailingZerosPrecision: 0,
                                symbol: c === uZ.NATIVE ? "" : "$",
                                padSymbol: !1,
                                symbolPosition: yI.START
                            })
                        }), e && null !== b && c === uZ.NATIVE && f]
                    })]
                }), e === Pd.SOLANA && a && r && n && s && v.jsxs(S, {
                    gap: E5,
                    pr: 1.5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        fontWeight: 400,
                        color: "text.label",
                        textAlign: "center",
                        children: i("Funded")
                    }), v.jsx(S5, {
                        chain: e,
                        fundHash: a,
                        fundFrom: s,
                        fundAmountNativeUi: r,
                        fundTs: n,
                        fundExchange: t,
                        fundedGroupCount: 0,
                        hideStatsTooltip: !0
                    })]
                })]
            })]
        })]
    })
}
))
  , I5 = {
    ml: -1
}
  , E5 = 1
  , M5 = 20
  , N5 = y.memo(( ({coinsTraded: e, realizedPnlUsd: t, wins: n, losses: r, buys: a, sells: s, perfTimespan: o, setPerfTimespan: l, chain: i}) => {
    const c = xw()
      , {t: d} = we()
      , [u,p] = Mx("padreV2-walletOverviewStatsPerformanceCurrencyMode", j5)
      , h = y.useCallback(( () => {
        p((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [p])
      , m = VV(i)
      , g = y.useMemo(( () => u === uZ.USD ? t : m && null !== t ? t / m : null), [m, u, t])
      , x = y.useMemo(( () => {
        const e = (n ?? 0) + (r ?? 0);
        return e ? (n ?? 0) / e * 100 : null
    }
    ), [r, n]);
    return v.jsxs(S, {
        flex: 1,
        gap: 4.5,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            pl: c ? 2 : 1.5,
            pr: 1.5,
            pt: 1.75,
            height: 40,
            children: [v.jsx(k, {
                variant: "h2",
                fontWeight: 400,
                children: d("Performance")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [!c && v.jsx(i5, {
                    perfTimespan: o,
                    setPerfTimespan: l
                }), i && v.jsx(A5, {
                    chain: i,
                    mode: u,
                    toggleMode: h
                })]
            })]
        }), v.jsxs(S, {
            gap: 1.5,
            pl: c ? 2 : 1.5,
            pr: c ? 1.5 : 1,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("Realized PNL")
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: i === Pd.BASE ? .5 : .25,
                    height: P5,
                    children: [v.jsx(RZ, {
                        variant: "paragraph1",
                        fontWeight: 400,
                        value: g ?? 0,
                        formattedDisplay: null === g ? Ud : `${g < 0 ? "-" : ""}${LI(Math.abs(g), {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            noTrailingZeros: !0,
                            symbol: u === uZ.NATIVE ? "" : "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })}`
                    }), i && null !== g && u === uZ.NATIVE && v.jsx(C, {
                        display: "flex",
                        mt: i === Pd.SOLANA ? "-1px" : 0,
                        children: v.jsx(Sz, {
                            chain: i,
                            grayOut: i !== Pd.SOLANA,
                            size: P5 + (i === Pd.SOLANA ? 2 : i === Pd.BASE ? -1 : 0)
                        })
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("TXNS")
                }), null === a || null === s ? v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    fontWeight: 400,
                    children: Ud
                }) : v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        fontWeight: 400,
                        mr: .5,
                        children: a + s
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "success.main",
                        fontWeight: 400,
                        children: a
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        fontWeight: 400,
                        children: "/"
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "error.main",
                        fontWeight: 400,
                        children: s
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("Coins traded")
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    fontWeight: 400,
                    children: null === e ? Ud : e
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("Wins")
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "success.main",
                    fontWeight: 400,
                    children: null === n ? Ud : n
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("Win rate")
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "success.main",
                    fontWeight: 400,
                    children: null === x ? Ud : jI(x, {
                        precision: 100 === x ? 0 : 1,
                        omitSign: !0
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    fontWeight: 400,
                    color: "text.value",
                    children: d("Losses")
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "error.main",
                    fontWeight: 400,
                    children: null === r ? Ud : r
                })]
            })]
        })]
    })
}
))
  , P5 = 13
  , O5 = (e, t=!1) => {
    const n = t ? L5 : bu.XXSMALL;
    return {
        border: "none",
        borderRadius: 1,
        width: n,
        minWidth: n,
        height: n,
        p: 0,
        color: e.palette.text.label,
        "&:hover": {
            backgroundColor: e.palette.background.buttonHover
        }
    }
}
  , L5 = 16
  , R5 = Kt`
  0%, 25% {
    max-width: 0%;
  }
  26%, 50% {
    max-width: 33%;
  }
  51%, 75% {
    max-width: 67%;
  }
  76%, 100% {
    max-width: 100%;
  }
`
  , D5 = () => v.jsx(k, {
    component: "span",
    sx: _5,
    children: v.jsx(k, {
        component: "span",
        sx: B5,
        children: "..."
    })
})
  , B5 = {
    font: "inherit",
    color: "transparent"
}
  , _5 = {
    position: "relative",
    "&, &:after": {
        font: "inherit",
        color: "inherit"
    },
    "&:after": {
        content: '"..."',
        position: "absolute",
        left: 0,
        top: 0,
        height: "100%",
        width: "100%",
        animation: `${R5} 3s infinite ease-out`,
        overflow: "hidden"
    }
}
  , U5 = ({title: e, subtitle: t, open: n=O, close: r, isOpen: a, children: s, modalLayoutProps: o={}, showCloseButton: l=!1, isModalOnly: i=!1}) => {
    const c = bw()
      , d = y.useMemo(( () => v.jsxs(S, {
        gap: 4,
        children: [e || t || l ? v.jsxs(S, {
            gap: 1.5,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    variant: "h3",
                    children: e
                }), l && v.jsx(F, {
                    onClick: r,
                    sx: {
                        m: -1
                    },
                    children: v.jsx(gy, {
                        size: 24
                    })
                })]
            }), t && v.jsx(k, {
                variant: "bodyLarge",
                color: "text.meta",
                children: t
            })]
        }) : null, v.jsx(S, {
            gap: 8,
            children: s
        })]
    })), [e, s, l, r, t]);
    return i || c ? v.jsx(Sw, {
        open: a,
        onClose: r,
        keepMounted: !1,
        ...o,
        children: d
    }) : v.jsx(_R, {
        anchor: "bottom",
        open: a,
        onOpen: n,
        onClose: r,
        disableSwipeToOpen: !0,
        keepMounted: !1,
        children: v.jsx(jR, {
            isOpen: a,
            children: d
        })
    })
}
  , W5 = new Set(["ce1290364ae0e51a526dec1a0f63e27a96756d57a6a7b3ebfa88d94f73d6c368", "c9ba7472d81013b64e0c8a630c506ead0c1b17c4be7ea641c3dd0433db9e6fe0", "52be2de64e1a83b8c9eb7b7f49833efe40c06e5b0f54e9236d34b01d15f2be0b", "f3c4495094277e06c5b5a68c46b710c3f5fbb1e44759bb90a3562357d53560a0", "da5884d0f9a41e35c1b6688117d77b33bf3e9cafe16b17863ffe45de773c6ee5"])
  , F5 = () => {
    const {user: e} = VK()
      , [t,n] = y.useState();
    return y.useEffect(( () => {
        (async () => {
            const t = await sf((null == e ? void 0 : e.uid) || "", W5);
            n(t)
        }
        )()
    }
    ), [null == e ? void 0 : e.uid]),
    t
}
  , V5 = ({chain: e, setChain: t, showNameLabels: n=!0, forceAllLabel: r=!1, isSmall: a=!1, possibleOptions: s, disabled: o=!1, disableWrap: l=!1, grayOutUnselected: i=!1}) => {
    const c = xw()
      , d = y.useCallback((e => {
        t(e)
    }
    ), [t])
      , u = a ? $5 : c ? H5 : z5;
    return v.jsx(S, {
        direction: "row",
        sx: {
            flexWrap: l ? "nowrap" : "wrap",
            gap: !c || a ? .5 : 1.5
        },
        children: (s ?? TQ).map((t => {
            const s = t === e;
            return v.jsxs(V, {
                className: "no-drag",
                disabled: o,
                variant: "tertiary",
                onClick: () => {
                    d(t)
                }
                ,
                onMouseDown: e => {
                    e.stopPropagation(),
                    e.preventDefault()
                }
                ,
                size: a ? "xsmall" : c ? "medium" : "small",
                sx: e => ({
                    bgcolor: s ? e.palette.background.active : e.palette.background.secondary,
                    "&:hover": {
                        bgcolor: s ? e.palette.background.active : e.palette.background.secondary
                    },
                    border: `1px solid ${s ? e.palette.background.borderMain : e.palette.background.borderSecondary}`,
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                    borderRadius: "4px",
                    p: a ? .5 : 1,
                    gap: 1,
                    transition: "0ms",
                    color: s ? e.palette.text.value : e.palette.text.label
                }),
                children: ["ALL_NETWORKS" === t ? r ? null : v.jsx(yk, {
                    size: u
                }) : v.jsx(Sz, {
                    chain: t,
                    size: u,
                    grayOut: "ALL_NETWORKS" !== e && i && !s
                }), (n || r && "ALL_NETWORKS" === t) && v.jsx(k, {
                    variant: a ? "paragraph3" : c ? "paragraph1" : "paragraph3",
                    lineHeight: 1,
                    noWrap: !0,
                    color: "inherit",
                    ...Nu,
                    children: IQ[t]
                })]
            }, t)
        }
        ))
    })
}
  , H5 = 20
  , z5 = 16
  , $5 = 14
  , G5 = y.memo(( ({chain: e, setChain: t, possibleOptions: n, disabled: r=!1, showAllTooltip: a=!1}) => {
    const s = D()
      , {t: o} = we()
      , l = y.useCallback((e => {
        t(e)
    }
    ), [t]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: (n ?? TQ).map((t => {
            const n = t === e
              , {Icon: i, color: c} = Y5(t, n, s)
              , d = q5 - (t === Pd.SOLANA ? 6 : 12);
            return v.jsx(GC, {
                title: a && "ALL_NETWORKS" === t ? o("All") : "",
                children: v.jsx(C, {
                    display: "flex",
                    children: v.jsx(F, {
                        className: "no-drag",
                        onClick: () => l(t),
                        onMouseDown: e => {
                            e.stopPropagation(),
                            e.preventDefault()
                        }
                        ,
                        sx: K5,
                        disabled: r,
                        children: v.jsx(i, {
                            size: d,
                            color: c
                        })
                    })
                })
            }, String(t))
        }
        ))
    })
}
))
  , q5 = 32
  , K5 = {
    p: .25,
    height: q5,
    width: q5
}
  , Y5 = (e, t, n) => {
    if ("ALL_NETWORKS" === e)
        return {
            Icon: yk,
            color: t ? n.palette.primary.main : n.palette.text.label
        };
    switch (e) {
    case Pd.SOLANA:
        return {
            Icon: t ? dk : Jv
        };
    case Pd.BASE:
        return {
            Icon: t ? nk : Xv
        };
    case Pd.BSC:
        return {
            Icon: t ? ak : rk
        };
    case Pd.ETH_MAINNET:
        return {
            Icon: Df,
            color: t ? d_(Pd.ETH_MAINNET) : void 0
        };
    default:
        return {
            Icon: yk
        }
    }
}
  , X5 = y.memo(( ({value: e, setValue: t, label: n, multiline: r=!1}) => {
    const a = y.useCallback(( ({target: {value: e}}) => {
        t(e)
    }
    ), [t]);
    return v.jsxs(S, {
        gap: .25,
        alignItems: "center",
        width: "100%",
        children: [v.jsx(k, {
            variant: "paragraph3",
            children: n
        }), v.jsx(je, {
            fullWidth: !0,
            multiline: r,
            maxRows: 4,
            minRows: 4,
            value: e,
            onChange: a,
            size: "xsmall",
            placeholder: n,
            sx: r ? Z5 : Q5
        })]
    })
}
))
  , Q5 = {
    height: 28
}
  , Z5 = {
    height: 120
}
  , J5 = {
    showUsdValues: !0,
    textShadow: !1,
    swapValues: !1,
    customRed: "#E73A44",
    customGreen: "#47CD88",
    customTextColor: "#FFFFFF",
    gradientColor: "#000000",
    gradientStrength: 6
}
  , e3 = [...["pnl_noir_1.png", "pnl_noir_2.png", "pump_it_gif.gif", "respect_mou_gif.gif", "pnl_noir_lana_gif.gif", "pnl_noir_marilyn_gif.gif", "pnl_noir_rocket_gif.gif"].map((e => ({
    src: `https://cards.padre.gg/backgrounds/${e}`,
    isGif: e.endsWith(".gif"),
    id: null
})))]
  , t3 = ["image/png", "image/jpeg", "image/webp", "image/gif"]
  , n3 = y.memo(( ({isOpen: e, onClose: t, setLocalBackground: n, saveValues: r, initialValues: a}) => {
    const {t: s} = we()
      , o = VV(Pd.SOLANA)
      , l = y.useRef(null)
      , i = y.useCallback((async e => {
        try {
            const [r,a] = await (t = e,
            new Promise(( (e, n) => {
                const r = new FileReader;
                r.onload = () => {
                    const t = r.result
                      , [n] = t.split(",")
                      , a = n.match(/^data:([^;]+);/)
                      , s = a ? a[1] : "";
                    e([s, t])
                }
                ,
                r.onerror = n,
                r.readAsDataURL(t)
            }
            )));
            n({
                src: a,
                isGif: "image/gif" === r,
                id: null
            })
        } catch (r) {}
        var t
    }
    ), [n])
      , c = y.useCallback((e => {
        var t;
        const n = null == (t = e.target.files) ? void 0 : t[0];
        n && i(n)
    }
    ), [i])
      , d = y.useCallback(( () => {
        var e;
        null == (e = l.current) || e.click()
    }
    ), [])
      , [u,p] = y.useState(a.chain)
      , h = y.useCallback((e => {
        "ALL_NETWORKS" !== e && p(e)
    }
    ), [])
      , [m,g] = y.useState(a.symbol)
      , [x,b] = y.useState(a.refCode ?? "")
      , [f,A] = y.useState(a.investedAmount.toString())
      , [w,j] = y.useState(null === a.investedNative ? "" : a.investedNative.toString())
      , [T,I] = y.useState(a.profitAmount.toString())
      , [E,M] = y.useState(null === a.profitNative ? "" : a.profitNative.toString())
      , [N,P] = y.useState(a.profitPercentage.toString())
      , [O,L] = y.useState(a.remainingAmount.toString())
      , [R,D] = y.useState(null === a.remainingNative ? "" : a.remainingNative.toString())
      , [B,_] = y.useState(null === a.holdTime ? "" : a.holdTime.toString())
      , [U,W] = y.useState(null === a.multiplier ? "" : a.multiplier)
      , [F,H] = y.useState(a.isPeriod ?? !1)
      , z = y.useCallback(( () => {
        H((e => !e))
    }
    ), [])
      , [$,G] = y.useState(a.showUsdOnPeriod ?? !1)
      , q = y.useCallback(( () => {
        G((e => !e))
    }
    ), [])
      , [K,Y] = y.useState(void 0 === a.totalBoughtUsd ? "" : a.totalBoughtUsd.toString())
      , [X,Q] = y.useState(void 0 === a.totalBoughtNative ? "" : a.totalBoughtNative.toString())
      , [Z,J] = y.useState(void 0 === a.totalSoldUsd ? "" : a.totalSoldUsd.toString())
      , [ee,te] = y.useState(void 0 === a.totalSoldNative ? "" : a.totalSoldNative.toString())
      , ne = y.useCallback(( () => {
        r({
            symbol: m,
            chain: u,
            investedAmount: Number(f ?? "0"),
            investedNative: "" === w ? null : Number(w),
            profitAmount: Number(T ?? "0"),
            profitNative: "" === E ? null : Number(E),
            profitPercentage: Number(N ?? "0"),
            remainingAmount: Number(O ?? "0"),
            remainingNative: "" === R ? null : Number(R),
            refCode: "" === x ? null : x,
            holdTime: "" === B ? null : Number(B),
            multiplier: "" === U ? null : U,
            ...F ? {
                isPeriod: !0,
                showUsdOnPeriod: $,
                totalBoughtUsd: "" === K ? void 0 : Number(K ?? "0"),
                totalBoughtNative: "" === X ? void 0 : Number(X ?? "0"),
                totalSoldUsd: "" === Z ? void 0 : Number(Z ?? "0"),
                totalSoldNative: "" === ee ? void 0 : Number(ee ?? "0")
            } : {}
        }),
        t()
    }
    ), [u, B, f, w, F, U, t, T, E, N, x, O, R, r, $, m, X, K, ee, Z])
      , re = y.useCallback(( () => {
        if (!o)
            return;
        const e = E && !isNaN(Number(E)) ? Number(E) * o : null;
        e && I(e.toFixed(9));
        const t = w && !isNaN(Number(w)) ? Number(w) * o : null;
        t && A(t.toFixed(9));
        const n = R && !isNaN(Number(R)) ? Number(R) * o : null;
        n && L(n.toFixed(9));
        const r = e && t ? 100 * e / t : null;
        if (r) {
            P(r.toFixed(9));
            const e = (r / 100 + 1).toFixed(r / 100 + 1 > .1 ? 2 : 4);
            W(e)
        }
        if (!F)
            return;
        const a = X && !isNaN(Number(X)) ? Number(X) * o : null;
        a && Y(a.toFixed(9));
        const s = ee && !isNaN(Number(ee)) ? Number(ee) * o : null;
        s && J(s.toFixed(9))
    }
    ), [w, F, E, R, o, X, ee]);
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        stackSx: r3,
        minDesktopWidth: 650,
        maxDesktopWidth: 650,
        children: v.jsxs(S, {
            gap: 2.5,
            children: [v.jsx("input", {
                ref: l,
                type: "file",
                accept: t3.join(","),
                hidden: !0,
                onChange: c
            }), v.jsx(k, {
                variant: "paragraph1",
                children: "Pnl Cards Generator"
            }), v.jsxs(S, {
                direction: "row",
                gap: 2,
                width: "100%",
                divider: s3,
                children: [v.jsxs(S, {
                    gap: .75,
                    flex: 1,
                    alignItems: "center",
                    divider: a3,
                    children: [v.jsx(V, {
                        size: "xsmall",
                        onClick: d,
                        children: "Upload custom background"
                    }), v.jsx(X5, {
                        value: m,
                        setValue: g,
                        label: "Symbol"
                    }), v.jsx(X5, {
                        value: x,
                        setValue: b,
                        label: "Ref code"
                    }), v.jsx(X5, {
                        value: T,
                        setValue: I,
                        label: "Profit amount"
                    }), v.jsx(X5, {
                        value: E,
                        setValue: M,
                        label: "Profit native"
                    }), v.jsx(X5, {
                        value: N,
                        setValue: P,
                        label: "Profit percentage"
                    }), v.jsx(X5, {
                        value: f,
                        setValue: A,
                        label: "Invested amount"
                    }), v.jsx(X5, {
                        value: w,
                        setValue: j,
                        label: "Invested native"
                    })]
                }), v.jsxs(S, {
                    gap: .75,
                    flex: 1,
                    alignItems: "center",
                    divider: a3,
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            children: "Chain"
                        }), v.jsx(V5, {
                            chain: u,
                            setChain: h,
                            isSmall: !0,
                            showNameLabels: !1,
                            possibleOptions: [Pd.SOLANA, Pd.ETH_MAINNET, Pd.BASE, Pd.BSC]
                        })]
                    }), v.jsx(X5, {
                        value: O,
                        setValue: L,
                        label: s("Remaining amount")
                    }), v.jsx(X5, {
                        value: R,
                        setValue: D,
                        label: s("Remaining native")
                    }), v.jsx(X5, {
                        value: B,
                        setValue: _,
                        label: "Hold time"
                    }), v.jsx(X5, {
                        value: U,
                        setValue: W,
                        label: "Multiplier"
                    }), v.jsx(S, {
                        height: 32,
                        alignItems: "center",
                        justifyContent: "center",
                        children: v.jsx(WR, {
                            label: "Is period alike",
                            isChecked: F,
                            onClick: z
                        })
                    }), F && v.jsx(S, {
                        height: 32,
                        alignItems: "center",
                        justifyContent: "center",
                        children: v.jsx(WR, {
                            label: "Show usd values on period",
                            isChecked: $,
                            onClick: q
                        })
                    })]
                }), v.jsxs(S, {
                    gap: .75,
                    flex: 1,
                    alignItems: "center",
                    divider: a3,
                    children: [F && v.jsx(X5, {
                        value: K,
                        setValue: Y,
                        label: "Total bought usd"
                    }), F && v.jsx(X5, {
                        value: X,
                        setValue: Q,
                        label: "Total bought native"
                    }), F && v.jsx(X5, {
                        value: Z,
                        setValue: J,
                        label: "Total sold usd"
                    }), F && v.jsx(X5, {
                        value: ee,
                        setValue: te,
                        label: "Total sold native"
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                gap: 8,
                children: [v.jsx(C, {
                    display: "flex",
                    flexGrow: 6,
                    children: v.jsx(V, {
                        size: "xsmall",
                        onClick: ne,
                        fullWidth: !0,
                        children: "Save and close"
                    })
                }), v.jsx(C, {
                    display: "flex",
                    flexGrow: 1,
                    children: v.jsx(V, {
                        size: "xsmall",
                        variant: "secondary",
                        onClick: re,
                        fullWidth: !0,
                        children: "Recalculate USD"
                    })
                })]
            })]
        })
    })
}
))
  , r3 = {
    p: 2,
    zIndex: Kw
}
  , a3 = v.jsx(Ee, {
    flexItem: !0,
    sx: e => ({
        borderColor: e.palette.background.borderActive,
        mx: -2
    })
})
  , s3 = v.jsx(Ee, {
    flexItem: !0,
    orientation: "vertical",
    sx: e => ({
        borderColor: e.palette.background.borderActive
    })
})
  , o3 = y.memo(( ({availableBackgrounds: e, selectedBackground: t, onSelect: n, refreshCustomBackgrounds: r, customBackgroundsCount: a}) => {
    const s = Ax()
      , o = pK()
      , l = y.useRef(null)
      , [i,c] = y.useState(!1)
      , d = y.useCallback((async e => {
        if (!s)
            return;
        if (!t3.includes(e.type))
            return void o({
                message: uu.unsupportedFileType,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "image-upload-error-type");
        if (e.size > 2048e3)
            return void o({
                message: uu.backgroundExceedsSize,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "image-upload-error-size");
        try {
            c(!0);
            const [n,a] = await (t = e,
            new Promise(( (e, n) => {
                const r = new FileReader;
                r.onload = () => {
                    const t = r.result
                      , [n,a] = t.split(",")
                      , s = n.match(/^data:([^;]+);/)
                      , o = s ? s[1] : "";
                    e([o, a])
                }
                ,
                r.onerror = n,
                r.readAsDataURL(t)
            }
            )));
            await Pm.uploadImage(s, {
                name: e.name.slice(0, 190),
                imgBase64: a,
                contentType: n
            }),
            await r(),
            o({
                message: pu.backgroundUploadSuccess,
                type: "success"
            }, "image-upload-success")
        } catch (n) {
            o({
                message: uu.unknownError,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "image-upload-error")
        } finally {
            c(!1)
        }
        var t
    }
    ), [o, r, s])
      , u = y.useCallback((e => {
        var t;
        const n = null == (t = e.target.files) ? void 0 : t[0];
        n && d(n)
    }
    ), [d])
      , p = y.useCallback(( () => {
        var e;
        null == (e = l.current) || e.click()
    }
    ), []);
    return v.jsxs(S, {
        direction: "row-reverse",
        gap: 1,
        children: [v.jsx("input", {
            ref: l,
            type: "file",
            accept: t3.join(","),
            hidden: !0,
            onChange: u
        }), v.jsx(V, {
            variant: "tertiary",
            size: "large",
            sx: i3,
            disabled: null === a || i || 10 <= a,
            onClick: p,
            children: i ? v.jsx(S, {
                color: "text.label",
                alignItems: "center",
                justifyContent: "center",
                height: "100%",
                children: v.jsx(J, {
                    color: "inherit",
                    size: 26
                })
            }) : v.jsxs(S, {
                sx: c3,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    children: "Upload image"
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: "Max 2 MB"
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: 10 === a ? "warning.main" : "text.label",
                    children: null === a ? v.jsx(Ie, {
                        width: 75
                    }) : `Uploaded ${a}/10`
                })]
            })
        }), v.jsx(S, {
            direction: "row",
            gap: 1,
            sx: l3,
            className: "padre-decorative-scroll",
            children: e.map((e => v.jsx(u3, {
                src: e.src,
                id: e.id,
                isSelected: e.src === t,
                onClick: () => {
                    n(e)
                }
                ,
                refreshCustomBackgrounds: r
            }, `${e.id}-${e.src}`)))
        })]
    })
}
))
  , l3 = {
    overflowX: "scroll"
}
  , i3 = {
    height: {
        xs: 60,
        md: 100
    },
    minWidth: 120,
    width: 120,
    px: 0
}
  , c3 = {
    gap: {
        xs: .25,
        md: 1
    }
}
  , d3 = {
    width: "100%",
    height: "100%",
    objectFit: "cover",
    display: "block"
}
  , u3 = y.memo(( ({src: e, id: t, isSelected: n, onClick: r, refreshCustomBackgrounds: a}) => {
    const s = Ax()
      , [o,l] = y.useState(!1)
      , i = y.useCallback((async e => {
        if (t && s) {
            e.stopPropagation(),
            l(!0);
            try {
                await Pm.deleteCustomBackground(s, {
                    uuid: t
                }),
                await a()
            } catch (fNe) {
                l(!1)
            }
        }
    }
    ), [s, t, a])
      , c = y.useMemo(( () => e => ({
        position: "relative",
        display: "flex",
        borderRadius: 1,
        border: `1px solid ${n ? e.palette.success.main : e.palette.background.borderMain}`,
        minWidth: {
            xs: 90,
            md: 150
        },
        width: {
            xs: 90,
            md: 150
        },
        height: {
            xs: 60,
            md: 100
        },
        "&:hover": {
            cursor: "pointer",
            ...t ? {
                [`.${p3}`]: {
                    display: "flex"
                }
            } : {}
        }
    })), [t, n]);
    return v.jsxs(C, {
        sx: c,
        onClick: r,
        children: [v.jsx(C, {
            className: p3,
            position: "absolute",
            top: 4,
            right: 4,
            display: "none",
            children: o ? v.jsx(J, {
                size: 16
            }) : v.jsx(F, {
                sx: h3,
                onClick: i,
                children: v.jsx(kS, {})
            })
        }), v.jsx("img", {
            src: e,
            style: d3
        })]
    })
}
))
  , p3 = "preview-item-indicator"
  , h3 = {
    p: .25
}
  , m3 = y.memo(( ({openColorSelector: e, selectedColor: t, setSelectedColor: n, defaultColor: r, color: a, setColor: s}) => {
    const [o,l] = y.useState(a.replace("#", "").toUpperCase());
    y.useEffect(( () => {
        l(a.replace("#", "").toUpperCase())
    }
    ), [a]);
    const i = y.useCallback(( () => {
        l(r.replace("#", "").toUpperCase()),
        s(r),
        n(r)
    }
    ), [r, s, n])
      , c = y.useMemo(( () => ({
        width: g3,
        height: g3,
        borderRadius: .5,
        backgroundColor: a || t || r,
        border: "1px dotted #CCCCCC",
        cursor: "pointer"
    })), [r, t, a])
      , d = y.useMemo(( () => v.jsxs(We, {
        position: "start",
        sx: v3,
        children: [v.jsx(C, {
            onClick: e,
            sx: c
        }), " "]
    })), [c, e])
      , u = y.useMemo(( () => t.toUpperCase() !== r.toUpperCase()), [r, t])
      , p = y.useMemo(( () => v.jsx(We, {
        position: "end",
        sx: v3,
        children: u && v.jsx(F, {
            sx: x3,
            onClick: i,
            children: v.jsx(_S, {
                size: 14
            })
        })
    })), [u, i])
      , h = y.useCallback(( () => {
        if (!(o.length >= b3))
            switch (o.length) {
            case 0:
                {
                    const e = r.replace("#", "");
                    return l(e),
                    n(r),
                    void s(r)
                }
            case 1:
                {
                    const e = o.repeat(6);
                    return l(e),
                    n(`#${e}`),
                    void s(`#${e}`)
                }
            case 2:
                {
                    const e = o.repeat(3);
                    return l(e),
                    n(`#${e}`),
                    void s(`#${e}`)
                }
            case 3:
                {
                    const e = o.repeat(2);
                    return l(e),
                    n(`#${e}`),
                    void s(`#${e}`)
                }
            case 4:
            case 5:
                {
                    const e = o.padEnd(6, o[o.length - 1]);
                    return l(e),
                    n(`#${e}`),
                    void s(`#${e}`)
                }
            }
    }
    ), [r, o, s, n])
      , m = y.useMemo(( () => e => ({
        maxWidth: 120,
        px: 1,
        gap: 0,
        ...u ? {
            "& .MuiOutlinedInput-notchedOutline": {
                borderColor: e.palette.background.borderActive
            },
            "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: e.palette.background.borderActive
            },
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: e.palette.background.borderActive
            }
        } : {}
    })), [u]);
    return v.jsxs(S, {
        position: "relative",
        children: [v.jsx(je, {
            value: o,
            onChange: e => {
                const t = e.target.value.slice(0, b3);
                f3.test(t) && (l(t),
                6 === t.length && (n(`#${t}`),
                s(`#${t}`)))
            }
            ,
            onBlur: h,
            size: "xsmall",
            placeholder: "0",
            fullWidth: !0,
            sx: m,
            endAdornment: p,
            startAdornment: d
        }), u && v.jsx(C, {
            position: "absolute",
            top: -1,
            right: -1,
            sx: S3
        })]
    })
}
))
  , g3 = 18
  , x3 = {
    p: .25,
    height: 18,
    width: 18
}
  , b3 = 6
  , f3 = /^[0-9a-fA-F]*$/
  , v3 = {
    minWidth: 18
}
  , S3 = e => ({
    borderRadius: "50%",
    height: 5,
    width: 5,
    background: e.palette.primary.main
})
  , y3 = y.memo(( ({label: e, selectedColor: t, setSelectedColor: n, defaultColor: r, enableAlpha: a=!1, saveOnClose: s=!1, onCloseCallback: o, showInput: l=!1, tooltipTitle: i}) => {
    const [d,u] = y.useState(null)
      , [p,h] = y.useState(t || r);
    y.useEffect(( () => {
        const e = a ? ix(p) : lx(p);
        p && !e && (n(r),
        h(r))
    }
    ), [p, r, a, n]),
    y.useEffect(( () => {
        s && h(t)
    }
    ), [s, t]);
    const m = y.useCallback((e => {
        u(e.currentTarget)
    }
    ), [])
      , g = y.useCallback(( () => {
        u(null),
        s && n(p),
        o && o(p)
    }
    ), [p, s, n, o])
      , x = y.useRef(c.debounce((e => {
        n(e)
    }
    ), A3, {
        maxWait: A3
    })).current
      , b = y.useCallback((e => {
        const t = w3(e.rgb, a);
        h(t),
        s || x(t)
    }
    ), [x, a, s])
      , f = y.useMemo(( () => ({
        width: k3,
        height: k3,
        borderRadius: .5,
        backgroundColor: s ? p : t || r,
        border: "1px dotted #CCCCCC",
        cursor: "pointer"
    })), [p, r, s, t]);
    return v.jsxs(S, {
        direction: "row",
        sx: C3,
        children: [!l && v.jsx(GC, {
            title: i,
            children: v.jsx(C, {
                onClick: m,
                sx: f
            })
        }), e && v.jsx(k, {
            variant: "paragraph3",
            color: "text.value",
            minWidth: l ? 100 : void 0,
            children: e
        }), l && v.jsx(m3, {
            openColorSelector: m,
            selectedColor: t,
            setSelectedColor: n,
            defaultColor: r,
            color: p,
            setColor: h
        }), v.jsx(ae, {
            open: !!d,
            anchorEl: d,
            onClose: g,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "left"
            },
            children: v.jsx(Ne, {
                color: p || r,
                onChange: b,
                disableAlpha: !a
            })
        })]
    })
}
))
  , k3 = 18
  , C3 = {
    p: .75,
    alignItems: "center",
    gap: .75,
    height: 34
}
  , A3 = 100
  , w3 = ({r: e, g: t, b: n, a: r}, a) => {
    const s = e => e.toString(16).padStart(2, "0")
      , o = s(e)
      , l = s(t)
      , i = s(n);
    if ("number" == typeof r && a) {
        return `#${o}${l}${i}${s(Math.round(255 * r))}`
    }
    return `#${o}${l}${i}`
}
  , j3 = y.createContext({
    isOpen: !1,
    open: c.noop,
    config: J5,
    setConfig: c.noop
});
j3.displayName = "ShareProfitContext";
const T3 = () => y.useContext(j3)
  , I3 = y.memo(( ({onClose: e}) => {
    const {config: t, setConfig: n} = T3()
      , {t: r} = we()
      , [a,s] = y.useState(t)
      , o = y.useCallback(( (e, t) => {
        s((e => ({
            ...e,
            showUsdValues: t
        })))
    }
    ), [s])
      , l = y.useCallback(( (e, t) => {
        s((e => ({
            ...e,
            textShadow: t
        })))
    }
    ), [s])
      , i = y.useCallback((e => {
        s((t => ({
            ...t,
            customTextColor: e
        })))
    }
    ), [s])
      , d = y.useCallback(( () => {
        s((e => ({
            ...e,
            customTextColor: J5.customTextColor
        })))
    }
    ), [s])
      , u = y.useCallback((e => {
        s((t => ({
            ...t,
            customGreen: e
        })))
    }
    ), [s])
      , p = y.useCallback(( () => {
        s((e => ({
            ...e,
            customGreen: J5.customGreen
        })))
    }
    ), [s])
      , h = y.useCallback((e => {
        s((t => ({
            ...t,
            customRed: e
        })))
    }
    ), [s])
      , m = y.useCallback(( () => {
        s((e => ({
            ...e,
            customRed: J5.customRed
        })))
    }
    ), [s])
      , g = y.useCallback((e => {
        s((t => ({
            ...t,
            gradientColor: e
        })))
    }
    ), [s])
      , x = y.useCallback(( () => {
        s((e => ({
            ...e,
            gradientColor: J5.gradientColor
        })))
    }
    ), [s])
      , b = y.useMemo(( () => c.debounce((e => {
        s((t => ({
            ...t,
            gradientStrength: e
        })))
    }
    ), 250)), [s])
      , f = y.useMemo(( () => !c.isEqual(a, t)), [a, t])
      , C = y.useCallback(( () => {
        n(a),
        e()
    }
    ), [a, e, n])
      , A = y.useMemo(( () => pZ(r, P3)), [r])
      , w = y.useCallback(( (e, t) => {
        s((e => ({
            ...e,
            swapValues: t === uZ.USD
        })))
    }
    ), []);
    return v.jsxs(S, {
        gap: 1.5,
        children: [v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: r("Customize PNL card")
            }), v.jsx(F, {
                sx: E3,
                onClick: e,
                children: v.jsx(kS, {})
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Text color")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(F, {
                    sx: M3,
                    onClick: d,
                    children: v.jsx(_S, {})
                }), v.jsx(y3, {
                    label: null,
                    selectedColor: a.customTextColor,
                    setSelectedColor: i,
                    defaultColor: J5.customTextColor,
                    saveOnClose: !0
                })]
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Profit color")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(F, {
                    sx: M3,
                    onClick: p,
                    children: v.jsx(_S, {})
                }), v.jsx(y3, {
                    label: null,
                    selectedColor: a.customGreen,
                    setSelectedColor: u,
                    defaultColor: J5.customGreen,
                    saveOnClose: !0
                })]
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Loss color")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(F, {
                    sx: M3,
                    onClick: m,
                    children: v.jsx(_S, {})
                }), v.jsx(y3, {
                    label: null,
                    selectedColor: a.customRed,
                    setSelectedColor: h,
                    defaultColor: J5.customRed,
                    saveOnClose: !0
                })]
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: a.swapValues ? r("Show Native values") : r("Show USD values")
            }), v.jsx(Ue, {
                checked: a.showUsdValues,
                size: "small",
                color: a.showUsdValues ? "positive" : "neutral",
                onChange: o
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Main stat value")
            }), v.jsx(IH, {
                size: "xxsmall",
                value: a.swapValues ? uZ.USD : uZ.NATIVE,
                onChange: w,
                items: A,
                maxItemWidth: O3
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Show text shadow")
            }), v.jsx(Ue, {
                checked: a.textShadow,
                size: "small",
                color: a.textShadow ? "positive" : "neutral",
                onChange: l
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Gradient color")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(F, {
                    sx: M3,
                    onClick: x,
                    children: v.jsx(_S, {})
                }), v.jsx(y3, {
                    label: null,
                    selectedColor: a.gradientColor,
                    setSelectedColor: g,
                    defaultColor: J5.gradientColor,
                    saveOnClose: !0
                })]
            })]
        }), v.jsxs(S, {
            width: "100%",
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            height: N3,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r("Gradient strength")
            }), v.jsx(jw, {
                valueSuffix: null,
                Icon: null,
                defaultValue: a.gradientStrength,
                min: 0,
                max: 10,
                step: 1,
                saveValue: b,
                width: 90
            })]
        }), v.jsx(V, {
            onClick: C,
            disabled: !f,
            size: "xxsmall",
            children: r("Apply")
        })]
    })
}
))
  , E3 = {
    p: .5
}
  , M3 = {
    p: .25,
    width: 24,
    height: 24
}
  , N3 = 30
  , P3 = [{
    value: uZ.USD,
    label: "USD"
}, {
    value: uZ.NATIVE,
    label: "Native"
}]
  , O3 = 54
  , L3 = y.memo(( ({isOpen: e, onClose: t}) => v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: R3,
    minDesktopWidth: 260,
    maxDesktopWidth: 260,
    children: v.jsx(I3, {
        onClose: t
    })
})))
  , R3 = {
    p: 2,
    zIndex: Kw
}
  , D3 = y.memo(( ({data: e, config: t, isPreview: n}) => {
    const {t: r} = we()
      , a = y.useMemo(( () => {
        const e = lb(t.gradientStrength, {
            min: 0,
            max: 10
        }) / 10
          , r = parseInt(t.gradientColor.slice(1, 3), 16)
          , a = parseInt(t.gradientColor.slice(3, 5), 16)
          , s = parseInt(t.gradientColor.slice(5, 7), 16);
        return {
            width: "1420px",
            height: "100%",
            borderRadius: 2,
            backgroundImage: 0 === t.gradientStrength ? "none" : `linear-gradient(to right, rgba(${r},${a},${s},${e}), rgba(${r},${a},${s},0))`,
            zIndex: n ? H3 : -1
        }
    }
    ), [t.gradientColor, t.gradientStrength, n])
      , [s,o] = y.useMemo(( () => $3(e.chain)), [e.chain]);
    return v.jsx(S, {
        width: 1980,
        height: 1320,
        py: 7.5,
        px: 10,
        children: v.jsxs(S, {
            position: "relative",
            height: "100%",
            pl: 15,
            pt: 15.5,
            gap: 35,
            children: [v.jsxs(S, {
                direction: "row",
                height: 90,
                gap: 6,
                alignItems: "center",
                zIndex: V3,
                children: [v.jsx("img", {
                    src: "/logo.png",
                    alt: "Padre.gg",
                    height: 90,
                    width: 430,
                    style: t.textShadow ? F3 : void 0
                }), e.refCode && v.jsx(kS, {
                    color: t.customTextColor,
                    size: 60,
                    shadow: t.textShadow ? U3 : void 0
                }), e.refCode && v.jsx(k, {
                    variant: "paragraph1",
                    fontFamily: Cu.INTER,
                    fontSize: 64,
                    color: t.customTextColor,
                    mt: -1,
                    sx: t.textShadow ? W3 : void 0,
                    children: `${e.refCode}`
                })]
            }), v.jsxs(S, {
                gap: 5.75,
                zIndex: V3,
                children: [v.jsx(S, {
                    height: 160,
                    justifyContent: "center",
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        fontFamily: Cu.INTER,
                        color: t.customTextColor,
                        fontWeight: 700,
                        fontSize: 100,
                        sx: t.textShadow ? W3 : void 0,
                        children: e.symbol.slice(0, B3)
                    })
                }), v.jsxs(S, {
                    height: 133,
                    alignItems: "center",
                    direction: "row",
                    color: e.isPeriod && e.showUsdOnPeriod || t.swapValues ? e.profitAmount > 0 ? t.customGreen : t.customRed : (e.profitNative ?? 0) > 0 ? t.customGreen : t.customRed,
                    ml: e.chain === Pd.SOLANA ? -3.5 : -2.5,
                    gap: 1,
                    children: [e.isPeriod && e.showUsdOnPeriod || t.swapValues || !s ? null : v.jsx(C, {
                        display: "flex",
                        children: v.jsx(s, {
                            size: o,
                            color: "inherit",
                            shadow: t.textShadow ? U3 : void 0
                        })
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        fontFamily: Cu.INTER,
                        color: "inherit",
                        fontWeight: 700,
                        fontSize: 149,
                        lineHeight: "133px",
                        sx: t.textShadow ? W3 : void 0,
                        children: LI(Math.abs(e.isPeriod && e.showUsdOnPeriod || t.swapValues ? e.profitAmount : e.profitNative ?? 0), {
                            collapseExponent: !0,
                            symbol: e.isPeriod && e.showUsdOnPeriod || t.swapValues ? (0 === e.profitAmount ? "" : e.profitAmount > 0 ? "+" : "-") + "$" : 0 === (e.profitNative ?? 0) ? "" : (e.profitNative ?? 0) > 0 ? "+" : "-",
                            symbolPosition: yI.START,
                            padSymbol: !1
                        })
                    })]
                }), v.jsxs(S, {
                    mt: 2.5,
                    direction: "row",
                    gap: 9,
                    children: [null !== e.investedNative && v.jsx(_3, {
                        config: t,
                        label: r("Invested"),
                        chain: e.chain,
                        valueFormatted: LI(t.swapValues ? e.investedAmount : e.investedNative, {
                            symbol: t.swapValues ? "$" : "",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            collapseExponent: !0
                        }),
                        bottomValue: t.showUsdValues ? t.swapValues ? e.investedNative : e.investedAmount : null,
                        isReversed: !!t.swapValues
                    }), null !== e.remainingNative && v.jsx(_3, {
                        config: t,
                        label: r("Position"),
                        chain: e.chain,
                        valueFormatted: LI(t.swapValues ? e.remainingAmount : e.remainingNative, {
                            symbol: t.swapValues ? "$" : "",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            collapseExponent: !0
                        }),
                        bottomValue: t.showUsdValues ? t.swapValues ? e.remainingNative : e.remainingAmount : null,
                        isReversed: !!t.swapValues
                    }), e.isPeriod && void 0 !== e.totalBoughtNative && void 0 !== e.totalBoughtUsd && v.jsx(_3, {
                        config: t,
                        label: r("Total Bought"),
                        chain: e.showUsdOnPeriod ? null : Pd.SOLANA,
                        valueFormatted: LI(e.showUsdOnPeriod || t.swapValues ? e.totalBoughtUsd : e.totalBoughtNative, {
                            symbol: e.showUsdOnPeriod || t.swapValues ? "$" : "",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            collapseExponent: !0
                        }),
                        bottomValue: null,
                        isReversed: !!t.swapValues
                    }), e.isPeriod && void 0 !== e.totalSoldNative && void 0 !== e.totalSoldUsd && v.jsx(_3, {
                        config: t,
                        label: r("Total Sold"),
                        chain: e.showUsdOnPeriod ? null : Pd.SOLANA,
                        valueFormatted: LI(e.showUsdOnPeriod || t.swapValues ? e.totalSoldUsd : e.totalSoldNative, {
                            symbol: e.showUsdOnPeriod || t.swapValues ? "$" : "",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            collapseExponent: !0
                        }),
                        bottomValue: null,
                        isReversed: !!t.swapValues
                    }), v.jsx(_3, {
                        config: t,
                        label: r("PNL"),
                        chain: t.swapValues ? e.chain : null,
                        valueFormatted: jI(e.profitPercentage),
                        bottomValue: e.isPeriod ? null : t.showUsdValues ? t.swapValues ? e.profitNative : e.profitAmount : null,
                        color: e.profitPercentage > 0 ? t.customGreen : t.customRed,
                        isReversed: !!t.swapValues
                    })]
                })]
            }), e.refCode && v.jsxs(S, {
                position: "absolute",
                top: 130,
                right: 0,
                zIndex: V3,
                pr: 14,
                children: [v.jsx(k, {
                    textAlign: "end",
                    variant: "paragraph1",
                    fontFamily: Cu.INTER,
                    fontWeight: 400,
                    fontSize: 40,
                    color: t.customTextColor,
                    sx: t.textShadow ? W3 : void 0,
                    children: "Unlock 35% cashback"
                }), v.jsx(k, {
                    textAlign: "end",
                    variant: "paragraph1",
                    fontFamily: Cu.INTER,
                    fontWeight: 700,
                    fontSize: 40,
                    color: t.customTextColor,
                    sx: t.textShadow ? W3 : void 0,
                    children: `padre.gg/rk/${e.refCode}`
                })]
            }), v.jsx(C, {
                top: 0,
                left: 0,
                position: "absolute",
                sx: a
            })]
        })
    })
}
))
  , B3 = 24
  , _3 = ({config: e, label: t, chain: n, valueFormatted: r, bottomValue: a, isReversed: s, color: o}) => {
    const [l,i,c,d,u] = y.useMemo(( () => z3(n)), [n]);
    return v.jsxs(S, {
        minWidth: 282,
        gap: 2.5,
        children: [v.jsxs(S, {
            gap: 1.25,
            children: [v.jsx(k, {
                variant: "paragraph1",
                fontFamily: Cu.INTER,
                fontWeight: 400,
                fontSize: 45,
                color: e.customTextColor,
                sx: {
                    opacity: e.textShadow ? 1 : .5,
                    ...e.textShadow ? W3 : {}
                },
                children: t
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                color: o ?? e.customTextColor,
                height: 73,
                ml: n ? n === Pd.SOLANA ? -1 : -.5 : 0,
                children: [!s && l && v.jsx(C, {
                    display: "flex",
                    mt: u,
                    overflow: "visible",
                    children: v.jsx(l, {
                        size: c,
                        color: "inherit",
                        shadow: e.textShadow ? U3 : void 0
                    })
                }), v.jsx(k, {
                    variant: "paragraph1",
                    fontFamily: Cu.INTER,
                    fontWeight: 700,
                    fontSize: 60,
                    color: "inherit",
                    sx: e.textShadow ? W3 : void 0,
                    children: r
                })]
            })]
        }), null !== a && v.jsxs(k, {
            variant: "paragraph1",
            display: "flex",
            fontFamily: Cu.INTER,
            fontWeight: 400,
            fontSize: 45,
            color: o ?? e.customTextColor,
            sx: o ? e.textShadow ? W3 : {} : {
                opacity: e.textShadow ? 1 : .5,
                ...e.textShadow ? W3 : {}
            },
            children: ["(", s && l && v.jsx(C, {
                display: "flex",
                mt: d,
                overflow: "visible",
                children: v.jsx(l, {
                    size: i,
                    color: "inherit",
                    shadow: e.textShadow ? U3 : void 0
                })
            }), `${LI(Math.abs(a), {
                collapseExponent: !0,
                maxPrecision: 2,
                minPrecision: 2,
                symbol: ""
            })}${s ? "" : " USD"})`]
        })]
    })
}
  , U3 = "2px 2px 6px black"
  , W3 = {
    textShadow: U3
}
  , F3 = {
    filter: `drop-shadow(${U3})`
}
  , V3 = 2
  , H3 = 1
  , z3 = e => {
    switch (e) {
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return [Bf, 46, 56, .25, 0];
    case Pd.SOLANA:
        return [Jv, 50, 73, 0, .5];
    case Pd.BSC:
        return [rk, 47, 64, 0, .25];
    default:
        return [null, 0, 0, 0, 0]
    }
}
  , $3 = e => {
    switch (e) {
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return [Bf, 143];
    case Pd.SOLANA:
        return [Jv, 175];
    case Pd.BSC:
        return [rk, 156];
    default:
        return [null, 0]
    }
}
  , G3 = y.memo(( ({selectedBg: e, data: t, displayWidth: n, displayHeight: r, config: a, imageToSaveRef: s, setGifProgress: o}) => {
    const l = bw()
      , i = y.useRef(null)
      , c = y.useRef(null)
      , [d,u] = y.useState(null)
      , [p,h] = y.useState(!0)
      , m = y.useRef(null)
      , g = y.useRef(null)
      , x = 1980
      , b = 1320
      , f = y.useCallback((async () => {
        const t = (Math.random() * Math.random()).toFixed(16);
        g.current = t;
        const n = i.current
          , r = c.current;
        if (!n || !r)
            return;
        const a = n.getContext("2d");
        if (!a)
            return;
        s.current = new Promise((e => {
            m.current = e
        }
        )),
        h(!0),
        u(null),
        n.width = x,
        n.height = b;
        const l = new Image;
        l.crossOrigin = "anonymous",
        l.src = e.src,
        l.onload = async () => {
            const s = l.width / l.height
              , i = n.width / n.height;
            let c = 0
              , d = 0
              , p = l.width
              , x = l.height;
            if (s > i) {
                const e = l.height * i;
                c = (l.width - e) / 2,
                p = e
            } else {
                const e = l.width / i;
                d = (l.height - e) / 2,
                x = e
            }
            if (e.isGif ?? !1) {
                o(5);
                const e = .5
                  , s = n.width * e
                  , i = n.height * e
                  , h = new Yt({
                    workers: 5,
                    quality: 20,
                    width: s,
                    height: i,
                    workerScript: "/gif.worker.js"
                })
                  , b = await Y3(l);
                for (let n = 0; n < b.length; n++) {
                    if (o(5 + n / b.length * 95),
                    g.current !== t)
                        return;
                    const e = b[n];
                    a.clearRect(0, 0, s, i),
                    a.drawImage(e.image, c, d, p, x, 0, 0, s, i);
                    const l = await Xt(r, {
                        useCORS: !0,
                        backgroundColor: null,
                        scale: .5
                    });
                    if (g.current !== t)
                        return;
                    if (a.drawImage(l, 0, 0),
                    h.addFrame(a, {
                        copy: !0,
                        delay: e.delay
                    }),
                    g.current !== t)
                        return
                }
                if (g.current !== t)
                    return;
                h.on("finished", (e => {
                    const t = new FileReader;
                    t.onloadend = () => {
                        const e = t.result;
                        u(e),
                        m.current && m.current(e)
                    }
                    ,
                    t.readAsDataURL(e)
                }
                )),
                h.render()
            } else {
                a.drawImage(l, c, d, p, x, 0, 0, n.width, n.height);
                const e = await Xt(r, {
                    useCORS: !0,
                    backgroundColor: null,
                    scale: 1
                });
                a.drawImage(e, 0, 0);
                const t = n.toDataURL("image/png");
                u(t),
                m.current && m.current(t)
            }
            g.current === t && (h(!1),
            o(null))
        }
        ,
        l.onerror = () => {
            g.current === t && (h(!1),
            o(null))
        }
    }
    ), [s, e, b, x, o]);
    y.useEffect(( () => {
        (async () => {
            try {
                f()
            } catch (fNe) {}
        }
        )()
    }
    ), [f, a]);
    const k = y.useMemo(( () => ({
        transform: `scale(${n / x})`
    })), [x, n])
      , A = y.useMemo(( () => ({
        width: "100%",
        height: "100%",
        backgroundImage: `url(${e.src})`,
        backgroundSize: "cover",
        backgroundPosition: "center"
    })), [e.src])
      , w = y.useMemo(( () => ({
        width: x,
        height: b,
        position: "absolute"
    })), [x, b])
      , j = y.useMemo(( () => ({
        width: x,
        height: b,
        position: "absolute",
        top: -1e4,
        left: -1e4
    })), [x, b]);
    return v.jsxs(S, {
        alignItems: "center",
        spacing: 2,
        children: [v.jsxs(S, {
            width: n,
            height: r,
            justifyContent: "center",
            alignItems: "center",
            position: "relative",
            children: [p && v.jsx(S, {
                position: "absolute",
                left: l ? 90 - n : void 0,
                top: l ? 60 - r : void 0,
                width: x,
                height: b,
                sx: k,
                children: v.jsx(C, {
                    position: "relative",
                    sx: A,
                    children: v.jsx("div", {
                        style: w,
                        children: v.jsx(D3, {
                            data: t,
                            config: a,
                            isPreview: !0
                        })
                    })
                })
            }), !p && d && v.jsx("img", {
                src: d,
                alt: "Generated",
                style: q3
            })]
        }), v.jsx("div", {
            ref: c,
            style: j,
            children: v.jsx(D3, {
                data: t,
                config: a
            })
        }), v.jsx("canvas", {
            ref: i,
            style: K3
        })]
    })
}
))
  , q3 = {
    width: "100%",
    height: "100%",
    objectFit: "cover"
}
  , K3 = {
    display: "none"
}
  , Y3 = async e => {
    const t = await fetch(e.src)
      , n = await t.arrayBuffer()
      , r = Qt(n)
      , a = Zt(r, !0)
      , s = document.createElement("canvas");
    s.width = e.width,
    s.height = e.height;
    const o = s.getContext("2d")
      , l = [];
    let i = null
      , c = null;
    for (const d of a) {
        if (i)
            switch (i.disposalType) {
            case 2:
                o.clearRect(i.dims.left, i.dims.top, i.dims.width, i.dims.height);
                break;
            case 3:
                c && o.putImageData(c, 0, 0)
            }
        3 === d.disposalType && (c = o.getImageData(0, 0, s.width, s.height));
        const {left: e, top: t, width: n, height: r} = d.dims
          , a = new ImageData(new Uint8ClampedArray(d.patch),n,r)
          , u = await createImageBitmap(a);
        o.drawImage(u, e, t);
        const p = new Image;
        p.src = s.toDataURL(),
        await new Promise((e => p.onload = e)),
        l.push({
            image: p,
            delay: d.delay ?? 100
        }),
        i = d
    }
    return l
}
;
let X3 = {
    images: [],
    ts: 0
};
const Q3 = ({children: e}) => {
    const {t: t} = we()
      , n = bw()
      , [r,a] = y.useState(!1)
      , s = pK()
      , [o,l] = y.useState(null)
      , c = F5()
      , [d,u] = y.useState(null)
      , {customBackgrounds: p, refreshCustomBackgrounds: h} = ( () => {
        const e = Ax()
          , [t,n] = y.useState(null)
          , [r,a] = y.useState(!1)
          , s = y.useCallback((async (t=!1) => {
            if ((t || r) && e)
                try {
                    const t = (await Pm.getUserCustomBackgrounds(e)).result.map((e => ({
                        src: e.imageUri,
                        isGif: "image/gif" === e.contentType,
                        isCustom: !0,
                        id: e.uuid
                    })));
                    X3 = {
                        images: t,
                        ts: i().unix()
                    },
                    n(t)
                } catch (fNe) {}
        }
        ), [r, e]);
        return y.useEffect(( () => {
            !r && e && (X3.images.length && i().unix() - 600 < X3.ts ? n(X3.images) : (a(!0),
            s(!0)))
        }
        ), [r, s, e]),
        {
            customBackgrounds: t,
            refreshCustomBackgrounds: s
        }
    }
    )()
      , m = y.useMemo(( () => [...o ? [o] : [], ...e3, ...p ?? []]), [p, o])
      , [g,x] = Mx("padreV2-shareProfitSelectedBackground", m[0]);
    y.useEffect(( () => {
        null !== p && (m.some((e => e.src === g.src)) || x(m[0]))
    }
    ), [m, g, x, p]);
    const [b,f] = Mx("padreV2-shareProfitConfig", J5)
      , A = y.useCallback((e => {
        u(e),
        f((e => ({
            ...e
        })))
    }
    ), [f])
      , w = y.useRef(null)
      , j = y.useCallback((async () => {
        if (!w.current)
            return;
        const e = document.createElement("a")
          , t = d ? `padre-${d.symbol.toLowerCase()}-pnl` : "padre-pnl"
          , n = g.isGif ? "gif" : "png"
          , r = `${t}.${n}`;
        e.href = await w.current,
        e.download = r,
        e.title = r,
        e.type = n,
        document.body.appendChild(e),
        e.click(),
        document.body.removeChild(e)
    }
    ), [d, g.isGif])
      , T = y.useCallback((async () => {
        if (w.current)
            try {
                const e = await fetch(await w.current)
                  , t = await e.blob();
                await navigator.clipboard.write([new ClipboardItem({
                    [t.type]: t
                })]),
                s({
                    message: uu.backgroundClipboardSaved,
                    type: "success"
                }, "clipboard-pnl-card-save-success")
            } catch (W$e) {
                s({
                    message: uu.clipboardEnableAccess,
                    snackName: pu.clipboardUnavailable,
                    type: "error"
                }, "clipboard-pnl-card-save-error")
            }
    }
    ), [s])
      , [I,E] = y.useState(!1)
      , [M,N] = y.useState(null)
      , P = y.useCallback(( () => {
        E(!0)
    }
    ), [])
      , O = y.useCallback(( () => {
        E(!1),
        N(null)
    }
    ), [])
      , L = y.useCallback(( () => {
        a(!1),
        u(null),
        N(null)
    }
    ), [])
      , D = y.useCallback((e => {
        a(!0),
        u(e)
    }
    ), [])
      , [B,_] = y.useState(!1)
      , U = y.useCallback(( () => {
        _(!0)
    }
    ), [])
      , W = y.useCallback(( () => {
        _(!1),
        N(null)
    }
    ), [])
      , F = y.useMemo(( () => ({
        open: D,
        isOpen: r,
        config: b,
        setConfig: f
    })), [D, r, b, f]);
    return v.jsxs(j3.Provider, {
        value: F,
        children: [e, v.jsxs(U5, {
            title: null,
            close: L,
            isOpen: r && !!d,
            modalLayoutProps: l4,
            children: [v.jsxs(S, {
                gap: 1,
                children: [v.jsx(S, {
                    justifyContent: "center",
                    alignItems: "center",
                    overflow: "hidden",
                    children: d && v.jsxs(C, {
                        sx: n4,
                        display: "flex",
                        position: "relative",
                        children: [v.jsx(G3, {
                            selectedBg: g,
                            data: d,
                            displayWidth: n ? Z3 : e4,
                            displayHeight: n ? J3 : t4,
                            config: b,
                            imageToSaveRef: w,
                            setGifProgress: N
                        }), g.isGif && null !== M && v.jsx(C, {
                            position: "absolute",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            zIndex: 10,
                            sx: a4,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                children: [v.jsxs(k, {
                                    variant: "paragraph1",
                                    fontSize: n ? 22 : 16,
                                    color: "text.value",
                                    sx: s4,
                                    children: ["Generating", v.jsx(D5, {})]
                                }), v.jsx(J, {
                                    size: n ? 22 : 16,
                                    variant: "determinate",
                                    value: M,
                                    sx: r4
                                })]
                            })
                        })]
                    })
                }), v.jsx(o3, {
                    availableBackgrounds: m,
                    selectedBackground: g.src,
                    onSelect: x,
                    refreshCustomBackgrounds: h,
                    customBackgroundsCount: null === p ? null : p.length
                }), v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: 1,
                        children: [v.jsx(V, {
                            variant: "tertiary",
                            size: "xxsmall",
                            onClick: P,
                            children: "Customize"
                        }), c && d && !R && v.jsx(V, {
                            variant: "tertiary",
                            size: "xxsmall",
                            onClick: U,
                            sx: o4,
                            children: "APG"
                        })]
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: 1,
                        children: [v.jsx(V, {
                            variant: "tertiary",
                            size: "xxsmall",
                            startIcon: v.jsx(xS, {}),
                            onClick: j,
                            disabled: g.isGif && null !== M,
                            children: "Download"
                        }), v.jsx(GC, {
                            title: t("Copy unavailable for gifs"),
                            children: v.jsx(C, {
                                display: "flex",
                                component: "span",
                                children: v.jsx(V, {
                                    variant: "tertiary",
                                    size: "xxsmall",
                                    startIcon: v.jsx(gk, {}),
                                    onClick: T,
                                    disabled: g.isGif,
                                    children: "Copy"
                                })
                            })
                        })]
                    })]
                })]
            }), v.jsx(L3, {
                isOpen: I,
                onClose: O
            }), B && c && d && !R && v.jsx(n3, {
                isOpen: B,
                onClose: W,
                setLocalBackground: l,
                saveValues: A,
                initialValues: d
            })]
        })]
    })
}
  , Z3 = 720
  , J3 = 480
  , e4 = 315
  , t4 = 210
  , n4 = e => ({
    border: `1px solid ${e.palette.background.borderMain}`,
    borderRadius: 1,
    overflow: "hidden"
})
  , r4 = {
    "& .MuiCircularProgress-circle": {
        animation: "none"
    }
}
  , a4 = {
    background: "rgba(0, 0, 0, 0.5)"
}
  , s4 = {
    textShadow: "2px 2px 6px #1F1F1F"
}
  , o4 = {
    opacity: 0,
    px: .5,
    "&:hover": {
        opacity: 1
    }
}
  , l4 = {
    maxDesktopHeight: "100%",
    maxDesktopWidth: 756,
    stackSx: {
        p: 2
    }
}
  , i4 = y.memo(( ({imageData: e, tooltipTitle: t="Flex your PNL", iconSize: n=c4, padding: r=d4}) => {
    const a = D()
      , s = y.useMemo(( () => e), [e])
      , o = y.useMemo(( () => ({
        p: r
    })), [r])
      , {open: l} = T3()
      , i = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        l(s)
    }
    ), [s, l]);
    return v.jsx(GC, {
        title: t,
        children: v.jsx(F, {
            onClick: i,
            sx: o,
            children: v.jsx(Nk, {
                size: n,
                color: a.palette.gold[500]
            })
        })
    })
}
))
  , c4 = 16
  , d4 = 1
  , u4 = () => y.useMemo(( () => Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"), []);
i.extend(Jt);
const p4 = i.utc("2025-07-10");
i.extend(en);
const h4 = (e, t) => [(e[0] ?? 0) + (t[0] ?? 0), (e[1] ?? 0) + (t[1] ?? 0), (e[2] ?? 0) + (t[2] ?? 0), (e[3] ?? 0) + (t[3] ?? 0), (e[4] ?? 0) + (t[4] ?? 0), (e[5] ?? 0) + (t[5] ?? 0)]
  , m4 = e => {
    const [t,n,r,a,s,o] = e.data
      , l = n - t
      , i = s - a
      , c = t ? l / t * 100 : 0
      , d = a ? i / a * 100 : 0;
    return {
        ts: e.startTs,
        value: l,
        nativeValue: i,
        valuePercentage: c,
        valuePercentageNative: d,
        totalBoughtUsd: t,
        totalBoughtNative: a,
        totalSoldUsd: n,
        totalSoldNative: s,
        totalFeesNative: o,
        totalFeesUsd: r
    }
}
  , g4 = e => Math.round(e).toString(16).padStart(2, "0").toUpperCase()
  , x4 = (e, t, n) => {
    if (0 === t.length)
        return [];
    const r = i.unix(t[t.length - 1]).tz(n).add(1, "day").startOf("day").unix()
      , a = c.reduce(e.flat(), ( (e, t) => (t.hourlyData,
    ( (e, t) => {
        var n, r, a;
        for (const s in t) {
            const o = Number(s);
            e[o] = {
                data: h4((null == (n = e[o]) ? void 0 : n.data) ?? [], t[o].data ?? []),
                buys: (null == (r = e[o]) ? void 0 : r.buys) ?? 0 + t[o].buys ?? 0,
                sells: (null == (a = e[o]) ? void 0 : a.sells) ?? 0 + t[o].sells ?? 0
            }
        }
    }
    )(e, t.hourlyData ?? {}),
    e)), {});
    return t.map(( (e, n) => {
        const s = {
            startTs: e,
            data: [0, 0, 0, 0, 0, 0],
            buys: 0,
            sells: 0
        }
          , o = [];
        for (let l = e; l < (n + 1 < t.length ? t[n + 1] : r); l += 3600)
            if (a[l]) {
                s.data = h4(s.data, a[l].data),
                s.buys += a[l].buys,
                s.sells += a[l].sells;
                const [e,t] = a[l].data;
                o.push({
                    ts: l,
                    value: t - e
                })
            } else
                o.push({
                    ts: l,
                    value: 0
                });
        return {
            merged: s,
            hourlyValues: o
        }
    }
    )).map(( ({merged: e, hourlyValues: t}) => ({
        ...m4(e),
        hourlyValues: t
    })))
}
  , b4 = y.memo(( ({date: e, currencyMode: t, usdPnl: n, nativePnl: r, percentagePnl: a, totalBoughtUsd: s, totalBoughtNative: o, totalSoldUsd: l, totalSoldNative: i, refCodeRef: c, isTopMonth: d, colorMultiplier: u}) => {
    const p = D()
      , {open: h} = T3()
      , [m,g,x,b,f] = y.useMemo(( () => {
        const a = t === uZ.USD ? n : r
          , [s,o] = ( (e, t, n) => {
            if (!e)
                return ["FF", "FF"];
            const r = n * (t ? .15 : 25.5)
              , a = n * (t ? 5 : 850)
              , s = 6 + (lb(Math.abs(e), {
                min: r,
                max: a
            }) - r) / (a - r) * 30;
            return [g4(s), g4(s + 8)]
        }
        )(a, t === uZ.NATIVE, u);
        return [a ? Math.abs(a) < .01 && t === uZ.USD ? `<${a < 0 ? "-" : ""}0.01$` : `${a < 0 ? "-" : "+"}${LI(Math.abs(a), {
            collapseExponent: !0,
            maxPrecision: 2,
            minPrecision: 2,
            symbol: t === uZ.USD ? "$" : "",
            symbolPosition: yI.START,
            padSymbol: !1
        })}` : t === uZ.USD ? "0$" : "0", a ? d && a > 0 ? p.palette.gold[500] : a > 0 ? p.palette.positive.main : p.palette.negative.main : null, a ? d && a > 0 ? `${p.palette.yellow[500]}24` : `${a > 0 ? p.palette.positive.main : p.palette.negative.main}${s}` : p.palette.background.default, a ? d && a > 0 ? `${p.palette.yellow[500]}40` : `${a > 0 ? p.palette.positive.main : p.palette.negative.main}${o}` : p.palette.background.default, e.date()]
    }
    ), [t, e, d, r, p.palette.background.default, p.palette.yellow, p.palette.gold, p.palette.negative.main, p.palette.positive.main, n, u])
      , C = y.useMemo(( () => ({
        height: {
            xs: 55,
            sm: 80
        },
        p: {
            xs: .5,
            sm: 1
        },
        backgroundColor: x,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        position: "relative",
        ...null !== n && null !== r ? {
            "&:hover": {
                cursor: "pointer",
                backgroundColor: b
            }
        } : {}
    })), [x, b, r, n])
      , A = y.useCallback(( () => {
        null !== n && null !== r && null !== a && null !== s && null !== o && null !== l && null !== i && h({
            symbol: e.format("D MMM YYYY"),
            chain: Pd.SOLANA,
            investedAmount: 0,
            investedNative: null,
            profitAmount: n,
            profitNative: r,
            profitPercentage: a,
            remainingAmount: 0,
            remainingNative: null,
            refCode: c.current,
            holdTime: null,
            multiplier: null,
            isPeriod: !0,
            showUsdOnPeriod: t === uZ.USD,
            totalBoughtUsd: s,
            totalBoughtNative: o,
            totalSoldUsd: l,
            totalSoldNative: i
        })
    }
    ), [n, r, s, o, l, i, h, e, c, t, a]);
    return v.jsxs(ee, {
        sx: C,
        onClick: A,
        children: [v.jsx(k, {
            variant: "paragraph3",
            position: "absolute",
            color: g ? `${g}AA` : "text.label",
            fontSize: 10,
            top: 4,
            left: 4,
            children: f
        }), v.jsxs(S, {
            direction: "row",
            gap: .25,
            alignItems: "center",
            justifyContent: "center",
            height: 12,
            children: [t === uZ.NATIVE && v.jsx(dk, {
                size: 12
            }), v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: g ?? "text.value",
                children: m
            })]
        })]
    })
}
));
i.extend(Jt),
i.extend(en);
const f4 = y.memo(( ({data: e, month: t, browserTz: n, currencyMode: r, isLoading: a, isBeingBackfilled: s}) => {
    const o = xw()
      , {userStats: l} = rH();
    y.useEffect(( () => {
        p.current = l.status === ox.READY && "kol" === l.data.type ? l.data.kolName : null
    }
    ), [l]);
    const d = y.useMemo(( () => c.reduce(Object.entries(e), ( (e, t) => (t[1].nativeValue <= 0 || e.topNativeValue < t[1].nativeValue && !isNaN(Number(t[0])) && (e.ts = Number(t[0]),
    e.topNativeValue = t[1].nativeValue),
    e)), {
        topNativeValue: 0,
        ts: null
    })), [e])
      , u = y.useMemo(( () => d.topNativeValue <= 5 ? 1 : Math.max(1, d.topNativeValue / 5 - .25)), [d.topNativeValue])
      , p = y.useRef(null)
      , h = y.useMemo(( () => {
        const a = i().tz(n).startOf("day").unix()
          , s = t
          , o = s.daysInMonth()
          , l = (s.day() + 6) % 7
          , c = Array(l).fill(null);
        for (let t = 0; t < o; t++) {
            const n = s.add(t, "day")
              , o = n.startOf("day").unix();
            if (o > a) {
                c.push(null);
                continue
            }
            const l = o === d.ts
              , i = e[o];
            c.push(v.jsx(b4, {
                date: n,
                currencyMode: r,
                usdPnl: i ? i.value : null,
                nativePnl: i ? i.nativeValue : null,
                percentagePnl: i ? r === uZ.USD ? i.valuePercentage : i.valuePercentageNative : null,
                totalBoughtUsd: i ? i.totalBoughtUsd : null,
                totalBoughtNative: i ? i.totalBoughtNative : null,
                totalSoldUsd: i ? i.totalSoldUsd : null,
                totalSoldNative: i ? i.totalSoldNative : null,
                refCodeRef: p,
                isTopMonth: l,
                colorMultiplier: u
            }, o))
        }
        return c
    }
    ), [u, r, e, t, n, d.ts]);
    return v.jsxs(S, {
        gap: .5,
        position: "relative",
        flexGrow: 1,
        children: [v.jsx(tn, {
            container: !0,
            spacing: v4,
            children: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"].map((e => v.jsx(tn, {
                item: !0,
                xs: 12 / 7,
                children: v.jsx(C, {
                    display: "flex",
                    justifyContent: "center",
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        textAlign: "center",
                        children: e
                    })
                })
            }, e)))
        }), v.jsx(tn, {
            container: !0,
            spacing: v4,
            children: h.map(( (e, t) => v.jsx(tn, {
                item: !0,
                xs: 12 / 7,
                children: e || v.jsx(C, {
                    height: o ? 80 : 55
                })
            }, t)))
        }), s && v.jsx(C, {
            position: "absolute",
            justifyContent: "center",
            alignItems: "center",
            display: "flex",
            sx: S4,
            children: v.jsx(k, {
                textAlign: "center",
                variant: "paragraph1",
                color: "text.value",
                children: "Data is being backfilled, come back in the next couple of days"
            })
        }), a && !s && v.jsx(C, {
            position: "absolute",
            justifyContent: "center",
            alignItems: "center",
            sx: S4,
            children: v.jsx(Km, {})
        })]
    })
}
))
  , v4 = .5
  , S4 = e => ({
    width: "100%",
    height: "100%",
    background: `${e.palette.background.secondary}A0`
});
i.extend(Jt),
i.extend(en);
const y4 = {}
  , k4 = (e, t, n) => {
    const [r,a] = y.useState({
        status: ox.INITIAL
    });
    return y.useEffect(( () => {
        const r = e.isSame(i().tz(t).startOf("month"), "month")
          , {startTs: s, endTs: o} = (e => ({
            startTs: e.utc().startOf("day").subtract(1, "day").unix(),
            endTs: e.add(1, "month").utc().startOf("day").add(1, "day").unix()
        }))(e);
        i.unix(s).isAfter(p4) ? (async () => {
            try {
                a({
                    status: ox.LOADING
                });
                const l = n.map((e => (async () => {
                    const t = ( (e, t) => `${e}-${t}`)(e, s)
                      , n = y4[t];
                    if (n && !r)
                        return n;
                    if (n && r) {
                        const r = await xm.getDailyPnlV2(ng(e), s, o)
                          , a = c.reduce(r, ( (e, t) => e = [...e.filter((e => e.startTs !== t.startTs)), t]), [...n]);
                        return y4[t] = a,
                        a
                    }
                    const a = await xm.getDailyPnlV2(ng(e), s, o);
                    return y4[t] = a,
                    a
                }
                )()))
                  , i = await Promise.all(l)
                  , d = x4(i, (e => {
                    const t = e.daysInMonth();
                    return Array.from({
                        length: t
                    }, ( (t, n) => e.clone().add(n, "day").startOf("day").unix()))
                }
                )(e), t);
                a({
                    status: ox.READY,
                    data: d
                })
            } catch (fNe) {
                a({
                    status: ox.ERROR
                })
            }
        }
        )() : a({
            status: ox.READY,
            data: []
        })
    }
    ), [e, t, n]),
    r
}
;
i.extend(Jt),
i.extend(en);
const C4 = y.memo(( ({onClose: e, wallets: t}) => {
    const {t: n} = we()
      , r = u4()
      , a = D()
      , {settings: s} = rf()
      , [o,l] = Mx("padreV2-pnlCalendarCurrencyMode", uZ.USD)
      , d = y.useCallback(( () => {
        l((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [l])
      , [u,p] = y.useState(i().tz(r).startOf("month"))
      , h = y.useCallback(( () => {
        p((e => e.subtract(1, "month")))
    }
    ), [])
      , m = y.useCallback(( () => {
        p((e => e.add(1, "month")))
    }
    ), [])
      , g = y.useMemo(( () => u.subtract(1, "month").isBefore(p4)), [u])
      , x = y.useMemo(( () => u.add(1, "month").isAfter(i())), [u])
      , b = VV(Pd.SOLANA)
      , f = k4(u, r, t)
      , A = y.useMemo(( () => f.status !== ox.READY ? f : s ? s.markPriceMode === Gh.TXN_TIME ? f : null === b ? {
        status: ox.LOADING
    } : {
        status: ox.READY,
        data: f.data.map((e => ({
            ...e,
            value: e.nativeValue * b,
            valuePercentageNative: e.valuePercentage,
            totalBoughtUsd: e.totalBoughtNative * b,
            totalSoldUsd: e.totalSoldNative * b,
            totalFeesUsd: e.totalFeesNative * b
        })))
    } : {
        status: ox.LOADING
    }), [f, s, b])
      , {userStats: w} = rH()
      , j = y.useMemo(( () => !u.isAfter(p4)), [u])
      , T = y.useMemo(( () => {
        if (A.status !== ox.READY)
            return null;
        if (j)
            return null;
        const {periodLabel: e, totalPnl: t, totalNativePnl: n, percentagePnl: r, totalBoughtUsd: a, totalBoughtNative: s, totalSoldUsd: l, totalSoldNative: i} = ( (e, t, n) => {
            const {totalPnl: r, totalNativePnl: a, totalBoughtUsd: s, totalBoughtNative: o, totalSoldUsd: l, totalSoldNative: i} = c.reduce(e, ( (e, t) => (e.totalPnl += t.value,
            e.totalNativePnl += t.nativeValue,
            e.totalBoughtUsd += t.totalBoughtUsd,
            e.totalBoughtNative += t.totalBoughtNative,
            e.totalSoldUsd += t.totalSoldUsd,
            e.totalSoldNative += t.totalSoldNative,
            e.totalFeesUsd += t.totalFeesUsd,
            e.totalFeesNative += t.totalFeesNative,
            e)), {
                totalPnl: 0,
                totalNativePnl: 0,
                totalBoughtUsd: 0,
                totalBoughtNative: 0,
                totalSoldUsd: 0,
                totalSoldNative: 0,
                totalFeesUsd: 0,
                totalFeesNative: 0
            });
            return {
                periodLabel: t.format("MMM YYYY"),
                totalPnl: r,
                totalNativePnl: a,
                percentagePnl: n === uZ.NATIVE ? o ? a / o * 100 : 0 : s ? r / s * 100 : 0,
                totalBoughtUsd: s,
                totalBoughtNative: o,
                totalSoldUsd: l,
                totalSoldNative: i
            }
        }
        )(A.data, u, o);
        return {
            symbol: e,
            chain: Pd.SOLANA,
            investedAmount: 0,
            investedNative: null,
            profitAmount: t,
            profitNative: n,
            profitPercentage: r,
            remainingAmount: 0,
            remainingNative: null,
            refCode: w.status === ox.READY && "kol" === w.data.type ? w.data.kolName : null,
            holdTime: null,
            multiplier: null,
            isPeriod: !0,
            showUsdOnPeriod: o === uZ.USD,
            totalBoughtUsd: a,
            totalBoughtNative: s,
            totalSoldUsd: l,
            totalSoldNative: i
        }
    }
    ), [o, A, u, w, j])
      , [I,E] = y.useMemo(( () => s ? s.markPriceMode === Gh.CURRENT && null === b ? [{}, !0] : A.status === ox.READY ? [c.reduce(A.data, ( (e, t) => (e[t.ts] = t,
    e)), {}), !1] : A.status === ox.ERROR ? [{}, !1] : [{}, !0] : [{}, !0]), [A, s, b]);
    return v.jsxs(S, {
        gap: 3,
        flexGrow: 1,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: n("PNL Calendar (Solana)")
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(F, {
                        sx: A4,
                        onClick: h,
                        disabled: g || E,
                        children: v.jsx(ky, {
                            color: g || E ? a.palette.text.disabled : a.palette.text.value
                        })
                    }), v.jsx(k, {
                        variant: "h2",
                        minWidth: 75,
                        textAlign: "center",
                        children: u.format("MMM YYYY")
                    }), v.jsx(F, {
                        sx: A4,
                        onClick: m,
                        disabled: x || E,
                        children: v.jsx(Cy, {
                            color: x || E ? a.palette.text.disabled : a.palette.text.value
                        })
                    })]
                }), v.jsx(GC, {
                    title: o === uZ.NATIVE ? n("Switch currency to USD") : n("Switch currency to SOL/ETH"),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            onClick: d,
                            variant: "tertiary",
                            sx: w4,
                            children: v.jsx(gS, {
                                color: o === uZ.NATIVE ? a.palette.positive.main : a.palette.text.label,
                                size: 14
                            })
                        })
                    })
                }), T && !j ? v.jsx(i4, {
                    imageData: T,
                    tooltipTitle: n("Flex your monthly PNL")
                }) : v.jsx(C, {
                    display: "flex",
                    width: 28
                }), v.jsx(F, {
                    sx: A4,
                    onClick: e,
                    children: v.jsx(gy, {})
                })]
            })]
        }), v.jsx(f4, {
            data: I,
            month: u,
            browserTz: r,
            currencyMode: o,
            isLoading: E,
            isBeingBackfilled: j
        })]
    })
}
))
  , A4 = {
    p: 0,
    width: 16,
    minWidth: 16,
    height: 16
}
  , w4 = {
    px: 0,
    height: 28,
    minWidth: 28
}
  , j4 = y.memo(( ({isOpen: e, onClose: t, wallets: n}) => e ? v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: T4,
    maxDesktopWidth: I4,
    minDesktopHeight: 615,
    children: v.jsx(C4, {
        onClose: t,
        wallets: n
    })
}) : null))
  , T4 = {
    zIndex: 1309,
    p: 2
}
  , I4 = 820
  , E4 = y.memo(( ({wallets: e, showLabel: t}) => {
    const {t: n} = we()
      , [r,a] = y.useState(!1)
      , s = y.useCallback(( () => {
        a(!0)
    }
    ), [])
      , o = y.useCallback(( () => {
        a(!1)
    }
    ), [])
      , l = y.useMemo(( () => e => ({
        ...O5(e, !0),
        ...t ? {
            width: 78,
            height: 22,
            gap: .5,
            alignItems: "center"
        } : {}
    })), [t]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(GC, {
            title: n("PNL Calendar"),
            children: v.jsx(C, {
                display: "flex",
                component: "span",
                children: v.jsxs(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: s,
                    sx: l,
                    children: [t && v.jsx(k, {
                        variant: "paragraph3",
                        color: "inherit",
                        sx: N4,
                        children: n("Calendar")
                    }), v.jsx(Oe, {
                        sx: M4
                    })]
                })
            })
        }), v.jsx(j4, {
            isOpen: r,
            onClose: o,
            wallets: e
        })]
    })
}
))
  , M4 = e => ({
    fontSize: 14,
    color: e.palette.text.label
})
  , N4 = {
    mt: .25
}
  , P4 = ({valueScaled: e, value: t, width: n, prefix: r, showLabel: a=!0, color: s, textBelow: o=!1}) => {
    const l = D();
    return v.jsxs(v.Fragment, {
        children: [a && v.jsx(nn, {
            fill: s ?? l.palette.text.meta,
            dy: e + (o ? 13 : -3),
            textAnchor: "end",
            dx: n,
            fontSize: O4,
            children: `${r ? `${r} ` : ""}${t < 0 ? "-" : ""}${LI(Math.abs(t), {
                symbol: "$",
                padSymbol: !1,
                symbolPosition: yI.START,
                maxPrecision: 2
            })}`
        }), v.jsx(rn, {
            from: {
                x: 0,
                y: e
            },
            to: {
                x: n,
                y: e
            },
            stroke: l.palette.text.meta,
            strokeWidth: 1,
            strokeDasharray: "2,2",
            opacity: .2,
            pointerEvents: "none"
        })]
    })
}
  , O4 = 12
  , L4 = O4 + 4 + 2;
i.extend(Jt),
i.extend(en);
const R4 = (e, t) => {
    const [n,r] = y.useState({
        status: ox.INITIAL
    });
    return y.useEffect(( () => {
        let n = !1;
        if (e)
            return (async () => {
                try {
                    r({
                        status: ox.LOADING
                    });
                    const a = await D4(e)
                      , s = x4(a, (e => {
                        const t = []
                          , n = i().tz(e).startOf("day");
                        for (let r = 29; r >= 0; --r) {
                            const e = n.clone().subtract(r, "day").startOf("day").unix();
                            t.push(e)
                        }
                        return t
                    }
                    )(t), t);
                    if (n)
                        return;
                    r({
                        status: ox.READY,
                        data: s
                    })
                } catch (W$e) {
                    if (n)
                        return;
                    r({
                        status: ox.ERROR
                    })
                }
            }
            )(),
            () => {
                n = !0
            }
            ;
        r({
            status: ox.INITIAL
        })
    }
    ), [e, t]),
    n
}
  , D4 = async e => Promise.all(e.map((e => xm.getDailyPnl(e, 32))))
  , B4 = y.memo(( ({walletAddress: e, perfTimespan: t, setPerfTimespan: n}) => {
    const r = xw()
      , {t: a} = we()
      , s = y.useMemo(( () => [e]), [e])
      , o = u4()
      , l = R4(s, o)
      , c = y.useMemo(( () => {
        if (l.status !== ox.READY)
            return [];
        const e = l.data ?? [];
        if ("day" === t) {
            const t = i(1e3 * ZA()).startOf("hour").unix()
              , n = t - 82800
              , r = e.flatMap((e => e.hourlyValues ?? [])).filter((e => e.ts >= n && e.ts <= t)).sort(( (e, t) => e.ts - t.ts));
            return r.map(( (e, t) => ({
                date: new Date(1e3 * e.ts),
                valueInUsd: e.value ?? 0,
                isLast: t === r.length - 1
            })))
        }
        const n = "week" === t ? 7 : 30
          , r = e.slice(-n);
        return r.map(( (e, t) => ({
            date: new Date(1e3 * e.ts),
            valueInUsd: e.value ?? 0,
            isLast: t === r.length - 1
        })))
    }
    ), [l, t]);
    return v.jsxs(S, {
        flex: 1,
        minHeight: 0,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            px: r ? 2 : 1.5,
            pt: 1.75,
            height: 40,
            children: [v.jsx(k, {
                variant: "h2",
                fontWeight: 400,
                children: a("Realized PNL")
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(E4, {
                    wallets: s
                }), !r && v.jsx(i5, {
                    perfTimespan: t,
                    setPerfTimespan: n
                })]
            })]
        }), v.jsx(S, {
            flex: 1,
            px: .5,
            pt: 1,
            position: "relative",
            minHeight: 0,
            children: v.jsx(_4, {
                dataPoints: c,
                dateFormatter: an("day" === t ? "%d %b %H:00" : "%d %b"),
                isLoading: l.status === ox.INITIAL || l.status === ox.LOADING
            })
        })]
    })
}
))
  , _4 = ({dataPoints: e, isLoading: t, dateFormatter: n}) => v.jsx("div", {
    style: U4,
    children: v.jsx(sn, {
        children: r => v.jsx(W4, {
            width: r.width,
            height: r.height,
            dataPoints: e,
            isLoading: t,
            dateFormatter: n
        })
    })
})
  , U4 = {
    width: "100%",
    height: "100%",
    position: "relative"
}
  , W4 = on(( ({showTooltip: e, hideTooltip: t, tooltipData: n, tooltipTop: r=0, tooltipLeft: a=0, dataPoints: s, width: o, height: l, isLoading: i, dateFormatter: c}) => {
    const d = D()
      , u = y.useMemo(( () => s.length ? s[s.length - 1].valueInUsd : 0), [s])
      , [p,h] = y.useMemo(( () => [d.palette.text.primary, {
        ...cn,
        fontSise: 12,
        background: d.palette.background.secondary,
        border: `1px solid ${d.palette.background.borderSubtle}`,
        color: d.palette.text.primary
    }]), [d.palette])
      , m = y.useMemo(( () => dn({
        range: [V4.left, o - V4.right],
        domain: un(s, H4) ?? [new Date, new Date]
    })), [s, o])
      , [g,x,b] = y.useMemo(( () => {
        const e = un(s, z4);
        return [(null == e ? void 0 : e[0]) ?? 0, (null == e ? void 0 : e[1]) ?? 0, u]
    }
    ), [s, u])
      , f = y.useMemo(( () => pn({
        range: [l - V4.bottom, V4.top],
        domain: [g - F4 * (x - g || 1), x + F4 * (x - g || 1)],
        nice: !0
    })), [l, g, x])
      , [C,A,w] = y.useMemo(( () => [g, x, b].map((e => f(e)))), [f, g, x, b])
      , j = f(0)
      , T = Math.max(V4.top, Math.min(l - V4.bottom, j))
      , I = Math.max(0, o - V4.left - V4.right)
      , E = Math.max(0, T - V4.top)
      , M = Math.max(0, l - V4.bottom - T)
      , N = y.useMemo(( () => Math.random().toString(36).slice(2)), [])
      , P = `pnl-grad-pos-${N}`
      , O = `pnl-grad-neg-${N}`
      , L = `pnl-clip-above-${N}`
      , R = `pnl-clip-below-${N}`
      , B = y.useCallback((t => {
        const {x: n} = hn(t) || {
            x: 0
        }
          , r = m.invert(n)
          , a = $4(s, r, 1)
          , o = s[a - 1]
          , l = s[a];
        let i = o ?? l;
        o && l && (i = r.valueOf() - H4(o).valueOf() > H4(l).valueOf() - r.valueOf() ? l : o),
        i && e({
            tooltipData: i,
            tooltipLeft: m(H4(i)) ?? 0,
            tooltipTop: f(z4(i)) ?? 0
        })
    }
    ), [e, f, m, s]);
    return !s.length || i ? v.jsx(S, {
        height: "100%",
        width: "100%",
        alignItems: "center",
        justifyContent: "center",
        children: i ? v.jsx(Km, {}) : v.jsx(k, {
            color: "text.meta",
            variant: "labelLarge",
            children: "No data to display"
        })
    }) : v.jsxs("div", {
        children: [v.jsx("svg", {
            width: o,
            height: l,
            children: v.jsxs(mn, {
                children: [v.jsx("rect", {
                    x: 0,
                    y: 0,
                    width: o,
                    height: l,
                    fill: "transparent",
                    rx: 14
                }), v.jsx(gn, {
                    id: P,
                    from: d.palette.success.main,
                    fromOpacity: .25,
                    to: d.palette.success.main,
                    toOpacity: 0
                }), v.jsx(gn, {
                    id: O,
                    from: d.palette.error.main,
                    fromOpacity: .25,
                    to: d.palette.error.main,
                    toOpacity: 0
                }), v.jsxs("defs", {
                    children: [v.jsx("clipPath", {
                        id: L,
                        children: v.jsx("rect", {
                            x: V4.left,
                            y: V4.top,
                            width: I,
                            height: E
                        })
                    }), v.jsx("clipPath", {
                        id: R,
                        children: v.jsx("rect", {
                            x: V4.left,
                            y: T,
                            width: I,
                            height: M
                        })
                    })]
                }), v.jsx(xn, {
                    data: s,
                    x: e => m(H4(e)) ?? 0,
                    y: e => f(z4(e)) ?? 0,
                    yScale: f,
                    y0: j,
                    fill: `url(#${P})`,
                    curve: bn,
                    clipPath: `url(#${L})`
                }), v.jsx(xn, {
                    data: s,
                    x: e => m(H4(e)) ?? 0,
                    y: e => f(z4(e)) ?? 0,
                    yScale: f,
                    y0: j,
                    fill: `url(#${O})`,
                    curve: bn,
                    clipPath: `url(#${R})`
                }), v.jsx(fn, {
                    data: s,
                    x: e => m(H4(e)) ?? 0,
                    y: e => f(z4(e)) ?? 0,
                    stroke: d.palette.success.main,
                    strokeWidth: 2,
                    strokeOpacity: .9,
                    strokeLinecap: "round",
                    curve: bn,
                    clipPath: `url(#${L})`
                }), v.jsx(fn, {
                    data: s,
                    x: e => m(H4(e)) ?? 0,
                    y: e => f(z4(e)) ?? 0,
                    stroke: d.palette.error.main,
                    strokeWidth: 2,
                    strokeOpacity: .9,
                    strokeLinecap: "round",
                    curve: bn,
                    clipPath: `url(#${R})`
                }), v.jsx(vn, {
                    x: V4.left,
                    y: V4.top,
                    width: o - V4.left - V4.right,
                    height: l - V4.top - V4.bottom,
                    fill: "transparent",
                    rx: 14,
                    onTouchStart: B,
                    onTouchMove: B,
                    onMouseMove: B,
                    onMouseLeave: () => t()
                }), v.jsx(P4, {
                    showLabel: !0,
                    value: g,
                    valueScaled: C,
                    width: o,
                    prefix: "min",
                    textBelow: Math.abs(C - w) <= L4
                }), v.jsx(P4, {
                    showLabel: !0,
                    value: x,
                    valueScaled: A,
                    width: o,
                    prefix: "max",
                    textBelow: Math.abs(A - w) <= L4
                }), n && v.jsxs("g", {
                    children: [v.jsx(rn, {
                        from: {
                            x: a,
                            y: V4.top
                        },
                        to: {
                            x: a,
                            y: l - V4.bottom
                        },
                        stroke: p,
                        opacity: .3,
                        strokeWidth: 1,
                        pointerEvents: "none",
                        strokeDasharray: "5,2"
                    }), v.jsx("circle", {
                        cx: a,
                        cy: r,
                        r: 4,
                        fill: z4(n) >= 0 ? d.palette.success[700] : d.palette.error[700],
                        stroke: z4(n) >= 0 ? d.palette.success.main : d.palette.error.main,
                        strokeWidth: 2,
                        pointerEvents: "none"
                    })]
                })]
            })
        }), n && v.jsxs("div", {
            children: [v.jsx(Sn, {
                top: r - 12,
                left: a + 12,
                style: h,
                children: (z4(n) < 0 ? "-" : "") + LI(Math.abs(z4(n)), {
                    symbol: "$",
                    padSymbol: !1,
                    symbolPosition: yI.START,
                    maxPrecision: 2
                })
            }, Math.random()), v.jsx(yn, {
                top: l - V4.bottom - 24,
                left: a,
                style: {
                    ...h,
                    minWidth: 72,
                    textAlign: "center",
                    transform: `translateX(${n.isLast ? "-100" : "-50"}%)`,
                    whiteSpace: "nowrap"
                },
                children: c(H4(n))
            })]
        })]
    })
}
))
  , F4 = .1
  , V4 = {
    top: 2,
    right: 8,
    bottom: 2,
    left: 8
}
  , H4 = ({date: e}) => e
  , z4 = ({valueInUsd: e}) => e
  , $4 = ln((e => new Date(e.date))).left;
var G4 = (e => (e.BALANCE = "BALANCE",
e.PNL_CHART = "PNL_CHART",
e.PERFORMANCE = "PERFORMANCE",
e))(G4 || {});
const q4 = y.memo(( ({walletAddress: e, chain: t, perfTimespan: n, setPerfTimespan: r, coinsTraded: a, realizedPnlUsd: s, wins: o, losses: l, buys: i, sells: c, exchange: d, fundedTs: u, fundedAmount: p, fundedTxnHash: h, fundedFrom: m, nativeBalance: g}) => {
    const {t: x} = we()
      , b = xw()
      , [f,k] = Mx("padreV2-walletOverviewStatsMobileTab", G4.BALANCE)
      , C = y.useCallback(( (e, t) => {
        k(t)
    }
    ), [k]);
    return v.jsx(S, {
        direction: b ? "row" : "column",
        alignItems: b ? "center" : "flex-start",
        gap: 2,
        height: b ? 280 : void 0,
        children: b ? v.jsxs(S, {
            direction: "row",
            divider: K4,
            height: "100%",
            flexGrow: 1,
            children: [v.jsx(T5, {
                chain: t,
                exchange: d,
                fundedTs: u,
                fundedAmount: p,
                fundedTxnHash: h,
                nativeBalance: g,
                fundedFrom: m
            }), v.jsx(B4, {
                walletAddress: e,
                perfTimespan: n,
                setPerfTimespan: r
            }), v.jsx(N5, {
                coinsTraded: a,
                realizedPnlUsd: s,
                wins: o,
                losses: l,
                buys: i,
                sells: c,
                perfTimespan: n,
                setPerfTimespan: r,
                chain: t
            })]
        }) : v.jsxs(S, {
            width: "100%",
            children: [v.jsxs(ot, {
                value: f,
                onChange: C,
                variant: "scrollable",
                children: [v.jsx(lt, {
                    label: x("Balance"),
                    value: G4.BALANCE
                }), v.jsx(lt, {
                    label: x("PNL Chart"),
                    value: G4.PNL_CHART
                }), v.jsx(lt, {
                    label: x("Performance"),
                    value: G4.PERFORMANCE
                })]
            }), v.jsx(S, {
                mt: .75,
                children: v.jsx(cA, {
                    customName: e,
                    address: e,
                    maxWidth: "100%"
                })
            }), v.jsxs(S, {
                height: 280,
                children: [f === G4.BALANCE && v.jsx(T5, {
                    chain: t,
                    exchange: d,
                    fundedTs: u,
                    fundedAmount: p,
                    fundedTxnHash: h,
                    fundedFrom: m,
                    nativeBalance: g
                }), f === G4.PNL_CHART && v.jsx(B4, {
                    walletAddress: e,
                    perfTimespan: n,
                    setPerfTimespan: r
                }), f === G4.PERFORMANCE && v.jsx(N5, {
                    coinsTraded: a,
                    realizedPnlUsd: s,
                    wins: o,
                    losses: l,
                    buys: i,
                    sells: c,
                    perfTimespan: n,
                    setPerfTimespan: r,
                    chain: t
                })]
            })]
        })
    })
}
))
  , K4 = v.jsx(Ee, {
    orientation: "vertical",
    flexItem: !0
})
  , Y4 = 3e3
  , X4 = y.memo(( ({walletAddress: e, onClose: t}) => {
    var n, r, a, s, o;
    const l = (e => {
        const t = Ax()
          , n = y.useCallback((n => t && e ? Rm.subscribeWalletOverview(e, n) : {
            unsubscribe: () => {}
        }), [t, e]);
        return kx(n, sQ)
    }
    )(e)
      , i = (e => {
        const t = Ax()
          , [n,r] = y.useState({
            status: ox.INITIAL
        });
        return y.useEffect(( () => {
            let n, a = !1;
            if (!t)
                return;
            const s = async () => {
                try {
                    r({
                        status: ox.LOADING
                    });
                    const t = await Rm.getWalletBasicInfo(e);
                    if (a)
                        return;
                    r({
                        status: ox.READY,
                        data: t.info
                    })
                } catch (fNe) {
                    a || (n = setTimeout(( () => {
                        s().catch(console.error)
                    }
                    ), Y4))
                }
            }
            ;
            return s(),
            () => {
                a = !0,
                clearTimeout(n ?? void 0)
            }
        }
        ), [t, e]),
        y.useMemo(( () => n.status === ox.READY ? n.data : null), [n])
    }
    )(e)
      , [c,d] = Mx("padreV2-walletOverviewPerfTimespan", "day")
      , u = y.useMemo(( () => {
        switch (c) {
        case "day":
            return (null == l ? void 0 : l.day) ?? null;
        case "week":
            return (null == l ? void 0 : l.week) ?? null;
        case "month":
            return (null == l ? void 0 : l.month) ?? null
        }
    }
    ), [l, c]);
    return v.jsx(_2, {
        walletAddress: e,
        children: v.jsxs(S, {
            divider: Q4,
            children: [v.jsx(p5, {
                walletAddress: e,
                chain: (null == i ? void 0 : i.chain) ?? null,
                perfTimespan: c,
                setPerfTimespan: d,
                onClose: t
            }), v.jsx(q4, {
                walletAddress: e,
                chain: (null == i ? void 0 : i.chain) ?? null,
                perfTimespan: c,
                setPerfTimespan: d,
                coinsTraded: u ? u.losses + u.wins : null,
                buys: (null == u ? void 0 : u.buys) ?? null,
                sells: (null == u ? void 0 : u.sells) ?? null,
                losses: (null == u ? void 0 : u.losses) ?? null,
                wins: (null == u ? void 0 : u.wins) ?? null,
                realizedPnlUsd: (null == u ? void 0 : u.realizedPnl) ?? null,
                exchange: (null == (n = null == i ? void 0 : i.devFundTxn) ? void 0 : n.exchange) ?? null,
                fundedTs: (null == (r = null == i ? void 0 : i.devFundTxn) ? void 0 : r.timestamp) ?? null,
                fundedAmount: (null == (a = null == i ? void 0 : i.devFundTxn) ? void 0 : a.solAmount) ?? null,
                fundedTxnHash: (null == (s = null == i ? void 0 : i.devFundTxn) ? void 0 : s.txnHash) ?? null,
                fundedFrom: (null == (o = null == i ? void 0 : i.devFundTxn) ? void 0 : o.fromAddress) ?? null,
                nativeBalance: (null == i ? void 0 : i.nativeBalance) ?? null
            }), v.jsx(z2, {
                walletAddress: e,
                chain: (null == i ? void 0 : i.chain) ?? null
            })]
        })
    })
}
))
  , Q4 = v.jsx(Ee, {
    flexItem: !0,
    sx: {
        mx: -1
    }
})
  , Z4 = ({walletAddress: e, onClose: t= () => {}
}) => v.jsx(Sw, {
    open: !0,
    onClose: t,
    minDesktopWidth: 740,
    maxDesktopWidth: 1100,
    minDesktopHeight: 500,
    maxDesktopHeight: aQ,
    stackSx: J4,
    children: v.jsx(S, {
        justifyContent: "space-between",
        height: "100%",
        children: v.jsx(X4, {
            onClose: t,
            walletAddress: e
        })
    })
})
  , J4 = {
    p: 1,
    height: "100%"
}
  , e6 = {
    openModal: O
}
  , t6 = y.createContext(e6);
t6.displayName = "WalletOverviewModalContext";
const n6 = y.memo(( ({children: e}) => {
    const [t,n] = y.useState(null)
      , r = y.useCallback((e => {
        n(ng(e))
    }
    ), [])
      , a = y.useCallback(( () => {
        n(null)
    }
    ), [])
      , s = y.useMemo(( () => ({
        openModal: r
    })), [r]);
    return v.jsxs(t6.Provider, {
        value: s,
        children: [e, t && v.jsx(Z4, {
            walletAddress: t,
            onClose: a
        })]
    })
}
))
  , r6 = () => y.useContext(t6)
  , a6 = y.createContext({
    telegram: {
        notificationsSettings: null,
        subscribe: Promise.resolve,
        unsubscribe: Promise.resolve,
        setNotificationsSetting: Promise.resolve,
        refresh: Promise.resolve
    },
    openModal: O,
    isAccountOverviewDrawerOpen: !1,
    toggleAccountOverviewDrawer: O
})
  , s6 = () => v.jsx(S, {
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    children: v.jsxs(S, {
        gap: 1.25,
        alignItems: "center",
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: "New version of this page is available."
        }), v.jsx(V, {
            size: "xxsmall",
            variant: "tertiary",
            onClick: XG,
            sx: o6,
            endIcon: v.jsx(_S, {}),
            children: "Refresh page"
        })]
    })
})
  , o6 = {
    maxWidth: 130,
    px: 1.5
}
  , l6 = 3
  , i6 = e => Promise.resolve({
    default: s6
})
  , c6 = y.lazy(( () => l(( () => import("./AccountSettingsModalContent-CnhZp-9U.js")), __vite__mapDeps([0, 1, 2, 3, 4])).catch(i6)))
  , d6 = y.memo(( ({isOpen: e, onClose: t, initialTab: n}) => v.jsx(Sw, {
    open: e,
    stackSx: {
        px: 3,
        py: 2,
        zIndex: $w
    },
    onClose: t,
    maxDesktopHeight: u6,
    minDesktopHeight: u6,
    children: v.jsx(y.Suspense, {
        fallback: null,
        children: v.jsx(c6, {
            initialTab: n,
            onClose: t
        })
    })
})))
  , u6 = 650
  , p6 = y.memo(( ({displayData: e, hideButton: t}) => {
    const {performBuy: n} = AD();
    k$(e && e.chain === Pd.SOLANA ? e.marketId : null);
    const {exitStrategies: r} = KR()
      , {settings: a} = rf()
      , {includeExitStrategies: s, selectedPreset: o, buttonValue: l, insufficientBalance: i} = uH()
      , [c,d] = JC(!1, 500)
      , u = y.useMemo(( () => !e || (!l || (!!i || (!e.marketId || !e.quoteAddress)))), [l, e, i])
      , p = y.useCallback((async () => {
        if (np.info("Watchlist buy button clicked", {
            buttonValue: l,
            tokenAddress: (null == e ? void 0 : e.tokenAddress) ?? null
        }),
        e && e.chain === Pd.SOLANA && null != l && e.marketId && e.quoteAddress)
            try {
                ((null == a ? void 0 : a.preventDoubleClick) ?? y$) && d(!0),
                await n({
                    value: l,
                    baseCurrency: e.tokenAddress,
                    baseTokenType: e.tokenType,
                    poolQuoteCurrency: e.quoteAddress,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: e.symbol,
                    quoteSymbol: "SOL",
                    marketId: e.marketId,
                    padreAvatarUrl: null,
                    presetName: o,
                    originWidget: Dp.WATCHLIST,
                    exitStrategies: s && r.length ? r : null
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing order", {
                    e: fNe,
                    value: l,
                    baseCurrency: e.tokenAddress,
                    baseTokenType: e.tokenType,
                    poolQuoteCurrency: e.quoteAddress,
                    marketId: e.marketId,
                    originWidget: Dp.WATCHLIST
                })
            }
        else
            np.warn("Order hasn't been sent - watchlist missing data", {
                value: l,
                originWidget: Dp.WATCHLIST,
                chain: (null == e ? void 0 : e.chain) ?? null,
                missingDisplayData: null === e,
                marketId: (null == e ? void 0 : e.marketId) ?? null,
                quoteAddress: (null == e ? void 0 : e.quoteAddress) ?? null
            })
    }
    ), [e, l, null == a ? void 0 : a.preventDoubleClick, n, o, s, r, d]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        children: [e && v.jsx(h$, {
            chain: e.chain,
            tokenAddress: e.tokenAddress,
            muteEvent: !0,
            showBackground: !0,
            showTrashForRemove: !0
        }), e && !t && v.jsxs(V, {
            className: "no-drag",
            disabled: u || c,
            onClick: p,
            size: "xxsmall",
            sx: h6,
            color: "success",
            children: [v.jsx(ay, {
                color: "inherit"
            }), l]
        })]
    })
}
))
  , h6 = {
    pl: .5,
    pr: 1,
    borderRadius: 4,
    display: "flex",
    gap: .5,
    cursor: "pointer",
    height: 32
};
var m6 = (e => (e.DESC = "desc",
e.ASC = "asc",
e))(m6 || {});
const g6 = y.memo(( ({label: e, onClick: t, direction: n, justifyEnd: r=!1}) => v.jsx(C, {
    component: "span",
    width: "100%",
    sx: b6,
    children: v.jsxs(C, {
        onClick: t,
        display: "flex",
        flexDirection: r ? "row-reverse" : "row",
        alignItems: "center",
        justifyContent: "flex-start",
        width: "100%",
        gap: .25,
        color: "text.label",
        sx: f6,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            children: e
        }), n && v.jsx(C, {
            display: "flex",
            children: n === m6.ASC ? v.jsx(JS, {
                animateColor: !0,
                color: "inherit",
                size: x6
            }) : v.jsx(ey, {
                animateColor: !0,
                color: "inherit",
                size: x6
            })
        })]
    })
})))
  , x6 = 16
  , b6 = {
    cursor: "pointer"
}
  , f6 = $_(200, !1)
  , v6 = ["asset", "priceInUsd", "fdvInUsd"]
  , S6 = ["asset", "priceInUsd", "fdvInUsd", "watchlist"]
  , y6 = new Set(["asset", "priceInUsd", "fdvInUsd"])
  , k6 = new Set(["priceInUsd", "fdvInUsd"])
  , C6 = {
    asset: n.t("Asset"),
    priceInUsd: n.t("Price"),
    fdvInUsd: n.t("MCap"),
    watchlist: ""
}
  , A6 = 1.75
  , w6 = !0
  , j6 = m6.DESC
  , T6 = () => R ? S6 : v6
  , I6 = y.memo(( ({gridTemplateColumns: e, sortDirection: t, sortColumnKey: n, setSort: r}) => {
    const {t: a} = we()
      , s = y.useMemo(( () => T6()), [])
      , o = y.useCallback((e => {
        const s = C6[e] ?? "";
        if (!s)
            return v.jsx("span", {}, e);
        if (y6.has(e)) {
            const a = n === e
              , o = () => {
                r(e, a ? t === m6.ASC ? m6.DESC : m6.ASC : m6.DESC)
            }
            ;
            return v.jsx(g6, {
                label: s,
                onClick: o,
                direction: a ? t : null,
                justifyEnd: k6.has(e)
            }, `${e}-${a}-${a ? t : ""}`)
        }
        return v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            display: "flex",
            alignItems: "center",
            justifyContent: k6.has(e) ? "flex-end" : "flex-start",
            noWrap: !0,
            children: a(s)
        }, e)
    }
    ), [r, n, t, a]);
    return v.jsx(C, {
        position: "sticky",
        top: 0,
        zIndex: 3,
        display: "grid",
        gridTemplateColumns: e,
        alignItems: "center",
        sx: E6,
        children: s.map(o)
    })
}
))
  , E6 = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    px: A6,
    height: 34,
    minHeight: 34,
    gap: 1.5,
    background: e.palette.background.secondary
})
  , M6 = y.memo(( ({gridTemplateColumns: e, onRowClick: t, onMouseOverRef: n, ...r}) => {
    const a = yT()
      , s = y.useMemo(( () => T6()), [])
      , {colorSkin: o} = Vb()
      , l = y.useMemo(( () => e => ({
        px: A6,
        gap: 1.5,
        "&:nth-of-type(odd)": {
            backgroundColor: o === rg.INDIGO ? tY : e.palette.background.secondary
        },
        cursor: "pointer",
        "&:hover": {
            backgroundColor: e.palette.background.hover
        }
    })), [o])
      , i = y.useCallback(( () => {
        a({
            chain: r.chain,
            tokenAddress: r.tokenAddress,
            tradePageOrigin: nT.WATCHLIST
        }),
        null == t || t()
    }
    ), [r.chain, r.tokenAddress, a, t])
      , c = y.useCallback((e => {
        switch (e) {
        case "asset":
            return v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.5,
                sx: N6,
                children: [v.jsx(b_, {
                    url: IE(r.chain, r.tokenAddress),
                    name: r.name,
                    chain: r.chain,
                    padreAvatarUrl: null,
                    size: 28,
                    borderRadius: "4px",
                    protocolInfo: null,
                    markerIcon: v.jsx(Sz, {
                        chain: r.chain,
                        size: P6
                    }),
                    markerSize: P6,
                    markerOverrides: O6
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    noWrap: !0,
                    children: r.symbol || r.name || r.tokenAddress
                })]
            }, e);
        case "priceInUsd":
            return v.jsx(k, {
                variant: "paragraph3",
                color: r.priceInUsd ? "text.value" : "text.label",
                textAlign: "right",
                children: r.priceInUsd ? LI(Number(r.priceInUsd), {
                    collapseExponent: !0,
                    symbol: "$",
                    padSymbol: !1,
                    symbolPosition: yI.START
                }) : ""
            }, e);
        case "fdvInUsd":
            return v.jsx(k, {
                variant: "paragraph3",
                color: r.fdvInUsd ? "text.value" : "text.label",
                textAlign: "right",
                children: r.fdvInUsd ? LI(Number(r.fdvInUsd), {
                    collapseExponent: !0,
                    symbol: "$",
                    desiredDigits: 3,
                    padSymbol: !1,
                    symbolPosition: yI.START
                }) : ""
            }, e);
        case "watchlist":
            return v.jsx(h$, {
                chain: r.chain,
                tokenAddress: r.tokenAddress,
                showTrashForRemove: !0,
                muteEvent: !0
            });
        default:
            return v.jsx("span", {}, e)
        }
    }
    ), [r])
      , d = y.useCallback(( () => {
        (null == n ? void 0 : n.current) && n.current(r)
    }
    ), [r, n]);
    return v.jsx(C, {
        display: "grid",
        gridTemplateColumns: e,
        alignItems: "center",
        height: 48,
        minHeight: 48,
        sx: l,
        onMouseEnter: d,
        onClick: i,
        role: "button",
        tabIndex: 0,
        children: s.map(c)
    })
}
))
  , N6 = {
    textDecoration: "none",
    color: "text.value",
    minWidth: 0,
    overflow: "hidden",
    minHeight: 32,
    pl: .25,
    ml: -.25
}
  , P6 = 14
  , O6 = {
    top: -4,
    left: void 0,
    right: -4
}
  , L6 = y.memo(( ({rowData: e, hasAnyWatched: t, onRowClick: n}) => {
    const r = y.useMemo(( () => T6()), [])
      , [a,s] = y.useMemo(( () => {
        const {templates: e, width: t} = c.reduce(r, ( (e, t) => {
            const [n,r] = (e => {
                switch (e) {
                case "asset":
                    return ["minmax(100px, 1fr)", 100];
                case "priceInUsd":
                case "fdvInUsd":
                    return ["minmax(72px, 0.5fr)", 72];
                case "watchlist":
                    return ["24px", 24];
                default:
                    return ["0px", 0]
                }
            }
            )(t);
            return e.templates.push(n ?? "0px"),
            e.width += r,
            e
        }
        ), {
            templates: [],
            width: 0
        })
          , n = t + 8 * (3.5 + 1.5 * (r.length - 1));
        return [e.join(" "), n]
    }
    ), [r])
      , [o,l] = Mx("padreV2-watchlistSortDirection", j6)
      , [i,d] = Mx("padreV2-watchlistSortColumn", "fdvInUsd")
      , u = y.useCallback(( (e, t) => {
        d(e),
        l(t)
    }
    ), [d, l])
      , p = y.useMemo(( () => {
        const t = ( (e, t) => (n, r) => {
            const a = t === m6.ASC ? n : r
              , s = t === m6.ASC ? r : n;
            return "asset" === e ? a.symbol.localeCompare(s.symbol) : "priceInUsd" === e ? (a.priceInUsd ? isNaN(Number(a.priceInUsd)) ? 0 : Number(a.priceInUsd) : 0) - (s.priceInUsd ? isNaN(Number(s.priceInUsd)) ? 0 : Number(s.priceInUsd) : 0) : "fdvInUsd" === e ? (a.fdvInUsd ? isNaN(Number(a.fdvInUsd)) ? 0 : Number(a.fdvInUsd) : 0) - (s.fdvInUsd ? isNaN(Number(s.fdvInUsd)) ? 0 : Number(s.fdvInUsd) : 0) : 0
        }
        )(i, o);
        return [...e].sort(t)
    }
    ), [e, i, o])
      , h = y.useRef(null)
      , [m,g] = y.useState(0);
    y.useLayoutEffect(( () => {
        const e = () => {
            h.current && g(h.current.clientWidth)
        }
        ;
        e();
        const t = new ResizeObserver(e);
        return h.current && t.observe(h.current),
        () => t.disconnect()
    }
    ), []);
    const [x,b] = y.useState(null)
      , [f,C] = y.useState(null)
      , A = y.useCallback(( () => {
        b(null),
        C(null)
    }
    ), [])
      , w = y.useCallback((e => {
        const t = p.findIndex((t => D6(e) === D6(t)));
        if (-1 === t)
            return b(null),
            void C(null);
        b(e),
        C(48 * t)
    }
    ), [p])
      , j = y.useRef(w);
    y.useEffect(( () => {
        j.current = w
    }
    ), [w]);
    const T = y.useMemo(( () => null === f || R ? null : v.jsx("div", {
        style: {
            position: "absolute",
            right: s > m ? s - m + 12 : 12,
            top: f + 10,
            zIndex: 10,
            pointerEvents: "auto",
            cursor: "pointer"
        },
        onClick: e => e.stopPropagation(),
        onMouseDown: e => e.stopPropagation(),
        children: v.jsx(p6, {
            displayData: x,
            hideButton: w6
        })
    })), [m, x, s, f]);
    return v.jsx(S, {
        sx: R6,
        className: "padre-no-scroll no-drag",
        position: "relative",
        ref: h,
        children: v.jsxs(S, {
            width: s,
            minWidth: "100%",
            height: "100%",
            children: [v.jsx(I6, {
                gridTemplateColumns: a,
                sortDirection: o,
                sortColumnKey: i,
                setSort: u
            }), v.jsxs(S, {
                height: "100%",
                position: "relative",
                onMouseLeave: A,
                children: [0 === p.length ? v.jsx(S, {
                    height: "100%",
                    width: "100%",
                    alignItems: "center",
                    justifyContent: "center",
                    minHeight: 100,
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        children: t ? "No tokens from this chain on watchlist" : "Your watchlist is empty"
                    })
                }) : p.map((e => v.jsx(M6, {
                    gridTemplateColumns: a,
                    onRowClick: n,
                    onMouseOverRef: j,
                    ...e
                }, D6(e)))), x && null !== f && T]
            })]
        })
    })
}
))
  , R6 = {
    overflow: "scroll",
    height: "100%",
    "&:hover": {
        cursor: "default"
    }
}
  , D6 = e => `${e.chain}-${e.tokenAddress}`
  , B6 = y.memo(( ({selectedChain: e, onRowClick: t, compact: n=!1}) => {
    const {watched: r, isLoading: a} = p$()
      , [s] = JC(!0, 300, !1)
      , o = y.useMemo(( () => r.filter((t => e === jQ || t.chain === e))), [e, r])
      , l = y.useMemo(( () => o.map((e => {
        var t, n, r, a, s, o, l;
        const i = !e.tokenInfo || !e.fastStats;
        return {
            chain: e.chain,
            name: (null == (t = e.tokenInfo) ? void 0 : t.name) ?? "",
            decimals: (null == (n = e.tokenInfo) ? void 0 : n.decimals) ?? 0,
            tokenAddress: e.tokenAddress,
            symbol: (null == (r = e.tokenInfo) ? void 0 : r.symbol) ?? "",
            fdvInUsd: (null == (s = null == (a = e.fastStats) ? void 0 : a.fdvInUsdUi) ? void 0 : s.toString()) ?? null,
            priceInUsd: (null == (l = null == (o = e.fastStats) ? void 0 : o.priceInUsdUi) ? void 0 : l.toString()) ?? null,
            isOptimisticUpdate: i,
            marketId: null,
            quoteAddress: null,
            tokenType: null
        }
    }
    ))), [o]);
    return n && (s || a && !r.length) ? v.jsx(S, {
        height: "100%",
        alignItems: "center",
        justifyContent: "center",
        minHeight: 100,
        children: v.jsx(Km, {})
    }) : v.jsx(L6, {
        rowData: l,
        hasAnyWatched: !!r.length,
        onRowClick: t
    })
}
))
  , _6 = ({isOpen: e, onClose: t}) => {
    const {t: n} = we()
      , [r,a] = y.useState(jQ)
      , s = bw()
      , o = xw()
      , l = y.useCallback(( () => t(!1)), [t])
      , i = y.useCallback(( () => {
        t(!0)
    }
    ), [t]);
    return v.jsx(cH, {
        contextId: "watchlistModal",
        children: v.jsx(Sw, {
            desktopWidth: "max-content",
            open: e,
            stackSx: V6,
            onClose: l,
            children: v.jsxs(v.Fragment, {
                children: [!o && v.jsxs(v.Fragment, {
                    children: [v.jsxs(S, {
                        flexShrink: 0,
                        direction: "row",
                        sx: W6,
                        children: [v.jsx(F, {
                            sx: F6,
                            onClick: l,
                            children: v.jsx(ky, {})
                        }), v.jsx(k, {
                            variant: "paragraph1",
                            children: n("Watchlist")
                        })]
                    }), v.jsx(Ee, {})]
                }), v.jsx(C, {
                    sx: U6,
                    children: v.jsxs(S, {
                        width: "100%",
                        height: "100%",
                        gap: 2,
                        children: [v.jsxs(S, {
                            direction: "row",
                            gap: 2,
                            alignItems: "center",
                            children: [o && v.jsx(k, {
                                variant: "h3",
                                children: n("Watchlist")
                            }), v.jsx(G5, {
                                chain: r,
                                setChain: a,
                                showAllTooltip: !0
                            }), !1]
                        }), v.jsx(S, {
                            mx: s ? 0 : -2,
                            flex: "1 1 200px",
                            height: "100%",
                            overflow: "hidden",
                            children: v.jsx(B6, {
                                selectedChain: r,
                                onRowClick: i
                            })
                        })]
                    })
                })]
            })
        })
    })
}
  , U6 = {
    px: 3,
    py: 2,
    flexGrow: 1
}
  , W6 = {
    px: {
        xs: 2,
        sm: Cw
    },
    py: .5,
    height: 48,
    gap: 1,
    backgroundColor: "background.secondary",
    alignItems: "center"
}
  , F6 = {
    px: 0,
    width: 16,
    height: 16
}
  , V6 = {
    p: 0,
    zIndex: $w,
    height: "100%"
};
var H6 = (e => (e.SETTINGS = "SETTINGS",
e.WATCHLIST = "WATCHLIST",
e))(H6 || {})
  , z6 = (e => (e.COLORS = "COLORS",
e.LAYOUT = "LAYOUT",
e.NOTIFICATIONS = "NOTIFICATIONS",
e.TRADING = "TRADING",
e.CHART = "CHART",
e.NAVIGATION = "NAVIGATION",
e))(z6 || {});
const $6 = ({children: e}) => {
    const t = xw()
      , {user: n} = VK()
      , [r,a] = y.useState(!1)
      , [s,o] = y.useState({
        status: ox.INITIAL
    })
      , [l,i] = y.useState(null)
      , [c,d] = y.useState(null);
    y.useEffect(( () => {
        l && [H6.WATCHLIST].includes(l) && t && i(null)
    }
    ), [l, t]);
    const u = y.useCallback((async e => {
        n && await vm.subscribe(n.uid, e)
    }
    ), [n])
      , p = y.useCallback((async () => {
        n && await vm.unsubscribe(n.uid)
    }
    ), [n])
      , h = y.useCallback((async () => {
        if (n)
            try {
                const e = await vm.getSettings(n.uid);
                o({
                    data: e,
                    status: ox.READY
                })
            } catch (fNe) {
                o({
                    status: ox.ERROR
                })
            }
    }
    ), [n])
      , m = y.useCallback((async (e, t) => {
        if (n) {
            o((n => n.status !== ox.READY || null === n.data ? n : {
                ...n,
                data: {
                    ...n.data,
                    settings: {
                        ...n.data.settings,
                        [e]: t
                    }
                }
            }));
            try {
                await vm.setSetting(n.uid, e, {
                    value: t
                })
            } catch (fNe) {
                await h()
            }
        }
    }
    ), [h, n])
      , g = y.useCallback(( (e, t) => (d(t || null),
    i(e))), [])
      , x = y.useCallback((e => {
        i(null),
        e && a(!1)
    }
    ), [])
      , b = y.useCallback(( () => {
        x(!1)
    }
    ), [x]);
    y.useEffect(( () => {
        let e = !1;
        if (n && s.status !== ox.READY)
            return (async () => {
                try {
                    if (s.status === ox.ERROR && (await Hu(G6),
                    e))
                        return;
                    const t = await vm.getSettings(n.uid);
                    if (e)
                        return;
                    o({
                        data: t,
                        status: ox.READY
                    })
                } catch (fNe) {
                    if (e)
                        return;
                    o({
                        status: ox.ERROR
                    })
                }
            }
            )(),
            () => {
                e = !0
            }
    }
    ), [n, s]);
    const f = y.useCallback((e => a(e)), [])
      , S = y.useMemo(( () => ({
        telegram: {
            notificationsSettings: s.status === ox.READY ? s.data : null,
            subscribe: u,
            unsubscribe: p,
            setNotificationsSetting: m,
            refresh: h
        },
        openModal: g,
        isAccountOverviewDrawerOpen: r,
        toggleAccountOverviewDrawer: f
    })), [s, h, g, m, u, p, r, f]);
    return v.jsxs(a6.Provider, {
        value: S,
        children: [e, l === H6.SETTINGS && v.jsx(d6, {
            isOpen: l === H6.SETTINGS,
            onClose: b,
            initialTab: c
        }), v.jsx(_6, {
            isOpen: l === H6.WATCHLIST,
            onClose: x
        })]
    })
}
  , G6 = 5e3
  , q6 = () => y.useContext(a6);
var K6 = (e => (e.LEFT = "LEFT",
e.RIGHT = "RIGHT",
e))(K6 || {})
  , Y6 = (e => (e.WATCHLIST = "WATCHLIST",
e.TRADING_WIDGET = "TRADING_WIDGET_V4",
e.TRACKED_WALLETS = "TRACKED_WALLETS",
e.TWITTER_TRACKER = "TWITTER_TRACKER",
e.PNL_TRACKER = "PNL_TRACKER",
e.BUBBLEMAP = "BUBBLEMAP",
e.TRENCHES = "TRENCHES",
e.ALPHA_TRACKER = "ALPHA_TRACKER",
e.ROLLING_RANKING = "ROLLING_RANKING",
e))(Y6 || {});
const X6 = {
    [Y6.WATCHLIST]: 0,
    [Y6.TRADING_WIDGET]: 1,
    [Y6.TRACKED_WALLETS]: 2,
    [Y6.TWITTER_TRACKER]: 3,
    [Y6.PNL_TRACKER]: 4,
    [Y6.BUBBLEMAP]: 5,
    [Y6.TRENCHES]: 6,
    [Y6.ALPHA_TRACKER]: 7,
    [Y6.ROLLING_RANKING]: 8
}
  , Q6 = K6.LEFT
  , Z6 = y.createContext({
    isPnlTrackerWidgetOpen: !1,
    togglePnlTrackerWidget: c.noop,
    isWatchlistWidgetOpen: !1,
    toggleWatchlistWidget: c.noop,
    isTrackedWalletsWidgetOpen: !1,
    toggleTrackedWalletsWidget: c.noop,
    isTwitterTrackerWidgetOpen: !1,
    toggleTwitterTrackerWidget: c.noop,
    isTrenchesWidgetOpen: !1,
    toggleTrenchesWidget: c.noop,
    trackedWalletsDock: null,
    onTrackedWalletsUndock: c.noop,
    twitterTrackerDock: null,
    onTwitterTrackerUndock: c.noop,
    trenchesDock: Q6,
    onTrenchesDock: c.noop,
    isAlphaTrackerWidgetOpen: !1,
    toggleAlphaTrackerWidget: c.noop,
    alphaTrackerDock: Q6,
    onAlphaTrackerUndock: c.noop
})
  , J6 = () => y.useContext(Z6)
  , e8 = $h.CORK
  , t8 = [Pd.SOLANA, Pd.BSC]
  , n8 = {
    minPublicMentions: null,
    maxTokenAgeInSeconds: null,
    onlyFirstMentionPerGroup: !1,
    onlyChannelIds: [],
    onlyChains: []
}
  , r8 = y.createContext({
    displayData: null,
    alertsEnabled: !1,
    toggleAlertsEnabled: c.noop,
    soundEffectEnabled: !1,
    setSoundEffectEnabled: c.noop,
    selectedSoundEffect: $h.CORK,
    setSelectedSoundEffect: c.noop,
    notificationsVolume: 100,
    setNotificationsVolume: c.noop,
    notificationsDuration: 5,
    setNotificationsDuration: c.noop,
    filters: n8,
    setFilters: c.noop,
    alphaGroupsSilenced: null,
    alphaGroupsHideOnChart: null,
    alphaGroupsHideOnLiveTrades: null
})
  , a8 = () => y.useContext(r8)
  , s8 = (e, t) => c.reduce(e, ( (e, n) => {
    const [r,a] = l8(n, t);
    return r && a ? (e.push({
        ...r,
        ...a
    }),
    e) : e
}
), [])
  , o8 = (e, t, n, r, a, s, o, l, i, d, u, p, h, m) => {
    const g = ( (e, t) => t.filter((t => {
        const n = `${(r = t).messageId}-${r.tokenAddress}`;
        var r;
        return !e.current.has(n) && (e.current.set(n, !0),
        !0)
    }
    )))(t, s8("init" === e.type ? e.snapshot : e.update, m));
    (null == g ? void 0 : g.length) ? o && ( (e, t, n, r, a, s, o, l, i, d) => {
        c.forEach(e, (e => {
            const {eventTimestamp: c, chain: u, tokenAddress: p, mentionedGroupIds: h} = e;
            if (h.every((e => d[e] ?? !1)))
                return;
            if (c < l - 5)
                return;
            n && nw.play(r, a);
            const m = () => {
                s(u, p)
            }
            ;
            "visible" === document.visibilityState && t({
                displayData: e,
                marketCapColorThresholds: i,
                navigateToMarketPage: m,
                variant: lK.ALPHA_TRACK
            }, "new-mention-snack", {
                autoHideDuration: 1e3 * lb(o, {
                    min: 1,
                    max: 10
                })
            })
        }
        ))
    }
    )(g, s, l, r, a, i, d, u, p, h) : null !== g && (n.current = !0)
}
  , l8 = (e, t) => {
    if (!e.enrichment || !e.enrichment.token || !t.current)
        return [null, null];
    const n = t.current[e.uiGroupId] ?? null;
    if (!n)
        return [null, null];
    const r = e.enrichment.summary
      , {chain: a, address: s, deployedAt: o, symbol: l, name: i, padreAvatarUrl: d, marketCapInUsd: u, volume1hInUsd: p} = e.enrichment.token
      , h = (null == r ? void 0 : r.mentionedAtPerUiGroup) ? Object.keys(r.mentionedAtPerUiGroup) : []
      , {totalMentions: m, firstMentionTs: g, firstMentionId: x} = c.reduce(Object.entries((null == r ? void 0 : r.mentionedAtPerUiGroup) ?? {}), ( (e, [t,n]) => ((null === e.firstMentionTs || e.firstMentionTs > n.firstMentionAt) && (e.firstMentionTs = n.firstMentionAt,
    e.firstMentionId = t),
    null === e.totalMentions ? e.totalMentions = n.mentionsCount : e.totalMentions = e.totalMentions + n.mentionsCount,
    e)), {
        totalMentions: null,
        firstMentionTs: null,
        firstMentionId: null
    })
      , b = x ? t.current[x] ?? null : null;
    return [{
        chain: a,
        tokenAddress: s,
        source: e.type,
        mentionGroupName: n.shortName ?? n.name,
        mentionGroupImageUrl: n.imageUrl,
        mentionMessageLink: i8(e.groupId, e.channelId, e.messageId),
        messageId: e.messageId,
        eventTimestamp: e.timestamp
    }, {
        chain: e.enrichment.token.chain,
        tokenAddress: e.enrichment.token.address,
        tokenName: i,
        tokenSymbol: l,
        deployedAt: o,
        padreAvatarUrl: d,
        mentionedGroupIds: h,
        totalMentions: m,
        firstMentionTs: g,
        firstMentionImageUrl: (null == b ? void 0 : b.imageUrl) ?? null,
        vol1h: p,
        marketCap: u
    }]
}
  , i8 = (e, t, n) => `https://discord.com/channels/${e}/${t}/${n}`
  , c8 = e => `${e.source}-${e.messageId}`
  , d8 = (e, t) => c.uniqBy([...e, ...t], c8).sort(( (e, t) => t.eventTimestamp - e.eventTimestamp)).slice(0, 30)
  , u8 = (e, t, n, r) => {
    const a = Ax()
      , s = y.useMemo(( () => (e => (t, n) => {
        if ("init" === n.type)
            return {
                mentions: d8([], s8(n.snapshot, e))
            };
        const r = s8(n.update, e);
        return {
            mentions: d8((null == t ? void 0 : t.mentions) ?? [], r)
        }
    }
    )(r)), [r])
      , o = y.useCallback((r => {
        var s, o;
        return a && e ? _m.subscribeTrackerGroupMentions(t.minPublicMentions ?? null, t.maxTokenAgeInSeconds ?? null, t.onlyFirstMentionPerGroup ? 1 : null, null, (null == (s = t.onlyChains) ? void 0 : s.length) && t.onlyChains.length !== t8.length ? YA(t.onlyChains) : YA(t8), (null == (o = t.onlyChannelUiIds) ? void 0 : o.length) ? JSON.stringify(t.onlyChannelUiIds) : null, {
            onMessage: e => {
                n.current && n.current(e),
                r.onMessage(e)
            }
            ,
            close: e => {
                r.close && r.close(e)
            }
        }) : {
            unsubscribe: () => {}
        }
    }
    ), [a, e, t.minPublicMentions, t.maxTokenAgeInSeconds, t.onlyFirstMentionPerGroup, t.onlyChains, t.onlyChannelUiIds, n])
      , l = kx(o, s);
    return e ? (null == l ? void 0 : l.mentions) ?? null : null
}
  , p8 = ({isVisible: e, children: t}) => {
    const n = y.useRef(!1)
      , r = y.useRef(new hg(1e3))
      , [a,s] = Mx("padreV2-alphaTrackerNotificationsEnabled", !1)
      , [o,l] = Mx("padreV2-alphaTrackerSoundEnabled", !1)
      , [i,d] = Mx("padreV2-alphaTrackerVolume", 100)
      , [u,p] = Mx("padreV2-alphaTrackerNotificationsDuration", 5)
      , [h,m] = Mx("padreV2-alphaTrackerSound", e8)
      , g = y.useMemo(( () => e || a), [a, e]);
    y.useEffect(( () => {
        g || (n.current = !1)
    }
    ), [g]);
    const x = mx(( () => {
        var e;
        const t = (null == (e = VK().user) ? void 0 : e.uid) ?? null
          , n = y.useCallback((e => t ? _m.subscribeUserOverrides(t, e) : {
            unsubscribe: () => {}
        }), [t]);
        return yx(n)
    }
    )())
      , {alphaGroupsSilenced: b, alphaGroupsHideOnChart: f, alphaGroupsHideOnLiveTrades: S, alphaTrackerConfigReady: k} = y.useMemo(( () => x ? c.reduce(Object.entries(x), ( (e, [t,n]) => (n.hideChartMarks && (e.alphaGroupsHideOnChart[t] = !0),
    n.hideInTracker && (e.alphaGroupsHideOnLiveTrades[t] = !0),
    n.hideNotifications && (e.alphaGroupsSilenced[t] = !0),
    e)), {
        alphaGroupsSilenced: {},
        alphaGroupsHideOnChart: {},
        alphaGroupsHideOnLiveTrades: {},
        alphaTrackerConfigReady: !0
    }) : {
        alphaGroupsSilenced: null,
        alphaGroupsHideOnChart: null,
        alphaGroupsHideOnLiveTrades: null,
        alphaTrackerConfigReady: !1
    }), [x])
      , {alphaGroups: C} = JG()
      , A = y.useRef(null)
      , [w,j] = y.useState(!1);
    y.useEffect(( () => {
        C ? (j(!0),
        A.current = c.reduce(C, ( (e, t) => (e[t.id] = t,
        e)), {})) : j(!1)
    }
    ), [C]);
    const T = pK()
      , I = yT()
      , E = y.useCallback(( (e, t) => {
        I({
            chain: e,
            tokenAddress: t,
            tradePageOrigin: nT.ALPHA_TRACKER
        })
    }
    ), [I])
      , {marketCapThresholds: M} = bA()
      , N = y.useRef(M);
    N.current = M;
    const P = ZA()
      , O = y.useRef(P);
    O.current = P;
    const L = y.useRef(h);
    L.current = h;
    const R = y.useRef(i);
    R.current = i;
    const D = y.useRef(u);
    D.current = u;
    const B = y.useRef(o);
    B.current = o;
    const _ = y.useRef(a);
    _.current = a;
    const U = y.useRef({});
    U.current = b ?? {};
    const W = y.useCallback((e => {
        o8(e, r, n, L.current, R.current, T, _.current, B.current, E, D.current, O.current, N.current, U.current, A)
    }
    ), [T, E])
      , F = y.useRef(W);
    y.useEffect(( () => {
        F.current = W
    }
    ), [W]);
    const [V,H] = Mx("padreV2-alphaTrackeFiltersV2", n8)
      , [z,$] = y.useState(!1);
    y.useEffect(( () => {
        var e, t;
        if (!C)
            return;
        const n = [...V.onlyChannelUiIds ?? [], ...(null == (e = V.onlyChannelIds) ? void 0 : e.length) ? V.onlyChannelIds.map((e => `discord-${e}`)) : []]
          , r = new Set(C.map((e => e.id)))
          , a = n.filter((e => r.has(e)));
        a.length !== ((null == (t = V.onlyChannelUiIds) ? void 0 : t.length) ?? 0) && H((e => {
            var t;
            return {
                ...e,
                onlyChannelUiIds: a,
                ...(null == (t = V.onlyChannelIds) ? void 0 : t.length) ? {
                    onlyChannelIds: []
                } : {}
            }
        }
        )),
        $(!0)
    }
    ), [C, V, H]);
    const G = u8(g && z && w && k, V, F, A)
      , q = y.useCallback(( () => {
        s((e => !e)),
        null !== G && (n.current = !0)
    }
    ), [G, s])
      , K = y.useMemo(( () => ({
        displayData: G,
        alertsEnabled: a,
        toggleAlertsEnabled: q,
        soundEffectEnabled: o,
        setSoundEffectEnabled: l,
        selectedSoundEffect: h,
        setSelectedSoundEffect: m,
        notificationsVolume: i,
        setNotificationsVolume: d,
        notificationsDuration: u,
        setNotificationsDuration: p,
        filters: V,
        setFilters: H,
        alphaGroupsSilenced: b,
        alphaGroupsHideOnChart: f,
        alphaGroupsHideOnLiveTrades: S
    })), [G, a, u, i, h, p, d, m, l, o, q, V, H, b, f, S]);
    return v.jsx(r8.Provider, {
        value: K,
        children: t
    })
}
  , h8 = y.memo(( ({onClose: e, alphaGroups: t}) => {
    var n;
    const r = xw()
      , {setFilters: a, filters: s} = a8()
      , [o,l] = y.useState(!!s.onlyFirstMentionPerGroup)
      , i = y.useCallback(( () => {
        l((e => !e))
    }
    ), [])
      , [c,d] = y.useState(s.maxTokenAgeInSeconds ? Math.ceil(s.maxTokenAgeInSeconds / 60).toString() : "")
      , u = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e);
        d(t)
    }
    ), [])
      , [p,h] = y.useState(s.minPublicMentions ? s.minPublicMentions.toString() : "")
      , m = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e);
        h(t)
    }
    ), [])
      , [g,x] = y.useState(s.onlyChains ?? t8)
      , b = y.useCallback((e => {
        x((t => t.includes(e) ? t.filter((t => t !== e)) : [...t, e]))
    }
    ), [])
      , [f,A] = y.useState((null == (n = s.onlyChannelUiIds) ? void 0 : n.length) ? s.onlyChannelUiIds : t.map((e => e.id)))
      , w = y.useCallback((e => {
        A((t => t.includes(e) ? t.filter((t => t !== e)) : [...t, e]))
    }
    ), [])
      , j = y.useMemo(( () => f.length === t.length), [t, f.length])
      , T = y.useCallback(( () => {
        A(j ? [] : t.map((e => e.id)))
    }
    ), [j, t])
      , I = y.useCallback(( () => {
        const n = f.length === t.length ? [] : f;
        a({
            ...s,
            onlyFirstMentionPerGroup: o,
            onlyChannelUiIds: n,
            maxTokenAgeInSeconds: isNaN(Number(c)) || !c ? null : 60 * Number(c),
            minPublicMentions: isNaN(Number(p)) || !p ? null : Number(p),
            onlyChains: g
        }),
        e()
    }
    ), [s, c, p, f, o, a, e, t, g])
      , E = y.useCallback(( () => {
        a(n8),
        e()
    }
    ), [e, a]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(WR, {
            label: "Only first mention per group",
            isChecked: o,
            onClick: i
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            gap: 1,
            alignItems: "center",
            height: m8,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "Max token age (minutes)"
            }), v.jsx(je, {
                ...g8,
                placeholder: "Max",
                value: c,
                onChange: u
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            gap: 1,
            alignItems: "center",
            height: m8,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "Min public mentions"
            }), v.jsx(je, {
                ...g8,
                placeholder: "Min",
                value: p,
                onChange: m
            })]
        }), v.jsxs(S, {
            gap: .5,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "Chains"
            }), v.jsx(S, {
                display: "grid",
                gridTemplateColumns: r ? "repeat(3, 1fr)" : "repeat(2, 1fr)",
                width: "100%",
                rowGap: f8,
                columnGap: 1,
                children: t8.map((e => {
                    const t = g.includes(e)
                      , n = Jd(eg(e));
                    return v.jsx(WR, {
                        label: v.jsxs(S, {
                            direction: "row",
                            gap: .5,
                            alignItems: "center",
                            children: [v.jsx(Sz, {
                                chain: e
                            }), v.jsx(k, {
                                variant: "paragraph3",
                                color: "inherit",
                                children: n
                            })]
                        }),
                        isChecked: t,
                        onClick: () => {
                            b(e)
                        }
                    }, e)
                }
                ))
            })]
        }), v.jsxs(S, {
            gap: .5,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: "Only channel ids"
                }), v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: T,
                    sx: b8,
                    children: j ? "Unselect All" : "Select All"
                })]
            }), v.jsx(S, {
                display: "grid",
                gridTemplateColumns: r ? "repeat(3, 1fr)" : "repeat(2, 1fr)",
                width: "100%",
                rowGap: f8,
                columnGap: 1,
                children: t.map((e => {
                    const t = f.includes(e.id)
                      , n = iu(e.shortName ?? e.name, 16, 2);
                    return v.jsx(WR, {
                        label: v.jsxs(S, {
                            direction: "row",
                            gap: .5,
                            alignItems: "center",
                            children: [v.jsx(C, {
                                component: "img",
                                src: e.imageUrl,
                                sx: v8
                            }), v.jsx(k, {
                                variant: "paragraph3",
                                color: "inherit",
                                children: n
                            })]
                        }),
                        isChecked: t,
                        onClick: () => {
                            w(e.id)
                        }
                    }, e.id)
                }
                ))
            })]
        }), v.jsxs(S, {
            direction: "row",
            mt: 1,
            justifyContent: "space-between",
            gap: 1,
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: e,
                    children: "Cancel"
                }), v.jsx(F, {
                    sx: x8,
                    onClick: E,
                    children: v.jsx(US, {})
                })]
            }), v.jsx(V, {
                variant: "primary",
                size: "xxsmall",
                onClick: I,
                children: "Save"
            })]
        })]
    })
}
))
  , m8 = 28
  , g8 = {
    sx: {
        flexGrow: 1,
        borderWidth: 1,
        maxWidth: 80
    },
    size: "xsmall",
    inputProps: {
        inputMode: "decimal",
        "data-pseudotype": "numberLike",
        style: {
            fontWeight: 500
        },
        sx: {
            textAlign: "left",
            pl: 1,
            pr: 0,
            py: 1.5
        }
    }
}
  , x8 = {
    width: 20,
    height: 20,
    p: .25
}
  , b8 = {
    height: 24,
    fontSize: 12,
    px: .75,
    py: 0,
    borderRadius: 4,
    mr: -.75
}
  , f8 = {
    xs: 1,
    sm: .5
}
  , v8 = {
    borderRadius: "50%",
    height: 16,
    width: 16
}
  , S8 = y.memo(( () => {
    const e = D()
      , {alphaGroups: t} = JG()
      , {filters: n} = a8()
      , r = y.useMemo(( () => {
        var e, t;
        return !c.isNil(n.maxTokenAgeInSeconds) || !c.isNil(n.minPublicMentions) || !0 === n.onlyFirstMentionPerGroup || !!(null == (e = n.onlyChannelUiIds) ? void 0 : e.length) || !!(null == (t = n.onlyChains) ? void 0 : t.length) && n.onlyChains.length !== t8.length
    }
    ), [n.maxTokenAgeInSeconds, n.minPublicMentions, n.onlyChannelUiIds, n.onlyChains, n.onlyFirstMentionPerGroup])
      , {buttonProps: a, popoverProps: s} = Fw({
        id: "alpha-tracker-filters"
    });
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: k8,
            ...a,
            children: v.jsx(xk, {
                size: y8,
                color: r ? e.palette.primary.main : e.palette.text.label
            })
        }), v.jsx(ae, {
            ...s,
            onClick: Ww,
            anchorOrigin: C8,
            transformOrigin: A8,
            slotProps: j8,
            children: v.jsx(ee, {
                elevation: 1,
                sx: w8,
                className: "no-drag padre-no-scroll",
                children: t ? v.jsx(h8, {
                    onClose: s.onClose,
                    alphaGroups: t
                }) : v.jsx(Km, {})
            })
        })]
    })
}
))
  , y8 = 18
  , k8 = {
    p: 0,
    height: 24,
    width: 24,
    minWidth: 24,
    border: "none",
    background: "transparent"
}
  , C8 = {
    vertical: "bottom",
    horizontal: "center"
}
  , A8 = {
    vertical: "top",
    horizontal: "center"
}
  , w8 = e => ({
    minWidth: 320,
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    px: {
        xs: 2,
        sm: 1.5
    },
    py: 1
})
  , j8 = {
    paper: {
        className: "padre-no-scroll"
    }
}
  , T8 = "14px"
  , I8 = "10px"
  , E8 = ({children: e, initialX: t=0, initialY: n=0, initialWidth: r=200, initialHeight: a=200, minWidth: s=200, minHeight: o=300, resizable: l=!1, cancel: i, zIndex: c, onMouseDown: d, onDragStart: u, onDrag: p, onPositionLocked: h, onResizeStart: m, onResize: g, onResizeStop: x, hasModals: b, resizeOnInitialChange: f, rightResizeOffset: S=0}) => {
    const k = y.useRef(null)
      , C = y.useRef({
        x: t,
        y: n
    })
      , A = y.useRef(!1)
      , w = y.useRef({
        x: 0,
        y: 0
    })
      , j = y.useRef({
        x: t,
        y: n
    })
      , T = y.useRef(null)
      , I = y.useRef(!1)
      , E = y.useRef({
        clickX: 0,
        clickY: 0,
        posX: t,
        posY: n,
        width: r,
        height: a
    })
      , M = y.useRef({
        width: r,
        height: a
    })
      , N = y.useRef({
        width: r,
        height: a
    })
      , P = y.useCallback((e => {
        var t;
        if (ke(null == (t = k.current) ? void 0 : t.parentElement))
            return e;
        const n = k.current.parentElement.clientWidth;
        return Math.min(Math.max(4, e), n - 4)
    }
    ), [])
      , O = y.useCallback((e => {
        var t;
        if (ke(null == (t = k.current) ? void 0 : t.parentElement))
            return e;
        const n = k.current.parentElement.clientHeight;
        return Math.min(Math.max(4, e), n - 4)
    }
    ), [])
      , L = y.useCallback((e => {
        var t;
        if (ke(null == (t = k.current) ? void 0 : t.parentElement))
            return e;
        const n = k.current.parentElement.clientWidth;
        return Math.min(Math.max(e, l ? s : 0), n - 8)
    }
    ), [s, l])
      , R = y.useCallback((e => {
        var t;
        if (ke(null == (t = k.current) ? void 0 : t.parentElement))
            return e;
        const n = k.current.parentElement.clientHeight;
        return Math.min(Math.max(e, l ? o : 0), n - 8)
    }
    ), [o, l])
      , D = y.useCallback(( (e, t, n, r) => {
        var a, o;
        const l = (null == (o = null == (a = k.current) ? void 0 : a.parentElement) ? void 0 : o.clientWidth) ?? 1 / 0
          , i = Math.min(Math.max(t, s), l)
          , c = Math.min(Math.max(4, e), l - t - 4);
        return c > n + r - s ? [n + r - s, s] : [c, L(i)]
    }
    ), [s, L])
      , B = y.useCallback(( (e, t, n, r) => {
        var a, s;
        const l = (null == (s = null == (a = k.current) ? void 0 : a.parentElement) ? void 0 : s.clientHeight) ?? 1 / 0
          , i = Math.min(Math.max(t, o), l)
          , c = Math.min(Math.max(4, e), l - t - 4);
        return c > n + r - o ? [n + r - o, o] : [c, R(i)]
    }
    ), [o, R])
      , [_,U] = y.useState(!1);
    y.useEffect(( () => {
        if (!k.current || _)
            return;
        const e = requestAnimationFrame(( () => {
            U(!0)
        }
        ));
        return () => cancelAnimationFrame(e)
    }
    ), [_]);
    const W = y.useCallback((e => {
        if (k.current && k.current.parentElement) {
            const {width: t, height: n} = M.current
              , r = k.current.parentElement.clientWidth
              , a = k.current.parentElement.clientHeight
              , {x: s, y: o} = C.current
              , l = Math.min(Math.max(4, s), Math.max(0, r - t - 4))
              , i = Math.min(Math.max(4, o), Math.max(a - n - 4, 0));
            C.current = {
                x: l,
                y: i
            },
            k.current.style.transform = `translate(${l}px, ${i}px)`,
            k.current.style.width = `${t}px`,
            k.current.style.height = `${n}px`,
            e && h && h(C.current.x, C.current.y)
        }
        T.current = null
    }
    ), [h]);
    y.useEffect(( () => {
        f && _ && (N.current = {
            width: r,
            height: a
        },
        M.current = {
            width: r,
            height: a
        },
        W(!0))
    }
    ), [r, a, f, W, _]);
    const F = y.useCallback((e => {
        d && d(e),
        i && (e.target.closest(`.${i}`) || b && e.target.closest(".MuiPopover-root")) || e.target.classList.contains("resize-handle") || (e.currentTarget.setPointerCapture(e.pointerId),
        A.current = !0,
        w.current = {
            x: e.clientX,
            y: e.clientY
        },
        j.current = {
            ...C.current
        },
        u && u(C.current.x, C.current.y))
    }
    ), [d, u, i, b])
      , V = y.useCallback((e => {
        if (A.current) {
            const t = e.clientX - w.current.x
              , n = e.clientY - w.current.y
              , r = j.current.x + t
              , a = j.current.y + n;
            C.current = {
                x: r,
                y: a
            },
            null === T.current && (T.current = requestAnimationFrame(( () => W(!1)))),
            p && p(r, a)
        }
    }
    ), [p, W])
      , H = y.useCallback((e => {
        A.current && (A.current = !1,
        h && h(C.current.x, C.current.y),
        e.currentTarget.releasePointerCapture(e.pointerId))
    }
    ), [h])
      , z = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        I.current = !0,
        E.current = {
            clickX: e.clientX,
            clickY: e.clientY,
            posX: C.current.x,
            posY: C.current.y,
            width: M.current.width,
            height: M.current.height
        },
        N.current = {
            ...M.current
        },
        e.currentTarget.setPointerCapture(e.pointerId),
        m && m(C.current.x, C.current.y, M.current.width, M.current.height)
    }
    ), [m])
      , $ = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = E.current.posX
              , r = L(Math.max(s, N.current.width + t));
            M.current.width = r,
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(n, E.current.posY, r, M.current.height)
        }
    }
    ), [g, P, L, W, s])
      , G = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = O(e.clientY) - E.current.clickY
              , r = E.current.posX
              , a = E.current.posY
              , l = L(Math.max(s, N.current.width + t))
              , i = R(Math.max(o, N.current.height + n));
            M.current = {
                width: l,
                height: i
            },
            C.current = {
                x: r,
                y: a
            },
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(r, a, l, i)
        }
    }
    ), [g, P, O, L, R, W, s, o])
      , q = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = O(e.clientY) - E.current.clickY
              , n = R(Math.max(o, N.current.height + t))
              , r = E.current.posY;
            M.current.height = n,
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(E.current.posY, r, M.current.width, n)
        }
    }
    ), [g, O, R, W, o])
      , K = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = O(e.clientY) - E.current.clickY
              , r = Math.max(s, N.current.width - t)
              , a = R(Math.max(o, N.current.height + n))
              , [l,i] = D(E.current.posX + t, r, E.current.posX, E.current.width)
              , c = E.current.posY;
            M.current = {
                width: i,
                height: a
            },
            C.current = {
                x: l,
                y: c
            },
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(l, c, i, a)
        }
    }
    ), [g, P, O, R, W, D, s, o])
      , Y = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = Math.max(s, N.current.width - t)
              , [r,a] = D(E.current.posX + t, n, E.current.posX, E.current.width);
            M.current.width = a,
            C.current.x = r,
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(r, C.current.y, a, M.current.height)
        }
    }
    ), [g, P, W, D, s])
      , X = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = O(e.clientY) - E.current.clickY
              , r = Math.max(s, N.current.width - t)
              , a = Math.max(o, N.current.height - n)
              , [l,i] = D(E.current.posX + t, r, E.current.posX, E.current.width)
              , [c,d] = B(E.current.posY + n, a, E.current.posY, E.current.height);
            M.current = {
                width: i,
                height: d
            },
            C.current = {
                x: l,
                y: c
            },
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(l, c, i, d)
        }
    }
    ), [g, P, O, D, B, W, s, o])
      , Q = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = O(e.clientY) - E.current.clickY
              , n = R(Math.max(o, N.current.height - t))
              , [r,a] = B(E.current.posY + t, n, E.current.posY, E.current.height);
            M.current.height = a,
            C.current.y = r,
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(E.current.posY, r, M.current.width, a)
        }
    }
    ), [g, O, R, W, B, o])
      , Z = y.useCallback((e => {
        if (I.current) {
            e.preventDefault();
            const t = P(e.clientX) - E.current.clickX
              , n = O(e.clientY) - E.current.clickY
              , r = E.current.posX
              , a = L(Math.max(s, N.current.width + t))
              , l = Math.max(o, N.current.height - n)
              , [i,c] = B(E.current.posY + n, l, E.current.posY, E.current.height);
            M.current = {
                width: a,
                height: c
            },
            C.current = {
                x: r,
                y: i
            },
            null === T.current && (T.current = requestAnimationFrame(( () => {
                W(!1)
            }
            ))),
            g && g(r, i, a, c)
        }
    }
    ), [g, P, O, L, W, B, s, o])
      , J = y.useCallback((e => {
        I.current && (I.current = !1,
        x && x(C.current.x, C.current.y, M.current.width, M.current.height),
        e.currentTarget.releasePointerCapture(e.pointerId))
    }
    ), [x]);
    return y.useEffect(( () => {
        if (k.current) {
            const e = k.current;
            e.style.position = "absolute",
            e.style.top = "0",
            e.style.left = "0",
            e.style.transform = `translate(${C.current.x}px, ${C.current.y}px)`,
            e.style.width = `${M.current.width}px`,
            e.style.height = `${M.current.height}px`,
            e.style.cursor = "move",
            e.style.userSelect = "none",
            "number" == typeof c && (e.style.zIndex = c.toString())
        }
    }
    ), [c]),
    y.useEffect(( () => {
        const e = setInterval(( () => {
            if (k.current && k.current.parentElement) {
                const e = k.current.parentElement.clientWidth
                  , t = k.current.parentElement.clientHeight
                  , n = 4
                  , {x: r, y: a} = C.current
                  , {width: s, height: o} = M.current;
                I.current || A.current || !(r < n || a < n || r > e - s - n || a > t - o - n || s > e - 2 * n || o > t - 2 * n) || (M.current.height = R(M.current.height),
                M.current.width = L(M.current.width),
                W(!0))
            }
        }
        ), 200);
        return () => clearInterval(e)
    }
    ), [R, L, W]),
    v.jsxs("div", {
        ref: k,
        onPointerDown: F,
        onPointerMove: V,
        onPointerUp: H,
        children: [e, l && v.jsxs(v.Fragment, {
            children: [v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    width: I8,
                    top: 0,
                    bottom: 0,
                    right: S,
                    cursor: "e-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: $,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    width: T8,
                    height: T8,
                    right: S,
                    bottom: 0,
                    cursor: "se-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: G,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    height: T8,
                    left: T8,
                    right: 0 === S ? T8 : `calc(${T8} + ${S}px)`,
                    bottom: 0,
                    cursor: "s-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: q,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    width: T8,
                    height: T8,
                    left: 0,
                    bottom: 0,
                    cursor: "sw-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: K,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    top: I8,
                    left: 0,
                    bottom: T8,
                    width: I8,
                    cursor: "w-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: Y,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    width: I8,
                    height: I8,
                    left: 0,
                    top: 0,
                    cursor: "nw-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: X,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    height: I8,
                    left: I8,
                    right: 0 === S ? I8 : `calc(${I8} + ${S}px)`,
                    top: 0,
                    cursor: "n-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: Q,
                onPointerUp: J
            }), v.jsx("div", {
                className: "resize-handle",
                style: {
                    position: "absolute",
                    width: I8,
                    height: I8,
                    right: S,
                    top: 0,
                    cursor: "ne-resize",
                    zIndex: Hw
                },
                onPointerDown: z,
                onPointerMove: Z,
                onPointerUp: J
            })]
        })]
    })
}
  , M8 = "floating-widget-no-opacity"
  , N8 = "flaoting-widget-side-panel"
  , P8 = y.memo(( ({id: e, width: t, height: n, initialX: r, initialY: a, isOpen: s=!0, header: o, onClose: l, children: i, internalIndex: c=0, resizeParams: d, headerSx: u={}, hasModals: p, disableHeader: h=!1, noPadding: m=!1, noContentPadding: g=!1, noBottomPadding: x=!1, disableScroll: b=!1, resizeOnInitialChange: f=!1, smallHeaderGap: C=!1, hasCustomBackgroundOpacity: A=!1, lightBackground: w=!1, sidePanel: j, sidePanelWidth: T}) => {
    const {toggleMostRecentWidget: I} = Lce()
      , [E,M] = Mx(`padreV2-${e.toLowerCase()}StickyNotePosition-v2`, {
        x: r,
        y: a
    })
      , [N,P] = Mx(`padreV2-${e.toLowerCase()}StickyNoteSize-v2`, {
        width: t,
        height: n
    });
    y.useEffect(( () => {
        f && P({
            width: t,
            height: n
        })
    }
    ), [n, f, P, t]);
    const O = y.useCallback(( (e, t, n, r) => {
        M({
            x: e,
            y: t
        }),
        P({
            width: n - (j && T ? T : 0),
            height: r
        })
    }
    ), [P, M, j, T])
      , L = y.useCallback(( (e, t) => {
        M({
            x: e,
            y: t
        })
    }
    ), [M])
      , R = y.useCallback(( () => {
        I(e)
    }
    ), [e, I])
      , D = !!j && !!T
      , B = D ? T : 0
      , [_,U] = y.useState(!1)
      , W = y.useMemo(( () => e => ({
        width: "100%",
        height: "100%",
        p: m || g ? 0 : 1,
        pt: g ? 1 : void 0,
        ...x ? {
            pb: 0
        } : {},
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-between",
        alignItems: "center",
        cursor: "grab",
        userSelect: "none",
        pointerEvents: "auto",
        border: `1px solid ${e.palette.background.borderSecondary}${A ? "77" : ""}`,
        ...A ? {
            background: "transparent"
        } : {
            backgroundColor: w ? e.palette.background.buttonDefault : e.palette.background.default
        },
        gap: g ? 0 : C ? "5px" : 1,
        overflowY: b ? "clip" : "scroll",
        overflowX: b ? "clip" : "auto",
        boxShadow: "0px 0px 10px 2px rgba(0, 0, 0, 0.5)",
        ...D ? {
            borderTopRightRadius: 0,
            borderBottomRightRadius: 0
        } : {}
    })), [m, g, x, C, b, A, D, w])
      , V = y.useRef(D)
      , H = y.useRef(B)
      , z = y.useMemo(( () => {
        const e = V.current !== D || H.current !== B;
        return f || e
    }
    ), [f, D, B]);
    y.useEffect(( () => {
        V.current = D,
        H.current = B
    }
    ), [D, B]);
    const $ = y.useCallback(( () => {
        U(!0)
    }
    ), [])
      , G = y.useCallback(( () => {
        U(!0)
    }
    ), [])
      , q = y.useCallback(( (e, t) => {
        U(!1),
        L(e, t)
    }
    ), [L])
      , K = y.useCallback(( (e, t, n, r) => {
        U(!1),
        O(e, t, n, r)
    }
    ), [O])
      , Y = y.useMemo(( () => e => ({
        borderRight: `1px solid ${e.palette.background.borderActive}`,
        borderTop: `1px solid ${e.palette.background.borderActive}`,
        borderBottom: `1px solid ${e.palette.background.borderActive}`,
        borderTopRightRadius: "4px",
        borderBottomRightRadius: "4px",
        py: "1px",
        borderLeft: "none",
        ..._ ? {
            [`.${N8}`]: {
                opacity: .5
            }
        } : {}
    })), [_]);
    return s ? v.jsx(E8, {
        onMouseDown: R,
        cancel: "no-drag",
        initialX: E.x ?? r,
        initialY: E.y ?? a,
        initialWidth: N.width + B,
        initialHeight: N.height,
        onResizeStop: K,
        onPositionLocked: q,
        onDragStart: $,
        onResizeStart: G,
        resizable: !!d,
        zIndex: Hw + c,
        hasModals: p,
        resizeOnInitialChange: z,
        ...d,
        minWidth: ((null == d ? void 0 : d.minWidth) ?? t) + (D ? B : 0),
        rightResizeOffset: D ? B : 0,
        children: v.jsxs(S, {
            direction: "row",
            width: "100%",
            height: "100%",
            children: [v.jsx(S, {
                flex: "1 1 auto",
                minWidth: 0,
                height: "100%",
                children: v.jsxs(ee, {
                    elevation: 0,
                    sx: W,
                    className: "padre-no-scroll",
                    children: [!h && v.jsxs(v.Fragment, {
                        children: [v.jsxs(S, {
                            direction: "row",
                            width: "100%",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: 1,
                            flex: "0 0 auto",
                            px: g ? 1 : 0,
                            pb: g ? 1 : 0,
                            mt: C ? "-3px" : 0,
                            children: [v.jsxs(S, {
                                width: "100%",
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                sx: u,
                                children: [v.jsx(wf, {}), o && "string" == typeof o ? v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    sx: {
                                        alignSelf: "center"
                                    },
                                    children: o
                                }) : o]
                            }), l && v.jsx(F, {
                                className: "no-drag",
                                sx: O8,
                                onClick: l,
                                children: v.jsx(gy, {})
                            })]
                        }), v.jsx(Ee, {
                            flexItem: !0,
                            sx: L8
                        })]
                    }), i]
                })
            }), D && v.jsx(S, {
                flex: "0 0 auto",
                width: B,
                sx: Y,
                children: j
            })]
        })
    }) : null
}
))
  , O8 = {
    p: 0,
    width: 16,
    minWidth: 16,
    height: 16
}
  , L8 = {
    mx: -1.25
}
  , R8 = [Pd.SOLANA, Pd.BSC]
  , D8 = y.memo(( ({customBgSrc: e, refreshCustomBgSrc: t, onClose: n, opacity: r, setOpacity: a, blur: s, setBlur: o, showUsd: l, toggleShowUsd: i}) => {
    const c = D()
      , d = Ax()
      , u = pK()
      , p = y.useCallback(( (e, t) => {
        const n = t;
        isNaN(n) || a(Number((n / 100).toFixed(2)))
    }
    ), [a])
      , h = y.useCallback(( (e, t) => {
        const n = t;
        isNaN(n) || o(lb(n, {
            min: 0,
            max: 20
        }))
    }
    ), [o])
      , m = y.useRef(null)
      , [g,x] = y.useState(!1)
      , [b,f] = y.useState(!1)
      , A = y.useCallback((async e => {
        if (!d)
            return;
        if (!_8.includes(e.type))
            return void u({
                message: uu.unsupportedFileType,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "bg-upload-error-type");
        if (e.size > Wh[Uh.CUSTOM_PNL_BACKGROUND].maxSize)
            return void u({
                message: uu.backgroundExceedsSize,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "bg-upload-error-size");
        try {
            x(!0);
            const [r,a] = await (n = e,
            new Promise(( (e, t) => {
                const r = new FileReader;
                r.onload = () => {
                    const t = r.result
                      , [n,a] = t.split(",")
                      , s = n.match(/^data:([^;]+);/)
                      , o = s ? s[1] : "";
                    e([o, a])
                }
                ,
                r.onerror = t,
                r.readAsDataURL(n)
            }
            )));
            await Im.upload(d, {
                name: e.name.slice(0, 190),
                base64: a,
                contentType: r,
                contentCategory: Uh.CUSTOM_PNL_BACKGROUND
            }),
            await t(),
            u({
                message: pu.backgroundUploadSuccess,
                type: "success"
            }, "bg-upload-success")
        } catch (r) {
            u({
                message: uu.unknownError,
                snackName: pu.backgroundUploadFailed,
                type: "error"
            }, "bg-upload-error")
        } finally {
            x(!1)
        }
        var n
    }
    ), [u, t, d])
      , w = y.useCallback((e => {
        var t;
        const n = null == (t = e.target.files) ? void 0 : t[0];
        n && A(n)
    }
    ), [A])
      , j = y.useCallback(( () => {
        var e;
        null == (e = m.current) || e.click()
    }
    ), [])
      , T = y.useCallback((async () => {
        if (d)
            try {
                f(!0),
                await Im.remove(d, {
                    contentCategory: Uh.CUSTOM_PNL_BACKGROUND
                }),
                await t(),
                u({
                    message: uu.backgroundRemovalSuccess,
                    type: "success"
                }, "bg-remove-success")
            } catch (fNe) {
                u({
                    message: uu.unknownError,
                    type: "error"
                }, "bg-remove-failed")
            } finally {
                f(!1)
            }
    }
    ), [u, t, d])
      , [I,E] = y.useState(!1)
      , M = y.useCallback((e => {
        var t;
        e.preventDefault();
        const n = null == (t = e.dataTransfer.items) ? void 0 : t[0];
        n && "file" === n.kind && _8.includes(n.type) ? E(!0) : E(!1)
    }
    ), [])
      , N = y.useCallback(( () => {
        E(!1)
    }
    ), [])
      , P = y.useCallback((async e => {
        var t;
        e.preventDefault(),
        E(!1);
        const n = null == (t = e.dataTransfer.files) ? void 0 : t[0];
        n && await A(n)
    }
    ), [A])
      , O = y.useMemo(( () => t => ({
        width: "100%",
        height: "auto",
        aspectRatio: 4,
        borderRadius: "4px",
        border: `${e && !I ? 1 : 2}px ${e && !I ? "solid" : "dashed"} ${I ? t.palette.primary.main : t.palette.background.borderMain}`,
        ...!e && I ? {
            background: t.palette.primary.background
        } : {},
        [`.${V8}`]: {
            display: "none"
        },
        overflow: "hidden",
        "&:hover": {
            cursor: "pointer",
            borderColor: I ? t.palette.primary.main : t.palette.background.borderActive,
            [`.${V8}`]: {
                display: "flex"
            }
        }
    })), [e, I])
      , L = y.useMemo(( () => () => ({
        width: "100%",
        height: "100%",
        objectFit: "cover",
        zIndex: 0,
        backgroundImage: e ? `url(${e})` : "none",
        backgroundSize: "cover",
        backgroundPosition: "center",
        pointerEvents: "none",
        opacity: r,
        filter: `blur(${lb(s, {
            min: 0,
            max: 20
        })}px)`
    })), [s, e, r]);
    return v.jsx(Sw, {
        open: !0,
        onClose: n,
        desktopWidth: U8,
        minDesktopWidth: U8,
        disableBackdropClick: !0,
        stackSx: W8,
        className: "no-drag",
        children: v.jsx(re, {
            onClickAway: n,
            children: v.jsxs(S, {
                gap: 2.5,
                children: [v.jsx(S, {
                    gap: 1.5,
                    children: v.jsxs(S, {
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        mt: -1,
                        children: [v.jsx(k, {
                            variant: "h1",
                            color: "text.main",
                            children: "Settings"
                        }), v.jsx(F, {
                            sx: B8,
                            onClick: n,
                            children: v.jsx(kS, {
                                size: 20
                            })
                        })]
                    })
                }), v.jsx(S, {
                    gap: 1,
                    children: v.jsxs(S, {
                        onClick: i,
                        sx: q8,
                        direction: "row",
                        justifyContent: "space-between",
                        gap: 1,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.value",
                            children: "Show USD values"
                        }), v.jsx(Ue, {
                            checked: l,
                            size: "small",
                            color: l ? "success" : "neutral"
                        })]
                    })
                }), v.jsx("input", {
                    ref: m,
                    type: "file",
                    accept: _8.join(","),
                    hidden: !0,
                    onChange: w
                }), v.jsxs(S, {
                    gap: 1.5,
                    children: [v.jsxs(S, {
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        gap: 1,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.main",
                            noWrap: !0,
                            children: "Custom Background"
                        }), e && v.jsx(F, {
                            sx: F8,
                            onClick: T,
                            disabled: g || b,
                            children: b ? v.jsx(J, {
                                size: 12
                            }) : v.jsx(wS, {
                                color: c.palette.error.main,
                                size: 14
                            })
                        })]
                    }), v.jsxs(C, {
                        display: "flex",
                        onClick: j,
                        position: "relative",
                        sx: O,
                        onDragOver: M,
                        onDragLeave: N,
                        onDrop: P,
                        children: [e && v.jsx(C, {
                            position: "absolute",
                            sx: L
                        }), !e && v.jsxs(S, {
                            position: "absolute",
                            alignItems: "center",
                            justifyContent: "center",
                            width: "100%",
                            height: "100%",
                            gap: 1,
                            children: [v.jsx(ek, {
                                size: 20
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                children: "Select or drag and drop an image here"
                            })]
                        }), e && v.jsxs(S, {
                            position: "absolute",
                            alignItems: "center",
                            justifyContent: "center",
                            width: "100%",
                            height: "100%",
                            gap: 1,
                            sx: $8,
                            className: V8,
                            children: [v.jsx(ek, {
                                size: 20
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                children: "Upload custom background"
                            })]
                        })]
                    })]
                }), e && v.jsxs(S, {
                    gap: 1.5,
                    children: [v.jsxs(S, {
                        gap: 1,
                        children: [v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.value",
                                children: "Opacity"
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                children: `${(100 * r).toFixed(0)}%`
                            })]
                        }), v.jsx(Z, {
                            size: "small",
                            step: 1,
                            min: 0,
                            max: 100,
                            value: 100 * r,
                            onChange: p,
                            marks: H8,
                            sx: G8
                        })]
                    }), v.jsxs(S, {
                        gap: 1,
                        children: [v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.value",
                                children: "Blur"
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                children: `${s.toFixed(0)}px`
                            })]
                        }), v.jsx(Z, {
                            size: "small",
                            step: 1,
                            min: 0,
                            max: 20,
                            value: s,
                            onChange: h,
                            marks: z8,
                            sx: G8
                        })]
                    })]
                })]
            })
        })
    })
}
))
  , B8 = {
    p: .25
}
  , _8 = ["image/png", "image/jpeg", "image/webp", "image/gif"]
  , U8 = 350
  , W8 = {
    px: 2,
    pb: 2,
    pt: 3
}
  , F8 = {
    p: .25,
    height: 18,
    width: 18
}
  , V8 = "pnl-background-preview-hover"
  , H8 = [{
    value: 0,
    label: "0"
}, {
    value: 25,
    label: "25"
}, {
    value: 50,
    label: "50"
}, {
    value: 75,
    label: "75"
}, {
    value: 100,
    label: "100"
}]
  , z8 = [{
    value: 0,
    label: "0"
}, {
    value: 5,
    label: "5"
}, {
    value: 10,
    label: "10"
}, {
    value: 15,
    label: "15"
}, {
    value: 20,
    label: "20"
}]
  , $8 = e => ({
    background: `${e.palette.background.primary}44`
})
  , G8 = e => ({
    transition: "none",
    "& .MuiSlider-thumb": {
        transition: "none",
        boxShadow: "none",
        "&:hover, &:focus, &.Mui-active, &.Mui-focusVisible": {
            boxShadow: "none"
        }
    },
    "& .MuiSlider-track": {
        transition: "none"
    },
    "& .MuiSlider-rail": {
        transition: "none"
    },
    "&:hover": {
        backgroundColor: "transparent"
    },
    "& .MuiSlider-markLabel": {
        fontSize: "0.7rem",
        color: e.palette.text.label,
        mt: "-8px"
    },
    "& .MuiSlider-mark": {
        height: 4
    }
})
  , q8 = {
    "&:hover": {
        cursor: "pointer"
    }
}
  , K8 = (e, t, n) => {
    if (e === Pd.SOLANA)
        return t;
    if (e === Pd.BSC)
        return n;
    throw new Error(`Unsupported chain ${e}`)
}
  , Y8 = (e, t, n) => e === Pd.BSC ? n : t;
let X8 = {
    bgSrc: null,
    ts: 0
};
const Q8 = e => Math.max(e.width, e.height)
  , Z8 = e => {
    const {valueSize: t} = (e => {
        const t = 4 * Math.round(.1125 * e / 4)
          , n = .4 * t;
        return {
            labelSize: Math.round(n),
            valueSize: t
        }
    }
    )(e.width)
      , {valueSize: n} = (e => {
        const t = 4 * Math.round(e * (18 / 53) / 4)
          , n = .4 * t;
        return {
            labelSize: Math.round(n),
            valueSize: t
        }
    }
    )(e.height)
      , r = Math.min(t, n)
      , a = e.width / 160
      , s = e.height / 53
      , o = Math.min(a, s)
      , l = 1 - Math.min(Math.max(0, o - 6), .18)
      , i = Math.max(8, 4 * Math.round(r * l / 4));
    return {
        labelSize: Math.round(.4 * i),
        valueSize: i
    }
}
  , J8 = y.memo(( ({onClose: e, opacity: t, setOpacity: n, blur: r, setBlur: a}) => {
    const s = D()
      , {t: o} = we()
      , [l,d] = y.useState(!1)
      , u = y.useCallback(( () => {
        d(!0)
    }
    ), [])
      , p = y.useCallback(( () => {
        d(!1)
    }
    ), [])
      , [h,m] = Mx("padreV2-pnlTrackerShowUsdValues", !0)
      , g = y.useCallback(( () => {
        m((e => !e))
    }
    ), [m])
      , {reset: x, currentTotalValue: b, initialTotalValue: f, pnlTrackerChain: A, setPnlTrackerChain: w} = ( () => {
        const {settings: e, updatePnlTrackerInitialValue: t, updatePnlTrackerInitialValueBsc: n} = rf()
          , {solBalances: r} = y.useContext(zD)
          , {bscBalances: a} = WJ()
          , [s,o] = Mx("padreV2-pnlTrackerChain", Pd.SOLANA);
        y.useEffect(( () => {
            !R8.includes(s) && R8.length && o(R8[0])
        }
        ), [s, o]);
        const l = y.useMemo(( () => r ? c.reduce(Object.values(r), ( (e, t) => {
            const n = t[Gc]
              , r = Number(n);
            return isNaN(r) ? e : e + Number(n) / 10 ** kU
        }
        ), 0) : null), [r])
          , i = y.useMemo(( () => a ? c.reduce(Object.values(a), ( (e, t) => {
            const n = Number(t);
            return isNaN(n) ? e : e + Number(t) / 10 ** yU
        }
        ), 0) : null), [a])
          , [d,u] = y.useState((null == e ? void 0 : e.pnlTrackerInitialValue) ?? null)
          , [p,h] = y.useState((null == e ? void 0 : e.pnlTrackerInitialValueBsc) ?? null)
          , m = y.useCallback(( () => {
            switch (s) {
            case Pd.BSC:
                null !== i && n(i);
                break;
            case Pd.SOLANA:
                null !== l && t(l);
                break;
            default:
                return
            }
        }
        ), [l, i, s, t, n]);
        return y.useEffect(( () => {
            null !== e && null === d && void 0 === (null == e ? void 0 : e.pnlTrackerInitialValue) && null !== l && (u(l),
            t(l))
        }
        ), [l, d, t, e]),
        y.useEffect(( () => {
            void 0 !== (null == e ? void 0 : e.pnlTrackerInitialValue) && u(e.pnlTrackerInitialValue)
        }
        ), [null == e ? void 0 : e.pnlTrackerInitialValue]),
        y.useEffect(( () => {
            null !== e && null === p && void 0 === (null == e ? void 0 : e.pnlTrackerInitialValueBsc) && null !== i && (h(i),
            n(i))
        }
        ), [l, d, t, e, p, i, n]),
        y.useEffect(( () => {
            void 0 !== (null == e ? void 0 : e.pnlTrackerInitialValueBsc) && h(e.pnlTrackerInitialValueBsc)
        }
        ), [null == e ? void 0 : e.pnlTrackerInitialValueBsc]),
        {
            reset: m,
            currentTotalValue: Y8(s, l, i),
            initialTotalValue: Y8(s, d, p),
            pnlTrackerChain: s,
            setPnlTrackerChain: o
        }
    }
    )()
      , j = y.useCallback(( () => {
        A !== Pd.SOLANA && w(Pd.SOLANA)
    }
    ), [A, w])
      , T = y.useCallback(( () => {
        A !== Pd.BSC && w(Pd.BSC)
    }
    ), [A, w])
      , {customBgSrc: I, refreshCustomBgSrc: E} = ( () => {
        const e = Ax()
          , [t,n] = y.useState(null)
          , [r,a] = Mx("padreV2-pnl-widget-last-custom-bg", null)
          , [s,o] = y.useState(!1)
          , l = y.useCallback((async (t=!1) => {
            if ((t || s) && e)
                try {
                    const t = await Im.getSingle(e, Uh.CUSTOM_PNL_BACKGROUND)
                      , r = t.result ? {
                        contentType: t.result.contentType,
                        contentUri: t.result.contentUri
                    } : null;
                    X8 = {
                        bgSrc: r,
                        ts: i().unix()
                    },
                    n(r),
                    a(r ? r.contentUri : null)
                } catch (fNe) {}
        }
        ), [s, a, e]);
        return y.useEffect(( () => {
            !s && e && (X8.bgSrc && i().unix() - 600 < X8.ts ? n(X8.bgSrc) : (o(!0),
            l(!0)))
        }
        ), [s, l, e]),
        {
            customBgSrc: r ?? (null == t ? void 0 : t.contentUri) ?? null,
            refreshCustomBgSrc: l
        }
    }
    )()
      , {chainStats: M} = FV()
      , [N,P,O,L,R,B] = y.useMemo(( () => {
        if (null === b || null === f || !R8.includes(A))
            return [null, null, null, null, null, null];
        const e = (null == M ? void 0 : M.perChain[Pd.SOLANA]) ?? null
          , t = (null == M ? void 0 : M.perChain[Pd.BSC]) ?? null
          , n = A === Pd.SOLANA ? e : t
          , r = n ? b * n.stats.nativePriceInUsdUi : null
          , a = b - f
          , s = n ? a * n.stats.nativePriceInUsdUi : null
          , o = 0 === f ? 0 : a / f * 100
          , l = 0 === Number(a.toFixed(Math.abs(a) < .1 ? 3 : 2)) ? null : a > 0;
        return [b.toFixed(b < .1 ? 3 : b >= 100 ? 0 : 2), null !== r ? LI(r, {
            collapseExponent: !0,
            desiredDigits: 3,
            symbol: "USD",
            symbolPosition: yI.END,
            padSymbol: !0
        }) : null, `${null === l ? "" : l ? "+" : "-"}${null === l ? "0.00" : Math.abs(a).toFixed(Math.abs(a) < .1 ? 3 : Math.abs(a) > 100 ? 0 : 2)}`, `${0 === Number(o.toFixed(2)) ? "" : o > 0 ? "+" : "-"}${jI(o, {
            omitSign: !0
        })}`, null !== s ? `${null === l ? "" : l ? "+" : "-"}${null === l ? "0.00$" : LI(Math.abs(s), {
            collapseExponent: !0,
            desiredDigits: 3,
            symbol: "USD",
            symbolPosition: yI.END,
            padSymbol: !0
        })}` : null, l]
    }
    ), [null == M ? void 0 : M.perChain, b, f, A])
      , [_,U] = y.useState({
        width: 0,
        height: 0
    })
      , W = y.useRef(null);
    y.useEffect(( () => {
        const e = W.current
          , t = e => {
            const {width: t, height: n} = e.contentRect;
            U({
                width: t,
                height: n
            })
        }
          , n = new ResizeObserver((e => {
            for (const n of e)
                t(n)
        }
        ));
        return e && (n.observe(e),
        t({
            contentRect: e.getBoundingClientRect()
        })),
        () => {
            e && n.unobserve(e)
        }
    }
    ), []);
    const V = y.useMemo(( () => Z8(_)), [_])
      , H = y.useMemo(( () => {
        const e = Q8(_);
        return t => ({
            position: "absolute",
            top: -e / 2,
            right: `calc(${-e / 2}px + 4%)`,
            width: e,
            height: e,
            borderRadius: "50%",
            background: `radial-gradient(circle at center, ${null === B ? t.palette.text.label : B ? t.palette.positive.main : t.palette.negative.main}80, transparent 70%)`,
            zIndex: 1
        })
    }
    ), [B, _])
      , z = y.useMemo(( () => {
        const e = Q8(_);
        return t => ({
            position: "absolute",
            bottom: -e / 2,
            left: `calc(${-e / 2}px + 4%)`,
            width: e,
            height: e,
            borderRadius: "50%",
            background: `radial-gradient(circle at center, ${t.palette.primary.main}80, transparent 70%)`,
            zIndex: 1
        })
    }
    ), [_])
      , $ = y.useMemo(( () => I ? {
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: "calc(100% + 8px)",
        height: "calc(100% + 8px)",
        objectFit: "cover",
        zIndex: 0,
        pointerEvents: "none",
        filter: `blur(${lb(r, {
            min: 0,
            max: 20
        })}px)`
    } : {
        top: "65%",
        left: "35%",
        transform: "translate(-50%, -50%) rotate(-15deg)",
        zIndex: 0,
        pointerEvents: "none"
    }), [r, I])
      , G = y.useMemo(( () => I ? {
        opacity: t,
        objectFit: "cover"
    } : {
        opacity: .15,
        width: "150%"
    }), [I, t])
      , q = y.useMemo(( () => I ? {} : {
        background: "black"
    }), [I])
      , K = y.useMemo(( () => null === B ? "text.value" : B ? "success.main" : "error.main"), [B])
      , Y = y.useMemo(( () => Math.max(c7, V.labelSize)), [V.labelSize]);
    return v.jsxs(S, {
        className: "padre-no-scroll",
        overflow: "hidden",
        height: "100%",
        width: "100%",
        position: "relative",
        sx: q,
        children: [v.jsx(C, {
            sx: $,
            position: "absolute",
            children: v.jsx(C, {
                draggable: !1,
                component: "img",
                src: I ?? "/pnlTrackerBg.png",
                alt: "center image",
                sx: G,
                width: "100%",
                height: "100%"
            })
        }), !I && v.jsx(C, {
            sx: z
        }), !I && v.jsx(C, {
            sx: H
        }), v.jsxs(S, {
            ref: W,
            direction: "row",
            alignItems: "center",
            px: "8%",
            justifyContent: "space-between",
            height: "100%",
            position: "relative",
            sx: n7,
            children: [v.jsxs(S, {
                height: "100%",
                justifyContent: "center",
                zIndex: 3,
                gap: .5,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    fontWeight: 600,
                    fontSize: V.labelSize,
                    lineHeight: `${V.labelSize}px`,
                    children: o("Balance {{symbol}}", {
                        symbol: GD(A)
                    })
                }), null === N ? v.jsx(Ie, {
                    variant: "rounded",
                    height: V.valueSize,
                    width: 4 * V.valueSize
                }) : v.jsxs(k, {
                    variant: "paragraph3",
                    fontWeight: 800,
                    fontSize: V.valueSize,
                    lineHeight: `${V.valueSize}px`,
                    display: "flex",
                    ml: `-${V.valueSize / 8}px`,
                    children: [v.jsx(Sz, {
                        chain: A,
                        size: V.valueSize
                    }), N]
                }), h ? null === P ? v.jsx(Ie, {
                    variant: "rounded",
                    height: V.labelSize,
                    width: 4 * V.labelSize
                }) : v.jsx(k, {
                    fontWeight: 400,
                    fontSize: V.labelSize,
                    lineHeight: `${V.labelSize}px`,
                    children: P
                }) : null]
            }), v.jsxs(S, {
                height: "100%",
                justifyContent: "center",
                zIndex: 3,
                gap: .5,
                children: [null === L ? v.jsx(Ie, {
                    sx: e7,
                    variant: "rounded",
                    height: V.labelSize,
                    width: 4 * V.labelSize
                }) : v.jsx(k, {
                    variant: "paragraph3",
                    fontWeight: 600,
                    fontSize: V.labelSize,
                    lineHeight: `${V.labelSize}px`,
                    textAlign: "end",
                    color: K,
                    children: L
                }), null === O ? v.jsx(Ie, {
                    sx: e7,
                    variant: "rounded",
                    height: V.valueSize,
                    width: 4 * V.valueSize
                }) : v.jsxs(k, {
                    variant: "paragraph3",
                    fontWeight: 800,
                    fontSize: V.valueSize,
                    lineHeight: `${V.valueSize}px`,
                    textAlign: "end",
                    color: K,
                    display: "flex",
                    children: [v.jsx(Sz, {
                        chain: A,
                        size: V.valueSize
                    }), O]
                }), h ? null === R ? v.jsx(Ie, {
                    sx: e7,
                    variant: "rounded",
                    height: V.labelSize,
                    width: 4 * V.labelSize
                }) : v.jsx(k, {
                    color: K,
                    fontWeight: 400,
                    textAlign: "end",
                    fontSize: V.labelSize,
                    lineHeight: `${V.labelSize}px`,
                    children: R
                }) : null]
            }), v.jsx(GC, {
                title: o("Reset"),
                sx: r7,
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(F, {
                        className: `${t7} no-drag`,
                        sx: d7,
                        onClick: x,
                        children: v.jsx(_S, {
                            color: s.palette.text.value,
                            size: Math.max(18, V.labelSize)
                        })
                    })
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .25,
                sx: s7,
                children: [v.jsx(F, {
                    className: `${t7} no-drag ${M8}`,
                    onClick: u,
                    sx: o7,
                    children: v.jsx(Ny, {
                        color: s.palette.text.value,
                        size: Math.max(c7, V.labelSize)
                    })
                }), v.jsx(F, {
                    className: `${t7} no-drag ${M8}`,
                    onClick: j,
                    sx: l7,
                    children: v.jsx(Sz, {
                        chain: Pd.SOLANA,
                        size: Y + i7,
                        grayOut: A !== Pd.SOLANA
                    })
                }), v.jsx(F, {
                    className: `${t7} no-drag ${M8}`,
                    onClick: T,
                    sx: l7,
                    children: v.jsx(Sz, {
                        chain: Pd.BSC,
                        size: Y + i7,
                        grayOut: A !== Pd.BSC
                    })
                })]
            }), v.jsx(F, {
                className: `${t7} no-drag`,
                sx: a7,
                onClick: e,
                children: v.jsx(kS, {
                    color: s.palette.text.value,
                    size: Math.max(14, V.labelSize)
                })
            }), l && v.jsx(D8, {
                onClose: p,
                customBgSrc: I ?? null,
                refreshCustomBgSrc: E,
                opacity: t,
                setOpacity: n,
                blur: r,
                setBlur: a,
                showUsd: h,
                toggleShowUsd: g
            })]
        })]
    })
}
))
  , e7 = {
    alignSelf: "end"
}
  , t7 = "pnl-tracked-hovered"
  , n7 = {
    [`.${t7}`]: {
        opacity: 0
    },
    "&:hover": {
        [`.${t7}`]: {
            opacity: 1
        }
    }
}
  , r7 = {
    position: "absolute",
    left: "50%",
    transform: "translateX(-50%)",
    bottom: "15%",
    p: 0,
    zIndex: 4
}
  , a7 = {
    position: "absolute",
    top: 7,
    right: 7,
    p: 0,
    zIndex: 4
}
  , s7 = {
    position: "absolute",
    top: 7,
    left: 7,
    p: 0,
    zIndex: 4
}
  , o7 = {
    p: .25
}
  , l7 = {
    p: 0
}
  , i7 = 4
  , c7 = 14
  , d7 = {
    p: 0
}
  , u7 = y.memo(( ({closePnlTrackerWidget: e, internalIndex: t}) => {
    const [n,r] = Mx("padreV2-pnlTrackerOpacity", 1)
      , [a,s] = Mx("padreV2-pnlTrackerBlur", 5);
    return v.jsx(P8, {
        id: Y6.PNL_TRACKER,
        width: 240,
        height: 80,
        initialX: 260,
        initialY: window.innerHeight - 180,
        onClose: e,
        header: null,
        internalIndex: t,
        resizeParams: p7,
        hasModals: !0,
        disableHeader: !0,
        noPadding: !0,
        hasCustomBackgroundOpacity: 1 !== n,
        children: v.jsx(J8, {
            onClose: e,
            opacity: n,
            setOpacity: r,
            blur: a,
            setBlur: s
        })
    })
}
))
  , p7 = {
    minWidth: 145,
    minHeight: 55,
    maxHeight: 500,
    maxWidth: 500
}
  , h7 = y.memo(( ({closeWatchlistWidget: e, internalIndex: t}) => {
    const [n,r] = y.useState(jQ);
    return v.jsx(P8, {
        id: Y6.WATCHLIST,
        width: 270,
        height: 300,
        initialX: 8,
        initialY: window.innerHeight - 334,
        onClose: e,
        header: "Watchlist",
        internalIndex: t,
        resizeParams: m7,
        children: v.jsx(cH, {
            contextId: "watchlistFloatingWidget",
            children: v.jsxs(S, {
                className: "padre-no-scroll",
                gap: 1,
                height: "calc(100% - 33px)",
                width: "100%",
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    justifyContent: "space-between",
                    sx: x7,
                    className: "padre-no-scroll",
                    children: [v.jsx(G5, {
                        chain: n,
                        setChain: r,
                        possibleOptions: g7,
                        showAllTooltip: !0
                    }), !1]
                }), v.jsx(S, {
                    className: "no-drag",
                    mx: -1,
                    overflow: "hidden",
                    mb: -.75,
                    children: v.jsx(B6, {
                        selectedChain: n,
                        compact: !0
                    })
                })]
            })
        })
    })
}
))
  , m7 = {
    minWidth: 200,
    minHeight: 300,
    maxHeight: 800,
    maxWidth: 400
}
  , g7 = ["ALL_NETWORKS", Pd.ETH_MAINNET, Pd.BASE, Pd.SOLANA, Pd.BSC]
  , x7 = {
    overflowX: "scroll",
    overflowY: "hidden",
    minHeight: 32,
    height: 32
}
  , b7 = y.memo(( ({onClick: e, onEdit: t, emoji: n, isSelected: r, label: a, maxWidth: s}) => {
    const o = y.useCallback((n => {
        "Enter" !== n.key && " " !== n.key || (n.preventDefault(),
        (r ? t : e)(n))
    }
    ), [r, e, t])
      , l = y.useMemo(( () => e => ({
        maxWidth: 80,
        height: f7,
        borderRadius: "16px",
        backgroundColor: r ? e.palette.background.secondary : "transparent",
        border: `1px solid ${r ? e.palette.text.label : e.palette.background.borderMain}`,
        outline: "none",
        px: a ? 1 : 0,
        gap: .5,
        color: r ? e.palette.text.value : e.palette.text.label,
        "&:hover": {
            backgroundColor: `${e.palette.background.buttonActive}DD`,
            border: `1px solid ${r ? e.palette.text.label : e.palette.background.buttonHover}`,
            cursor: "pointer",
            color: e.palette.text.value
        },
        "&:focus": {
            outline: "none",
            backgroundColor: r ? `${e.palette.background.buttonActive}EE` : `${e.palette.background.secondary}`,
            border: `1px solid ${r ? e.palette.text.label : `${e.palette.background.borderActive}`}`
        },
        "&:focus-visible": {
            outline: "none",
            border: `1px solid ${e.palette.background.borderActive}`
        }
    })), [r, a]);
    return v.jsxs(C, {
        display: "flex",
        alignItems: "center",
        onClick: r ? t : e,
        onKeyDown: o,
        sx: l,
        tabIndex: 0,
        role: "button",
        children: [v.jsx(ZT, {
            emoji: n
        }), a && v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            noWrap: !0,
            sx: s ? {
                maxWidth: s
            } : {},
            lineHeight: 1.1,
            mt: "1px",
            children: a
        })]
    })
}
))
  , f7 = 28
  , v7 = y.memo(( ({selectedGroupId: e, items: t, onGroupClick: n, onEditClick: r}) => {
    const a = y.useRef(null)
      , [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        const e = a.current;
        if (!e)
            return void o(!1);
        const {scrollLeft: t, scrollWidth: n, clientWidth: r} = e;
        o(n - r > 1 && !(t + r >= n - 1))
    }
    ), []);
    y.useEffect(( () => {
        l()
    }
    ), [t, l]),
    y.useEffect(( () => (window.addEventListener("resize", l),
    () => {
        window.removeEventListener("resize", l)
    }
    )), [l]);
    const i = y.useMemo(( () => [...t].sort(( (e, t) => e.createdAt - t.createdAt))), [t]);
    return v.jsxs(C, {
        position: "relative",
        width: "100%",
        minHeight: S7,
        children: [v.jsx(S, {
            ref: a,
            direction: "row",
            gap: .5,
            overflow: "auto",
            className: "padre-no-scroll",
            minHeight: S7,
            onScroll: l,
            children: i.map((t => {
                const a = t.groupId === e;
                return v.jsx(b7, {
                    onClick: () => {
                        a || n(t.groupId)
                    }
                    ,
                    onEdit: () => {
                        r(t.groupId)
                    }
                    ,
                    label: t.name,
                    emoji: $j(t.icon, t.emoji),
                    isSelected: a
                }, t.groupId)
            }
            ))
        }), s && v.jsx(C, {
            sx: y7
        })]
    })
}
))
  , S7 = 28
  , y7 = e => ({
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    width: 12,
    pointerEvents: "none",
    background: `linear-gradient(90deg, ${e.palette.background.default}00 0%, ${e.palette.background.default}FF 100%)`
})
  , k7 = e => au.test(e) ? pc.ETH : su.test(e) ? pc.SOL : null
  , C7 = e => c.reduce(e, ( (e, t) => {
    const n = ng(t)
      , r = k7(n);
    return r ? (e.push({
        address: n,
        walletType: r
    }),
    e) : e
}
), [])
  , A7 = /[0-9a-fA-Fx1-9A-HJ-NP-Za-km-z]/g
  , w7 = e => {
    var t;
    return (null == (t = e.match(A7)) ? void 0 : t.join("")) || ""
}
  , j7 = /^"([^"]*)","([^"]*)","([^"]*)","([^"]*)"?$/
  , T7 = e => {
    const t = (e => {
        try {
            const t = JSON.parse(e);
            return Array.isArray(t) ? t.map((e => ({
                address: w7(e.address ?? e.trackedWalletAddress),
                customLabel: e.name ?? null,
                customEmoji: e.emoji ?? null,
                alertsOn: e.alertsOn ?? null
            }))) : null
        } catch (W$e) {
            return null
        }
    }
    )(e);
    if (t)
        return t;
    const n = e.trim().split("\n")
      , r = (e => j7.test(e[0]) ? c.reduce(e, ( (e, t) => {
        const n = t.match(j7);
        if (!n)
            return e;
        const [,r,a,,s] = n;
        return e.push({
            address: r,
            customLabel: a || null,
            customEmoji: null,
            alertsOn: "Active" === s
        }),
        e
    }
    ), []) : null)(n);
    if (r)
        return r;
    const a = [];
    if (n.forEach((e => {
        const [t,...n] = e.split(",").map((e => e.trim()))
          , r = n.join(",").slice(0, 120)
          , s = ng(t);
        (su.test(s) || au.test(s)) && a.push({
            address: s,
            customLabel: r ?? null,
            customEmoji: null,
            alertsOn: null
        })
    }
    )),
    0 === a.length) {
        const e = I7(n);
        if (e)
            return e
    }
    return c.uniqBy(a, (e => e.address))
}
  , I7 = e => c.reduce(e, ( (e, t) => {
    if (null === e)
        return e;
    const n = t.trim();
    if (!n)
        return e;
    const [r,a] = (e => {
        const t = e.indexOf(" ");
        return -1 === t ? [e.trim(), ""] : [e.slice(0, t).trim(), e.slice(t + 1).trim()]
    }
    )(n)
      , s = ng(r);
    return su.test(s) || au.test(s) ? (e.push({
        address: s,
        customLabel: a ?? null,
        customEmoji: rI,
        alertsOn: null
    }),
    e) : e = null
}
), [])
  , E7 = y.memo(( ({isOpen: e, onClose: t, groupId: n}) => {
    const {t: r} = we()
      , a = Ax()
      , {walletGroups: s} = rf()
      , [o,l] = y.useState(n)
      , i = y.useCallback((e => {
        l(e.target.value)
    }
    ), [l])
      , c = y.useMemo(( () => s ? s.find((e => e.groupId === o)) : null), [o, s]);
    y.useEffect(( () => {
        void 0 === c && t()
    }
    ), [t, c]);
    const [d,u] = y.useState("")
      , p = y.useCallback((e => {
        u(e.target.value.slice(0, 120))
    }
    ), [u])
      , [h,m] = y.useState(null)
      , g = y.useCallback((e => {
        m(e)
    }
    ), [])
      , [x,b] = y.useState("")
      , f = y.useCallback((e => {
        const t = w7(e.target.value);
        b(t)
    }
    ), [b])
      , A = y.useMemo(( () => {
        if (!x)
            return r("Wallet address cannot be empty");
        const e = ng(x);
        return c && c.addresses.some((t => t === e)) ? r("This wallet is already added to selected wallet group") : su.test(e) || au.test(e) ? "" : r("Wallet address must be a valid EVM or Solana address")
    }
    ), [c, x, r])
      , w = y.useCallback((async () => {
        if (A || !a)
            return;
        const e = ng(x);
        try {
            const n = [];
            n.push(ym.updateWalletGroup(a, o, {
                add: [e]
            })),
            d ? n.push(ym.updateCustomWalletNames(a, {
                [e]: d
            }).then(( () => {
                if (h)
                    return ym.updateCustomWalletEmojis(a, {
                        [e]: h
                    })
            }
            ))) : h && n.push(ym.updateCustomWalletEmojis(a, {
                [e]: h
            })),
            await Promise.all(n),
            t()
        } catch (fNe) {}
    }
    ), [A, t, o, a, x, d, h]);
    return v.jsx(Sw, {
        className: "no-drag",
        open: e,
        stackSx: P7,
        onClose: t,
        desktopWidth: M7,
        minDesktopWidth: M7,
        children: v.jsxs(S, {
            height: "100%",
            gap: 2,
            justifyContent: "space-between",
            children: [v.jsxs(S, {
                gap: 1,
                divider: O7,
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        variant: "h2",
                        children: r("Add wallet")
                    }), v.jsx(F, {
                        onClick: t,
                        sx: L7,
                        children: v.jsx(kS, {})
                    })]
                }), v.jsxs(S, {
                    gap: 1,
                    mt: 1,
                    children: [v.jsx(je, {
                        value: x,
                        onChange: f,
                        size: "xsmall",
                        placeholder: r("Wallet Address"),
                        fullWidth: !0,
                        sx: {
                            height: 32
                        },
                        inputProps: {
                            style: {
                                textAlign: "left",
                                fontWeight: 400
                            },
                            inputMode: "text"
                        }
                    }), v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        alignItems: "center",
                        children: [v.jsx(it, {
                            value: o,
                            onChange: i,
                            IconComponent: () => null,
                            notched: !1,
                            sx: {
                                p: 0,
                                width: 175,
                                height: 32,
                                zIndex: 1307,
                                "& .MuiOutlinedInput-input": {
                                    padding: "0px 8px 0px 10px !important"
                                }
                            },
                            renderValue: () => v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                width: "100%",
                                textOverflow: "ellipsis",
                                mt: "1px",
                                children: [c && v.jsx(ZT, {
                                    emoji: $j(c.icon, c.emoji)
                                }), v.jsx(k, {
                                    variant: "paragraph3",
                                    textOverflow: "ellipsis",
                                    noWrap: !0,
                                    children: null == c ? void 0 : c.name
                                })]
                            }),
                            input: v.jsx(je, {}),
                            children: (s ?? []).map((e => {
                                const t = e.addresses.length >= wT
                                  , n = e.groupId === o;
                                return v.jsx(te, {
                                    className: "no-drag",
                                    disabled: t,
                                    value: e.groupId,
                                    sx: {
                                        px: 1
                                    },
                                    children: v.jsxs(S, {
                                        direction: "row",
                                        alignItems: "center",
                                        gap: 1,
                                        children: [v.jsx(ZT, {
                                            emoji: $j(e.icon, e.emoji)
                                        }), v.jsx(k, {
                                            variant: "paragraph3",
                                            color: t ? "text.disabled" : n ? "text.value" : "text.label",
                                            children: iu(e.name, 24)
                                        })]
                                    })
                                }, e.groupId)
                            }
                            ))
                        }), v.jsx(eI, {
                            currentEmoji: h ?? rI,
                            onEmojiSelected: g
                        }), v.jsx(je, {
                            value: d,
                            onChange: p,
                            size: "xsmall",
                            placeholder: r("Wallet Name"),
                            fullWidth: !0,
                            sx: {
                                height: 32
                            },
                            inputProps: {
                                style: {
                                    textAlign: "left",
                                    fontWeight: 400
                                },
                                inputMode: "text"
                            }
                        })]
                    })]
                })]
            }), v.jsx(GC, {
                title: A,
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        fullWidth: !0,
                        onClick: w,
                        disabled: !!A,
                        sx: N7,
                        children: r("Add wallet")
                    })
                })
            })]
        })
    })
}
))
  , M7 = 400
  , N7 = {
    borderRadius: "16px"
}
  , P7 = {
    p: 2,
    zIndex: qw
}
  , O7 = v.jsx(Ee, {
    flexItem: !0,
    sx: {
        mx: -2
    }
})
  , L7 = {
    p: .25,
    mr: -.25
}
  , R7 = y.memo(( ({notifyTg: e, setNotifyTg: t}) => {
    const {t: n} = we()
      , r = PR()
      , {telegram: a} = q6()
      , s = y.useMemo(( () => null !== a.notificationsSettings), [a])
      , o = y.useCallback(( () => {
        t((e => !e))
    }
    ), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: [v.jsx(WR, {
            label: n("Notify buys on Telegram"),
            isChecked: e,
            onClick: o
        }), !r && !s && v.jsx(z, {
            title: n("Go to Notifications and connect telegram first"),
            children: v.jsx(C, {
                display: "flex",
                alignItems: "center",
                sx: {
                    cursor: "help"
                },
                children: v.jsx(QS, {
                    size: 14
                })
            })
        })]
    })
}
))
  , D7 = y.memo(( ({minChartTradeUsd: e, setMinChartTradeUsd: t}) => {
    const n = y.useCallback((e => {
        const n = QR(e.target.value);
        t(n)
    }
    ), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        children: [v.jsx(k, {
            variant: "paragraph3",
            minWidth: 155,
            children: "Min value for chart marker"
        }), v.jsx(je, {
            value: e,
            onChange: n,
            size: "xsmall",
            placeholder: "Min usd",
            fullWidth: !0,
            sx: B7,
            inputProps: _7,
            endAdornment: v.jsx(We, {
                position: "end",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: "$"
                })
            })
        })]
    })
}
))
  , B7 = {
    height: 32,
    maxWidth: 100
}
  , _7 = {
    style: {
        textAlign: "left",
        fontWeight: 400
    },
    inputMode: "text"
}
  , U7 = y.memo(( ({walletGroupName: e, setWalletGroupName: t, currentEmoji: n, onEmojiSelected: r}) => {
    const {t: a} = we()
      , s = y.useCallback((e => {
        t(e.target.value.slice(0, 120))
    }
    ), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        children: [v.jsx(k, {
            variant: "paragraph1",
            children: a("Group")
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            flex: 1,
            children: [v.jsx(eI, {
                currentEmoji: n,
                onEmojiSelected: r,
                height: 30,
                alwaysShowButton: !0
            }), v.jsx(je, {
                value: e,
                onChange: s,
                size: "xsmall",
                placeholder: a("Group name"),
                fullWidth: !0,
                sx: W7,
                inputProps: F7
            })]
        })]
    })
}
))
  , W7 = {
    height: 32
}
  , F7 = {
    style: {
        textAlign: "left",
        fontWeight: 400
    },
    inputMode: "text"
}
  , V7 = y.memo(( ({isOpen: e, onClose: t, editProps: n}) => {
    const {t: r} = we()
      , a = Ax()
      , s = pK()
      , [o,l] = y.useState(n ? n.name : "")
      , [i,c] = y.useState(n ? n.emoji : "")
      , [d,u] = y.useState(!!n && n.notifyTg)
      , [p,h] = y.useState(n && n.minChartTradeUsd ? n.minChartTradeUsd.toString() : "")
      , [m,g] = y.useState(!!n && (null !== n.soundEffect || null !== n.alertDuration || null !== n.soundVolume))
      , x = y.useCallback(( () => {
        g((e => !e))
    }
    ), [])
      , [b,f] = y.useState(n ? n.soundEffect : null)
      , A = y.useCallback((e => {
        e || f(null)
    }
    ), [])
      , [w,j] = y.useState(n ? n.soundVolume ?? ET : ET)
      , [T,I] = y.useState(n ? n.alertDuration ?? 5 : 5)
      , E = y.useMemo(( () => {
        var e;
        if (!n)
            return !1;
        const t = m && null === b
          , r = m ? b : null
          , a = n.isDisabled
          , s = n.soundEffect;
        if (t !== a)
            return !0;
        if (r !== s)
            return !0;
        const l = (null == (e = n.minChartTradeUsd) ? void 0 : e.toString()) ?? "";
        return p !== l || (n.emoji !== i || n.notifyTg !== d || n.name !== o || n.alertDuration !== (m ? T : null) || n.soundVolume !== (m ? w : null))
    }
    ), [T, n, m, p, d, i, b, w, o])
      , M = y.useMemo(( () => n && !E ? "Wallet group is unchanged" : o ? "" : "Wallet group name is required"), [n, E, o])
      , [N,P] = y.useState(!1)
      , [O,L] = y.useState(!1)
      , [R,D] = JC(!1, z7)
      , B = y.useCallback(( () => {
        D(!0)
    }
    ), [D])
      , _ = y.useCallback((async () => {
        if (a && n)
            try {
                P(!0),
                await ym.deleteWalletGroup(a, n.groupId),
                s({
                    message: uu.removeWalletGroupSuccess,
                    snackName: pu.removeSuccess,
                    type: "success"
                }, "wallet-group-remove-success"),
                t()
            } catch (fNe) {
                s({
                    message: uu.unknownError,
                    snackName: pu.removeFailed,
                    type: "error"
                }, "wallet-group-remove-failed"),
                P(!1)
            }
    }
    ), [n, s, t, a])
      , U = y.useCallback((async () => {
        if (a && !O)
            try {
                L(!0),
                await ym.createWalletGroup(a, {
                    name: o,
                    icon: 0,
                    emoji: i,
                    notifyTg: d,
                    addresses: [],
                    minChartTradeUsd: "" === p || isNaN(Number(p)) ? null : Number(p),
                    ...m ? {
                        disableSound: null === b,
                        soundEffect: b,
                        soundVolume: w,
                        alertDuration: T
                    } : {
                        disableSound: !1,
                        soundEffect: null,
                        soundVolume: null,
                        alertDuration: null
                    }
                }),
                s({
                    message: uu.createWalletGroupSuccess,
                    snackName: pu.createSuccess,
                    type: "success"
                }, "wallet-group-create-success"),
                t()
            } catch (fNe) {
                s({
                    message: uu.unknownError,
                    snackName: pu.createFailed,
                    type: "error"
                }, "wallet-group-create-failed"),
                L(!1)
            }
    }
    ), [a, O, o, i, d, p, m, b, w, T, s, t])
      , W = y.useCallback((async () => {
        var e;
        if (a && n && !O)
            try {
                L(!0),
                await ym.updateWalletGroup(a, n.groupId, {
                    ...n.name !== o ? {
                        name: o
                    } : {},
                    ...n.emoji !== i ? {
                        emoji: i
                    } : {},
                    ...n.notifyTg !== d ? {
                        notifyTg: d
                    } : {},
                    ...((null == (e = n.minChartTradeUsd) ? void 0 : e.toString()) ?? "") !== p ? {
                        minChartTradeUsd: "" === p || isNaN(Number(p)) ? null : Number(p)
                    } : {},
                    ...m ? {
                        disableSound: null === b,
                        soundEffect: b,
                        soundVolume: w,
                        alertDuration: T
                    } : {
                        disableSound: !1,
                        soundEffect: null,
                        soundVolume: null,
                        alertDuration: null
                    }
                }),
                s({
                    message: uu.updateWalletGroupSuccess,
                    snackName: pu.updateSuccess,
                    type: "success"
                }, "wallet-group-update-success"),
                t()
            } catch (fNe) {
                s({
                    message: uu.unknownError,
                    snackName: pu.updateFailed,
                    type: "error"
                }, "wallet-group-update-failed"),
                L(!1)
            }
    }
    ), [a, n, O, o, i, d, p, m, b, w, T, s, t]);
    return v.jsx(Sw, {
        className: "no-drag",
        open: e,
        stackSx: {
            p: 2,
            zIndex: qw
        },
        onClose: t,
        desktopWidth: H7,
        minDesktopWidth: H7,
        children: v.jsxs(S, {
            height: "100%",
            gap: 2,
            justifyContent: "space-between",
            children: [v.jsxs(S, {
                gap: 1,
                divider: v.jsx(Ee, {
                    flexItem: !0,
                    sx: {
                        mx: -2
                    }
                }),
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        variant: "h2",
                        children: r(n ? "Edit Wallet Group" : "Add Wallet Group")
                    }), v.jsx(F, {
                        onClick: t,
                        sx: $7,
                        children: v.jsx(kS, {})
                    })]
                }), v.jsxs(S, {
                    gap: 1,
                    mt: 1,
                    children: [v.jsx(U7, {
                        walletGroupName: o,
                        setWalletGroupName: l,
                        currentEmoji: i,
                        onEmojiSelected: c
                    }), v.jsx(R7, {
                        notifyTg: d,
                        setNotifyTg: u
                    })]
                }), v.jsxs(S, {
                    gap: 1,
                    children: [v.jsx(D7, {
                        minChartTradeUsd: p,
                        setMinChartTradeUsd: h
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "space-between",
                        gap: .5,
                        children: [v.jsx(WR, {
                            label: r("Custom group alerts settings"),
                            isChecked: m,
                            onClick: x
                        }), v.jsx(C, {
                            display: "flex",
                            children: v.jsx(ej, {
                                idKey: "custom-group-sound-effect",
                                soundEffectEnabled: null !== b,
                                setSoundEffectEnabled: A,
                                selectedSoundEffect: b ?? $h.CORK,
                                setSelectedSoundEffect: f,
                                usePopper: !0,
                                volume: w,
                                disabled: !m,
                                showName: !0,
                                isInModal: !0
                            })
                        })]
                    }), v.jsx(jw, {
                        valueSuffix: "%",
                        Icon: hS,
                        defaultValue: w,
                        min: 10,
                        max: 100,
                        step: 10,
                        saveValue: j,
                        disabled: !m
                    }), v.jsx(jw, {
                        valueSuffix: "s",
                        Icon: Fk,
                        defaultValue: T,
                        min: 1,
                        max: 10,
                        step: 1,
                        saveValue: I,
                        disabled: !m
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                children: [v.jsx(C, {
                    component: "span",
                    flex: 1,
                    children: v.jsx(V, {
                        variant: n ? R ? "primary" : "secondary" : "tertiary",
                        color: n ? "error" : "primary",
                        fullWidth: !0,
                        sx: G7,
                        onClick: n ? R ? _ : B : t,
                        disabled: O || N,
                        children: r(n ? R ? "Confirm Removal" : "Remove" : "Cancel")
                    })
                }), v.jsx(GC, {
                    sx: q7,
                    title: M,
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            fullWidth: !0,
                            onClick: n ? W : U,
                            disabled: !!M || O || N,
                            sx: G7,
                            children: r(n ? "Save changes" : "Create Group")
                        })
                    })
                })]
            })]
        })
    })
}
))
  , H7 = 340
  , z7 = 6e3
  , $7 = {
    p: .25,
    mr: -.25
}
  , G7 = {
    borderRadius: "24px",
    fontWeight: 600
}
  , q7 = {
    flex: 1
}
  , K7 = y.memo(( ({inputText: e, setInputText: t}) => {
    const n = y.useCallback((e => {
        t(e.target.value)
    }
    ), [t]);
    return v.jsx(je, {
        multiline: !0,
        value: e,
        onChange: n,
        minRows: 8,
        maxRows: 8,
        size: "xsmall",
        placeholder: Q7,
        fullWidth: !0,
        sx: Y7,
        inputProps: X7
    })
}
))
  , Y7 = {
    height: 144,
    pr: .25,
    pl: 1,
    pt: 2.25,
    borderRadius: 2
}
  , X7 = {
    style: {
        fontWeight: 400,
        fontSize: 12,
        lineHeight: "17px"
    },
    className: "padre-decorative-scroll",
    inputMode: "text"
}
  , Q7 = "Exported wallets, JSON or csv like:\n0x5A3cC3Bb...2D53Ea,WalletLabel\n0x4b20993b...2C02db\n5F6joCGLyzk...zuwGrX,SolanaWhale"
  , Z7 = y.memo(( ({isOpen: e, onClose: t, walletsDisplayItems: n, onBulkAddWalletItems: r}) => {
    const {t: a} = we()
      , [s,o] = y.useState("")
      , [l,i] = y.useState(!1)
      , d = y.useCallback((e => {
        o(e),
        i(!1)
    }
    ), [])
      , u = Ax()
      , p = y.useMemo(( () => n.length >= wT), [n.length])
      , h = pK()
      , [m,g] = y.useState(!1)
      , x = y.useCallback((async () => {
        if (!m && u) {
            g(!0);
            try {
                const l = T7(s);
                if (!l.length)
                    return void i(!0);
                const d = n.length + l.length > wT
                  , p = d ? l.slice(0, wT - n.length) : l;
                d && h({
                    snackName: pu.limitExceeded,
                    message: (e = p.length,
                    a = l.length,
                    o = wT,
                    `Only ${e} wallet${e > 1 ? "s" : ""} will be added out of ${a} found (max total ${o})`),
                    type: "warning"
                }, "bulk-add-limit-exceed-warning");
                try {
                    await Promise.all([(async () => {
                        try {
                            await r(p.map((e => e.address)))
                        } catch (fNe) {}
                    }
                    )(), (async () => {
                        try {
                            const e = c.reduce(p, ( (e, t) => t.customLabel ? (e[t.address] = t.customLabel,
                            e) : e), {})
                              , t = c.reduce(p, ( (e, t) => t.customEmoji ? (e[t.address] = t.customEmoji,
                            e) : e), {})
                              , n = c.reduce(p, ( (e, t) => (null === t.alertsOn || (e[t.address] = !t.alertsOn),
                            e)), {});
                            Object.keys(e).length && await ym.updateCustomWalletNames(u, e),
                            Object.keys(t).length && await ym.updateCustomWalletEmojis(u, t),
                            Object.keys(n).length && await ym.updateCustomWalletSilenced(u, n)
                        } catch (fNe) {
                            h({
                                message: pu.bulkCustomNamesUpdateFailed,
                                type: "error"
                            }, "bulk-custom-names-update-failed")
                        }
                    }
                    )()])
                } catch (fNe) {}
                t()
            } catch (W$e) {
                h({
                    message: uu.clipboardEnableAccess,
                    snackName: pu.clipboardUnavailable,
                    type: "error"
                }, "clipboard-check-failed")
            } finally {
                g(!1)
            }
            var e, a, o
        }
    }
    ), [m, u, s, n.length, h, r, t]);
    return v.jsx(Sw, {
        className: "no-drag",
        open: e,
        stackSx: n9,
        onClose: t,
        desktopWidth: J7,
        minDesktopWidth: J7,
        children: v.jsxs(S, {
            height: "100%",
            gap: 2,
            justifyContent: "space-between",
            children: [v.jsxs(S, {
                gap: 1,
                divider: v.jsx(Ee, {
                    flexItem: !0,
                    sx: r9
                }),
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        variant: "h2",
                        children: a("Import Wallet Group")
                    }), v.jsx(F, {
                        onClick: t,
                        sx: t9,
                        children: v.jsx(kS, {})
                    })]
                }), v.jsx(K7, {
                    inputText: s,
                    setInputText: d
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "error.main",
                sx: e9,
                children: l ? a("Invalid format") : ""
            }), v.jsx(GC, {
                title: p ? a("Limit reached") : s ? "" : a("Input is empty"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        fullWidth: !0,
                        onClick: x,
                        disabled: m || p || !s,
                        sx: a9,
                        children: m ? v.jsx(J, {
                            size: 16,
                            color: "inherit"
                        }) : v.jsx(k, {
                            variant: "inherit",
                            color: "inherit",
                            children: a("Import")
                        })
                    })
                })
            })]
        })
    })
}
))
  , J7 = 325
  , e9 = {
    ml: .25,
    mb: -1,
    mt: -1.5,
    height: 15
}
  , t9 = {
    p: .25,
    mr: -.25
}
  , n9 = {
    p: 2,
    zIndex: qw
}
  , r9 = {
    mx: -2
}
  , a9 = {
    borderRadius: "20px"
}
  , s9 = y.memo(( ({walletsDisplayItems: e}) => {
    const t = D()
      , n = Ax()
      , {t: r} = we()
      , {buttonProps: a, popoverProps: s} = Fw({
        id: "wallet-group-bulk-edit"
    })
      , {customWalletSilenced: o, customWalletOnChart: l, customWalletOnLiveTrades: i} = rf()
      , d = y.useMemo(( () => e.map((e => ng(e.address)))), [e])
      , u = y.useMemo(( () => !d.some((e => !0 === o[e]))), [d, o])
      , p = y.useCallback(( () => {
        if (n) {
            try {
                const e = c.reduce(d, ( (e, t) => (e[t] = u,
                e)), {});
                ym.updateCustomWalletSilenced(n, e)
            } catch (fNe) {}
            s.onClose()
        }
    }
    ), [u, d, s, n])
      , h = y.useMemo(( () => !d.some((e => !1 === l[e]))), [d, l])
      , m = y.useCallback(( () => {
        if (n) {
            try {
                const e = c.reduce(d, ( (e, t) => (e[t] = !h,
                e)), {});
                ym.updateCustomWalletOnChart(n, e)
            } catch (fNe) {}
            s.onClose()
        }
    }
    ), [h, d, s, n])
      , g = y.useMemo(( () => !d.some((e => !1 === i[e]))), [d, i])
      , x = y.useCallback(( () => {
        if (n) {
            try {
                const e = c.reduce(d, ( (e, t) => (e[t] = !g,
                e)), {});
                ym.updateCustomWalletOnLiveTrades(n, e)
            } catch (fNe) {}
            s.onClose()
        }
    }
    ), [g, d, s, n]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(F, {
            ...a,
            sx: l9,
            children: v.jsx(SS, {})
        }), v.jsx(ne, {
            ...s,
            onClick: Ww,
            sx: c9,
            children: v.jsx(re, {
                onClickAway: s.onClose,
                children: v.jsx(ee, {
                    elevation: 1,
                    sx: i9,
                    className: "padre-no-scroll, no-drag",
                    children: v.jsxs(S, {
                        children: [v.jsx(te, {
                            tabIndex: -1,
                            onMouseDown: Uw,
                            disableRipple: !0,
                            disableTouchRipple: !0,
                            value: "never",
                            sx: d9,
                            onClick: p,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                justifyContent: "space-between",
                                width: "100%",
                                gap: 1,
                                children: [v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    children: r(u ? "Disable all wallet notifications" : "Enable all wallet notifications")
                                }), u ? v.jsx(jy, {
                                    size: o9,
                                    color: t.palette.primary.main
                                }) : v.jsx(Ey, {
                                    size: o9
                                })]
                            })
                        }), v.jsx(te, {
                            tabIndex: -1,
                            onMouseDown: Uw,
                            disableRipple: !0,
                            disableTouchRipple: !0,
                            value: "never",
                            sx: d9,
                            onClick: m,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                justifyContent: "space-between",
                                width: "100%",
                                gap: 1,
                                children: [v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    children: r(h ? "Hide all wallets from chart" : "Show all wallets on chart")
                                }), v.jsx(my, {
                                    size: o9,
                                    color: h ? t.palette.primary.main : t.palette.text.label
                                })]
                            })
                        }), v.jsx(te, {
                            tabIndex: -1,
                            onMouseDown: Uw,
                            disableRipple: !0,
                            disableTouchRipple: !0,
                            value: "never",
                            sx: d9,
                            onClick: x,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                justifyContent: "space-between",
                                width: "100%",
                                gap: 1,
                                children: [v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "text.value",
                                    children: r(g ? "Hide all wallets from live trades" : "Show all wallets on live trades")
                                }), v.jsx(Vk, {
                                    size: o9,
                                    color: g ? t.palette.primary.main : t.palette.text.label
                                })]
                            })
                        })]
                    })
                })
            })
        })]
    })
}
))
  , o9 = 16
  , l9 = {
    p: .25,
    height: 28,
    width: 28
}
  , i9 = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , c9 = {
    zIndex: 1290
}
  , d9 = e => ({
    px: 1,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    },
    height: 27
})
  , u9 = y.memo(( ({walletsDisplayItems: e}) => {
    const {t: t} = we()
      , {customWalletNames: n, customWalletEmojis: r, customWalletSilenced: a} = rf()
      , s = Ax()
      , o = pK()
      , l = y.useCallback((async () => {
        s && e.length && (QC || o({
            message: uu.clipboardEnableAccess,
            snackName: pu.clipboardUnavailable,
            type: "success"
        }, "clipboard-export-unavailable"),
        ZC(( (e, t, n, r) => JSON.stringify(e.map((e => {
            const a = ng(e.address);
            return {
                trackedWalletAddress: a,
                name: t[a] ?? null,
                emoji: n[a] ?? rI,
                alertsOn: !r[a]
            }
        }
        )), null, 2))(e, n, r, a)),
        o({
            message: uu.clipboardExportWalletsSuccess,
            type: "success"
        }, "clipboard-export-success"))
    }
    ), [s, e, n, r, a, o]);
    return QC && e.length ? v.jsx(GC, {
        title: t("Export the wallets from the current group to the clipboard"),
        children: v.jsx(C, {
            component: "span",
            children: v.jsx(V, {
                disabled: !s,
                variant: "tertiary",
                size: "xsmall",
                onClick: l,
                sx: IT,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: t("Export")
                })
            })
        })
    }) : null
}
))
  , p9 = y.memo(( ({walletsLimitReached: e, onAddWalletClick: t, walletsDisplayItems: n, onImportClick: r}) => {
    const {t: a} = we();
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        gap: 1,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            children: [v.jsx(V, {
                variant: "tertiary",
                size: "xsmall",
                onClick: r,
                sx: IT,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    children: a("Import")
                })
            }), v.jsx(u9, {
                walletsDisplayItems: n
            })]
        }), v.jsx(GC, {
            title: e ? "Reached wallets limit" : "",
            children: v.jsx(C, {
                width: "100%",
                display: "flex",
                justifyContent: "flex-end",
                children: v.jsx(V, {
                    disabled: e,
                    onClick: t,
                    variant: "primary",
                    size: "xsmall",
                    sx: TT,
                    children: v.jsx(k, {
                        variant: "inherit",
                        fontWeight: 600,
                        color: "inherit",
                        children: a("Add wallet")
                    })
                })
            })
        })]
    })
}
))
  , h9 = 430
  , m9 = y.memo(( ({address: e, onRemoveClick: t, customEmoji: n, customName: r, openWalletOverview: a, showNotifications: s, toggleNotifications: o, showOnChart: l, toggleShowOnChart: i, showOnLiveTrades: c, toggleShowOnLiveTrades: d, currentWalletGroupId: u}) => {
    const p = D()
      , {t: h} = we();
    return v.jsxs(C, {
        display: "flex",
        height: 34,
        minHeight: 34,
        minWidth: h9,
        width: "100%",
        alignItems: "center",
        justifyContent: "space-between",
        sx: b9,
        onClick: a,
        children: [v.jsx(aI, {
            customName: r,
            customEmoji: n,
            address: e
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1.25,
            children: [v.jsx(cA, {
                address: e,
                customName: e.slice(-6),
                preventDefault: !0,
                stopPropagation: !0,
                labelSx: x9
            }), v.jsx(GC, {
                title: h(c ? s ? "Disable notifications" : "Enable notifications" : "Enable on live trades to show notifications"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    onClick: Ww,
                    children: v.jsx(V, {
                        disabled: !c,
                        onClick: o,
                        ...g9,
                        children: s && c ? v.jsx(jy, {
                            size: 16,
                            color: p.palette.primary.main
                        }) : v.jsx(Ey, {
                            size: 16
                        })
                    })
                })
            }), v.jsx(GC, {
                title: h(l ? "Hide on Chart" : "Show on Chart"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    children: v.jsx(V, {
                        onClick: i,
                        ...g9,
                        children: v.jsx(my, {
                            size: 16,
                            color: l ? p.palette.primary.main : p.palette.text.label
                        })
                    })
                })
            }), v.jsx(GC, {
                title: h(c ? "Hide on Live Trades" : "Show on Live Trades"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    children: v.jsx(V, {
                        onClick: d,
                        ...g9,
                        children: v.jsx(Vk, {
                            size: 16,
                            color: c ? p.palette.primary.main : p.palette.text.label
                        })
                    })
                })
            }), v.jsx(J2, {
                walletAddress: e,
                compact: !0,
                currentWalletGroupId: u
            }), v.jsx(V, {
                onClick: t,
                ...g9,
                children: v.jsx(wS, {
                    size: 16,
                    color: p.palette.error.main
                })
            })]
        })]
    })
}
))
  , g9 = {
    size: "xxsmall",
    variant: "tertiary",
    sx: e => ({
        px: 0,
        width: 22,
        minWidth: 22,
        height: 22,
        color: e.palette.text.label,
        background: "transparent",
        border: "none",
        "&:hover": {
            border: "none",
            color: e.palette.text.value
        }
    })
}
  , x9 = {
    fontWeight: 400,
    lineHeight: 1.1
}
  , b9 = e => ({
    px: 2.25,
    gap: 1,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonDefault
    }
})
  , f9 = (e, t, n) => e.startsWith(n) ? t : 0
  , v9 = (e, t, n) => e.includes(n) ? t : 0
  , S9 = ({walletsDisplayItems: e, customWalletNames: t, customWalletEmojis: n, customWalletSilenced: r, customWalletOnChart: a, customWalletOnLiveTrades: s, search: o}) => {
    const l = c.reduce(e, ( (e, l) => {
        const i = l.address
          , c = n[i] ?? null
          , d = t[i] ?? null
          , u = r[i] ?? !1
          , p = a[i] ?? !0
          , h = s[i] ?? !0
          , [m,g] = ( (e, t, n) => {
            if (!e)
                return [!0, 0];
            const r = e.toLowerCase();
            let a = !1
              , s = 0;
            if (t) {
                const e = t.toLowerCase()
                  , n = f9(e, 1e3, r)
                  , o = v9(e, 100, r);
                (n || o) && (a = !0),
                s += n + o
            }
            if (n) {
                const e = n.toLowerCase()
                  , t = f9(e, 10, r)
                  , o = v9(e, 1, r);
                (t || o) && (a = !0),
                s += t + o
            }
            return [a, a ? s : 0]
        }
        )(o, d, ng(i));
        return m ? (e.push({
            item: {
                ...l,
                customEmoji: c,
                customName: d,
                isSilenced: u,
                isOnChart: p,
                isOnLiveTrades: h
            },
            sortPriority: g
        }),
        e) : e
    }
    ), []);
    return l.sort(( (e, t) => t.sortPriority - e.sortPriority)).map((e => e.item))
}
  , y9 = y.memo(( ({walletsDisplayItems: e, onRemove: t, onChangeNotifications: n, onChangeOnChart: r, onChangeOnLiveTrades: a, search: s, isInModal: o, currentWalletGroupId: l, isInTracker: i}) => {
    const c = xw()
      , {customWalletNames: d, customWalletEmojis: u, customWalletSilenced: p, customWalletOnChart: h, customWalletOnLiveTrades: m} = rf()
      , {openModal: g} = r6()
      , x = y.useMemo(( () => S9({
        walletsDisplayItems: e,
        customWalletNames: d,
        customWalletEmojis: u,
        customWalletSilenced: p,
        customWalletOnChart: h,
        customWalletOnLiveTrades: m,
        search: s
    })), [u, d, p, s, e, h, m]);
    return v.jsx(S, {
        height: o ? k9 : `calc(100% - ${c || !i ? 80 : 150}px)`,
        width: "100%",
        children: x.length ? v.jsx(mt, {
            children: ({height: e, width: s}) => v.jsx(C, {
                className: "padre-decorative-scroll",
                sx: {
                    width: s > h9 ? s : s - C9,
                    height: e - C9,
                    overflowX: "auto",
                    overflowY: "hidden"
                },
                children: v.jsx(C, {
                    sx: A9,
                    children: v.jsx(gt, {
                        className: "padre-no-scroll",
                        height: e,
                        width: Math.max(s, h9),
                        rowHeight: 34,
                        rowCount: x.length,
                        itemData: x,
                        rowRenderer: ({index: e, style: s}) => {
                            const o = x[e]
                              , i = ng(o.address);
                            return v.jsx("div", {
                                style: s,
                                children: v.jsx(m9, {
                                    address: i,
                                    onRemoveClick: e => {
                                        e.stopPropagation(),
                                        t(o.address)
                                    }
                                    ,
                                    customEmoji: o.customEmoji,
                                    customName: o.customName,
                                    openWalletOverview: () => {
                                        g(o.address)
                                    }
                                    ,
                                    showNotifications: !o.isSilenced,
                                    toggleNotifications: e => {
                                        e.stopPropagation(),
                                        n(o.address, !o.isSilenced)
                                    }
                                    ,
                                    showOnChart: o.isOnChart,
                                    toggleShowOnChart: e => {
                                        e.stopPropagation(),
                                        r(o.address, !o.isOnChart)
                                    }
                                    ,
                                    showOnLiveTrades: o.isOnLiveTrades,
                                    toggleShowOnLiveTrades: e => {
                                        e.stopPropagation(),
                                        a(o.address, !o.isOnLiveTrades)
                                    }
                                    ,
                                    currentWalletGroupId: l
                                }, i)
                            }, i)
                        }
                        ,
                        overscanRowCount: 5
                    })
                })
            })
        }) : v.jsx(S, {
            height: "100%",
            width: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: e.length ? "All addresses are filtered out" : "No addresses in group yet"
            })
        })
    })
}
))
  , k9 = 375
  , C9 = 2
  , A9 = e => ({
    width: "max(430px, 100%)",
    "& .ReactVirtualized__Grid__innerScrollContainer > div:nth-of-type(odd)": {
        background: e.palette.background.secondary
    }
})
  , w9 = y.memo(( ({isInModal: e=!1, isInTracker: t=!1, isInSidePanel: n=!1}) => {
    const r = Ax()
      , a = xw()
      , s = pK()
      , {walletGroups: o} = rf()
      , {t: l} = we()
      , [i,d] = Mx(jT, null)
      , [u,p] = y.useState("");
    y.useEffect(( () => {
        (null == o ? void 0 : o.length) && (o.some((e => e.groupId === i)) || d(o.sort(( (e, t) => t.createdAt - e.createdAt))[0].groupId))
    }
    ), [i, d, o]);
    const h = y.useMemo(( () => o && i ? o.find((e => e.groupId === i)) : null), [i, o])
      , [m,g] = y.useState([])
      , x = y.useCallback((e => {
        if (!o)
            return;
        const t = o.find((t => t.groupId === e));
        t && (d(e),
        g(C7(t.addresses)))
    }
    ), [d, o]);
    y.useEffect(( () => {
        if (!o)
            return;
        const e = o.find((e => e.groupId === i));
        e && g(C7(e.addresses))
    }
    ), [i, o]);
    const b = y.useCallback((async e => {
        const t = c.reduce(e, ( (e, t) => {
            const n = k7(t);
            return n ? (m.some((e => e.address === t && e.walletType === n)) || e.push({
                address: t,
                walletType: n
            }),
            e) : e
        }
        ), []);
        if (t.length && (g((e => [...e, ...t])),
        i && r))
            try {
                await ym.updateWalletGroup(r, i, {
                    add: t.map((e => e.address))
                })
            } catch (fNe) {
                s({
                    message: pu.bulkAddFailed,
                    type: "error"
                }, "bulk-add-failed")
            }
    }
    ), [s, i, r, m])
      , f = y.useCallback((e => {
        const t = ng(e);
        if (g((e => e.filter((e => ng(e.address) !== t)))),
        i && r)
            try {
                ym.updateWalletGroup(r, i, {
                    remove: [t]
                })
            } catch (fNe) {}
    }
    ), [i, r])
      , A = y.useCallback(( (e, t) => {
        const n = ng(e);
        if (r)
            try {
                ym.updateCustomWalletSilenced(r, {
                    [n]: t
                })
            } catch (fNe) {}
    }
    ), [r])
      , w = y.useCallback(( (e, t) => {
        const n = ng(e);
        if (r)
            try {
                ym.updateCustomWalletOnChart(r, {
                    [n]: t
                })
            } catch (fNe) {}
    }
    ), [r])
      , j = y.useCallback(( (e, t) => {
        const n = ng(e);
        if (r)
            try {
                ym.updateCustomWalletOnLiveTrades(r, {
                    [n]: t
                })
            } catch (fNe) {}
    }
    ), [r])
      , [T,I] = y.useState(!1)
      , E = y.useCallback(( () => {
        I(!1)
    }
    ), [])
      , M = y.useCallback(( () => {
        I(!0)
    }
    ), [])
      , [N,P] = y.useState(!1)
      , O = y.useCallback(( () => {
        P(!0)
    }
    ), [])
      , L = y.useCallback(( () => {
        P(!1)
    }
    ), [])
      , [R,D] = y.useState(!1)
      , [B,_] = y.useState(null)
      , U = y.useCallback(( () => {
        D(!1),
        _(null)
    }
    ), [])
      , W = y.useCallback(( () => {
        _(null),
        D(!0)
    }
    ), [])
      , F = y.useCallback((e => {
        if (!(null == o ? void 0 : o.length))
            return;
        const t = o.find((t => t.groupId === e));
        if (!t)
            return;
        const {icon: n, emoji: r, name: a, notifyTg: s, minChartTradeUsd: l, soundEffect: i, soundVolume: c, alertDuration: d, disableSound: u} = t;
        _({
            groupId: e,
            emoji: $j(n, r),
            name: a,
            notifyTg: s,
            minChartTradeUsd: l ?? null,
            soundEffect: u ? null : i ?? null,
            isDisabled: u ?? !1,
            soundVolume: c ?? null,
            alertDuration: d ?? null
        }),
        D(!0)
    }
    ), [o])
      , [H,z] = y.useState(!1)
      , $ = y.useRef(!1);
    y.useEffect(( () => {
        let e = !1;
        if (!o || !r || H || $.current)
            return;
        if (o.length)
            return;
        $.current = !0;
        let t = 0;
        return (async () => {
            for (; t < j9; )
                try {
                    return await ym.createWalletGroup(r, {
                        name: "Default",
                        icon: 0,
                        emoji: "",
                        notifyTg: !1,
                        addresses: []
                    }),
                    void (t = 1 / 0)
                } catch (fNe) {
                    t++,
                    t < j9 ? await new Promise((e => setTimeout(e, T9 * t))) : e || (z(!0),
                    $.current = !1)
                }
        }
        )(),
        () => {
            e = !0
        }
    }
    ), [o, r, H]);
    const G = y.useCallback((e => {
        F(e)
    }
    ), [F])
      , q = y.useMemo(( () => ({
        height: 28,
        minWidth: 28,
        borderRadius: "14px",
        fontWeight: 600,
        pl: n ? 0 : .5,
        pr: n ? 0 : 1,
        mr: .25,
        borderColor: "transparent",
        "&:hover, &:focus": {
            borderColor: "transparent"
        }
    })), [n]);
    return H ? v.jsx(S, {
        height: "100%",
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "Couldnt create the default group. Please try again later"
        })
    }) : o && o.length && i ? v.jsxs(S, {
        height: "100%",
        justifyContent: e ? "flex-start" : "space-between",
        gap: t ? 1.5 : 1,
        pb: t ? 1.5 : 1,
        px: t ? 0 : e ? 1 : 0,
        pt: t ? "3px" : 0,
        children: [v.jsxs(S, {
            direction: a ? "row" : "column",
            alignItems: a || !t ? "center" : "flex-start",
            justifyContent: "space-between",
            gap: a ? .5 : 1,
            px: t ? 2 : 0,
            children: [v.jsx(S, {
                direction: "row",
                gap: .5,
                flexGrow: a ? 1 : 0,
                minWidth: 0,
                maxWidth: "100%",
                children: v.jsx(v7, {
                    selectedGroupId: i,
                    items: o,
                    onGroupClick: x,
                    onEditClick: G
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "flex-end",
                flexGrow: 1,
                gap: .5,
                width: a ? void 0 : "100%",
                minWidth: n ? 135 : 175,
                children: [v.jsx(GC, {
                    title: o.length >= 10 ? "Groups limit reached" : "",
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            size: "xsmall",
                            variant: "primary",
                            onClick: W,
                            disabled: o.length >= 10,
                            sx: q,
                            children: v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: .25,
                                children: [v.jsx(XS, {
                                    color: "inherit"
                                }), !n && v.jsx(k, {
                                    variant: "inherit",
                                    color: "inherit",
                                    lineHeight: 1.2,
                                    children: l("Group")
                                })]
                            })
                        })
                    })
                }), v.jsx(S, {
                    flexGrow: 1,
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    minWidth: 0,
                    children: v.jsx(oQ, {
                        search: u,
                        setSearch: p
                    })
                }), v.jsx(s9, {
                    walletsDisplayItems: m
                })]
            })]
        }), v.jsx(y9, {
            walletsDisplayItems: m,
            onRemove: f,
            onChangeNotifications: A,
            onChangeOnChart: w,
            onChangeOnLiveTrades: j,
            search: u,
            isInModal: e,
            currentWalletGroupId: i,
            isInTracker: t
        }), v.jsx(S, {
            direction: "row",
            alignItems: "center",
            px: t ? 2 : 0,
            children: v.jsx(p9, {
                walletsLimitReached: !!h && h.addresses.length >= wT,
                onAddWalletClick: M,
                walletsDisplayItems: m,
                onImportClick: O
            })
        }), T && v.jsx(E7, {
            isOpen: T,
            onClose: E,
            groupId: i
        }), R && v.jsx(V7, {
            isOpen: R,
            onClose: U,
            editProps: B
        }), N && v.jsx(Z7, {
            isOpen: N,
            onClose: L,
            walletsDisplayItems: m,
            onBulkAddWalletItems: b
        })]
    }) : v.jsx(S, {
        height: "100%",
        children: v.jsx(Km, {})
    })
}
))
  , j9 = 5
  , T9 = 1e3;
var I9 = (e => (e.WALLET_MANAGER = "WALLET_MANAGER",
e.LIVE_TRADES = "LIVE_TRADES",
e))(I9 || {});
const E9 = "padreV2-trackedWalletsSelectedTab"
  , M9 = I9.WALLET_MANAGER
  , N9 = {
    [I9.WALLET_MANAGER]: n.t("Manager"),
    [I9.LIVE_TRADES]: n.t("Trades")
}
  , P9 = y.memo(( ({selectedTab: e, setSelectedTab: t, onDock: n, onUndock: r, onClose: a}) => {
    const s = D()
      , {t: o} = we()
      , {alertsEnabled: l, toggleAlertsEnabled: i, soundEffectEnabled: c, setSoundEffectEnabled: d, selectedSoundEffect: u, setSelectedSoundEffect: p, notificationsVolume: h, setNotificationsDuration: m, notificationsDuration: g, setNotificationsVolume: x} = uI();
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        justifyContent: "space-between",
        children: [v.jsx(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: O9.map((n => {
                const r = n === e;
                return v.jsx(V, {
                    className: "no-drag",
                    onClick: () => {
                        t(n)
                    }
                    ,
                    variant: "tertiary",
                    size: "xxsmall",
                    sx: e => ({
                        px: .75,
                        pb: .25,
                        border: "none",
                        height: 24,
                        mt: "-2px",
                        backgroundColor: "transparent",
                        color: r ? e.palette.text.main : e.palette.text.label,
                        "&:hover": {
                            border: "none",
                            backgroundColor: "transparent",
                            color: r ? e.palette.text.main : e.palette.text.value
                        },
                        "&:focus": {
                            border: "none",
                            backgroundColor: "transparent"
                        }
                    }),
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "inherit",
                        children: N9[n]
                    })
                }, n)
            }
            ))
        }), v.jsxs(S, {
            direction: "row",
            gap: 1.5,
            alignItems: "center",
            className: "no-drag",
            children: [l && v.jsx(C, {
                component: "span",
                children: v.jsx(pI, {
                    soundEffectEnabled: c,
                    selectedSoundEffect: u,
                    notificationsVolume: h,
                    setNotificationsVolume: x,
                    notificationsDuration: g,
                    setNotificationsDuration: m,
                    isInFloatingWidget: !0
                })
            }), l && v.jsx(C, {
                component: "span",
                children: v.jsx(ej, {
                    idKey: "notifications",
                    soundEffectEnabled: c,
                    setSoundEffectEnabled: d,
                    selectedSoundEffect: u,
                    setSelectedSoundEffect: p,
                    volume: h,
                    usePopper: !0,
                    isInFloatingWidget: !0
                })
            }), v.jsx(GC, {
                title: o(l ? "Disable notification" : "Enable notifications"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...R9,
                        onClick: i,
                        children: l ? v.jsx(jy, {
                            size: L9,
                            color: s.palette.primary.main
                        }) : v.jsx(Ey, {
                            size: L9
                        })
                    })
                })
            }), n && v.jsx(v.Fragment, {
                children: D9.map((e => v.jsx(GC, {
                    title: o("Dock {{side}}", {
                        side: e.toLowerCase()
                    }),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            ...R9,
                            onClick: () => {
                                n(e)
                            }
                            ,
                            children: v.jsx(C, {
                                display: "flex",
                                sx: {
                                    transform: e === K6.LEFT ? "scaleX(-1)" : "none"
                                },
                                children: v.jsx(_f, {
                                    size: L9
                                })
                            })
                        })
                    })
                }, e)))
            }), r && v.jsx(GC, {
                title: o("Undock"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...R9,
                        onClick: r,
                        children: v.jsx(Rf, {
                            size: L9
                        })
                    })
                })
            }), a && v.jsx(C, {
                display: "flex",
                alignSelf: "center",
                pt: .25,
                children: v.jsx(F, {
                    onClick: a,
                    sx: B9,
                    children: v.jsx(gy, {})
                })
            })]
        })]
    })
}
))
  , O9 = [I9.WALLET_MANAGER, I9.LIVE_TRADES]
  , L9 = 18
  , R9 = {
    variant: "tertiary",
    size: "xxsmall",
    sx: {
        p: 0,
        height: 24,
        width: 24,
        minWidth: 24,
        border: "none",
        background: "transparent"
    }
}
  , D9 = [K6.LEFT, K6.RIGHT]
  , B9 = {
    p: .25
}
  , _9 = y.memo(( ({closeTrackedWalletsWidget: e, internalIndex: t, onDock: n}) => {
    const [r,a] = dx(E9, M9);
    return v.jsx(P8, {
        id: Y6.TRACKED_WALLETS,
        width: 800,
        height: 600,
        initialX: 80,
        initialY: window.innerHeight - 434,
        onClose: e,
        header: v.jsx(P9, {
            selectedTab: r,
            setSelectedTab: a,
            onDock: n
        }),
        headerSx: W9,
        internalIndex: t,
        resizeParams: F9,
        hasModals: !0,
        smallHeaderGap: !0,
        children: v.jsxs(S, {
            className: "padre-no-scroll",
            overflow: "hidden",
            mt: r === I9.LIVE_TRADES ? -.75 : 0,
            mb: -1,
            gap: 1,
            width: "100%",
            height: "100%",
            children: [r === I9.WALLET_MANAGER && v.jsx(S, {
                className: "no-drag",
                height: "100%",
                sx: U9,
                children: v.jsx(w9, {})
            }), r === I9.LIVE_TRADES && v.jsx(S, {
                className: "no-drag",
                height: "100%",
                sx: U9,
                children: v.jsx(g2, {
                    isFloating: !0
                })
            })]
        })
    })
}
))
  , U9 = {
    cursor: "default"
}
  , W9 = {
    height: 22
}
  , F9 = {
    minWidth: 340,
    minHeight: 235
}
  , V9 = y.memo(( ({closeTrackedWalletsWidget: e, onUndock: t}) => {
    const [n,r] = dx(E9, M9);
    return v.jsxs(S, {
        gap: 1,
        height: "100%",
        py: .75,
        children: [v.jsx(S, {
            px: .5,
            children: v.jsx(P9, {
                selectedTab: n,
                setSelectedTab: r,
                onUndock: t,
                onClose: e
            })
        }), v.jsxs(S, {
            className: "padre-no-scroll",
            overflow: "hidden",
            mt: n === I9.LIVE_TRADES ? -.75 : 0,
            mb: -1,
            gap: 1,
            width: "100%",
            height: "100%",
            children: [n === I9.WALLET_MANAGER && v.jsx(S, {
                className: "no-drag",
                height: "100%",
                sx: {
                    cursor: "default",
                    px: .75
                },
                children: v.jsx(w9, {
                    isInSidePanel: !0
                })
            }), n === I9.LIVE_TRADES && v.jsx(S, {
                className: "no-drag",
                mb: -.75,
                height: "100%",
                children: v.jsx(g2, {
                    isDocked: !0
                })
            })]
        })]
    })
}
))
  , H9 = y.memo(( ({isLive: e, isSync: t=!0, compact: n=!1}) => {
    const r = D();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        width: n ? z9 : $9,
        pl: n && e && t ? .5 : 0,
        children: [!n && v.jsx(k, {
            variant: "paragraph3",
            color: e && t ? "success.main" : "warning.main",
            children: t ? e ? "Feed is live" : "Feed is paused" : "Low FPS - feed paused"
        }), e && t ? null : n ? v.jsx(ok, {
            color: r.palette.primary.main,
            size: G9
        }) : void 0]
    })
}
))
  , z9 = 14
  , $9 = 90
  , G9 = z9
  , q9 = y.memo(( ({count: e=0, size: t=K9, grayOut: n}) => {
    const r = y.useMemo(( () => e => ({
        borderRadius: "4px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        bgcolor: `${e.palette.background.default}40`,
        border: `1px solid ${n ? e.palette.background.borderMain : e.palette.primary[700]}`
    })), [n]);
    return v.jsx(C, {
        width: t,
        height: t,
        sx: r,
        children: v.jsx(k, {
            variant: "paragraph2",
            fontWeight: ju,
            color: n ? "text.label" : "primary.main",
            fontSize: 10,
            children: e
        })
    })
}
))
  , K9 = 18
  , Y9 = {
    [FA.TWEET]: "TWEET",
    [FA.RETWEET]: "RETWEET",
    [FA.REPLY]: "REPLY",
    [FA.QUOTE]: "QUOTE",
    [FA.FOLLOW]: "FOLLOW",
    [FA.PROFILE_UPDATE]: "PROFILE_UPDATE"
}
  , X9 = y.memo(( ({initialFilters: e, isFeed: t, handleClose: n, setFilters: r, width: a}) => {
    const {t: s} = we()
      , o = xw()
      , [l,i] = y.useState(e.content ?? $A)
      , [c,d] = y.useState(e.address)
      , u = y.useCallback(( () => {
        r({
            content: Array.from(l),
            address: c
        }),
        n()
    }
    ), [c, l, r, n])
      , p = y.useCallback(( () => {
        r(zA),
        n()
    }
    ), [r, n]);
    return v.jsxs(S, {
        gap: Q9,
        p: 1.5,
        height: "100%",
        justifyContent: "space-between",
        width: a,
        children: [v.jsxs(S, {
            gap: Q9,
            children: [!o && v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: "Filters"
                }), v.jsx(F, {
                    onClick: n,
                    children: v.jsx(kS, {})
                })]
            }), t && v.jsxs(S, {
                gap: 1.5,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: s("By Token Address")
                }), v.jsx(oQ, {
                    search: c ?? "",
                    setSearch: d,
                    placeholder: "Token address"
                })]
            }), Z9 && t && v.jsxs(S, {
                gap: 1.5,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: "By Content Type"
                }), v.jsx(S, {
                    gap: 1.25,
                    children: $A.map(( (e, t) => {
                        const n = !l.includes(e);
                        return v.jsx(WR, {
                            label: Y9[e],
                            isChecked: n,
                            onClick: t => {
                                t.metaKey || t.ctrlKey ? i($A.filter((t => t !== e))) : i(n ? t => [...t, e] : t => [...t].filter((t => t !== e)))
                            }
                            ,
                            size: "medium",
                            textVariant: "paragraph1"
                        }, t)
                    }
                    ))
                })]
            })]
        }), v.jsxs(S, {
            gap: Q9,
            children: [v.jsx(Ee, {
                flexItem: !0
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsx(V, {
                    size: "xsmall",
                    variant: "tertiary",
                    onClick: p,
                    children: "Reset"
                }), v.jsx(V, {
                    size: "xsmall",
                    variant: "primary",
                    onClick: u,
                    children: "Apply"
                })]
            })]
        })]
    })
}
))
  , Q9 = 2
  , Z9 = !1
  , J9 = y.memo(( ({id: e, initialFilters: t, isFeed: n, isOpen: r, anchorEl: a, setFilters: s, onClose: o, compact: l=!1}) => xw() ? l ? v.jsx(ne, {
    id: e,
    className: "no-drag",
    open: r,
    anchorEl: a,
    onClick: oee,
    sx: aee,
    children: v.jsx(re, {
        onClickAway: o,
        children: v.jsx(ee, {
            elevation: 1,
            sx: see,
            className: "padre-no-scroll, no-drag",
            children: v.jsx(X9, {
                initialFilters: t,
                isFeed: n,
                handleClose: o,
                setFilters: s,
                width: tee
            })
        })
    })
}) : v.jsx(ae, {
    id: e,
    className: "no-drag",
    open: r,
    anchorEl: a,
    onClose: o,
    marginThreshold: 0,
    TransitionComponent: Q,
    anchorReference: "anchorEl",
    anchorOrigin: ree,
    container: () => (null == a ? void 0 : a.parentElement) ?? null,
    sx: nee,
    elevation: 1,
    children: v.jsx(X9, {
        initialFilters: t,
        isFeed: n,
        handleClose: o,
        setFilters: s,
        width: tee
    })
}) : v.jsx(Sw, {
    open: r,
    stackSx: eee,
    children: v.jsx(X9, {
        initialFilters: t,
        isFeed: n,
        handleClose: o,
        setFilters: s
    })
})))
  , eee = {
    p: 0,
    border: "none"
}
  , tee = 330
  , nee = {
    zIndex: 10,
    "& .MuiPopover-paper": {
        mt: 1
    }
}
  , ree = {
    vertical: "bottom",
    horizontal: "left"
}
  , aee = {
    zIndex: 1299
}
  , see = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    cursor: "auto",
    p: 0
})
  , oee = e => {
    e.stopPropagation()
}
  , lee = y.memo(( ({compact: e=!1, isFeed: t=!1, currentFilters: n, setFilters: r}) => {
    const a = y.useMemo(( () => (e => {
        var t, n;
        return [!!e.address, !!(null == (t = e.content) ? void 0 : t.length) && (null == (n = e.content) ? void 0 : n.length) !== $A.length].filter(Boolean).length
    }
    )(n)), [n])
      , s = y.useMemo(( () => ({
        px: e ? 0 : .5,
        minWidth: 0,
        ...e ? {
            width: dee,
            height: dee,
            border: "none",
            background: "transparent"
        } : {}
    })), [e])
      , {buttonProps: o, popoverProps: l} = Fw({
        id: "tracker-filters" + (e ? "-comapct" : "")
    });
    return v.jsxs(C, {
        children: [v.jsx(V, {
            ...o,
            tabIndex: -1,
            onMouseDown: uee,
            onClick: l.open ? l.onClose : o.onClick,
            variant: "tertiary",
            size: "xxsmall",
            sx: s,
            children: v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "center",
                children: [!e && v.jsx(xk, {}), !e && v.jsx(k, {
                    variant: "paragraph3",
                    children: "Filter"
                }), a ? v.jsx(q9, {
                    size: iee,
                    count: a
                }) : e ? v.jsx(xk, {
                    size: cee
                }) : v.jsx(C, {
                    width: iee,
                    height: iee
                })]
            })
        }), l.open && v.jsx(J9, {
            compact: e,
            isOpen: !0,
            initialFilters: n,
            isFeed: t,
            setFilters: r,
            ...l
        })]
    })
}
))
  , iee = 14
  , cee = 18
  , dee = 24
  , uee = e => {
    e.preventDefault()
}
  , pee = y.memo(( ({isLive: e, onDock: t, onUndock: n, onClose: r}) => {
    const {t: a} = we()
      , {tweetsFilters: s, setTweetsFilters: o} = KA()
      , l = y.useMemo(( () => e => ({
        px: n ? .75 : 0,
        py: n ? .75 : 0,
        gap: 1,
        width: "100%",
        borderBottom: n ? `1px solid ${e.palette.background.borderMain}` : "none"
    })), [n])
      , i = y.useCallback(( () => {
        window.open(`${tT.TRACKER}`, "_blank"),
        r()
    }
    ), [r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: l,
        children: [v.jsxs(S, {
            direction: "row",
            gap: .25,
            alignItems: "center",
            children: [v.jsx(Mk, {
                size: 14,
                color: "inherit"
            }), v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                children: a("Tracker")
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            className: "no-drag",
            height: bee,
            children: [v.jsx(C, {
                mt: .25,
                children: v.jsx(H9, {
                    isLive: e,
                    compact: !0
                })
            }), v.jsx(vI, {
                isInFloatingWidget: !0
            }), v.jsx(lee, {
                compact: !0,
                isFeed: !0,
                currentFilters: s,
                setFilters: o
            }), t && v.jsx(v.Fragment, {
                children: fee.map((e => v.jsx(GC, {
                    title: a("Dock {{side}}", {
                        side: e.toLowerCase()
                    }),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            ...xee,
                            onClick: () => {
                                t(e)
                            }
                            ,
                            children: v.jsx(C, {
                                display: "flex",
                                sx: {
                                    transform: e === K6.LEFT ? "scaleX(-1)" : "none"
                                },
                                children: v.jsx(_f, {
                                    size: mee
                                })
                            })
                        })
                    })
                }, e)))
            }), n && v.jsx(GC, {
                title: a("Undock"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...xee,
                        onClick: n,
                        children: v.jsx(Rf, {
                            size: mee
                        })
                    })
                })
            }), v.jsx(GC, {
                title: a("Open in new tab"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...xee,
                        onClick: i,
                        children: v.jsx(tk, {
                            size: gee
                        })
                    })
                })
            }), r && v.jsx(F, {
                onClick: r,
                sx: hee,
                children: v.jsx(gy, {})
            })]
        })]
    })
}
))
  , hee = {
    p: .25
}
  , mee = 18
  , gee = 16
  , xee = {
    variant: "tertiary",
    size: "xxsmall",
    sx: {
        p: 0,
        height: 24,
        width: 24,
        minWidth: 24,
        border: "none",
        background: "transparent"
    }
}
  , bee = 24
  , fee = [K6.LEFT, K6.RIGHT]
  , vee = y.memo(( ({closeTwitterTrackerWidget: e, internalIndex: t, onDock: n}) => {
    const [r,a] = y.useState(!0)
      , s = y.useMemo(( () => v.jsx(pee, {
        onDock: n,
        onClose: e,
        isLive: r
    })), [e, n, r]);
    return v.jsx(P8, {
        id: Y6.TWITTER_TRACKER,
        width: 315,
        height: 300,
        initialX: 265,
        initialY: window.innerHeight - 340,
        header: s,
        smallHeaderGap: !0,
        internalIndex: t,
        resizeParams: See,
        disableScroll: !0,
        noBottomPadding: !0,
        children: v.jsx(S, {
            alignItems: "flex-start",
            className: "no-drag padre-decorative-scroll",
            mt: -1,
            mb: -1,
            width: "calc(100% + 16px)",
            sx: yee,
            children: v.jsx(JP, {
                isLive: r,
                setIsLive: a
            })
        })
    })
}
))
  , See = {
    minWidth: 315,
    minHeight: 300,
    maxHeight: 800,
    maxWidth: 600
}
  , yee = {
    cursor: "default",
    overscrollBehaviorY: "contain",
    flex: 1,
    minHeight: 0,
    overflow: "auto"
}
  , kee = y.memo(( ({closeTwitterTrackerWidget: e, onUndock: t}) => {
    const [n,r] = y.useState(!0);
    return v.jsxs(S, {
        gap: 1,
        height: "100%",
        overflow: "hidden",
        children: [v.jsx(pee, {
            onUndock: t,
            onClose: e,
            isLive: n
        }), v.jsx(S, {
            sx: Cee,
            className: "padre-decorative-scroll",
            children: v.jsx(JP, {
                isLive: n,
                setIsLive: r
            })
        })]
    })
}
))
  , Cee = {
    overflowY: "scroll"
}
  , Aee = (e, t=0) => {
    let n = 3735928559 ^ t
      , r = 1103547991 ^ t;
    for (let a, s = 0; s < e.length; s++)
        a = e.charCodeAt(s),
        n = Math.imul(n ^ a, 2654435761),
        r = Math.imul(r ^ a, 1597334677);
    n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(r ^ r >>> 13, 3266489909),
    r = Math.imul(r ^ r >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909);
    return 4294967296 * (2097151 & r) + (n >>> 0)
}
  , wee = new Set(["en", "zh"])
  , jee = (e, t) => {
    if (!t || !e || !wee.has(e))
        return {
            translatedSymbol: null,
            translatedName: null
        };
    const n = t[e];
    return n ? {
        translatedSymbol: n.symbol,
        translatedName: n.name
    } : {
        translatedSymbol: null,
        translatedName: null
    }
}
  , Tee = e => e.split(",").filter((e => e.length > 0)).slice(0, Iee).map((e => e.toLowerCase()))
  , Iee = 5
  , Eee = {
    [Zh.NEW]: "New",
    [Zh.ALMOST_BONDED]: "Soon",
    [Zh.RECENTLY_BONDED]: "Migrated"
}
  , Mee = "trenches-quick-buy-hover"
  , Nee = "trenches-ultra-quick-buy-hover"
  , Pee = 1.25
  , Oee = ["pumpfun", "boop", "meteora-curve", "launchlab", "bonk", "believe", "moonshot", "bags", "jup", "moonit", "sugar", "heaven", "token-mill"]
  , Lee = {
    direction: "row",
    minWidth: 35,
    gap: .5,
    alignItems: "center",
    justifyContent: "space-between"
}
  , Ree = "moxia-static-stats"
  , Dee = e => {
    if (!e)
        return null;
    const [t,n] = fR(e);
    return n ? null : t ? /^\d+$/.test(t) ? null : t : null
}
  , Bee = e => e.itemKey
  , _ee = (e, t) => e ? e.map((e => {
    const {type: n, launchpadAux: r, decimals: a, createdAt: s, bondedAt: o, raydiumCreatedAt: l, pumpSwapCreatedAt: i, meteoraCreatedAt: c, devAddress: d, displayedCreatorAddress: u, devHolding: p, devHoldingPcnt: h, devHoldingAth: m, symbol: g, name: x, tokenAddress: b, tokenType: f, quoteTokenAddr: v, pumpfunAddress: S, pumpSwapAddress: y, raydiumAddress: k, meteoraAddress: C, curveProgress: A, curveProgressAth: w, fdvInUsd: j, priceInUsd: T, migrationPriceInUsd: I, postMigrationPriceInUsdAtl: E, postMigrationPriceInUsdAth: M, totalBuys: N, totalSells: P, totalTxns: O, tradingAppTxns: L, volumeInUsd: R, m5VolumeInUsd: D, top10HoldingPcnt: B, totalHolders: _, totalProHolders: U, insidersHolding: W, insidersHoldingPcnt: F, totalSnipers: V, snipersHoldingPcnt: H, socialsReuse: z, totalBundlesCount: $, totalSolSpentInBundles: G, totalTokenBoughtInBundles: q, totalSupply: K, padreAvatarUrl: Y, isAvatarReused: X, telegramUrl: Q, twitterUrl: Z, twitterUsernameReuse: J, projectWebsiteUrl: ee, bundlesHoldingPcnt: te, freshWalletBuys: ne, devFundTxn: re, wasRecentlyBoostedOnDexscreener: ae, isDexscreenerPaid: se, dexPaidAt: oe, totalDevMigrationsCount: le, postMigrationProtocol: ie, dexBannerUrl: ce, groupHoldings: de, totalSolFees: ue, realQuoteToken: pe, liquidityInUsd: he, activityStats: me, twitterLaunchMetadata: ge, alphaMentionPublicGroupCount: xe, alphaMentionPublicUiGroups: be, translations: fe, pfArticles: ve, mayhemActiveUntilTs: Se, isConfirmedBot: ye} = e
      , {translatedSymbol: ke, translatedName: Ce} = jee(t, fe)
      , Ae = Sp(e)
      , we = Dee(Z)
      , je = (e => (null == e ? void 0 : e.length) ? e.sort(( (e, t) => t.createdAt - e.createdAt))[0].articleId : null)(ve);
    return {
        itemKey: `${S}-${s}`,
        type: n,
        chain: Pd.SOLANA,
        launchpadAux: r,
        decimals: a,
        createdAt: s,
        createdAtBlock: null,
        bondedAt: o,
        raydiumCreatedAt: l,
        pumpSwapCreatedAt: i,
        meteoraCreatedAt: c,
        pancakeSwapCreatedAt: null,
        pancakeSwapAddress: null,
        fourMemeAddress: null,
        devAddress: ng(d),
        displayedCreatorAddress: u,
        devHolding: p,
        devHoldingPcnt: h,
        devHoldingAth: m,
        symbol: g,
        name: x,
        tokenAddress: ng(b),
        tokenType: f,
        quoteTokenAddr: v,
        pumpfunAddress: S,
        pumpSwapAddress: y,
        raydiumAddress: k,
        meteoraAddress: C,
        postMigrationProtocol: ie,
        devFundTxnHash: (null == re ? void 0 : re.txnHash) ?? null,
        devFundTxnFromAddress: (null == re ? void 0 : re.fromAddress) ?? null,
        devFundTxnWalletAddress: (null == re ? void 0 : re.walletAddress) ?? null,
        devFundTxnSolAmount: (null == re ? void 0 : re.solAmount) ?? null,
        devFundTxnTimestamp: (null == re ? void 0 : re.timestamp) ?? null,
        devFundTxnExchange: (null == re ? void 0 : re.exchange) ?? null,
        curveProgress: A,
        curveProgressAth: w,
        fdvInUsd: j,
        priceInUsd: T,
        migrationPriceInUsd: I,
        postMigrationPriceInUsdAtl: E,
        postMigrationPriceInUsdAth: M,
        totalBuys: N,
        totalSells: P,
        totalTxns: O,
        tradingAppTxns: L,
        volumeInUsd: R,
        m5VolumeInUsd: D,
        freshWalletBuysCount: (null == ne ? void 0 : ne.count) ?? null,
        freshWalletBuysSol: (null == ne ? void 0 : ne.sol) ?? null,
        top10HoldingPcnt: B,
        totalHolders: _,
        totalProHolders: U,
        insidersHolding: W,
        insidersHoldingPcnt: F,
        totalSnipers: V,
        snipersHoldingPcnt: H,
        socialsReuse: z,
        bundlesHoldingPcntCurrent: (null == te ? void 0 : te.current) ?? null,
        bundlesHoldingPcntAth: (null == te ? void 0 : te.ath) ?? null,
        totalBundlesCount: $,
        totalSolSpentInBundles: G,
        totalTokenBoughtInBundles: q,
        totalSupply: K,
        padreAvatarUrl: Y,
        isAvatarReused: X,
        telegramUrl: Q && ou.test(Q) ? Q : null,
        twitterUrl: Z && ou.test(Z) ? Z : null,
        tweetCreatedAt: (null == ge ? void 0 : ge.tweetCreatedAt) ?? null,
        twitterHandle: we ? we.toLowerCase() : null,
        twitterUsernameReuse: J,
        projectWebsiteUrl: ee && ou.test(ee) ? ee : null,
        wasRecentlyBoostedOnDexscreener: ae,
        isDexscreenerPaid: se,
        dexPaidAt: oe,
        totalDevMigrationsCount: le,
        groupHoldings: de ?? null,
        dexBannerUrl: ce ?? null,
        protocol: kp({
            type: n,
            raydiumAddress: k,
            pumpfunAddress: S,
            pumpSwapAddress: y,
            meteoraAddress: C,
            postMigrationProtocol: ie
        }),
        totalSolFees: ue,
        isHidden: !1,
        isBlacklisted: !1,
        isHandleBlacklisted: !1,
        realQuoteToken: pe,
        liquidityInUsd: he,
        migrationTime: Ae,
        isPermissioned: !1,
        activityStats: me,
        alphaMentionPublicGroupCount: xe,
        alphaMentionPublicUiGroups: be ?? null,
        translatedSymbol: ke,
        translatedName: Ce,
        pumpFunNewsArticleId: je,
        mayhemUntil: Se,
        isConfirmedBot: ye ?? !1
    }
}
)) : null
  , Uee = (e, t) => e ? e.map((e => {
    const {type: n, createdAt: r, createdAtBlock: a, bondedAt: s, pancakeSwapCreatedAt: o, devAddress: l, devHolding: i, devHoldingPcnt: c, devHoldingAth: d, symbol: u, name: p, tokenAddress: h, quoteTokenAddress: m, fourMemeAddress: g, pancakeSwapAddress: x, curveProgress: b, curveProgressAth: f, fdvInUsd: v, priceInUsd: S, migrationPriceInUsd: y, postMigrationPriceInUsdAtl: k, postMigrationPriceInUsdAth: C, totalBuys: A, totalSells: w, totalTxns: j, volumeInUsd: T, m5VolumeInUsd: I, top10HoldingPcnt: E, totalHolders: M, totalProHolders: N, insidersHoldingPcnt: P, totalSnipers: O, socialsReuse: L, activityStats: R, totalSupply: D, padreAvatarUrl: B, isAvatarReused: _, telegramUrl: U, twitterUrl: W, twitterUsernameReuse: F, projectWebsiteUrl: V, twitterLaunchMetadata: H, wasRecentlyBoostedOnDexscreener: z, isDexscreenerPaid: $, dexPaidAt: G, totalDevMigrationsCount: q, postMigrationProtocol: K, isPermissioned: Y, alphaMentionPublicGroupCount: X, alphaMentionPublicUiGroups: Q, dexBannerUrl: Z, translations: J} = e
      , {translatedSymbol: ee, translatedName: te} = jee(t, J)
      , ne = vp(e)
      , re = Dee(W);
    return {
        itemKey: `${h}-${r}`,
        isPermissioned: Y,
        type: n,
        chain: Pd.BSC,
        launchpadAux: null,
        decimals: 18,
        createdAt: r,
        createdAtBlock: a,
        bondedAt: s,
        raydiumCreatedAt: null,
        pumpSwapCreatedAt: null,
        meteoraCreatedAt: null,
        pancakeSwapCreatedAt: o,
        devAddress: ng(l),
        displayedCreatorAddress: null,
        devHolding: i,
        devHoldingPcnt: c,
        devHoldingAth: d,
        symbol: u,
        name: p,
        tokenAddress: ng(h),
        tokenType: null,
        quoteTokenAddr: m,
        pumpfunAddress: h,
        pumpSwapAddress: null,
        raydiumAddress: null,
        meteoraAddress: null,
        fourMemeAddress: g,
        pancakeSwapAddress: x,
        postMigrationProtocol: K,
        devFundTxnHash: null,
        devFundTxnFromAddress: null,
        devFundTxnWalletAddress: null,
        devFundTxnSolAmount: null,
        devFundTxnTimestamp: null,
        devFundTxnExchange: null,
        curveProgress: b,
        curveProgressAth: f,
        fdvInUsd: v,
        priceInUsd: S,
        migrationPriceInUsd: y,
        postMigrationPriceInUsdAtl: k,
        postMigrationPriceInUsdAth: C,
        totalBuys: A,
        totalSells: w,
        totalTxns: j,
        tradingAppTxns: null,
        volumeInUsd: T,
        m5VolumeInUsd: I,
        freshWalletBuysCount: null,
        freshWalletBuysSol: null,
        top10HoldingPcnt: E,
        totalHolders: M,
        totalProHolders: N ?? null,
        insidersHolding: null,
        insidersHoldingPcnt: P,
        totalSnipers: O,
        snipersHoldingPcnt: null,
        socialsReuse: L,
        bundlesHoldingPcntCurrent: null,
        bundlesHoldingPcntAth: null,
        totalBundlesCount: null,
        totalSolSpentInBundles: null,
        totalTokenBoughtInBundles: null,
        totalSupply: D,
        padreAvatarUrl: B,
        isAvatarReused: _,
        telegramUrl: U && ou.test(U) ? U : null,
        twitterUrl: W && ou.test(W) ? W : null,
        tweetCreatedAt: (null == H ? void 0 : H.tweetCreatedAt) ?? null,
        twitterHandle: re ? re.toLowerCase() : null,
        twitterUsernameReuse: F,
        projectWebsiteUrl: V && ou.test(V) ? V : null,
        wasRecentlyBoostedOnDexscreener: z,
        isDexscreenerPaid: $,
        dexPaidAt: G ?? null,
        totalDevMigrationsCount: q,
        groupHoldings: null,
        dexBannerUrl: Z ?? null,
        protocol: yp({
            type: n,
            pancakeSwapAddress: x,
            postMigrationProtocol: K
        }),
        totalSolFees: null,
        isHidden: !1,
        isBlacklisted: !1,
        isHandleBlacklisted: !1,
        realQuoteToken: null,
        liquidityInUsd: 0,
        migrationTime: ne,
        activityStats: R,
        alphaMentionPublicGroupCount: X,
        alphaMentionPublicUiGroups: Q ?? null,
        translatedSymbol: ee,
        translatedName: te,
        pumpFunNewsArticleId: null,
        mayhemUntil: null,
        isConfirmedBot: !1
    }
}
)) : null
  , Wee = (e, t) => {
    const n = new Map(e.map((e => [Bee(e), e])))
      , r = t.current.map((e => {
        const t = n.get(Bee(e));
        return t || {
            ...e,
            deprecated: !0
        }
    }
    ));
    return t.current = r,
    r
}
  , Fee = (e, t) => ({
    from: c.isNil(null == e ? void 0 : e.from) ? null : e.from * t,
    to: c.isNil(null == e ? void 0 : e.to) ? null : e.to * t
})
  , Vee = e => e.map(Aee)
  , Hee = e => e && Oee.length !== e.length ? e : Oee
  , zee = (e, t, n) => {
    var r, a;
    return {
        span: n,
        tickers: (null == (r = e[Qh.TICKERS]) ? void 0 : r.length) ? Tee(e[Qh.TICKERS][0]) : [],
        excludeKeywords: (null == (a = e[Qh.EXCLUDE_KEYWORDS]) ? void 0 : a.length) ? Tee(e[Qh.EXCLUDE_KEYWORDS][0]) : [],
        excludeDevCyrbs: t.length ? Vee(t) : null,
        hasSocials: e[Qh.HAS_SOCIALS],
        noSocialsReuse: e[Qh.NO_SOCIALS_REUSE],
        noPermissioned: e[Qh.NO_PERMISSIONED] ?? !1,
        curveProgress: e[Qh.CURVE_PROGRESS],
        top10HoldersPcnt: e[Qh.TOP_10_HOLDERS_PCNT],
        topInsidersHoldingPcnt: e[Qh.TOP_INSIDERS_HOLDING_PCNT],
        snipersHoldingPcnt: e[Qh.SNIPERS_HOLDINGS_PCNT],
        devHolding: e[Qh.DEV_HOLDING],
        isActiveMayhem: e[Qh.IS_ACTIVE_MAYHEM] ?? null,
        noConfirmedBots: e[Qh.NO_CONFIRMED_BOTS] ?? null,
        pumpLive: e[Qh.PUMP_LIVE],
        volume: e[Qh.VOLUME],
        marketCap: e[Qh.MARKET_CAP],
        buys: e[Qh.BUYS],
        sells: e[Qh.SELLS],
        totalSolFees: e[Qh.TOTAL_SOL_FEES] ?? null,
        tokenAgeInSeconds: Fee(e[Qh.TOKEN_AGE_IN_MINUTES], 60),
        holdersCount: e[Qh.HOLDERS_COUNT],
        bundlesHoldingPcnt: e[Qh.BUNDLES_HOLDING_PCNT],
        noAvatarReuse: e[Qh.HAS_ORIGINAL_AVATAR],
        devHoldingPcnt: e[Qh.PERCENTAGE_DEV_HOLDING],
        isDexBoosted: e[Qh.DEXSCREENER_BOOSTED] ?? null,
        devBondedCount: e[Qh.DEV_BONDED],
        launchpads: Hee(e[Qh.LAUNCHPADS]),
        liquidityInUsd: e[Qh.LIQUIDITY] ?? null,
        freshWalletBuysInSol: e[Qh.FRESH_WALLETS_BUYS] ?? null,
        alphaMentions: e[Qh.ALPHA_GROUP_MENTIONS] ?? null,
        proHoldersCount: e[Qh.PRO_HOLDERS_COUNT] ?? null
    }
}
  , $ee = (e, t, n, r, a) => e ? 0 !== n.size || t ? e.map((e => ({
    ...e,
    isHidden: !!t && (t[kX(e.tokenAddress, a)] ?? !1),
    isBlacklisted: n.has(e.devAddress),
    isHandleBlacklisted: !!e.twitterHandle && r.has(e.twitterHandle.toLowerCase())
}))) : e : null
  , Gee = e => e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress ?? e.pumpfunAddress
  , qee = e => {
    switch (e) {
    case "boop":
        return {
            type: Rc.BOOP
        };
    case "meteora-curve":
        return {
            type: Rc.METEORA_CURVE
        };
    case "launchlab":
        return {
            type: Rc.LAUNCH_LAB,
            curveType: _c.CONSTANT
        };
    case "sugar":
        return {
            type: Rc.SUGAR
        };
    case "moonit":
        return {
            type: Rc.MOONIT
        };
    case "heaven":
        return {
            type: Rc.HEAVEN
        };
    case "token-mill":
        return {
            type: Rc.TOKEN_MILL
        };
    case "pumpfun":
        return {
            type: Rc.PUMP_FUN
        };
    case "fourmeme":
        return {
            type: Lc.FOUR_MEME
        };
    case "wagmi":
    case "vista":
        return null;
    default:
        return e
    }
}
  , Kee = N((e => ({
    images: {
        cache: new hg(100)
    },
    insertImage: t => e((e => (e.images.cache.set(t.tokenAddress, t),
    {
        ...e
    })))
})))
  , Yee = e => {
    const t = oN(e);
    return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
  , Xee = e => T(Object.values(e), [e => e.createdAt ?? 0, "tokenAddress"], ["desc", "asc"])
  , Qee = e => T(Object.values(e), [e => e.curveProgress ?? 0, "tokenAddress"], ["desc", "asc"])
  , Zee = e => T(Object.values(e), [e => e.fdvInUsd ?? 0, "tokenAddress"], ["desc", "asc"])
  , Jee = e => T(Object.values(e), [e => "heaven" !== e.type && "token-mill" !== e.type || !e.bondedAt ? e.meteoraCreatedAt ?? e.pumpSwapCreatedAt ?? e.raydiumCreatedAt ?? 0 : e.bondedAt, "tokenAddress"], ["desc", "asc"])
  , ete = e => T(Object.values(e), [e => {
    var t;
    return (null == (t = e.activityStats) ? void 0 : t.m1.volUsd) ?? 0
}
], ["desc"])
  , tte = e => T(Object.values(e), [e => {
    var t;
    return (null == (t = e.activityStats) ? void 0 : t.m5.volUsd) ?? 0
}
], ["desc"])
  , nte = e => T(Object.values(e), [e => {
    var t;
    return (null == (t = e.activityStats) ? void 0 : t.m30.volUsd) ?? 0
}
], ["desc"])
  , rte = e => T(Object.values(e), [e => {
    var t;
    return (null == (t = e.activityStats) ? void 0 : t.h1.volUsd) ?? 0
}
], ["desc"])
  , ate = e => T(Object.values(e), [e => e.dexPaidAt ?? 0], ["desc"])
  , ste = e => T(Object.values(e), [e => e.createdAt ?? 0, "tokenAddress"], ["desc", "asc"])
  , ote = e => T(Object.values(e), [e => e.fdvInUsd ?? 0, "tokenAddress"], ["desc", "asc"])
  , lte = e => (e => !(("heaven" !== e.type && "token-mill" !== e.type || !e.bondedAt) && c.isNil(e.raydiumCreatedAt) && c.isNil(e.pumpSwapCreatedAt) && c.isNil(e.meteoraCreatedAt)))(e) ? ite(e) : e.createdAt
  , ite = e => "token-mill" !== e.type && "heaven" !== e.type || !e.bondedAt ? c.isNil(e.raydiumCreatedAt) ? c.isNil(e.pumpSwapCreatedAt) ? c.isNil(e.meteoraCreatedAt) ? -1 / 0 : e.meteoraCreatedAt : e.pumpSwapCreatedAt : e.raydiumCreatedAt : e.bondedAt
  , cte = e => T(Object.values(e), [e => lte(e)], ["desc"])
  , dte = e => {
    switch (e) {
    case "new":
        return Xee;
    case "soon":
        return Qee;
    case "soon-by-mc":
        return Zee;
    case "graduated":
        return Jee;
    case "vol1m":
        return ete;
    case "vol5m":
        return tte;
    case "vol30m":
        return nte;
    case "vol1h":
        return rte;
    case "dex-update":
        return ate;
    case "trending-new":
        return cte;
    case "live-pf-latest":
        return ste;
    case "live-pf-highest-mc":
        return ote
    }
}
  , ute = (e, t, n) => (r, a) => {
    var s;
    if ("init" === a.type) {
        const r = kn(a.snapshot.gazes, (e => null !== e.totalHolders && void 0 !== e.totalHolders))
          , s = e(r);
        return (null == t ? void 0 : t.current) && n && t.current(s, n, {
            isInit: !0
        }),
        {
            displayData: r,
            orderedDisplayData: s
        }
    }
    const o = r ? {
        ...r
    } : {
        orderedDisplayData: [],
        displayData: {}
    };
    if ("update" === a.type && (o.displayData = {
        ...o.displayData,
        ...Vt(a.update.adds ?? [], (e => e.tokenAddress))
    },
    (a.update.updates ?? []).forEach((e => {
        const t = e.tokenAddress;
        o.displayData[t] = {
            ...o.displayData[t],
            ...e
        }
    }
    )),
    (a.update.deletes ?? []).forEach((e => {
        delete o.displayData[e]
    }
    )),
    o.orderedDisplayData = e(o.displayData)),
    (null == t ? void 0 : t.current) && n && (null == (s = a.update.adds) ? void 0 : s.length)) {
        const e = c.maxBy(a.update.adds, (e => Sp(e) ?? 0))
          , r = c.maxBy(o.orderedDisplayData, (e => Sp(e) ?? 0));
        e && (Sp(e) ?? 0) >= (r ? Sp(r) ?? 0 : 0) && t.current(o.orderedDisplayData, n, {
            isInit: !1
        })
    }
    return o
}
  , pte = N((e => ({
    updateState: (t, n) => e((e => ({
        ...e,
        states: {
            ...e.states,
            [t]: n
        }
    }))),
    decreaseSubsCount: t => e((e => ({
        ...e,
        subscribersCount: {
            ...e.subscribersCount,
            [t]: (e.subscribersCount[t] ?? 0) - 1
        }
    }))),
    increaseSubsCount: t => e((e => ({
        ...e,
        subscribersCount: {
            ...e.subscribersCount,
            [t]: (e.subscribersCount[t] ?? 0) + 1
        }
    }))),
    states: {
        new: null,
        soon: null,
        "soon-by-mc": null,
        graduated: null,
        vol1m: null,
        vol5m: null,
        vol30m: null,
        vol1h: null,
        "dex-update": null,
        "trending-new": null,
        "live-pf-latest": null,
        "live-pf-highest-mc": null
    },
    subscribersCount: {
        new: 0,
        soon: 0,
        "soon-by-mc": 0,
        graduated: 0,
        vol1m: 0,
        vol5m: 0,
        vol30m: 0,
        vol1h: 0,
        "dex-update": 0,
        "trending-new": 0,
        "live-pf-latest": 0,
        "live-pf-highest-mc": 0
    }
})))
  , hte = (e, t, n, r, a, s, o, l, i, d) => {
    const u = Ax()
      , {settings: p} = rf()
      , h = pte((e => e.updateState), c.isEqual)
      , m = pte((e => e.subscribersCount.new))
      , g = pte((e => e.subscribersCount.soon))
      , x = pte((e => e.subscribersCount["soon-by-mc"]))
      , b = pte((e => e.subscribersCount.graduated))
      , f = pte((e => e.subscribersCount.vol1m))
      , v = pte((e => e.subscribersCount.vol5m))
      , S = pte((e => e.subscribersCount.vol30m))
      , k = pte((e => e.subscribersCount.vol1h))
      , C = pte((e => e.subscribersCount["dex-update"]))
      , A = pte((e => e.subscribersCount["trending-new"]))
      , w = pte((e => e.subscribersCount["live-pf-latest"]))
      , j = pte((e => e.subscribersCount["live-pf-highest-mc"]))
      , T = m > 0
      , I = g > 0
      , E = x > 0
      , M = b > 0
      , N = f > 0
      , P = v > 0
      , O = S > 0
      , L = k > 0
      , R = C > 0
      , D = A > 0
      , B = w > 0
      , _ = j > 0
      , U = y.useMemo(( () => p ? [Zh.NEW, Zh.ALMOST_BONDED, Zh.RECENTLY_BONDED].reduce(( (t, n) => {
        const r = e[n] ?? void 0
          , a = zee(r, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return t[n] = JSON.stringify(a),
        t
    }
    ), {}) : null), [e, p, o])
      , W = y.useMemo(( () => ({
        shouldSkip: !T && !D
    })), [T, D])
      , F = y.useMemo(( () => {
        if (!p || !t)
            return null;
        const e = zee(t, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return JSON.stringify(e)
    }
    ), [p, o, t])
      , V = y.useMemo(( () => {
        if (!p || !r)
            return null;
        const e = zee(r, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], l);
        return JSON.stringify(e)
    }
    ), [p, o, r, l])
      , H = y.useMemo(( () => {
        if (!p || !n)
            return null;
        const e = zee(n, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], l);
        return JSON.stringify(e)
    }
    ), [p, o, n, l])
      , z = y.useMemo(( () => {
        if (!p || !a)
            return null;
        const e = zee(a, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return JSON.stringify(e)
    }
    ), [p, o, a]);
    ( ({shouldSkip: e}) => {
        const t = Ax()
          , n = Kee()
          , r = y.useRef(n);
        r.current = n;
        const a = y.useCallback(( (n, r) => {
            if (ke(t) || e)
                return {
                    unsubscribe: () => {}
                };
            const a = Cg()
              , s = Lm.subscribeNewPumpFunImages({
                onMessage: e => {
                    r.onMessage(e),
                    e.processedAtMs && a.recordUpdate({
                        serverSideMs: e.processedAtMs
                    })
                }
                ,
                close: r.close
            });
            return {
                unsubscribe: () => {
                    s.unsubscribe(),
                    a.close()
                }
            }
        }
        ), [t, e])
          , s = y.useMemo(( () => ({
            transition: (e, t) => ((e = e ?? r.current).insertImage(t),
            e),
            extractPageCursor: () => ""
        })), []);
        vx(a, s)
    }
    )(W);
    const $ = y.useCallback((e => u && U && T ? Lm.subscribeV2(u, "new", Yee(U[Zh.NEW]), e) : {
        unsubscribe: () => {}
    }), [u, U, T])
      , G = y.useCallback((e => u && U && I ? Lm.subscribeV2(u, "soon", Yee(U[Zh.ALMOST_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, I])
      , q = y.useCallback((e => u && U && E ? Lm.subscribeV2(u, "soon-by-mc", Yee(U[Zh.ALMOST_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, E])
      , K = y.useCallback((e => u && U && M ? Lm.subscribeV2(u, "graduated", Yee(U[Zh.RECENTLY_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, M])
      , Y = y.useCallback((e => u && F && N ? Lm.subscribeV2(u, "vol1m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, N, F])
      , X = y.useCallback((e => u && F && P ? Lm.subscribeV2(u, "vol5m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, P])
      , Q = y.useCallback((e => u && F && O ? Lm.subscribeV2(u, "vol30m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, O])
      , Z = y.useCallback((e => u && F && L ? Lm.subscribeV2(u, "vol1h", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, L])
      , J = y.useCallback((e => u && H && R ? Lm.subscribeV2(u, "dex-update", Yee(H), {
        onMessage: t => {
            "init" === t.type && i(l),
            e.onMessage(t)
        }
        ,
        close: t => {
            e.close && e.close(t)
        }
    }) : {
        unsubscribe: () => {}
    }), [u, H, R, i, l])
      , ee = y.useCallback((e => u && V && D ? Lm.subscribeV2(u, "trending-new", Yee(V), {
        onMessage: t => {
            "init" === t.type && d(l),
            e.onMessage(t)
        }
        ,
        close: t => {
            e.close && e.close(t)
        }
    }) : {
        unsubscribe: () => {}
    }), [u, V, D, d, l])
      , te = y.useCallback((e => u && z && B ? Lm.subscribeV2(u, "live-pf-latest", Yee(z), e) : {
        unsubscribe: () => {}
    }), [u, z, B])
      , ne = y.useCallback((e => u && z && _ ? Lm.subscribeV2(u, "live-pf-highest-mc", Yee(z), e) : {
        unsubscribe: () => {}
    }), [u, z, _])
      , re = y.useMemo(( () => ute(dte("new"), s, Zh.NEW)), [s])
      , ae = y.useMemo(( () => ute(dte("soon"), s, Zh.ALMOST_BONDED)), [s])
      , se = y.useMemo(( () => ute(dte("soon-by-mc"), s, Zh.ALMOST_BONDED)), [s])
      , oe = y.useMemo(( () => ute(dte("graduated"), s, Zh.RECENTLY_BONDED)), [s])
      , le = y.useMemo(( () => ute(dte("vol1m"), null, null)), [])
      , ie = y.useMemo(( () => ute(dte("vol5m"), null, null)), [])
      , ce = y.useMemo(( () => ute(dte("vol30m"), null, null)), [])
      , de = y.useMemo(( () => ute(dte("vol1h"), null, null)), [])
      , ue = y.useMemo(( () => ute(dte("dex-update"), null, null)), [])
      , pe = y.useMemo(( () => ute(dte("trending-new"), null, null)), [])
      , he = y.useMemo(( () => ute(dte("live-pf-latest"), null, null)), [])
      , me = y.useMemo(( () => ute(dte("live-pf-highest-mc"), null, null)), [])
      , ge = y.useCallback((e => {
        h("new", e)
    }
    ), [h])
      , xe = y.useCallback((e => {
        h("soon", e)
    }
    ), [h])
      , be = y.useCallback((e => {
        h("soon-by-mc", e)
    }
    ), [h])
      , fe = y.useCallback((e => {
        h("graduated", e)
    }
    ), [h])
      , ve = y.useCallback((e => {
        h("vol1m", e)
    }
    ), [h])
      , Se = y.useCallback((e => {
        h("vol5m", e)
    }
    ), [h])
      , ye = y.useCallback((e => {
        h("vol30m", e)
    }
    ), [h])
      , Ce = y.useCallback((e => {
        h("vol1h", e)
    }
    ), [h])
      , Ae = y.useCallback((e => {
        h("dex-update", e)
    }
    ), [h])
      , we = y.useCallback((e => {
        h("trending-new", e)
    }
    ), [h])
      , je = y.useCallback((e => {
        h("live-pf-latest", e)
    }
    ), [h])
      , Te = y.useCallback((e => {
        h("live-pf-highest-mc", e)
    }
    ), [h]);
    Cx($, re, ge),
    Cx(G, ae, xe),
    Cx(q, se, be),
    Cx(K, oe, fe),
    Cx(Y, le, ve),
    Cx(X, ie, Se),
    Cx(Q, ce, ye),
    Cx(Z, de, Ce),
    Cx(J, ue, Ae),
    Cx(ee, pe, we),
    Cx(te, he, je),
    Cx(ne, me, Te)
}
  , mte = e => {
    const t = pte((t => e ? t.states[e] : null), c.isEqual)
      , n = pte((e => e.increaseSubsCount), c.isEqual)
      , r = pte((e => e.decreaseSubsCount), c.isEqual);
    return y.useEffect(( () => {
        if (null !== e)
            return n(e),
            () => {
                setTimeout(( () => {
                    try {
                        r(e)
                    } catch (fNe) {}
                }
                ), 15e3)
            }
    }
    ), [r, n, e]),
    y.useMemo(( () => ({
        data: t,
        isSync: !0
    })), [t])
}
  , gte = N((e => ({
    images: {
        cache: new hg(100)
    },
    insertImage: t => e((e => (e.images.cache.set(t.tokenAddress, t),
    {
        ...e
    })))
})))
  , xte = e => T(Object.values(e), [e => e.createdAt ?? 0, "tokenAddress"], ["desc", "asc"])
  , bte = e => T(Object.values(e), [e => e.curveProgress ?? 0, "tokenAddress"], ["desc", "asc"])
  , fte = e => T(Object.values(e), [e => e.fdvInUsd ?? 0, "tokenAddress"], ["desc", "asc"])
  , vte = e => T(Object.values(e), [e => e.bondedAt ?? e.pancakeSwapCreatedAt ?? 0, "tokenAddress"], ["desc", "asc"])
  , Ste = e => (e => !!e.bondedAt || !c.isNil(e.pancakeSwapCreatedAt))(e) ? yte(e) : e.createdAt
  , yte = e => e.bondedAt ?? (c.isNil(e.pancakeSwapCreatedAt) ? -1 / 0 : e.pancakeSwapCreatedAt)
  , kte = e => T(Object.values(e), [e => Ste(e)], ["desc"])
  , Cte = e => Object.values(e)
  , Ate = e => {
    switch (e) {
    case "new":
        return xte;
    case "soon":
        return bte;
    case "soon-by-mc":
        return fte;
    case "graduated":
        return vte;
    case "vol1m":
    case "vol5m":
    case "vol30m":
    case "vol1h":
    case "dex-update":
    case "live-pf-latest":
    case "live-pf-highest-mc":
        return Cte;
    case "trending-new":
        return kte
    }
}
  , wte = (e, t, n) => (r, a) => {
    var s;
    if ("init" === a.type) {
        const r = kn(a.snapshot.gazes, (e => null !== e.totalHolders && void 0 !== e.totalHolders))
          , s = e(r);
        return (null == t ? void 0 : t.current) && n && t.current(s, n, {
            isInit: !0
        }),
        {
            displayData: r,
            orderedDisplayData: s
        }
    }
    const o = r ? {
        ...r
    } : {
        orderedDisplayData: [],
        displayData: {}
    };
    if ("update" === a.type && (o.displayData = {
        ...o.displayData,
        ...Vt(a.update.adds ?? [], (e => e.tokenAddress))
    },
    (a.update.updates ?? []).forEach((e => {
        const t = e.tokenAddress;
        o.displayData[t] = {
            ...o.displayData[t],
            ...e
        }
    }
    )),
    (a.update.deletes ?? []).forEach((e => {
        delete o.displayData[e]
    }
    )),
    o.orderedDisplayData = e(o.displayData)),
    (null == t ? void 0 : t.current) && n && (null == (s = a.update.adds) ? void 0 : s.length)) {
        const e = c.maxBy(a.update.adds, (e => vp(e) ?? 0))
          , r = c.maxBy(o.orderedDisplayData, (e => vp(e) ?? 0));
        e && (vp(e) ?? 0) >= (r ? vp(r) ?? 0 : 0) && t.current(o.orderedDisplayData, n, {
            isInit: !1
        })
    }
    return o
}
  , jte = N((e => ({
    updateState: (t, n) => e((e => ({
        ...e,
        states: {
            ...e.states,
            [t]: n
        }
    }))),
    decreaseSubsCount: t => e((e => ({
        ...e,
        subscribersCount: {
            ...e.subscribersCount,
            [t]: (e.subscribersCount[t] ?? 0) - 1
        }
    }))),
    increaseSubsCount: t => e((e => ({
        ...e,
        subscribersCount: {
            ...e.subscribersCount,
            [t]: (e.subscribersCount[t] ?? 0) + 1
        }
    }))),
    states: {
        new: null,
        soon: null,
        "soon-by-mc": null,
        graduated: null,
        vol1m: null,
        vol5m: null,
        vol30m: null,
        vol1h: null,
        "dex-update": null,
        "trending-new": null,
        "live-pf-latest": null,
        "live-pf-highest-mc": null
    },
    subscribersCount: {
        new: 0,
        soon: 0,
        "soon-by-mc": 0,
        graduated: 0,
        vol1m: 0,
        vol5m: 0,
        vol30m: 0,
        vol1h: 0,
        "dex-update": 0,
        "trending-new": 0,
        "live-pf-latest": 0,
        "live-pf-highest-mc": 0
    }
})))
  , Tte = (e, t, n, r, a, s, o, l, i, d) => {
    const u = Ax()
      , {settings: p} = rf()
      , h = jte((e => e.updateState), c.isEqual)
      , m = jte((e => e.subscribersCount.new))
      , g = jte((e => e.subscribersCount.soon))
      , x = jte((e => e.subscribersCount["soon-by-mc"]))
      , b = jte((e => e.subscribersCount.graduated))
      , f = jte((e => e.subscribersCount.vol1m))
      , v = jte((e => e.subscribersCount.vol5m))
      , S = jte((e => e.subscribersCount.vol30m))
      , k = jte((e => e.subscribersCount.vol1h))
      , C = jte((e => e.subscribersCount["dex-update"]))
      , A = jte((e => e.subscribersCount["trending-new"]))
      , w = jte((e => e.subscribersCount["live-pf-latest"]))
      , j = jte((e => e.subscribersCount["live-pf-highest-mc"]))
      , T = m > 0
      , I = g > 0
      , E = x > 0
      , M = b > 0
      , N = f > 0
      , P = v > 0
      , O = S > 0
      , L = k > 0
      , R = C > 0
      , D = A > 0
      , B = w > 0
      , _ = j > 0
      , U = y.useMemo(( () => p ? [Zh.NEW, Zh.ALMOST_BONDED, Zh.RECENTLY_BONDED].reduce(( (t, n) => {
        const r = e[n] ?? void 0
          , a = zee(r, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return t[n] = JSON.stringify(a),
        t
    }
    ), {}) : null), [e, p, o])
      , W = y.useMemo(( () => ({
        shouldSkip: !T && !D
    })), [T, D])
      , F = y.useMemo(( () => {
        if (!p || !t)
            return null;
        const e = zee(t, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return JSON.stringify(e)
    }
    ), [p, o, t])
      , V = y.useMemo(( () => {
        if (!p || !r)
            return null;
        const e = zee(r, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], l);
        return JSON.stringify(e)
    }
    ), [p, o, r, l])
      , H = y.useMemo(( () => {
        if (!p || !n)
            return null;
        const e = zee(n, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], l);
        return JSON.stringify(e)
    }
    ), [p, o, n, l])
      , z = y.useMemo(( () => {
        if (!p || !a)
            return null;
        const e = zee(a, o ? [] : (null == p ? void 0 : p.devBlacklist) ?? [], null);
        return JSON.stringify(e)
    }
    ), [p, o, a]);
    ( ({shouldSkip: e}) => {
        const t = Ax()
          , n = gte()
          , r = y.useRef(n);
        r.current = n;
        const a = y.useCallback(( (n, r) => {
            if (ke(t) || e)
                return {
                    unsubscribe: () => {}
                };
            const a = Cg()
              , s = Lm.subscribeNewFourMemeImages({
                onMessage: e => {
                    r.onMessage(e),
                    e.processedAtMs && a.recordUpdate({
                        serverSideMs: e.processedAtMs
                    })
                }
                ,
                close: r.close
            });
            return {
                unsubscribe: () => {
                    s.unsubscribe(),
                    a.close()
                }
            }
        }
        ), [t, e])
          , s = y.useMemo(( () => ({
            transition: (e, t) => ((e = e ?? r.current).insertImage(t),
            e),
            extractPageCursor: () => ""
        })), []);
        vx(a, s)
    }
    )(W);
    const $ = y.useCallback((e => u && U && T ? Lm.subscribeBsc("new", Yee(U[Zh.NEW]), e) : {
        unsubscribe: () => {}
    }), [u, U, T])
      , G = y.useCallback((e => u && U && I ? Lm.subscribeBsc("soon", Yee(U[Zh.ALMOST_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, I])
      , q = y.useCallback((e => u && U && E ? Lm.subscribeBsc("soon-by-mc", Yee(U[Zh.ALMOST_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, E])
      , K = y.useCallback((e => u && U && M ? Lm.subscribeBsc("graduated", Yee(U[Zh.RECENTLY_BONDED]), e) : {
        unsubscribe: () => {}
    }), [u, U, M])
      , Y = y.useCallback((e => u && F && N ? Lm.subscribeBsc("vol1m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, N, F])
      , X = y.useCallback((e => u && F && P ? Lm.subscribeBsc("vol5m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, P])
      , Q = y.useCallback((e => u && F && O ? Lm.subscribeBsc("vol30m", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, O])
      , Z = y.useCallback((e => u && F && L ? Lm.subscribeBsc("vol1h", Yee(F), e) : {
        unsubscribe: () => {}
    }), [u, F, L])
      , J = y.useCallback((e => u && H && R ? Lm.subscribeBsc("dex-update", Yee(H), {
        onMessage: t => {
            "init" === t.type && i(l),
            e.onMessage(t)
        }
        ,
        close: t => {
            e.close && e.close(t)
        }
    }) : {
        unsubscribe: () => {}
    }), [u, H, R, i, l])
      , ee = y.useCallback((e => u && V && D ? Lm.subscribeBsc("trending-new", Yee(V), {
        onMessage: t => {
            "init" === t.type && d(l),
            e.onMessage(t)
        }
        ,
        close: t => {
            e.close && e.close(t)
        }
    }) : {
        unsubscribe: () => {}
    }), [u, V, D, d, l])
      , te = y.useCallback((e => u && z && B ? Lm.subscribeBsc("live-pf-latest", Yee(z), e) : {
        unsubscribe: () => {}
    }), [u, z, B])
      , ne = y.useCallback((e => u && z && _ ? Lm.subscribeBsc("live-pf-highest-mc", Yee(z), e) : {
        unsubscribe: () => {}
    }), [u, z, _])
      , re = y.useMemo(( () => wte(Ate("new"), s, Zh.NEW)), [s])
      , ae = y.useMemo(( () => wte(Ate("soon"), s, Zh.ALMOST_BONDED)), [s])
      , se = y.useMemo(( () => wte(Ate("soon-by-mc"), s, Zh.ALMOST_BONDED)), [s])
      , oe = y.useMemo(( () => wte(Ate("graduated"), s, Zh.RECENTLY_BONDED)), [s])
      , le = y.useMemo(( () => wte(Ate("vol1m"), null, null)), [])
      , ie = y.useMemo(( () => wte(Ate("vol5m"), null, null)), [])
      , ce = y.useMemo(( () => wte(Ate("vol30m"), null, null)), [])
      , de = y.useMemo(( () => wte(Ate("vol1h"), null, null)), [])
      , ue = y.useMemo(( () => wte(Ate("dex-update"), null, null)), [])
      , pe = y.useMemo(( () => wte(Ate("trending-new"), null, null)), [])
      , he = y.useMemo(( () => wte(Ate("live-pf-latest"), null, null)), [])
      , me = y.useMemo(( () => wte(Ate("live-pf-highest-mc"), null, null)), [])
      , ge = y.useCallback((e => {
        h("new", e)
    }
    ), [h])
      , xe = y.useCallback((e => {
        h("soon", e)
    }
    ), [h])
      , be = y.useCallback((e => {
        h("soon-by-mc", e)
    }
    ), [h])
      , fe = y.useCallback((e => {
        h("graduated", e)
    }
    ), [h])
      , ve = y.useCallback((e => {
        h("vol1m", e)
    }
    ), [h])
      , Se = y.useCallback((e => {
        h("vol5m", e)
    }
    ), [h])
      , ye = y.useCallback((e => {
        h("vol30m", e)
    }
    ), [h])
      , Ce = y.useCallback((e => {
        h("vol1h", e)
    }
    ), [h])
      , Ae = y.useCallback((e => {
        h("dex-update", e)
    }
    ), [h])
      , we = y.useCallback((e => {
        h("trending-new", e)
    }
    ), [h])
      , je = y.useCallback((e => {
        h("live-pf-latest", e)
    }
    ), [h])
      , Te = y.useCallback((e => {
        h("live-pf-highest-mc", e)
    }
    ), [h]);
    Cx($, re, ge),
    Cx(G, ae, xe),
    Cx(q, se, be),
    Cx(K, oe, fe),
    Cx(Y, le, ve),
    Cx(X, ie, Se),
    Cx(Q, ce, ye),
    Cx(Z, de, Ce),
    Cx(J, ue, Ae),
    Cx(ee, pe, we),
    Cx(te, he, je),
    Cx(ne, me, Te)
}
  , Ite = e => {
    const t = jte((t => e ? t.states[e] : null), c.isEqual)
      , n = jte((e => e.increaseSubsCount), c.isEqual)
      , r = jte((e => e.decreaseSubsCount), c.isEqual);
    return y.useEffect(( () => {
        if (null !== e)
            return n(e),
            () => {
                setTimeout(( () => {
                    try {
                        r(e)
                    } catch (fNe) {}
                }
                ), 15e3)
            }
    }
    ), [r, n, e]),
    y.useMemo(( () => ({
        data: t,
        isSync: !0
    })), [t])
}
  , Ete = e => Cn({
    ...e,
    cellCache: {},
    isScrolling: !1,
    isScrollingOptOut: !1
})
  , Mte = 200
  , Nte = 40;
var Pte = (e => (e.SQUARE = "SQUARE",
e.ROUNDED = "ROUNDED",
e))(Pte || {});
const Ote = y.memo(( ({name: e, tokenAddress: t, avatarSize: n, progressBarGap: r, padreAvatarUrl: a, isAvatarReused: s, curveProgress: o, hasBonded: l, chain: i, shape: c, protocol: d, launchpad: u, launchpadAux: p, devAddress: h, isHidden: m, isBlacklisted: g, isHandleBlacklisted: x, twitterHandle: b, compact: f=!1, trending: S=!1, protocolMarkerSize: k=12, protocolMarkerOffset: A=6, protocolMarkerInnerIconSize: w=11, avatarGap: j=0, shadow: T=!1, subtleBorder: I=!1, migrationHide: E=!1, cornerButtons: M=!1, actionButtonSize: N}) => {
    const {hideHoverAvatar: P, toggleHideHoverAvatar: O} = xne()
      , L = pK()
      , {hidePair: R, showPair: D} = SX()
      , B = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        O && O(!0),
        m ? D(t, i) : R(t, i, E)
    }
    ), [O, m, D, t, i, R, E])
      , {addToDevBlacklist: _, removeFromDevBlacklist: U, addToHandlesBlacklist: W, removeFromHandlesBlacklist: F, settings: V} = rf()
      , H = y.useCallback((e => {
        if (e.stopPropagation(),
        e.preventDefault(),
        !V)
            return;
        if (g)
            return U(ng(h)),
            void L({
                message: uu.devBlacklistRemove,
                type: "success"
            }, "dev-blacklist-remove-success");
        if (V.devBlacklist && V.devBlacklist.length >= Mte)
            return void L({
                message: uu.devBlacklistLimitReached,
                type: "warning"
            }, "dev-blacklist-error");
        const t = ng(h);
        lu.has(t) ? L({
            message: uu.devProtectedBlacklist,
            type: "warning"
        }, "dev-blacklist-protected-error") : (_(t),
        L({
            message: uu.devBlacklisted,
            type: "success"
        }, "dev-blacklist-success"))
    }
    ), [_, h, L, g, U, V])
      , z = y.useCallback((e => {
        if (e.stopPropagation(),
        e.preventDefault(),
        V && b)
            return x ? (F(b),
            void L({
                message: uu.handleBlacklistRemove,
                type: "success"
            }, "handles-blacklist-remove-success")) : void (V.handlesBlacklist && V.handlesBlacklist.length >= 200 ? L({
                message: uu.handlesBlacklistLimitReached,
                type: "warning"
            }, "handles-blacklist-error") : (W(b),
            L({
                message: uu.handleBlacklisted,
                type: "success"
            }, "handles-blacklist-success")))
    }
    ), [W, L, x, F, V, b])
      , $ = Kee((e => e.images.cache.get(t)), ze)
      , G = gte((e => e.images.cache.get(t)), ze)
      , q = y.useMemo(( () => Y8(i, $, G)), [i, $, G])
      , K = y.useMemo(( () => v$(d.type, u, p, i, l)), [l, u, p, d, i])
      , Y = y.useMemo(( () => ({
        width: n,
        height: n,
        position: "relative",
        zIndex: 2
    })), [n])
      , X = y.useMemo(( () => ({
        position: "absolute",
        inset: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
    })), [])
      , Q = y.useMemo(( () => e => T ? {
        boxShadow: `0 0 0 1px ${e.palette.text.value}16`,
        borderRadius: c === Pte.SQUARE ? "2px" : "50%",
        display: "inline-flex"
    } : {
        display: "inline-flex"
    }), [c, T])
      , Z = y.useMemo(( () => {
        const e = n - Dte - r - (c === Pte.SQUARE ? 0 : 2) - j;
        return e % 2 == n % 2 ? e : e - 1
    }
    ), [n, r, c, j]);
    return v.jsxs(C, {
        sx: Y,
        children: [v.jsx(C, {
            sx: X,
            children: v.jsx(C, {
                sx: Q,
                children: v.jsx(b_, {
                    size: Z,
                    url: IE(i, t),
                    name: e,
                    chain: i,
                    padreAvatarUrl: a,
                    imageData: q ? `data:image/jpeg;base64,${q.imageBase64}` : void 0,
                    protocolInfo: K,
                    hideBorder: !0,
                    showLens: !0,
                    actionButtonSize: N,
                    onHideClick: S && f ? void 0 : B,
                    isHidden: m,
                    onBlacklistClick: lu.has(ng(h)) || S && f ? void 0 : H,
                    isBlacklisted: g,
                    onHandleBlacklistClick: S && f || !b ? void 0 : z,
                    isHandleBlacklisted: x,
                    borderRadius: c === Pte.SQUARE ? "2px" : "50%",
                    protocolMarkerSize: k,
                    protocolMarkerOffset: A,
                    protocolMarkerInnerIconSize: w,
                    hideHoverAvatar: P,
                    cornerButtons: M
                })
            })
        }), s && v.jsx(Rte, {
            shape: c
        }), v.jsx(Lte, {
            avatarSize: n,
            curveProgress: o,
            hasBonded: l,
            launchpad: u,
            launchpadAux: p,
            shape: c,
            protocolType: d.type,
            subtleBorder: I
        })]
    })
}
))
  , Lte = y.memo(( ({avatarSize: e, shape: t, curveProgress: n, launchpad: r, launchpadAux: a, hasBonded: s, protocolType: o, subtleBorder: l}) => {
    const i = D()
      , [c,d] = y.useMemo(( () => RM(s, a ?? r, o, i)), [s, r, a, o, i])
      , u = y.useMemo(( () => l ? 0 : s ? Ute : Math.min(Ute, Math.max(_te, _te + n / 100 * (Ute - _te)))), [n, s, l])
      , [p,h,m,g] = y.useMemo(( () => {
        const t = e - Dte
          , n = (t - Dte) / 2;
        return [t, 4 * (t - 2 * Bte) + 2 * Math.PI * Bte, n, 2 * Math.PI * n]
    }
    ), [e]);
    return t === Pte.SQUARE ? v.jsxs(v.Fragment, {
        children: [v.jsx("svg", {
            width: e,
            height: e,
            viewBox: `0 0 ${e} ${e}`,
            style: $te,
            children: v.jsx("rect", {
                x: Dte / 2,
                y: Dte / 2,
                width: p,
                height: p,
                rx: Bte,
                ry: Bte,
                fill: "none",
                stroke: c,
                strokeWidth: Dte,
                strokeDasharray: h,
                strokeDashoffset: h * (1 + u / 100)
            })
        }), v.jsx("svg", {
            width: e,
            height: e,
            viewBox: `0 0 ${e} ${e}`,
            style: Gte,
            children: v.jsx("rect", {
                x: Dte / 2,
                y: Dte / 2,
                width: p,
                height: p,
                rx: Bte,
                ry: Bte,
                fill: "none",
                stroke: l ? `${d}55` : d,
                strokeWidth: Dte,
                strokeDasharray: h,
                strokeDashoffset: 2 * h
            })
        })]
    }) : v.jsxs(v.Fragment, {
        children: [v.jsx("svg", {
            width: e,
            height: e,
            viewBox: `0 0 ${e} ${e}`,
            style: qte,
            children: v.jsx("circle", {
                cx: e / 2,
                cy: e / 2,
                r: m,
                fill: "none",
                stroke: `${c}44`,
                strokeWidth: Dte,
                strokeDasharray: g,
                strokeDashoffset: 0
            })
        }), v.jsx("svg", {
            width: e,
            height: e,
            viewBox: `0 0 ${e} ${e}`,
            style: Kte,
            children: v.jsx("circle", {
                cx: e / 2,
                cy: e / 2,
                r: m,
                fill: "none",
                stroke: c,
                strokeWidth: Dte,
                strokeDasharray: g,
                strokeDashoffset: g * (1 - u / 100)
            })
        })]
    })
}
))
  , Rte = y.memo(( ({shape: e}) => {
    const {t: t} = we()
      , n = y.useMemo(( () => t => ({
        position: "absolute",
        right: e === Pte.SQUARE ? Vte : Hte,
        top: e === Pte.SQUARE ? Vte : Hte,
        width: Fte,
        height: Fte,
        border: `1px solid ${t.palette.text.label}`,
        borderRadius: "50%",
        background: t.palette.background.default
    })), [e]);
    return v.jsx(C, {
        sx: n,
        children: v.jsx(GC, {
            title: t("Avatar reused"),
            children: v.jsx(C, {
                sx: zte,
                children: v.jsx(Ak, {
                    size: Wte
                })
            })
        })
    })
}
))
  , Dte = 1
  , Bte = 4
  , _te = 6
  , Ute = 98.5
  , Wte = 11
  , Fte = 15
  , Vte = -3
  , Hte = 3
  , zte = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    mt: "1px"
}
  , $te = {
    transform: "rotate(90deg) scaleX(-1)",
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: -1
}
  , Gte = {
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: -2
}
  , qte = {
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: -2
}
  , Kte = {
    transform: "rotate(38deg)",
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: -1
};
var Yte = (e => (e.DEX = "DEX",
e.VOL_1M = "VOL_1M",
e.VOL_5M = "VOL_5M",
e.VOL_30M = "VOL_30M",
e.VOL_1H = "VOL_1H",
e.NEW = "NEW",
e.PUMP_LIVE = "PUMP_LIVE",
e))(Yte || {})
  , Xte = (e => (e.M1 = "M1",
e.M5 = "M5",
e.M30 = "M30",
e.H1 = "H1",
e))(Xte || {});
const Qte = HX.SPACED
  , Zte = $X.NORMAL
  , Jte = zX.NORMAL
  , ene = Pte.SQUARE
  , tne = GX.ROUNDED
  , nne = qX.MOXIA
  , rne = YX.CURVE
  , ane = KX.NONE;
var sne = (e => (e.HIDE = "HIDE",
e.SHOW_ALL = "SHOW_ALL",
e.SHOW_MIGRATED = "SHOW_MIGRATED",
e))(sne || {});
const one = y.createContext({
    trenchesChain: Pd.SOLANA,
    setTrenchesChain: c.noop,
    trendingMode: Yte.VOL_5M,
    setTrendingMode: c.noop,
    trendingTimespan: Xte.M5,
    setTrendingTimespan: c.noop,
    dexTrendingTimespan: Xte.M5,
    newTrendingTimespan: Xte.M5,
    hideMode: sne.HIDE,
    setHideMode: c.noop,
    hideHoverAvatar: !1,
    toggleHideHoverAvatar: c.noop,
    spacingMode: Qte,
    toggleSpacingMode: c.noop,
    trenchesFontMode: Zte,
    toggleTrenchesFontMode: c.noop,
    trenchesButtonMode: Jte,
    toggleTrenchesButtonMode: c.noop,
    trenchesButtonEdges: tne,
    toggleTrenchesButtonEdges: c.noop,
    avatarShape: ene,
    toggleAvatarShape: c.noop,
    trenchesTileLayout: nne,
    toggleTrenchesTileLayout: c.noop,
    selectedColor: null,
    setSelectedColor: c.noop,
    selectedTextColor: null,
    setSelectedTextColor: c.noop,
    quickBuyButtonExtraPadding: 0,
    setQuickBuyButtonExtraPadding: c.noop,
    quickBuyButtonExtraOffset: 0,
    setQuickBuyButtonExtraOffset: c.noop,
    quickBuyButtonTransparency: 0,
    setQuickBuyButtonTransparency: c.noop,
    statsDesiredDigits: 2,
    setStatsDesiredDigits: c.noop,
    launchpadBackgroundColor: !1,
    toggleLaunchpadBackgroundColor: c.noop,
    pauseOnHover: !0,
    togglePauseOnHover: c.noop,
    ultraBuyButton: !1,
    toggleUltraBuyButton: c.noop,
    showAvatarReused: !0,
    toggleShowAvatarReused: c.noop,
    hiddenColumns: [],
    toggleHiddenColumns: c.noop,
    resetHiddenColumns: c.noop,
    showUltraGlow: !1,
    toggleShowUltraGlow: c.noop,
    showUltraBorder: !1,
    toggleShowUltraBorder: c.noop,
    showExtraButton: !1,
    toggleShowExtraButton: c.noop,
    selectedExtraColor: null,
    setSelectedExtraColor: c.noop,
    selectedExtraTextColor: null,
    setSelectedExtraTextColor: c.noop,
    quickBuyExtraAction: ane,
    toggleQuickBuyExtraAction: c.noop,
    soonMode: rne,
    toggleSoonMode: c.noop,
    allowCopyName: !0,
    toggleAllowCopyName: c.noop
})
  , lne = {
    [Yte.DEX]: Xte.M5,
    [Yte.VOL_1M]: Xte.M1,
    [Yte.VOL_5M]: Xte.M5,
    [Yte.VOL_30M]: Xte.M30,
    [Yte.VOL_1H]: Xte.H1,
    [Yte.NEW]: Xte.M5,
    [Yte.PUMP_LIVE]: Xte.M5
}
  , ine = {
    [Xte.M1]: Yte.VOL_1M,
    [Xte.M5]: Yte.VOL_5M,
    [Xte.M30]: Yte.VOL_30M,
    [Xte.H1]: Yte.VOL_1H
}
  , cne = {
    [Xte.M1]: "1m",
    [Xte.M5]: "5m",
    [Xte.M30]: "30m",
    [Xte.H1]: "1h"
}
  , dne = {
    "1m": Xte.M1,
    "5m": Xte.M5,
    "30m": Xte.M30,
    "1h": Xte.H1
}
  , une = new Set([Yte.PUMP_LIVE, Yte.DEX])
  , pne = e => e.tokenAddress
  , hne = (e, t, n, r) => {
    const {solFilters: a, bscFilters: s} = JX()
      , o = K8(r, a, s)
      , l = y.useRef(null)
      , i = NA(o[e]);
    return y.useEffect(( () => {
        c.isEqual(o[e], i) || (l.current = null)
    }
    ), [i, o, e]),
    y.useCallback(( (e, r) => {
        if (r.isInit) {
            const t = (e ?? []).map(pne);
            return void (l.current = new hg(1e3,t.map((e => ({
                key: e,
                value: !0
            })))))
        }
        if (!e || 0 === e.length)
            return;
        const a = e.map(pne)
          , s = !!a.some((e => {
            var t;
            return !(null == (t = l.current) ? void 0 : t.get(e))
        }
        ));
        a.forEach((e => {
            var t;
            null == (t = l.current) || t.set(e, !0)
        }
        )),
        n && s && !r.isInit && nw.play(t)
    }
    ), [t, n])
}
  , mne = ({children: e}) => {
    const [t,n] = Mx("padreV2-trenchesSelectedChain", Pd.SOLANA)
      , [r,a] = JC(!1, gne)
      , [s,o] = Mx("padreV2-trendingGazeMode", Yte.VOL_5M)
      , [l,i] = Mx("padreV2-trendingTimespanMode", lne[s]);
    y.useEffect(( () => {
        t !== Pd.SOLANA && une.has(s) && o(ine[l])
    }
    ), [o, t, s, l]);
    const c = y.useCallback((e => {
        e !== Pd.SOLANA && une.has(s) && o(ine[l]),
        n(e)
    }
    ), [n, o, s, l])
      , d = y.useMemo(( () => cne[l]), [l])
      , [u,p] = y.useState(cne[l])
      , h = y.useMemo(( () => dne[u]), [u])
      , [m,g] = y.useState(cne[l])
      , x = y.useMemo(( () => dne[m]), [m])
      , [b] = Mx("padreV2-trenchesShowHidden", !1)
      , [f,S] = Mx("padreV2-trenchesHideMode", b ? sne.SHOW_ALL : sne.HIDE)
      , [k,C] = Mx("padreV2-trenchesSpacingMode", Qte)
      , [A,w] = Mx("padreV2-trenchesFontMode", Zte)
      , [j,T] = Mx("padreV2-trenchesUltraButton", !1)
      , [I,E] = Mx("padreV2-trenchesButtonMode", Jte)
      , [M,N] = Mx("padreV2-trenchesButtonEdges", tne)
      , [P,O] = Mx("padreV2-trenchesAvatarShape", ene)
      , [L,R] = Mx("padreV2-trenchesTileLayout", nne)
      , D = y.useCallback(( () => {
        O((e => e === Pte.ROUNDED ? Pte.SQUARE : Pte.ROUNDED))
    }
    ), [O])
      , B = y.useCallback(( () => {
        C((e => e === HX.COMPACT ? HX.SPACED : HX.COMPACT))
    }
    ), [C])
      , _ = y.useCallback(( () => {
        E((e => {
            switch (e) {
            case zX.NORMAL:
                return zX.LARGE;
            case zX.LARGE:
                return zX.MEGA;
            case zX.MEGA:
                return zX.NORMAL
            }
        }
        ))
    }
    ), [E])
      , U = y.useCallback(( () => {
        N((e => e === GX.ROUNDED ? GX.SQUARE : GX.ROUNDED))
    }
    ), [N])
      , W = y.useCallback(( () => {
        w((e => e === $X.NORMAL ? $X.LARGE_IMPORTANT_STATS : $X.NORMAL))
    }
    ), [w])
      , F = y.useCallback(( () => {
        T((e => !e))
    }
    ), [T])
      , V = y.useCallback(( () => {
        R((e => e === qX.MOXIA ? qX.ORIGINAL : qX.MOXIA))
    }
    ), [R])
      , [H,z] = Mx("padreV2-trenchesCustomButtonColor", null)
      , [$,G] = Mx("padreV2-trenchesCustomButtonTextColor", null)
      , [q,K] = Mx("padreV2-trenchesCustomButtonPadding", 0)
      , [Y,X] = Mx("padreV2-trenchesCustomButtonOffset", 0)
      , [Q,Z] = Mx("padreV2-trenchesCustomButtonTransparency", 0)
      , [J,ee] = Mx("padreV2-trenchesStatsDesiredDigits", 2)
      , [te,ne] = Mx("padreV2-trenchesLaunchpadBackground", !1)
      , re = y.useCallback(( () => {
        ne((e => !e))
    }
    ), [ne])
      , [ae,se] = Mx("padreV2-trenchesPauseOnHover", !0)
      , oe = y.useCallback(( () => {
        se((e => !e))
    }
    ), [se])
      , [le,ie] = Mx("padreV2-trenchesShowAvatarReused", !0)
      , ce = y.useCallback(( () => {
        ie((e => !e))
    }
    ), [ie])
      , [de,ue] = Mx("padreV2-trenchesShowUltraGlow", !1)
      , pe = y.useCallback(( () => {
        ue((e => !e))
    }
    ), [ue])
      , [he,me] = Mx("padreV2-trenchesShowUltraBorder", !1)
      , ge = y.useCallback(( () => {
        me((e => !e))
    }
    ), [me])
      , [xe,be] = Mx("padreV2-trenchesShowExtraButton", !1)
      , fe = y.useCallback(( () => {
        be((e => !e))
    }
    ), [be])
      , [ve,Se] = Mx("padreV2-trenchesSoonMode", rne)
      , ye = y.useCallback(( () => {
        Se((e => e === YX.M_CAP ? YX.CURVE : YX.M_CAP))
    }
    ), [Se])
      , [ke,Ce] = Mx("padreV2-trenchesAllowCopy", !0)
      , Ae = y.useCallback(( () => {
        Ce((e => !e))
    }
    ), [Ce])
      , [we,je] = Mx("padreV2-trenchesCustomExtraButtonColor", null)
      , [Te,Ie] = Mx("padreV2-trenchesCustomExtraButtonTextColor", null)
      , [Ee,Me] = Mx("padreV2-trenchesQuickBuyExtraAction", ane)
      , Ne = y.useCallback(( () => {
        Me((e => e === KX.NONE ? KX.OPEN_MARKET : e === KX.OPEN_MARKET ? KX.NEW_TAB_OPEN_MARKET : KX.NONE))
    }
    ), [Me])
      , [Pe,Oe] = Mx("padreV2-trenchesHiddenColumns", [])
      , Le = y.useCallback((e => {
        Oe((t => t.includes(e) ? t.filter((t => t !== e)) : [...t, e]))
    }
    ), [Oe])
      , Re = y.useCallback(( () => {
        Oe([])
    }
    ), [Oe])
      , {solFilters: De, bscFilters: Be, trendingSolFilters: _e, trendingBscFilters: Ue, solDexFilters: We, bscDexFilters: Fe, trendingSolNewFilters: Ve, trendingBscNewFilters: He, livePumpFilters: ze, selectedSoundEffects: $e, soundEffectsEnabled: Ge, selectedBscSoundEffects: qe, bscSoundEffectsEnabled: Ke} = JX()
      , Ye = hne(Zh.NEW, $e[Zh.NEW] ?? Xw, Ge[Zh.NEW] ?? !1, Pd.SOLANA)
      , Xe = hne(Zh.ALMOST_BONDED, $e[Zh.ALMOST_BONDED] ?? Xw, Ge[Zh.ALMOST_BONDED] ?? !1, Pd.SOLANA)
      , Qe = hne(Zh.RECENTLY_BONDED, $e[Zh.RECENTLY_BONDED] ?? Xw, Ge[Zh.RECENTLY_BONDED] ?? !1, Pd.SOLANA)
      , Ze = hne(Zh.NEW, qe[Zh.NEW] ?? Xw, Ke[Zh.NEW] ?? !1, Pd.BSC)
      , Je = hne(Zh.ALMOST_BONDED, qe[Zh.ALMOST_BONDED] ?? Xw, Ke[Zh.ALMOST_BONDED] ?? !1, Pd.BSC)
      , et = hne(Zh.RECENTLY_BONDED, qe[Zh.RECENTLY_BONDED] ?? Xw, Ke[Zh.RECENTLY_BONDED] ?? !1, Pd.BSC)
      , tt = y.useCallback(( (e, t, n) => {
        switch (t) {
        case Zh.NEW:
            Ye(e, n);
            break;
        case Zh.ALMOST_BONDED:
            Xe(e, n);
            break;
        case Zh.RECENTLY_BONDED:
            Qe(e, n)
        }
    }
    ), [Qe, Ye, Xe])
      , nt = y.useCallback(( (e, t, n) => {
        switch (t) {
        case Zh.NEW:
            Ze(e, n);
            break;
        case Zh.ALMOST_BONDED:
            Je(e, n);
            break;
        case Zh.RECENTLY_BONDED:
            et(e, n)
        }
    }
    ), [et, Ze, Je])
      , rt = y.useRef(tt);
    y.useEffect(( () => {
        rt.current = tt
    }
    ), [tt]);
    const at = y.useRef(nt);
    y.useEffect(( () => {
        at.current = nt
    }
    ), [nt]),
    hte(De, _e, We, Ve, ze, rt, f === sne.SHOW_ALL, d, p, g),
    Tte(Be, Ue, Fe, He, ze, at, f === sne.SHOW_ALL, d, p, g);
    const st = y.useMemo(( () => ({
        trenchesChain: t,
        setTrenchesChain: c,
        trendingMode: s,
        setTrendingMode: o,
        trendingTimespan: l,
        setTrendingTimespan: i,
        dexTrendingTimespan: h,
        newTrendingTimespan: x,
        hideMode: f,
        setHideMode: S,
        hideHoverAvatar: r,
        toggleHideHoverAvatar: a,
        spacingMode: k,
        toggleSpacingMode: B,
        toggleTrenchesFontMode: W,
        trenchesFontMode: A,
        toggleTrenchesButtonMode: _,
        trenchesButtonMode: I,
        trenchesButtonEdges: M,
        toggleTrenchesButtonEdges: U,
        avatarShape: P,
        toggleAvatarShape: D,
        trenchesTileLayout: t === Pd.SOLANA ? L : qX.MOXIA,
        toggleTrenchesTileLayout: V,
        selectedColor: H,
        setSelectedColor: z,
        selectedTextColor: $,
        setSelectedTextColor: G,
        quickBuyButtonExtraPadding: q,
        setQuickBuyButtonExtraPadding: K,
        quickBuyButtonExtraOffset: Y,
        setQuickBuyButtonExtraOffset: X,
        quickBuyButtonTransparency: Q,
        setQuickBuyButtonTransparency: Z,
        statsDesiredDigits: J,
        setStatsDesiredDigits: ee,
        launchpadBackgroundColor: te,
        toggleLaunchpadBackgroundColor: re,
        pauseOnHover: ae,
        togglePauseOnHover: oe,
        ultraBuyButton: j,
        toggleUltraBuyButton: F,
        showAvatarReused: le,
        toggleShowAvatarReused: ce,
        hiddenColumns: Pe,
        toggleHiddenColumns: Le,
        resetHiddenColumns: Re,
        showUltraGlow: de,
        toggleShowUltraGlow: pe,
        showUltraBorder: he,
        toggleShowUltraBorder: ge,
        showExtraButton: xe,
        toggleShowExtraButton: fe,
        selectedExtraColor: we,
        setSelectedExtraColor: je,
        selectedExtraTextColor: Te,
        setSelectedExtraTextColor: Ie,
        quickBuyExtraAction: Ee,
        toggleQuickBuyExtraAction: Ne,
        soonMode: ve,
        toggleSoonMode: ye,
        allowCopyName: ke,
        toggleAllowCopyName: Ae
    })), [t, c, s, o, l, i, h, x, f, S, r, a, k, B, W, A, _, I, M, U, P, D, L, V, H, z, $, G, q, K, Y, X, Q, Z, J, ee, te, re, ae, oe, j, F, Pe, Le, Re, le, ce, de, pe, he, ge, xe, fe, we, je, Te, Ie, Ee, Ne, ve, ye, ke, Ae]);
    return v.jsx(one.Provider, {
        value: st,
        children: e
    })
}
  , gne = 200
  , xne = () => y.useContext(one)
  , bne = y.createContext({
    visibleSections: new Set,
    toggleVisibleSection: c.noop
})
  , fne = [Qh.LAUNCHPADS];
var vne = (e => (e.TOP_10_HOLDERS = "TOP_10_HOLDERS",
e.DEV_HOLDING = "DEV_HOLDING",
e.INSIDERS_HOLDING = "INSIDERS_HOLDING",
e.BUNDLES = "BUNDLES",
e.QUICK_X_SEARCH = "QUICK_X_SEARCH",
e.X_DEV_SEARCH = "X_DEV_SEARCH",
e.FUNDED_TXN = "FUNDED_TXN",
e.PROGRESS_LINE = "PROGRESS_LINE",
e.PROGRESS_LINE_ATH = "PROGRESS_LINE_ATH",
e.SOCIALS = "SOCIALS",
e.FRESH_WALLET_BUYS = "FRESH_WALLET_BUYS",
e.TOTAL_HOLDERS = "TOTAL_HOLDERS",
e.VOLUME = "VOLUME",
e.MARKET_CAP = "MARKET_CAP",
e.VIBING = "VIBING",
e.TXN_COUNT = "TXN_COUNT",
e.DEV_BONDED = "DEV_BONDED",
e.DEX_BOOSTED = "DEX_BOOSTED",
e.DEX_PAID = "DEX_PAID",
e.KEYWORDS_SEARCH = "KEYWORDS_SEARCH",
e.CA = "CA",
e.TWITTER_USER_NAME = "TWITTER_USER_NAME",
e.PRO_HOLDERS = "PRO_HOLDERS",
e.GLOBAL_FEES = "GLOBAL_FEES",
e.SNIPERS_HOLDING = "SNIPERS_HOLDING",
e.SNIPERS_COUNT = "SNIPERS_COUNT",
e.EXTRA_MCAP_DISPLAY = "EXTRA_MCAP_DISPLAY",
e))(vne || {});
const Sne = {
    [vne.TOP_10_HOLDERS]: !0,
    [vne.DEV_HOLDING]: !0,
    [vne.INSIDERS_HOLDING]: !0,
    [vne.BUNDLES]: !0,
    [vne.QUICK_X_SEARCH]: !0,
    [vne.X_DEV_SEARCH]: !1,
    [vne.FUNDED_TXN]: !0,
    [vne.PROGRESS_LINE]: !1,
    [vne.PROGRESS_LINE_ATH]: !0,
    [vne.SOCIALS]: !0,
    [vne.FRESH_WALLET_BUYS]: !1,
    [vne.TOTAL_HOLDERS]: !0,
    [vne.VOLUME]: !0,
    [vne.MARKET_CAP]: !0,
    [vne.VIBING]: !1,
    [vne.TXN_COUNT]: !1,
    [vne.DEV_BONDED]: !0,
    [vne.DEX_BOOSTED]: !0,
    [vne.DEX_PAID]: !0,
    [vne.KEYWORDS_SEARCH]: !0,
    [vne.CA]: !0,
    [vne.TWITTER_USER_NAME]: !0,
    [vne.PRO_HOLDERS]: !0,
    [vne.GLOBAL_FEES]: !0,
    [vne.SNIPERS_HOLDING]: !0,
    [vne.SNIPERS_COUNT]: !0,
    [vne.EXTRA_MCAP_DISPLAY]: !1
}
  , yne = {
    [vne.TOP_10_HOLDERS]: !1,
    [vne.DEV_HOLDING]: !1,
    [vne.INSIDERS_HOLDING]: !1,
    [vne.BUNDLES]: !1,
    [vne.QUICK_X_SEARCH]: !1,
    [vne.X_DEV_SEARCH]: !1,
    [vne.FUNDED_TXN]: !0,
    [vne.PROGRESS_LINE]: !1,
    [vne.PROGRESS_LINE_ATH]: !0,
    [vne.SOCIALS]: !1,
    [vne.FRESH_WALLET_BUYS]: !1,
    [vne.TOTAL_HOLDERS]: !1,
    [vne.VOLUME]: !1,
    [vne.MARKET_CAP]: !1,
    [vne.VIBING]: !1,
    [vne.TXN_COUNT]: !1,
    [vne.DEV_BONDED]: !0,
    [vne.DEX_BOOSTED]: !0,
    [vne.DEX_PAID]: !0,
    [vne.KEYWORDS_SEARCH]: !0,
    [vne.CA]: !0,
    [vne.TWITTER_USER_NAME]: !0,
    [vne.PRO_HOLDERS]: !0,
    [vne.GLOBAL_FEES]: !0,
    [vne.SNIPERS_HOLDING]: !0,
    [vne.SNIPERS_COUNT]: !0,
    [vne.EXTRA_MCAP_DISPLAY]: !1
}
  , kne = ({children: e}) => {
    const [t] = dx("padreV2-trenchesVisibleSections", null)
      , [n,r] = dx("padreV2-trenchesVisibleSectionsV2", t ? c.reduce(t, ( (e, t) => (e[t] = !0,
    e)), yne) : Sne)
      , a = y.useMemo(( () => new Set(Object.keys(Sne).filter((e => n[e] ?? Sne[e])))), [n])
      , s = y.useCallback((e => {
        const t = {
            ...Sne,
            ...n
        };
        t[e] = !t[e],
        r(t)
    }
    ), [r, n])
      , o = y.useMemo(( () => ({
        visibleSections: a,
        toggleVisibleSection: s
    })), [a, s]);
    return v.jsx(bne.Provider, {
        value: o,
        children: e
    })
}
  , Cne = () => y.useContext(bne)
  , Ane = 276
  , wne = y.memo(( ({menuKey: e, label: t, onClick: n, values: r, selectedValueIndex: a, valuesInNewLine: s=!1}) => {
    const {t: o} = we()
      , l = D();
    return v.jsx(te, {
        sx: s ? Tne : jne,
        onClick: n,
        children: v.jsxs(S, {
            direction: s ? "column" : "row",
            alignItems: s ? "flex-start" : "center",
            justifyContent: "space-between",
            width: "100%",
            gap: s ? .5 : 0,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                textAlign: "center",
                children: o(t)
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: r.reduce(( (e, t, n) => {
                    const s = n === a;
                    return e.push(v.jsx("span", {
                        style: {
                            color: s ? l.palette.primary.main : "inherit"
                        },
                        children: o(t)
                    }, t)),
                    n < r.length - 1 && e.push(" / "),
                    e
                }
                ), [])
            })]
        })
    }, e)
}
))
  , jne = e => ({
    width: Ane,
    height: 31,
    pl: 1.75,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , Tne = e => ({
    ...jne(e),
    height: 46.5
})
  , Ine = y.memo(( ({avatarShape: e, toggleAvatarShape: t}) => v.jsx(wne, {
    menuKey: "avatar-shape-toggle",
    onClick: t,
    label: "Avatar",
    values: Ene,
    selectedValueIndex: e === Pte.ROUNDED ? 0 : 1
})))
  , Ene = ["Circle", "Square"]
  , Mne = y.memo(( ({spacingMode: e, toggleSpacingMode: t}) => v.jsx(wne, {
    menuKey: "compact-mode-toggle",
    onClick: t,
    label: "Columns",
    values: Nne,
    selectedValueIndex: e === HX.COMPACT ? 0 : 1
})))
  , Nne = ["Compact", "Spaced"]
  , Pne = y.memo(( ({trenchesButtonMode: e, toggleTrenchesButtonMode: t, ultraBuyButton: n, toggleUltraBuyButton: r}) => {
    const a = y.useCallback(( () => {
        if (n)
            return r(),
            void (e === zX.MEGA && t());
        e !== zX.MEGA ? e !== zX.NORMAL && e !== zX.LARGE || t() : r()
    }
    ), [t, r, e, n]);
    return v.jsx(wne, {
        menuKey: "trenches-button-mode-toggle",
        onClick: a,
        label: "Size",
        values: One,
        selectedValueIndex: n ? 3 : e === zX.NORMAL ? 0 : e === zX.LARGE ? 1 : 2
    })
}
))
  , One = ["Small", "Large", "Mega", "Ultra"]
  , Lne = y.memo(( ({trenchesFontMode: e, toggleTrenchesFontMode: t}) => v.jsx(wne, {
    menuKey: "trenches-font-mode-toggle",
    onClick: t,
    label: "Metrics",
    values: Rne,
    selectedValueIndex: e === $X.NORMAL ? 0 : 1
})))
  , Rne = ["Small", "Large"]
  , Dne = y.memo(( ({menuKey: e, value: t, onClick: n, label: r, isSelected: a=!1, hideCheckbox: s=!1}) => {
    const o = D();
    return v.jsx(te, {
        value: t,
        sx: Bne,
        onClick: n,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: s ? "center" : "space-between",
            width: "100%",
            children: ["string" == typeof r ? v.jsx(k, {
                variant: "paragraph3",
                color: s ? "text.label" : a ? "text.value" : "text.label",
                textAlign: "center",
                children: v.jsx("span", {
                    style: {
                        color: a && s ? o.palette.primary.main : "inherit"
                    },
                    children: r
                })
            }) : r, !s && v.jsx(UR, {
                size: "small",
                checked: a
            })]
        })
    }, e)
}
))
  , Bne = e => ({
    width: Ane,
    pl: 1.75,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , _ne = y.memo(( ({searchKeywords: e, toggleSearchKeywords: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "search-keywords-mode-toggle",
        value: String(e),
        onClick: t,
        label: n("Search keywords"),
        isSelected: e
    })
}
))
  , Une = y.memo(( ({trenchesButtonEdges: e, toggleTrenchesButtonEdges: t}) => v.jsx(wne, {
    menuKey: "trenches-button-edges-toggle",
    onClick: t,
    label: "Shape",
    values: Wne,
    selectedValueIndex: e === GX.ROUNDED ? 0 : 1
})))
  , Wne = ["Round", "Square"]
  , Fne = y.memo(( ({trenchesTileLayout: e, toggleTrenchesTileLayout: t}) => v.jsx(wne, {
    menuKey: "trenches-tile-layout-toggle",
    onClick: t,
    label: "Display",
    values: Vne,
    selectedValueIndex: e === qX.MOXIA ? 0 : 1
})))
  , Vne = ["Moxia", "Legacy"]
  , Hne = y.memo(( ({statsDesiredDigits: e, setStatsDesiredDigits: t}) => {
    const n = y.useCallback(( () => {
        t(e === $ne ? Gne : $ne)
    }
    ), [t, e]);
    return v.jsx(wne, {
        menuKey: "stats-deisred-digits-toggle",
        onClick: n,
        label: "Stats digits",
        values: zne,
        selectedValueIndex: e === $ne ? 0 : 1
    })
}
))
  , zne = ["Short", "Rounded"]
  , $ne = 1
  , Gne = 2
  , qne = y.memo(( ({launchpadBackgroundColor: e, toggleLaunchpadBackgroundColor: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "launchpad-background-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Background color"),
        isSelected: e
    })
}
))
  , Kne = y.memo(( ({hiddenColumns: e, toggleHiddenColumns: t, soonMode: n, toggleSoonMode: r}) => {
    const {t: a} = we()
      , s = bw()
      , o = y.useCallback(( () => {
        t(Zh.NEW)
    }
    ), [t])
      , l = y.useCallback(( () => {
        t(Zh.ALMOST_BONDED)
    }
    ), [t])
      , i = y.useCallback(( () => {
        t(Zh.RECENTLY_BONDED)
    }
    ), [t]);
    return v.jsxs(v.Fragment, {
        children: [s && v.jsx(wne, {
            menuKey: "new-column-visible-toggle",
            onClick: o,
            label: a("New"),
            values: Yne,
            selectedValueIndex: e.includes(Zh.NEW) ? 1 : 0
        }), s && v.jsx(wne, {
            menuKey: "almost-bonded-column-visible-toggle",
            onClick: l,
            label: a("Almost bonded"),
            values: Yne,
            selectedValueIndex: e.includes(Zh.ALMOST_BONDED) ? 1 : 0
        }), (!s || !e.includes(Zh.ALMOST_BONDED)) && v.jsx(wne, {
            menuKey: "almost-bonded-column-sort-mode-toggle",
            onClick: r,
            label: a("Almost bonded by"),
            values: Xne,
            selectedValueIndex: n === YX.CURVE ? 0 : 1
        }), s && v.jsx(wne, {
            menuKey: "recently-bonded-column-visible-toggle",
            onClick: i,
            label: a("Migrated"),
            values: Yne,
            selectedValueIndex: e.includes(Zh.RECENTLY_BONDED) ? 1 : 0
        })]
    })
}
))
  , Yne = ["Visible", "Hidden"]
  , Xne = ["Curve", "M Cap"]
  , Qne = y.memo(( ({showAvatarReused: e, toggleShowAvatarReused: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "launchpad-avatar-reused-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Show avatar reused"),
        isSelected: e
    })
}
))
  , Zne = y.memo(( ({config: e, setConfig: t, min: n, max: r, defaultColor: a, label: s, suffix: o}) => {
    const [l,i] = y.useState(null)
      , [d,u] = y.useState(e.color)
      , [p,h] = y.useState(e.value.toString())
      , {t: m} = we();
    y.useEffect(( () => {
        d && !/^#([0-9A-F]{3}){1,2}$/i.test(d) && (t({
            color: a,
            value: e.value
        }),
        u(a))
    }
    ), [d, e.value, a, t]);
    const g = y.useCallback((e => {
        i(e.currentTarget)
    }
    ), [])
      , x = y.useCallback(( () => {
        i(null)
    }
    ), [])
      , b = y.useRef(c.debounce(( (e, n) => {
        t({
            color: e,
            value: n
        })
    }
    ), nre, {
        maxWait: nre
    })).current
      , f = y.useCallback((t => {
        u(t.hex),
        b(t.hex, e.value)
    }
    ), [e.value, b])
      , A = y.useCallback(( () => {
        t({
            color: a,
            value: e.value
        }),
        u(a)
    }
    ), [e.value, a, t])
      , w = y.useMemo(( () => e => ({
        width: Jne,
        height: Jne,
        borderRadius: .5,
        backgroundColor: d || e.palette.success.main,
        border: `1px solid ${Me(d || e.palette.success.main, .08)}`,
        cursor: "pointer"
    })), [d])
      , j = y.useCallback(( ({target: {value: t}}) => {
        const a = QR(t)
          , s = XR(a, 2, r);
        h(s),
        !isNaN(Number(s)) && n < Number(s) && b(e.color, Number(s))
    }
    ), [r, n, b, e.color])
      , T = y.useMemo(( () => v.jsx(We, {
        position: "end",
        sx: {
            width: 10
        },
        children: v.jsx(S, {
            alignItems: "center",
            children: o
        })
    })), [o]);
    return v.jsxs(S, {
        justifyContent: "center",
        sx: rre,
        children: [v.jsx(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: s
            })
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [v.jsx(F, {
                    sx: tre,
                    onClick: A,
                    children: v.jsx(_S, {
                        size: ere
                    })
                }), v.jsx(C, {
                    onClick: g,
                    sx: w
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                minWidth: 58,
                children: m("if at least")
            }), v.jsx(je, {
                error: isNaN(Number(p)) || n > Number(p) || !!(r && r < Number(p)),
                value: p,
                onChange: j,
                size: "xsmall",
                placeholder: "0",
                inputProps: sre,
                "data-pseudotype": "numberLike",
                inputMode: "decimal",
                sx: are,
                endAdornment: T
            })]
        }), v.jsx(ae, {
            open: !!l,
            anchorEl: l,
            onClose: x,
            anchorOrigin: ore,
            children: v.jsx(re, {
                onClickAway: x,
                children: v.jsx(Ne, {
                    color: d,
                    onChange: f,
                    disableAlpha: !0
                })
            })
        })]
    })
}
))
  , Jne = 16
  , ere = 14
  , tre = {
    p: .5
}
  , nre = 100
  , rre = e => ({
    px: 1.75,
    height: 62,
    gap: .5,
    background: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , are = {
    height: 28,
    borderRadius: 1,
    pl: .5,
    border: "none",
    outline: "none",
    "& .MuiOutlinedInput-notchedOutline": {
        display: "none"
    }
}
  , sre = {
    style: {
        textAlign: "right"
    },
    inputMode: "decimal",
    sx: {
        mr: -.5,
        ml: -.75
    }
}
  , ore = {
    vertical: "bottom",
    horizontal: "left"
  }
  , lre = y.memo(( ({marketCapThresholds: e, setMarketCapThresholds: t}) => {
    const {t: n} = we()
      , [r,a,s] = y.useMemo(( () => [e.length > 0 ? e[0] : hA[0], e.length > 1 ? e[1] : hA[1], e.length > 2 ? e[2] : hA[2]]), [e])
      , o = y.useCallback((e => {
        t([e, a, s])
    }
    ), [a, s, t])
      , l = y.useCallback((e => {
        t([r, e, s])
    }
    ), [r, s, t])
      , i = y.useCallback((e => {
        t([r, a, e])
    }
    ), [r, a, t]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(Zne, {
            config: r,
            setConfig: o,
            min: a.value,
            max: null,
            defaultColor: hA[0].color,
            label: n("Market Cap Threshold"),
            suffix: "$"
        }), v.jsx(Zne, {
            config: a,
            setConfig: l,
            min: s.value,
            max: r.value,
            defaultColor: hA[1].color,
            label: n("Market Cap Threshold"),
            suffix: "$"
        }), v.jsx(Zne, {
            config: s,
            setConfig: i,
            min: 0,
            max: a.value,
            defaultColor: hA[2].color,
            label: n("Market Cap Threshold"),
            suffix: "$"
        })]
    })
}
))
  , ire = y.memo(( ({pauseOnHover: e, togglePauseOnHover: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "pause-on-hover-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Pause on hover"),
        isSelected: e
    })
}
))
  , cre = y.memo(( ({showUltraBorder: e, toggleShowUltraBorder: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "quick-buy-border-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Show border"),
        isSelected: e
    })
}
))
  , dre = y.memo(( ({showUltraGlow: e, toggleShowUltraGlow: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "quick-buy-glow-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Show glow"),
        isSelected: e
    })
}
))
  , ure = y.memo(( ({showExtraButton: e, toggleShowExtraButton: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "extra-quick-buy-button-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Show second button"),
        isSelected: e
    })
}
))
  , pre = y.memo(( ({chain: e}) => {
    const {t: t} = we();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: hre,
        children: [v.jsx(k, {
            variant: "paragraph3",
            children: t("Config")
        }), e === Pd.SOLANA && v.jsx(dz, {
            useExtra: !0
        }), e === Pd.BSC && v.jsx(d0, {
            useExtra: !0
        })]
    })
}
))
  , hre = e => ({
    py: .5,
    pl: 1.75,
    pr: 1,
    background: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , mre = y.memo(( ({quickBuyExtraAction: e, toggleQuickBuyExtraAction: t}) => {
    const {t: n} = we();
    return v.jsx(wne, {
        menuKey: "buy-extra-action-toggle",
        onClick: t,
        label: n("Quick buy extra behavior"),
        values: gre,
        selectedValueIndex: e === KX.OPEN_MARKET ? 1 : e === KX.NEW_TAB_OPEN_MARKET ? 2 : 0,
        valuesInNewLine: !0
    })
}
))
  , gre = ["None", "Open Market", "Open New Tab"]
  , xre = y.memo(( ({allowCopyName: e, toggleAllowCopyName: t}) => {
    const {t: n} = we();
    return v.jsx(Dne, {
        menuKey: "allow-copy-name-toggle",
        value: e.toString(),
        onClick: t,
        label: n("Copy name on click"),
        isSelected: e
    })
}
))
  , bre = y.memo(( ({config: e, setConfig: t, defaultColor: n, label: r, isLast: a=!1, previousConfig: s}) => {
    const {t: o} = we()
      , [l,i] = y.useState(null)
      , [d,u] = y.useState(e.color)
      , [p,h] = y.useState(e.value.toString())
      , [m,g] = y.useState(e.timeUnit);
    y.useEffect(( () => {
        d && !/^#([0-9A-F]{3}){1,2}$/i.test(d) && (t({
            color: n,
            value: e.value,
            timeUnit: e.timeUnit
        }),
        u(n))
    }
    ), [d, e.timeUnit, e.value, n, t]);
    const x = y.useCallback((e => {
        i(e.currentTarget)
    }
    ), [])
      , b = y.useCallback(( () => {
        i(null)
    }
    ), [])
      , f = y.useRef(c.debounce(( (e, n, r) => {
        t({
            color: e,
            value: n,
            timeUnit: r
        })
    }
    ), yre, {
        maxWait: yre
    })).current
      , A = y.useCallback((t => {
        u(t.hex),
        f(t.hex, e.value, e.timeUnit)
    }
    ), [e.timeUnit, e.value, f])
      , w = y.useCallback(( () => {
        t({
            color: n,
            value: e.value,
            timeUnit: e.timeUnit
        }),
        u(n)
    }
    ), [e.timeUnit, e.value, n, t])
      , j = y.useMemo(( () => e => ({
        width: fre,
        height: fre,
        borderRadius: .5,
        backgroundColor: d || e.palette.success.main,
        border: `1px solid ${Me(d || e.palette.success.main, .08)}`,
        cursor: "pointer"
    })), [d])
      , T = y.useCallback(( ({target: {value: t}}) => {
        const n = QR(t)
          , r = XR(n, 0, Ere);
        h(r),
        isNaN(Number(r)) || f(e.color, Number(r), e.timeUnit)
    }
    ), [f, e.color, e.timeUnit])
      , I = y.useCallback((e => {
        g(e)
    }
    ), []);
    return v.jsxs(S, {
        justifyContent: "center",
        sx: kre,
        children: [v.jsx(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: r
            })
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            mr: -1,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [v.jsx(F, {
                    sx: Sre,
                    onClick: w,
                    children: v.jsx(_S, {
                        size: vre
                    })
                }), v.jsx(C, {
                    onClick: x,
                    sx: j
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                minWidth: 58,
                children: a && s ? `${o("if below")} ${s.value} ${jre[s.timeUnit]}` : o("if at least")
            }), (!a || !s) && v.jsxs(S, {
                direction: "row",
                gap: .25,
                alignItems: "center",
                children: [v.jsx(je, {
                    error: isNaN(Number(p)),
                    value: p,
                    onChange: T,
                    size: "xsmall",
                    placeholder: "0",
                    inputProps: Are,
                    "data-pseudotype": "numberLike",
                    inputMode: "decimal",
                    sx: Cre
                }), v.jsx(it, {
                    size: "xsmall",
                    sx: Mre,
                    value: m ?? pA.SECOND,
                    renderValue: () => v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: jre[m]
                    }),
                    children: Ire.map((t => v.jsx(te, {
                        value: t,
                        onClick: () => {
                            I(t),
                            f(d, e.value, t)
                        }
                        ,
                        children: Tre[t]
                    }, t)))
                })]
            })]
        }), v.jsx(ae, {
            open: !!l,
            anchorEl: l,
            onClose: b,
            anchorOrigin: wre,
            children: v.jsx(re, {
                onClickAway: b,
                children: v.jsx(Ne, {
                    color: d,
                    onChange: A,
                    disableAlpha: !0
                })
            })
        })]
    })
}
))
  , fre = 16
  , vre = 14
  , Sre = {
    p: .5
}
  , yre = 100
  , kre = e => ({
    px: 1.75,
    height: 62,
    gap: .5,
    background: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , Cre = {
    height: 28,
    borderRadius: 1,
    pl: 0,
    border: "none",
    outline: "none",
    "& .MuiOutlinedInput-notchedOutline": {
        display: "none"
    }
}
  , Are = {
    style: {
        textAlign: "right"
    },
    inputMode: "decimal",
    sx: {
        mr: -.5,
        ml: -.75
    }
}
  , wre = {
    vertical: "bottom",
    horizontal: "left"
}
  , jre = {
    [pA.SECOND]: "s",
    [pA.MINUTE]: "m",
    [pA.HOUR]: "h"
}
  , Tre = {
    [pA.SECOND]: n.t("Seconds"),
    [pA.MINUTE]: n.t("Minutes"),
    [pA.HOUR]: n.t("Hours")
}
  , Ire = [pA.SECOND, pA.MINUTE, pA.HOUR]
  , Ere = 1e8
  , Mre = {
    height: 28,
    minWidth: 34,
    px: 0,
    "& .MuiSelect-icon": {
        mr: "-4px"
    },
    "& .MuiSelect-select": {
        pl: .75,
        pr: "2px"
    }
}
  , Nre = y.memo(( ({tweetCreationThresholds: e, setTweetCreationThresholds: t}) => {
    const {t: n} = we()
      , [r,a,s] = y.useMemo(( () => [e.length > 0 ? e[0] : mA[0], e.length > 1 ? e[1] : mA[1], e.length > 2 ? e[2] : mA[2]]), [e])
      , o = y.useCallback((e => {
        t([e, a, s])
    }
    ), [a, s, t])
      , l = y.useCallback((e => {
        t([r, e, s])
    }
    ), [r, s, t])
      , i = y.useCallback((e => {
        t([r, a, e])
    }
    ), [r, a, t]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(bre, {
            config: r,
            setConfig: o,
            defaultColor: mA[0].color,
            label: n("Tweet Age Threshold")
        }), v.jsx(bre, {
            config: a,
            setConfig: l,
            defaultColor: mA[1].color,
            label: n("Tweet Age Threshold")
        }), v.jsx(bre, {
            config: s,
            setConfig: i,
            defaultColor: mA[2].color,
            label: n("Tweet Age Threshold"),
            isLast: !0,
            previousConfig: a
        })]
    })
}
))
  , Pre = e => {
    switch (e) {
    case "meteora-curve":
        return "Dynamic BC";
    case "launchlab":
        return "LaunchLab";
    case "believe":
        return "Believe";
    case "bags":
        return "Bags";
    case "jup":
        return "Jupiter";
    case "sugar":
        return "Sugar";
    case "moonit":
        return "Moonit";
    case "heaven":
        return "Heaven";
    case "token-mill":
        return "Token Mill";
    default:
        return c.capitalize(e)
    }
}
  , Ore = y.memo(( ({currentColor: e, saveColor: t, launchpad: n}) => {
    const r = D()
      , [a,s] = y.useState(null)
      , [o,l] = y.useState(null)
      , i = y.useRef(null)
      , {label: c, Icon: d, fallbackColor: u} = y.useMemo(( () => {
        const e = Hz(n)
          , [t] = RM(!1, n, null, r)
          , a = Hre(t) ?? r.palette.primary.main;
        return {
            Icon: e,
            label: Pre(n),
            fallbackColor: a
        }
    }
    ), [n, r])
      , p = Hre(e) ?? u
      , h = (a && o ? Hre(o) ?? u : p) ?? u
      , m = y.useMemo(( () => e => ({
        borderRadius: "12px",
        height: Lre,
        display: "flex",
        alignItems: "center",
        overflow: "visible",
        py: 0,
        px: .5,
        gap: .25,
        color: h,
        background: $t(h, .12),
        border: `1px solid ${h}`,
        opacity: 1,
        "&:hover, &:focus": {
            color: h,
            background: $t(h, .12),
            border: `1px solid ${h}`,
            opacity: 1
        },
        [`& .${_re}`]: {
            width: R ? `${Fre}px` : 0,
            marginLeft: 0,
            overflow: "hidden",
            display: "flex",
            alignItems: "center",
            justifyContent: "flex-end",
            flexShrink: 0,
            pointerEvents: R ? "auto" : "none",
            transition: R ? "none" : e.transitions.create("width", {
                duration: e.transitions.duration.shorter
            })
        },
        [`& .${Bre}`]: {
            opacity: R ? 1 : 0,
            transform: R ? "translateX(0)" : "translateX(8px)",
            transition: e.transitions.create(["opacity", "transform"], {
                duration: e.transitions.duration.shorter
            })
        },
        ...R ? {} : {
            [`&:hover .${_re}`]: {
                width: `${Fre}px`,
                pointerEvents: "auto"
            },
            [`&:hover .${Bre}`]: {
                opacity: 1,
                transform: "translateX(0)"
            }
        }
    })), [h])
      , g = y.useMemo(( () => ({
        width: Wre,
        height: Wre,
        p: .25,
        color: h,
        backgroundColor: "transparent",
        "&:hover": {
            backgroundColor: "transparent"
        }
    })), [h])
      , x = y.useCallback((e => {
        i.current = p,
        l(p),
        s(e.currentTarget)
    }
    ), [p])
      , b = y.useCallback(( () => {
        s(null);
        const e = Hre(o)
          , n = Hre(i.current);
        e && e !== n && t(e),
        i.current = null,
        l(null)
    }
    ), [o, t])
      , f = y.useCallback((e => {
        l(e.hex)
    }
    ), [])
      , S = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        s(null),
        l(null),
        i.current = null,
        t(null)
    }
    ), [t])
      , A = Boolean(a);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(C, {
            display: "flex",
            children: v.jsxs(V, {
                variant: "tertiary",
                size: "xxsmall",
                sx: m,
                onClick: x,
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "center",
                    gap: .25,
                    flexGrow: 1,
                    children: [d && v.jsx(C, {
                        display: "flex",
                        className: Dre,
                        children: v.jsx(d, {
                            size: Rre
                        })
                    }), v.jsx(k, {
                        color: "inherit",
                        variant: "paragraph1",
                        noWrap: !0,
                        height: 14,
                        mt: "1px",
                        children: c
                    })]
                }), v.jsx(C, {
                    className: _re,
                    children: v.jsx(F, {
                        component: "span",
                        size: "small",
                        className: Bre,
                        sx: g,
                        onClick: S,
                        onMouseDown: Ww,
                        disableRipple: !0,
                        tabIndex: -1,
                        "aria-label": "Reset color",
                        children: v.jsx(_S, {
                            size: Ure,
                            color: "inherit"
                        })
                    })
                })]
            })
        }), v.jsx(ae, {
            open: A,
            anchorEl: a,
            onClose: b,
            anchorOrigin: Vre,
            children: v.jsx(re, {
                onClickAway: b,
                children: v.jsx(Ne, {
                    color: o ?? p,
                    onChange: f,
                    disableAlpha: !0
                })
            })
        })]
    })
}
))
  , Lre = 24
  , Rre = 14
  , Dre = "launchpad-control-button-icon"
  , Bre = "background-color-config-reset"
  , _re = "background-color-config-reset-wrapper"
  , Ure = 12
  , Wre = 22
  , Fre = Wre
  , Vre = {
    vertical: "bottom",
    horizontal: "left"
}
  , Hre = e => {
    if (!e)
        return null;
    const t = e.trim();
    return t ? t.toLowerCase() : null
}
  , zre = y.memo(( () => {
    const {t: e} = we()
      , {protocolsRowColors: t, setProtocolsRowColors: n} = bA();
    return v.jsxs(S, {
        sx: Gre,
        children: [v.jsx(C, {
            display: "flex",
            alignItems: "center",
            height: $re,
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                pl: 1.75,
                lineHeight: 1.2,
                children: e("Protocol row colors")
            })
        }), v.jsx(S, {
            sx: qre,
            children: Oee.map((e => {
                const r = t[e] ?? null;
                return v.jsx(Ore, {
                    currentColor: r,
                    saveColor: r => {
                        const a = {
                            ...t
                        };
                        null === r ? delete a[e] : a[e] = r,
                        n(a)
                    }
                    ,
                    launchpad: e
                }, e)
            }
            ))
        })]
    })
}
))
  , $re = 28
  , Gre = e => ({
    background: e.palette.background.secondary
})
  , qre = e => ({
    display: "grid",
    gridTemplateColumns: "repeat(2, 1fr)",
    gridAutoRows: "34px",
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "& > *": {
        display: "flex",
        alignItems: "center",
        overflow: "visible",
        pl: 1.5
    }
})
  , Kre = y.memo(( ({progressLine: e, toggleProgressLine: t}) => v.jsx(wne, {
    menuKey: "progress-line-toggle",
    onClick: t,
    label: "Progress",
    values: Yre,
    selectedValueIndex: e ? 0 : 1
})))
  , Yre = ["Bar", "Ring"]
  , Xre = {
    [vne.TOP_10_HOLDERS]: "Top 10 holders",
    [vne.DEV_HOLDING]: "Dev holding",
    [vne.INSIDERS_HOLDING]: "Insiders holding",
    [vne.BUNDLES]: "Bundles",
    [vne.QUICK_X_SEARCH]: "X token search",
    [vne.X_DEV_SEARCH]: "X dev search",
    [vne.FUNDED_TXN]: "Dev funded",
    [vne.PROGRESS_LINE]: "Progress line",
    [vne.PROGRESS_LINE_ATH]: "Show ATH progress",
    [vne.SOCIALS]: "Socials",
    [vne.FRESH_WALLET_BUYS]: "Fresh wallet buys",
    [vne.TOTAL_HOLDERS]: "Total holders",
    [vne.VOLUME]: "Volume",
    [vne.MARKET_CAP]: "Market cap",
    [vne.VIBING]: "Vibing",
    [vne.TXN_COUNT]: "Total txns",
    [vne.DEV_BONDED]: "Dev bonded",
    [vne.DEX_BOOSTED]: "Dex boosted",
    [vne.DEX_PAID]: "Dex paid",
    [vne.KEYWORDS_SEARCH]: "Keywords search",
    [vne.CA]: "Contract address",
    [vne.TWITTER_USER_NAME]: "Linked X user",
    [vne.PRO_HOLDERS]: "Pro holders",
    [vne.GLOBAL_FEES]: "Total fees",
    [vne.SNIPERS_HOLDING]: "Snipers holdings",
    [vne.SNIPERS_COUNT]: "Snipers count",
    [vne.EXTRA_MCAP_DISPLAY]: "Market cap in stats"
}
  , Qre = [vne.TOP_10_HOLDERS, vne.DEV_HOLDING, vne.SNIPERS_HOLDING, vne.SNIPERS_COUNT, vne.INSIDERS_HOLDING, vne.QUICK_X_SEARCH, vne.PROGRESS_LINE, vne.PROGRESS_LINE_ATH, vne.TXN_COUNT, vne.DEV_BONDED, vne.SOCIALS, vne.PRO_HOLDERS, vne.FRESH_WALLET_BUYS, vne.TOTAL_HOLDERS, vne.VOLUME, vne.MARKET_CAP, vne.EXTRA_MCAP_DISPLAY, vne.GLOBAL_FEES, vne.DEX_BOOSTED, vne.DEX_PAID, vne.CA, vne.TWITTER_USER_NAME]
  , Zre = [vne.TOP_10_HOLDERS, vne.DEV_HOLDING, vne.FUNDED_TXN, vne.SNIPERS_HOLDING, vne.SNIPERS_COUNT, vne.INSIDERS_HOLDING, vne.BUNDLES, vne.DEX_BOOSTED, vne.DEX_PAID, vne.QUICK_X_SEARCH, vne.PROGRESS_LINE, vne.PROGRESS_LINE_ATH, vne.TXN_COUNT, vne.DEV_BONDED, vne.SOCIALS, vne.PRO_HOLDERS, vne.FRESH_WALLET_BUYS, vne.TOTAL_HOLDERS, vne.VOLUME, vne.MARKET_CAP, vne.EXTRA_MCAP_DISPLAY, vne.GLOBAL_FEES, vne.VIBING, vne.CA, vne.TWITTER_USER_NAME, vne.KEYWORDS_SEARCH]
  , Jre = Zre
  , eae = new Set([vne.X_DEV_SEARCH])
  , tae = [vne.BUNDLES]
  , nae = new Set([])
  , rae = new Set([vne.VIBING, vne.BUNDLES, vne.FUNDED_TXN, vne.FRESH_WALLET_BUYS, vne.SNIPERS_HOLDING, vne.GLOBAL_FEES]);
var aae = (e => (e.LAYOUT = "LAYOUT",
e.DATA = "DATA",
e.QUICK_BUY = "QUICK_BUY",
e))(aae || {});
const sae = R ? 40 : 50
  , oae = y.memo(( () => {
    const e = D()
      , {t: t} = we()
      , n = bw()
      , r = fw()
      , {trenchesChain: a, spacingMode: s, toggleSpacingMode: o, trenchesFontMode: l, toggleTrenchesFontMode: i, trenchesButtonMode: d, toggleTrenchesButtonMode: u, trenchesButtonEdges: p, toggleTrenchesButtonEdges: h, avatarShape: m, toggleAvatarShape: g, selectedColor: x, setSelectedColor: b, selectedTextColor: f, setSelectedTextColor: C, quickBuyButtonExtraPadding: A, setQuickBuyButtonExtraPadding: w, quickBuyButtonTransparency: j, setQuickBuyButtonTransparency: T, trenchesTileLayout: I, toggleTrenchesTileLayout: E, statsDesiredDigits: M, setStatsDesiredDigits: N, launchpadBackgroundColor: P, toggleLaunchpadBackgroundColor: O, pauseOnHover: L, togglePauseOnHover: B, ultraBuyButton: _, toggleUltraBuyButton: U, hiddenColumns: W, toggleHiddenColumns: F, showAvatarReused: H, toggleShowAvatarReused: z, showUltraGlow: $, toggleShowUltraGlow: G, showUltraBorder: q, toggleShowUltraBorder: K, showExtraButton: Y, toggleShowExtraButton: X, selectedExtraColor: Q, setSelectedExtraColor: Z, selectedExtraTextColor: J, setSelectedExtraTextColor: ne, quickBuyExtraAction: re, toggleQuickBuyExtraAction: se, soonMode: oe, toggleSoonMode: le, allowCopyName: ie, toggleAllowCopyName: ce} = xne()
      , {marketCapThresholds: de, setMarketCapThresholds: ue, tweetCreationThresholds: pe, setTweetCreationThresholds: he} = bA()
      , {visibleSections: me, toggleVisibleSection: ge} = Cne()
      , xe = y.useCallback((e => {
        const t = e / sae
          , n = Math.sqrt(t);
        T(n * sae)
    }
    ), [T])
      , be = y.useCallback(( () => {
        ge(vne.KEYWORDS_SEARCH)
    }
    ), [ge])
      , fe = y.useCallback(( () => {
        ge(vne.PROGRESS_LINE)
    }
    ), [ge])
      , ve = y.useMemo(( () => {
        const e = r ? Jre : n ? Zre : Qre
          , t = I === qX.MOXIA ? c.uniq([...e, ...tae]).filter((e => !eae.has(e))) : e
          , s = a === Pd.BSC ? rae : nae
          , o = t.filter((e => !s.has(e)))
          , l = me.has(vne.PROGRESS_LINE)
          , i = me.has(vne.DEV_HOLDING);
        return o.filter((e => !(I === qX.MOXIA && e === vne.FUNDED_TXN && !i) && !(e === vne.PROGRESS_LINE_ATH && !l)))
    }
    ), [r, n, I, me, a])
      , {buttonProps: Se, popoverProps: ye} = Fw({
        id: "trenches-customize-popover"
    })
      , [ke,Ce] = Mx("padreV2-trenchesCustomizationTabV2", aae.LAYOUT)
      , Ae = y.useCallback(( (e, t) => {
        Ce(t)
    }
    ), [Ce])
      , je = y.useMemo(( () => {
        const t = x ?? e.palette.success.main;
        return An(t, "#fff") > 4.5 ? "#ffffff" : "#111111"
    }
    ), [x, e.palette.success.main]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...Se,
            size: "xxsmall",
            variant: "tertiary",
            sx: cae,
            children: v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "center",
                children: [v.jsx(Ny, {}), v.jsx(k, {
                    variant: "paragraph3",
                    children: t("Customize")
                })]
            })
        }), v.jsx(ae, {
            ...ye,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: pae,
            transformOrigin: hae,
            slotProps: mae,
            children: v.jsx(ee, {
                elevation: 1,
                sx: iae,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    width: Ane,
                    children: [v.jsx(S, {
                        position: "sticky",
                        top: 0,
                        zIndex: 1,
                        children: v.jsxs(ot, {
                            sx: lae,
                            value: ke,
                            onChange: Ae,
                            children: [v.jsx(lt, {
                                value: aae.LAYOUT,
                                label: t("Layout")
                            }, aae.LAYOUT), v.jsx(lt, {
                                value: aae.DATA,
                                label: t("Data")
                            }, aae.DATA), v.jsx(lt, {
                                value: aae.QUICK_BUY,
                                label: t("Quick Buy"),
                                sx: uae
                            }, aae.QUICK_BUY)]
                        })
                    }), ke === aae.LAYOUT && v.jsxs(v.Fragment, {
                        children: [a === Pd.SOLANA && v.jsx(Fne, {
                            trenchesTileLayout: I,
                            toggleTrenchesTileLayout: E
                        }), v.jsx(Lne, {
                            toggleTrenchesFontMode: i,
                            trenchesFontMode: l
                        }), v.jsx(Ine, {
                            avatarShape: m,
                            toggleAvatarShape: g
                        }), v.jsx(Kre, {
                            progressLine: me.has(vne.PROGRESS_LINE),
                            toggleProgressLine: fe
                        }), n && v.jsx(Mne, {
                            spacingMode: s,
                            toggleSpacingMode: o
                        }), v.jsx(Kne, {
                            hiddenColumns: W,
                            toggleHiddenColumns: F,
                            soonMode: oe,
                            toggleSoonMode: le
                        }), v.jsx(Hne, {
                            statsDesiredDigits: M,
                            setStatsDesiredDigits: N
                        }), v.jsx(xre, {
                            allowCopyName: ie,
                            toggleAllowCopyName: ce
                        }), !R && v.jsx(ire, {
                            pauseOnHover: L,
                            togglePauseOnHover: B
                        }), n && v.jsx(_ne, {
                            searchKeywords: me.has(vne.KEYWORDS_SEARCH),
                            toggleSearchKeywords: be
                        }), v.jsx(Qne, {
                            showAvatarReused: H,
                            toggleShowAvatarReused: z
                        }), v.jsx(qne, {
                            launchpadBackgroundColor: P,
                            toggleLaunchpadBackgroundColor: O
                        }), P && a === Pd.SOLANA && v.jsx(zre, {}), v.jsx(lre, {
                            marketCapThresholds: de,
                            setMarketCapThresholds: ue
                        }), v.jsx(Nre, {
                            tweetCreationThresholds: pe,
                            setTweetCreationThresholds: he
                        })]
                    }), ke === aae.DATA && v.jsx(v.Fragment, {
                        children: ve.map((e => {
                            const n = me.has(e);
                            return v.jsx(te, {
                                value: e,
                                sx: dae,
                                onClick: () => {
                                    ge(e)
                                }
                                ,
                                children: v.jsxs(S, {
                                    direction: "row",
                                    alignItems: "center",
                                    justifyContent: "space-between",
                                    width: "100%",
                                    children: [v.jsx(k, {
                                        variant: "paragraph3",
                                        color: n ? "text.value" : "text.label",
                                        children: t(Xre[e])
                                    }), v.jsx(UR, {
                                        size: "small",
                                        checked: n
                                    })]
                                })
                            }, e)
                        }
                        ))
                    }), ke === aae.QUICK_BUY && v.jsxs(v.Fragment, {
                        children: [v.jsx(UM, {
                            label: t("Button color"),
                            selectedColor: x,
                            setSelectedColor: b,
                            defaultColor: e.palette.success.main,
                            placeholderColor: e.palette.success.main
                        }), v.jsx(UM, {
                            label: t("Button text color"),
                            selectedColor: f,
                            setSelectedColor: C,
                            defaultColor: null,
                            placeholderColor: je
                        }), v.jsx(mre, {
                            quickBuyExtraAction: re,
                            toggleQuickBuyExtraAction: se
                        }), v.jsx(Pne, {
                            toggleTrenchesButtonMode: u,
                            trenchesButtonMode: d,
                            ultraBuyButton: _,
                            toggleUltraBuyButton: U
                        }), _ && v.jsx(dre, {
                            showUltraGlow: $,
                            toggleShowUltraGlow: G
                        }), _ && v.jsx(cre, {
                            showUltraBorder: q,
                            toggleShowUltraBorder: K
                        }), !_ && v.jsx(Une, {
                            trenchesButtonEdges: p,
                            toggleTrenchesButtonEdges: h
                        }), v.jsx(GM, {
                            label: t("Width"),
                            defaultValue: A,
                            min: -24,
                            max: 32,
                            step: 1,
                            saveValue: w
                        }), !_ && v.jsx(GM, {
                            label: "Transparency",
                            defaultValue: j,
                            min: 0,
                            max: sae,
                            step: 1,
                            saveValue: xe
                        }), v.jsx(ure, {
                            showExtraButton: Y,
                            toggleShowExtraButton: X
                        }), Y && v.jsx(pre, {
                            chain: a
                        }), Y && v.jsx(UM, {
                            label: "Extra button color",
                            selectedColor: Q,
                            setSelectedColor: Z,
                            defaultColor: e.palette.success.main,
                            placeholderColor: e.palette.success.main
                        }), Y && v.jsx(UM, {
                            label: "Extra button text color",
                            selectedColor: J,
                            setSelectedColor: ne,
                            defaultColor: null,
                            placeholderColor: je
                        })]
                    })]
                })
            })
        })]
    })
}
))
  , lae = e => ({
    background: e.palette.background.secondary
})
  , iae = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    maxHeight: 395
})
  , cae = {
    px: {
        xs: .75,
        md: 1
    },
    height: 29,
    minWidth: 100,
    backgroundColor: "transparent"
}
  , dae = e => ({
    width: {
        md: Ane
    },
    pl: 1.75,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , uae = {
    minWidth: 75
}
  , pae = {
    vertical: "bottom",
    horizontal: "center"
}
  , hae = {
    vertical: "top",
    horizontal: "center"
}
  , mae = {
    paper: {
        className: "padre-no-scroll"
    }
}
  , gae = y.memo(( () => {
    const {t: e} = we()
      , {hideMode: t, setHideMode: n} = xne()
      , r = y.useMemo(( () => e => ({
        zIndex: 2,
        transition: "none",
        py: 0,
        px: .5,
        minWidth: xae,
        border: e.palette.primary.main,
        backgroundColor: "transparent",
        color: t === sne.SHOW_ALL ? e.palette.text.value : t === sne.SHOW_MIGRATED ? e.palette.lavender[500] : e.palette.text.label,
        "&:focus": {
            border: "none",
            backgroundColor: e.palette.background.buttonDefault
        },
        "&:hover": {
            border: "none",
            backgroundColor: e.palette.background.buttonHover
        }
    })), [t])
      , {buttonProps: a, popoverProps: s} = Fw({
        id: "trenches-hidden-lists-mode"
    })
      , o = y.useCallback((e => {
        n(e),
        s.onClose()
    }
    ), [s, n]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...a,
            className: "no-drag",
            variant: "tertiary",
            size: "xxsmall",
            sx: r,
            children: v.jsx(C, {
                display: "flex",
                children: t === sne.HIDE ? v.jsx(Ek, {
                    color: "inherit"
                }) : v.jsx(Tk, {
                    color: "inherit"
                })
            })
        }), v.jsx(ae, {
            ...s,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: bae,
            transformOrigin: fae,
            slotProps: Sae,
            children: v.jsx(ee, {
                elevation: 1,
                sx: vae,
                className: "padre-no-scroll",
                children: yae.map((n => {
                    const r = t === n;
                    return v.jsx(te, {
                        sx: Cae,
                        onClick: () => {
                            o(n)
                        }
                        ,
                        children: v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            width: "100%",
                            gap: 1,
                            children: [v.jsx(k, {
                                variant: "paragraph3",
                                color: r ? "text.value" : "text.label",
                                textAlign: "center",
                                children: e(kae[n])
                            }), r && v.jsx(xy, {})]
                        })
                    }, n)
                }
                ))
            })
        })]
    })
}
))
  , xae = 28
  , bae = {
    vertical: "bottom",
    horizontal: "center"
}
  , fae = {
    vertical: "top",
    horizontal: "center"
}
  , vae = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , Sae = {
    paper: {
        className: "padre-no-scroll"
    }
}
  , yae = [sne.HIDE, sne.SHOW_MIGRATED, sne.SHOW_ALL]
  , kae = {
    [sne.HIDE]: "Hide hidden",
    [sne.SHOW_MIGRATED]: "Unhide on migration",
    [sne.SHOW_ALL]: "Show hidden"
}
  , Cae = e => ({
    height: 31,
    pl: 1.75,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
});
var Aae = (e => (e.MANUAL = "MANUAL",
e.SAVED = "SAVED",
e))(Aae || {});
const wae = y.memo(( ({icons: e, offset: t=jae, size: n=Tae, reverse: r}) => {
    const a = y.useMemo(( () => ({
        display: "flex",
        position: "relative",
        height: n,
        mt: -.5
    })), [n]);
    return v.jsx(C, {
        sx: a,
        children: e.map(( (a, s) => v.jsx(C, {
            sx: {
                position: "relative",
                marginLeft: 0 === s ? 0 : `-${t}px`,
                zIndex: r ? e.length - s : s
            },
            children: v.jsx(a, {
                size: n
            })
        }, s)))
    })
}
))
  , jae = 3
  , Tae = 16
  , Iae = y.memo(( ({walletType: e, ...t}) => v.jsx(wae, {
    ...t,
    icons: e === pc.ETH ? [sk, nk, ak] : [dk]
})))
  , Eae = e => c.filter([null !== e[Qh.BUYS].from, null !== e[Qh.BUYS].to, null !== e[Qh.SELLS].from, null !== e[Qh.SELLS].to, null !== e[Qh.TOTAL_SOL_FEES].from, null !== e[Qh.TOTAL_SOL_FEES].to, null !== e[Qh.CURVE_PROGRESS].from, null !== e[Qh.CURVE_PROGRESS].to, null !== e[Qh.MARKET_CAP].from, null !== e[Qh.MARKET_CAP].to, e[Qh.LIQUIDITY] && null !== e[Qh.LIQUIDITY].from, e[Qh.LIQUIDITY] && null !== e[Qh.LIQUIDITY].to, e[Qh.FRESH_WALLETS_BUYS] && null !== e[Qh.FRESH_WALLETS_BUYS].from, e[Qh.FRESH_WALLETS_BUYS] && null !== e[Qh.FRESH_WALLETS_BUYS].to, e[Qh.ALPHA_GROUP_MENTIONS] && null !== e[Qh.ALPHA_GROUP_MENTIONS].from, e[Qh.ALPHA_GROUP_MENTIONS] && null !== e[Qh.ALPHA_GROUP_MENTIONS].to, e[Qh.PRO_HOLDERS_COUNT] && null !== e[Qh.PRO_HOLDERS_COUNT].from, e[Qh.PRO_HOLDERS_COUNT] && null !== e[Qh.PRO_HOLDERS_COUNT].to, null !== e[Qh.TOP_10_HOLDERS_PCNT].from, null !== e[Qh.TOP_10_HOLDERS_PCNT].to, null !== e[Qh.TOP_INSIDERS_HOLDING_PCNT].from, null !== e[Qh.TOP_INSIDERS_HOLDING_PCNT].to, null !== e[Qh.SNIPERS_HOLDINGS_PCNT].from, null !== e[Qh.SNIPERS_HOLDINGS_PCNT].to, null !== e[Qh.VOLUME].from, null !== e[Qh.VOLUME].to, null !== e[Qh.TICKERS] && !!e[Qh.TICKERS].length, null !== e[Qh.EXCLUDE_KEYWORDS] && !!e[Qh.EXCLUDE_KEYWORDS].length, e[Qh.HAS_SOCIALS], e[Qh.NO_SOCIALS_REUSE], e[Qh.NO_PERMISSIONED], e[Qh.DEV_HOLDING], e[Qh.IS_ACTIVE_MAYHEM], e[Qh.NO_CONFIRMED_BOTS], e[Qh.PUMP_LIVE], e[Qh.HAS_ORIGINAL_AVATAR], e[Qh.DEXSCREENER_BOOSTED], null !== e[Qh.TOKEN_AGE_IN_MINUTES].from, null !== e[Qh.TOKEN_AGE_IN_MINUTES].to, null !== e[Qh.HOLDERS_COUNT].from, null !== e[Qh.HOLDERS_COUNT].to, null !== e[Qh.BUNDLES_HOLDING_PCNT].from, null !== e[Qh.BUNDLES_HOLDING_PCNT].to, null !== e[Qh.PERCENTAGE_DEV_HOLDING].from, null !== e[Qh.PERCENTAGE_DEV_HOLDING].to, null !== e[Qh.DEV_BONDED].from, null !== e[Qh.DEV_BONDED].to, e[Qh.LAUNCHPADS] && null !== e[Qh.LAUNCHPADS] && e[Qh.LAUNCHPADS].length !== Oee.length], Boolean).length
  , Mae = e => {
    const t = XX[e];
    return !!t && "object" == typeof t && !Array.isArray(t) && "from"in t && "to"in t
}
  , Nae = e => Array.isArray(XX[e])
  , Pae = e => "boolean" == typeof XX[e]
  , Oae = "Max value must be less than min value"
  , Lae = Qe(Object.values(Qh).reduce(( (e, t) => (Mae(t) ? e[t] = Qe({
    from: qe().numberLikeDecimal().positive().nullable().when("to", {
        is: e => null != e && "" !== e,
        then: e => e.test({
            test: function(e, {createError: t, parent: n}) {
                if ("" === e || null == e)
                    return !0;
                return !!(Number(e) <= Number(n.to)) || t({
                    message: Oae
                })
            }
        })
    }),
    to: qe().numberLikeDecimal().positive().nullable()
}) : Nae(t) && (e[t] = wn().nullable()),
e)), {}))
  , Rae = e => e === Qh.VOLUME || e === Qh.MARKET_CAP || e === Qh.LIQUIDITY
  , Dae = e => [Qh.TOP_10_HOLDERS_PCNT, Qh.TOP_INSIDERS_HOLDING_PCNT, Qh.SNIPERS_HOLDINGS_PCNT, Qh.CURVE_PROGRESS, Qh.BUNDLES_HOLDING_PCNT, Qh.PERCENTAGE_DEV_HOLDING].includes(e)
  , Bae = e => e === Qh.FRESH_WALLETS_BUYS || e === Qh.TOTAL_SOL_FEES
  , _ae = ({smallPadding: e, ...t}) => v.jsx(jn, {
    ...t,
    sx: t => ({
        "&.MuiChip-root": {
            height: bu.XXSMALL,
            px: 1,
            py: .75,
            borderRadius: 1,
            backgroundColor: "transparent",
            borderColor: t.palette.background.borderStandard,
            overflow: "visible"
        },
        "& .MuiChip-label": {
            pl: 0,
            pr: .75,
            mb: e ? -.5 : 0,
            overflow: "visible"
        }
    }),
    variant: "outlined"
})
  , Uae = ({filters: e}) => {
    const t = Object.values(Qh).flatMap((t => {
        const n = [];
        if (Mae(t)) {
            const r = Rae(t)
              , a = Bae(t)
              , s = Dae(t)
              , o = t === Qh.TOKEN_AGE_IN_MINUTES;
            e[t].from && n.push(v.jsx(_ae, {
                label: v.jsxs(k, {
                    variant: "paragraph3",
                    sx: {
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: .25
                    },
                    children: [`${Wae[t]}  ${LI(e[t].from || 0, {
                        collapseExponent: (e[t].from || 0) >= 1e3,
                        symbol: a ? "" : s ? "%" : r ? "$" : o ? "m" : "",
                        padSymbol: !1,
                        symbolPosition: a || s || o ? yI.END : yI.START,
                        removeTrailingZerosPrecision: 0,
                        maxPrecision: 0,
                        minPrecision: 1
                    })}`, a && v.jsx(dk, {
                        size: 12
                    })]
                })
            }, `${t}-from`)),
            e[t].to && n.push(v.jsx(_ae, {
                label: v.jsxs(k, {
                    variant: "paragraph3",
                    sx: {
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: .25
                    },
                    children: [`${Wae[t]}  ${LI(e[t].to || 0, {
                        collapseExponent: (e[t].to || 0) >= 1e3,
                        symbol: a ? "" : s ? "%" : r ? "$" : o ? "m" : "",
                        padSymbol: !1,
                        symbolPosition: a || s || o ? yI.END : yI.START,
                        removeTrailingZerosPrecision: 0,
                        maxPrecision: 0,
                        minPrecision: 1
                    })}`, a && v.jsx(dk, {
                        size: 12
                    })]
                })
            }, `${t}-to`))
        } else if (Nae(t)) {
            const r = e[t];
            if (!(null == r ? void 0 : r.length))
                return n;
            n.push(v.jsx(_ae, {
                label: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    sx: {
                        textWrap: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        maxWidth: 125
                    },
                    children: r.length ? r[0] : ""
                })
            }, t))
        } else if (Pae(t)) {
            if (!e[t])
                return n;
            n.push(v.jsx(_ae, {
                label: v.jsx(k, {
                    variant: "paragraph3",
                    children: Fae[t]
                })
            }, t))
        } else if (t === Qh.LAUNCHPADS) {
            const r = e[t];
            if (!r || r.length === Oee.length)
                return n;
            if (!r.length)
                return v.jsx(_ae, {
                    label: "No launchpads"
                }, t);
            const a = r.map((e => Hz(e))).filter((e => null !== e));
            return a.length ? v.jsx(_ae, {
                label: v.jsx(wae, {
                    icons: a,
                    size: 14
                }),
                smallPadding: !0
            }, t) : n
        }
        return n
    }
    ));
    return v.jsx(v.Fragment, {
        children: t
    })
}
  , Wae = {
    [Qh.BUYS]: "Buys",
    [Qh.SELLS]: "Sells",
    [Qh.VOLUME]: "Vol",
    [Qh.MARKET_CAP]: "MC",
    [Qh.TOP_INSIDERS_HOLDING_PCNT]: "Insiders",
    [Qh.TOP_10_HOLDERS_PCNT]: "Top 10",
    [Qh.CURVE_PROGRESS]: "Curve",
    [Qh.TOKEN_AGE_IN_MINUTES]: "Age",
    [Qh.HOLDERS_COUNT]: "Holders",
    [Qh.BUNDLES_HOLDING_PCNT]: "Bundle",
    [Qh.PERCENTAGE_DEV_HOLDING]: "Dev holds",
    [Qh.SNIPERS_HOLDINGS_PCNT]: "Snipers holds",
    [Qh.DEV_BONDED]: "Dev bonded",
    [Qh.LIQUIDITY]: "Liq",
    [Qh.FRESH_WALLETS_BUYS]: "Fresh buys",
    [Qh.ALPHA_GROUP_MENTIONS]: "Groups mentions",
    [Qh.PRO_HOLDERS_COUNT]: "Pros",
    [Qh.TOTAL_SOL_FEES]: "Fees"
}
  , Fae = {
    [Qh.DEV_HOLDING]: "Dev still holding",
    [Qh.PUMP_LIVE]: "Pump live",
    [Qh.HAS_SOCIALS]: "At least one social",
    [Qh.HAS_ORIGINAL_AVATAR]: "Original avatar",
    [Qh.NO_SOCIALS_REUSE]: "Original socials",
    [Qh.NO_PERMISSIONED]: "Not permissioned",
    [Qh.DEXSCREENER_BOOSTED]: "Boosted",
    [Qh.IS_ACTIVE_MAYHEM]: "Mayhem",
    [Qh.NO_CONFIRMED_BOTS]: "No bots"
}
  , Vae = y.memo(( ({filter: e, onRemove: t, onClick: n}) => {
    const r = xw()
      , a = y.useCallback((e => {
        e.stopPropagation(),
        t()
    }
    ), [t]);
    return v.jsx(te, {
        sx: e => ({
            px: 1,
            py: 1.5,
            mx: -2,
            bgcolor: e.palette.background.secondary,
            borderBottom: `1px solid ${e.palette.background.borderSubtle}`,
            "&:hover": {
                bgcolor: e.palette.background.tertiary
            },
            ":last-child": {
                borderBottom: "none"
            }
        }),
        onClick: n,
        children: v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            width: "100%",
            gap: Hae,
            children: [v.jsx(S, {
                width: `calc(100% - ${zae + 8 * (Hae + $ae)}px)`,
                direction: "row",
                gap: 1,
                flexWrap: r ? "wrap" : "nowrap",
                overflow: "hidden",
                children: v.jsx(Uae, {
                    filters: e
                })
            }), v.jsx(F, {
                onClick: a,
                sx: e => ({
                    p: $ae,
                    color: e.palette.text.meta,
                    "&:hover": {
                        color: e.palette.primary.main
                    }
                }),
                children: v.jsx(wS, {
                    color: "inherit",
                    animateColor: !0,
                    size: zae
                })
            })]
        })
    })
}
))
  , Hae = 1
  , zae = 16
  , $ae = 1
  , Gae = y.memo(( () => {
    const {values: e, setFieldValue: t, setFieldTouched: n} = Tn()
      , r = y.useMemo(( () => {
        const t = e[Qh.LAUNCHPADS];
        return c.reduce(t ?? Oee, ( (e, t) => (e[t] = !0,
        e)), {})
    }
    ), [e])
      , a = y.useCallback((e => {
        t(Qh.LAUNCHPADS, c.reduce(Object.entries(r), ( (t, [n,r]) => (n === e || r && t.push(n),
        t)), r[e] ? [] : [e])),
        n(Qh.LAUNCHPADS)
    }
    ), [r, n, t])
      , s = y.useMemo(( () => {
        const t = e[Qh.LAUNCHPADS];
        return null === t || t.length === Oee.length
    }
    ), [e])
      , o = y.useCallback(( () => {
        t(Qh.LAUNCHPADS, s ? [] : null),
        n(Qh.LAUNCHPADS)
    }
    ), [s, n, t]);
    return v.jsxs(S, {
        gap: .5,
        width: "100%",
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            pr: .75,
            mb: .75,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "Launchpads"
            }), v.jsx(V, {
                variant: "tertiary",
                size: "xxsmall",
                onClick: o,
                sx: qae,
                children: s ? "Unselect All" : "Select All"
            })]
        }), v.jsx(qz, {
            launchpadsOrdered: Oee,
            toggleLaunchpad: a,
            selectedLaunchpads: r
        })]
    })
}
))
  , qae = {
    height: 24,
    fontSize: 12,
    px: .75,
    py: 0,
    borderRadius: 4,
    mr: -.75
}
  , Kae = ({isOpen: e, anchorEl: t, resetFilters: n, handleClose: r, chain: a}) => {
    const {t: s} = we()
      , {savedSolFilters: o, saveSolFilter: l, removeSolFilter: i, savedBscFilters: d, saveBscFilter: u, removeBscFilter: p} = JX()
      , h = K8(a, o, d)
      , m = K8(a, l, u)
      , g = K8(a, i, p)
      , x = pK()
      , {values: b, touched: f, errors: A, isValid: w, handleBlur: j, handleChange: T, handleSubmit: I, resetForm: E, setFieldValue: M, setFieldTouched: N} = Tn()
      , P = D()
      , O = xw()
      , L = y.useCallback(( (e, t) => {
        const n = e.target.value.replace(/[%$]/g, "")
          , r = QR(n)
          , a = Number(r)
          , s = isNaN(a) || !Dae(t) ? r : a > 100 ? "100" : r;
        e.target.value = s,
        M(e.target.name, "" === s ? null : s)
    }
    ), [M])
      , B = y.useCallback((async (e, t) => {
        await M(t, "" === e.target.value ? [] : [e.target.value]),
        await N(t)
    }
    ), [N, M])
      , _ = y.useCallback((e => {
        E({
            values: e
        }),
        I(),
        r()
    }
    ), [r, I, E])
      , U = y.useMemo(( () => Eae(b)), [b])
      , W = y.useMemo(( () => c.some(h, (e => c.isEqual(e.filter, b)))), [h, b])
      , H = y.useMemo(( () => h.length >= 10), [h.length])
      , $ = y.useCallback(( () => {
        var e;
        const t = {
            ...b,
            [Qh.LAUNCHPADS]: (null == (e = b[Qh.LAUNCHPADS]) ? void 0 : e.length) === Oee.length ? null : b[Qh.LAUNCHPADS]
        };
        m(t),
        _(t)
    }
    ), [_, m, b])
      , [G,q] = y.useState(Aae.MANUAL)
      , K = y.useCallback(( (e, t) => {
        q(t)
    }
    ), [])
      , Y = y.useCallback((e => {
        var t, n, r, a, o, l, i, c, d, u;
        if (Mae(e)) {
            const p = Rae(e)
              , h = Bae(e)
              , m = Dae(e) ? "%" : h ? "" : p ? "$" : ""
              , g = ((null == (t = f[e]) ? void 0 : t.to) || (null == (n = f[e]) ? void 0 : n.from)) && (!!(null == (r = A[e]) ? void 0 : r.to) || !!(null == (a = A[e]) ? void 0 : a.from))
              , x = t => {
                L(t, e)
            }
            ;
            return v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(z, {
                    title: g && (null == (o = A[e]) ? void 0 : o.from) ? null == (l = A[e]) ? void 0 : l.from : void 0,
                    children: y.createElement(je, {
                        ...ose,
                        name: `${e}.from`,
                        key: `${e}.from`,
                        placeholder: s("Min"),
                        value: b[e].from ?? "",
                        onChange: x,
                        onBlur: j,
                        error: g,
                        endAdornment: v.jsx(We, {
                            position: "end",
                            children: v.jsx(k, {
                                variant: "paragraph2",
                                children: m
                            })
                        })
                    })
                }), v.jsx(z, {
                    title: (null == (i = A[e]) ? void 0 : i.to) || (null == (c = A[e]) ? void 0 : c.from) === Oae ? (null == (d = A[e]) ? void 0 : d.to) || (null == (u = A[e]) ? void 0 : u.from) : void 0,
                    children: y.createElement(je, {
                        ...ose,
                        name: `${e}.to`,
                        key: `${e}.to`,
                        placeholder: s("Max"),
                        value: b[e].to ?? "",
                        onChange: x,
                        onBlur: j,
                        error: g,
                        endAdornment: v.jsx(We, {
                            position: "end",
                            children: v.jsx(k, {
                                variant: "paragraph2",
                                children: m
                            })
                        })
                    })
                })]
            })
        }
        if (Nae(e)) {
            const t = f[e] && !!A[e]
              , n = b[e]
              , r = Array.isArray(n) && n.length ? n[0] : ""
              , a = async t => {
                await B(t, e)
            }
            ;
            return y.createElement(je, {
                ...lse,
                placeholder: s("keyword1, keyword2..."),
                name: `${e}`,
                key: `${e}`,
                value: r,
                onChange: a,
                onBlur: j,
                error: t
            })
        }
        return Pae(e) ? v.jsx(UR, {
            name: `${e}`,
            onChange: T,
            checked: b[e] ?? !1
        }, `${e}`) : e === Qh.LAUNCHPADS ? v.jsx(Gae, {}) : void 0
    }
    ), [A, j, L, T, B, f, b, s])
      , X = y.useCallback(( () => {
        const e = n();
        E({
            values: e
        }),
        I(),
        r()
    }
    ), [n, E, r, I])
      , Z = y.useCallback((async () => {
        if (QC)
            try {
                const e = (e => {
                    try {
                        const t = JSON.parse(e);
                        if ("object" != typeof t || null === t || Array.isArray(t))
                            return null;
                        const n = {
                            ...XX
                        };
                        for (const e in t) {
                            if (!(e in XX))
                                return null;
                            const r = XX[e]
                              , a = t[e];
                            if (Array.isArray(r)) {
                                if (!Array.isArray(a))
                                    return null
                            } else if (typeof r != typeof a)
                                return null;
                            n[e] = a
                        }
                        return n
                    } catch (fNe) {
                        return null
                    }
                }
                )(await navigator.clipboard.readText());
                if (null === e)
                    return void x({
                        message: pu.clipboardCouldntDetermineFilters,
                        type: "error"
                    }, "clipboard-filters-invalid-format-failed");
                E({
                    values: e
                })
            } catch (e) {
                x({
                    message: uu.clipboardEnableAccess,
                    snackName: pu.clipboardUnavailable,
                    type: "error"
                }, "clipboard-check-failed")
            }
        else
            x({
                message: uu.clipboardEnableAccess,
                snackName: pu.clipboardUnavailable,
                type: "error"
            }, "clipboard-check-failed")
    }
    ), [x, E])
      , J = y.useCallback(( () => {
        QC ? (ZC((e => {
            const t = {};
            return Object.keys(XX).forEach((n => {
                c.isEqual(e[n], XX[n]) || (t[n] = e[n])
            }
            )),
            JSON.stringify(t)
        }
        )(b)),
        x({
            message: mu("Filters"),
            type: "success"
        }, "clipboard-filters-save-success")) : x({
            message: uu.clipboardEnableAccess,
            snackName: pu.clipboardUnavailable,
            type: "error"
        }, "clipboard-check-failed")
    }
    ), [x, b])
      , te = y.useCallback(( () => {
        I()
    }
    ), [I])
      , ne = y.useMemo(( () => Object.keys(A).some((e => Mae(e)))), [A])
      , re = y.useMemo(( () => {
        switch (a) {
        case Pd.BSC:
            return gse;
        case Pd.SOLANA:
            return mse
        }
    }
    ), [a])
      , se = v.jsxs(ee, {
        elevation: 0,
        className: "padre-no-scroll",
        sx: cse,
        children: [!O && v.jsxs(C, {
            sx: dse,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                px: 2,
                py: 1,
                height: ise,
                children: [v.jsx(F, {
                    onClick: r,
                    sx: pse,
                    children: v.jsx(ky, {
                        color: P.palette.text.label
                    })
                }), v.jsx(k, {
                    variant: "h4",
                    children: "Filters"
                })]
            }), v.jsx(Ee, {
                flexItem: !0
            })]
        }), v.jsxs(C, {
            component: "form",
            onSubmit: I,
            height: "100%",
            children: [v.jsxs(ot, {
                value: G,
                onChange: K,
                sx: Xae,
                children: [v.jsx(lt, {
                    label: "Manual",
                    value: Aae.MANUAL
                }), v.jsx(lt, {
                    label: `Saved (${h.length})`,
                    value: Aae.SAVED
                })]
            }), v.jsx(S, {
                gap: G === Aae.MANUAL ? 1.5 : 0,
                px: 2,
                py: G === Aae.MANUAL ? 2 : 0,
                maxHeight: `calc(100% - ${(O ? sse : ase) - (G === Aae.SAVED ? O ? nse : rse : 0)}px)`,
                height: "100%",
                sx: Yae,
                className: "padre-no-scroll",
                justifyContent: G !== Aae.SAVED || h.length ? "flex-start" : "center",
                children: G === Aae.MANUAL ? v.jsx(v.Fragment, {
                    children: re.map((e => v.jsxs(S, {
                        gap: .75,
                        width: "100%",
                        justifyContent: "space-between",
                        direction: "row",
                        children: [!fne.includes(e) && v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            minWidth: tse,
                            children: [v.jsx(k, {
                                variant: "paragraph3",
                                color: "text.label",
                                children: s(hse[e])
                            }), e === Qh.IS_ACTIVE_MAYHEM && v.jsx(TC, {}), bse[e] && !R && v.jsx(z, {
                                title: s(bse[e]),
                                children: v.jsx(C, {
                                    component: "span",
                                    sx: fse,
                                    children: v.jsx(QS, {
                                        size: xse
                                    })
                                })
                            })]
                        }), Y(e)]
                    }, e)))
                }) : v.jsx(v.Fragment, {
                    children: h.length ? h.sort(( (e, t) => t.addedAt - e.addedAt)).map((e => {
                        const t = {
                            ...XX,
                            ...e.filter
                        };
                        return v.jsx(Vae, {
                            filter: t,
                            onRemove: () => {
                                g(e.id)
                            }
                            ,
                            onClick: () => {
                                _(t)
                            }
                        }, e.id)
                    }
                    )) : v.jsx(S, {
                        width: "100%",
                        children: v.jsx(k, {
                            textAlign: "center",
                            variant: "paragraph3",
                            color: "text.label",
                            children: s("You don't have any saved filters")
                        })
                    })
                })
            }), G === Aae.MANUAL && v.jsxs(S, {
                sx: Qae,
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .75,
                    alignItems: "center",
                    children: [v.jsx(GC, {
                        title: s("Reset filters"),
                        children: v.jsx(F, {
                            onClick: X,
                            sx: yse,
                            children: v.jsx(US, {
                                size: vse
                            })
                        })
                    }), v.jsx(V, {
                        onClick: Z,
                        size: "xsmall",
                        sx: use,
                        variant: "tertiary",
                        children: s("Import")
                    }), v.jsx(GC, {
                        title: 0 === U ? "You don't have any active filters" : w ? "" : "Invalid filters",
                        children: v.jsx(C, {
                            component: "span",
                            display: "flex",
                            children: v.jsx(V, {
                                onClick: J,
                                size: "xsmall",
                                sx: use,
                                variant: "tertiary",
                                disabled: !w || 0 === U,
                                children: s("Export")
                            })
                        })
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: .75,
                    alignItems: "center",
                    children: [v.jsx(GC, {
                        title: H ? s("Reached saved filters limit") : !w || 0 === U || W ? "" : s("Save filters"),
                        children: v.jsx(F, {
                            onClick: $,
                            disabled: !w || 0 === U || W || H,
                            sx: kse,
                            children: v.jsx(cS, {
                                size: vse,
                                color: !w || 0 === U || W || H ? P.palette.text.disabled : P.palette.text.label
                            })
                        })
                    }), v.jsx(V, {
                        onClick: te,
                        disabled: ne,
                        size: "xsmall",
                        sx: use,
                        children: s("Apply")
                    })]
                })]
            })]
        })]
    });
    return O ? v.jsx(ae, {
        open: e,
        anchorEl: t,
        onClose: r,
        marginThreshold: 0,
        TransitionComponent: Q,
        anchorReference: "anchorEl",
        anchorOrigin: Jae,
        container: () => (null == t ? void 0 : t.parentElement) ?? null,
        sx: ese,
        children: se
    }) : v.jsx(Sw, {
        open: e,
        stackSx: Zae,
        children: se
    })
}
  , Yae = {
    overflowY: "scroll",
    overflowX: "hidden"
}
  , Xae = {
    mx: -1
}
  , Qae = e => ({
    background: e.palette.background.primary,
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    flexDirection: "row",
    position: {
        xs: "fixed",
        sm: "absolute"
    },
    bottom: 0,
    left: 0,
    right: 0,
    py: 1.5,
    pl: .75,
    pr: 1.5,
    justifyContent: "space-between",
    alignItems: "center"
})
  , Zae = {
    p: 0,
    border: "none"
}
  , Jae = {
    vertical: "bottom",
    horizontal: "left"
}
  , ese = {
    zIndex: 1241,
    "& .MuiPopover-paper": {
        mt: 0
    }
}
  , tse = 110
  , nse = 20
  , rse = 66
  , ase = 144
  , sse = 94
  , ose = {
    sx: {
        flexGrow: 1,
        borderWidth: 1
    },
    size: "xsmall",
    inputProps: {
        inputMode: "decimal",
        "data-pseudotype": "numberLike",
        style: {
            fontWeight: 500
        },
        sx: {
            textAlign: "left",
            pl: 1,
            pr: 0,
            py: 1.5
        }
    }
}
  , lse = {
    ...ose,
    inputProps: {
        inputMode: "text",
        "data-pseudotype": void 0,
        style: {
            fontWeight: 500
        },
        sx: {
            textAlign: "left",
            pl: 1,
            pr: 0,
            py: 1.5
        }
    }
}
  , ise = 48
  , cse = e => ({
    background: e.palette.background.primary,
    width: {
        xs: "100%",
        sm: 345
    },
    height: {
        xs: "100%",
        sm: "min(calc(100vh - 108px), 840px)"
    },
    maxHeight: "100%",
    overflow: "scroll",
    border: 1,
    borderColor: e.palette.background.borderSubtle,
    position: "relative"
})
  , dse = e => ({
    background: e.palette.background.primary,
    zIndex: 10
})
  , use = {
    width: 64
}
  , pse = {
    p: 0
}
  , hse = {
    [Qh.TICKERS]: "Search keywords",
    [Qh.EXCLUDE_KEYWORDS]: "Exclude keywords",
    [Qh.HAS_SOCIALS]: "At least one social",
    [Qh.NO_SOCIALS_REUSE]: "Original socials",
    [Qh.NO_PERMISSIONED]: "Not permissioned",
    [Qh.HAS_ORIGINAL_AVATAR]: "Original avatar",
    [Qh.DEV_HOLDING]: "Dev still holding",
    [Qh.IS_ACTIVE_MAYHEM]: "Mayhem mode",
    [Qh.PUMP_LIVE]: "Pump live",
    [Qh.CURVE_PROGRESS]: "Curve progress",
    [Qh.TOP_10_HOLDERS_PCNT]: "Top 10 holders",
    [Qh.TOP_INSIDERS_HOLDING_PCNT]: "Insiders holdings",
    [Qh.SNIPERS_HOLDINGS_PCNT]: "Snipers holdings",
    [Qh.VOLUME]: "Volume",
    [Qh.MARKET_CAP]: "Market cap",
    [Qh.BUYS]: "Buys",
    [Qh.SELLS]: "Sells",
    [Qh.TOKEN_AGE_IN_MINUTES]: "Token age (mins)",
    [Qh.HOLDERS_COUNT]: "Holders",
    [Qh.BUNDLES_HOLDING_PCNT]: "Bundles holding",
    [Qh.PERCENTAGE_DEV_HOLDING]: "Dev holding",
    [Qh.DEXSCREENER_BOOSTED]: "Dex paid",
    [Qh.DEV_BONDED]: "Dev bonded",
    [Qh.LAUNCHPADS]: "Launchpads",
    [Qh.LIQUIDITY]: "Liquidity",
    [Qh.FRESH_WALLETS_BUYS]: "Fresh wallets buys (SOL)",
    [Qh.ALPHA_GROUP_MENTIONS]: "Alpha group mentions",
    [Qh.PRO_HOLDERS_COUNT]: "Pro holders",
    [Qh.TOTAL_SOL_FEES]: "Total fees (SOL)",
    [Qh.NO_CONFIRMED_BOTS]: "Not created by a known bot"
}
  , mse = [Qh.LAUNCHPADS, Qh.TICKERS, Qh.EXCLUDE_KEYWORDS, Qh.IS_ACTIVE_MAYHEM, Qh.HAS_SOCIALS, Qh.NO_SOCIALS_REUSE, Qh.HAS_ORIGINAL_AVATAR, Qh.DEXSCREENER_BOOSTED, Qh.DEV_HOLDING, Qh.NO_CONFIRMED_BOTS, Qh.PUMP_LIVE, Qh.MARKET_CAP, Qh.VOLUME, Qh.LIQUIDITY, Qh.TOP_10_HOLDERS_PCNT, Qh.TOP_INSIDERS_HOLDING_PCNT, Qh.SNIPERS_HOLDINGS_PCNT, Qh.CURVE_PROGRESS, Qh.BUYS, Qh.SELLS, Qh.DEV_BONDED, Qh.TOTAL_SOL_FEES, Qh.FRESH_WALLETS_BUYS, Qh.TOKEN_AGE_IN_MINUTES, Qh.HOLDERS_COUNT, Qh.PRO_HOLDERS_COUNT, Qh.BUNDLES_HOLDING_PCNT, Qh.PERCENTAGE_DEV_HOLDING, Qh.ALPHA_GROUP_MENTIONS]
  , gse = [Qh.TICKERS, Qh.EXCLUDE_KEYWORDS, Qh.HAS_SOCIALS, Qh.NO_SOCIALS_REUSE, Qh.NO_PERMISSIONED, Qh.HAS_ORIGINAL_AVATAR, Qh.DEV_HOLDING, Qh.MARKET_CAP, Qh.VOLUME, Qh.TOP_10_HOLDERS_PCNT, Qh.TOP_INSIDERS_HOLDING_PCNT, Qh.CURVE_PROGRESS, Qh.BUYS, Qh.SELLS, Qh.DEV_BONDED, Qh.TOKEN_AGE_IN_MINUTES, Qh.HOLDERS_COUNT, Qh.PRO_HOLDERS_COUNT, Qh.PERCENTAGE_DEV_HOLDING, Qh.ALPHA_GROUP_MENTIONS]
  , xse = 14
  , bse = {
    [Qh.TICKERS]: null,
    [Qh.EXCLUDE_KEYWORDS]: null,
    [Qh.HAS_SOCIALS]: "Filters out tokens that don't have any socials",
    [Qh.HAS_ORIGINAL_AVATAR]: "Filters out tokens that reused avatar from existing tokens",
    [Qh.NO_SOCIALS_REUSE]: "Filters out tokens that reused social links from existing tokens",
    [Qh.NO_PERMISSIONED]: "Filters out tokens that can only be traded via other interface, i.e. Binance",
    [Qh.DEV_HOLDING]: null,
    [Qh.IS_ACTIVE_MAYHEM]: null,
    [Qh.PUMP_LIVE]: null,
    [Qh.CURVE_PROGRESS]: null,
    [Qh.TOP_10_HOLDERS_PCNT]: null,
    [Qh.TOP_INSIDERS_HOLDING_PCNT]: null,
    [Qh.SNIPERS_HOLDINGS_PCNT]: null,
    [Qh.VOLUME]: null,
    [Qh.MARKET_CAP]: null,
    [Qh.BUYS]: null,
    [Qh.SELLS]: null,
    [Qh.TOKEN_AGE_IN_MINUTES]: null,
    [Qh.HOLDERS_COUNT]: null,
    [Qh.BUNDLES_HOLDING_PCNT]: null,
    [Qh.PERCENTAGE_DEV_HOLDING]: null,
    [Qh.DEXSCREENER_BOOSTED]: "Only tokens with dexscreener paid",
    [Qh.DEV_BONDED]: null,
    [Qh.LAUNCHPADS]: null,
    [Qh.LIQUIDITY]: null,
    [Qh.FRESH_WALLETS_BUYS]: null,
    [Qh.PRO_HOLDERS_COUNT]: null,
    [Qh.TOTAL_SOL_FEES]: null,
    [Qh.ALPHA_GROUP_MENTIONS]: "Filters out tokens that were not mentioned in alpha groups",
    [Qh.NO_CONFIRMED_BOTS]: "Filter out tokens created by known bots"
}
  , fse = {
    maxHeight: 19,
    mt: -.25,
    "&:hover": {
        cursor: "help"
    }
}
  , vse = 18
  , Sse = .75
  , yse = {
    p: Sse,
    height: vse + 12,
    width: vse + 12
}
  , kse = {
    p: Sse,
    height: vse + 12,
    width: vse + 12
}
  , Cse = y.memo(( ({filterMode: e, chain: t, size: n=28, iconSize: r=20, tooltipTitle: a, tooltipOffset: s}) => {
    const {solFilters: o, setSolFilter: l, bscFilters: i, setBscFilter: d, trendingSolFilters: u, setTrendingSolFilters: p, trendingBscFilters: h, setTrendingBscFilters: m, solDexFilters: g, setSolDexFilters: x, bscDexFilters: b, setBscDexFilters: f, trendingSolNewFilters: k, setTrendingSolNewFilters: A, trendingBscNewFilters: w, setTrendingBscNewFilters: j, livePumpFilters: T, setLivePumpFilters: I} = JX()
      , E = K8(t, o, i)
      , M = K8(t, l, d)
      , N = K8(t, u, h)
      , P = K8(t, p, m)
      , O = K8(t, k, w)
      , L = K8(t, A, j)
      , R = K8(t, g, b)
      , D = K8(t, x, f)
      , B = y.useMemo(( () => {
        switch (e) {
        case "TRENDING":
            return N ? {
                ...XX,
                ...N
            } : XX;
        case "TRENDING_NEW":
            return O ? {
                ...XX,
                ...O
            } : XX;
        case "DEX":
            return R ? {
                ...XX,
                ...R
            } : XX;
        case "LIVE_PUMP":
            return T ? {
                ...XX,
                ...T
            } : XX;
        case Zh.NEW:
        case Zh.ALMOST_BONDED:
        case Zh.RECENTLY_BONDED:
            return E[e] ? {
                ...XX,
                ...E[e]
            } : XX
        }
    }
    ), [R, e, E, N, O, T])
      , _ = y.useCallback(( () => {
        switch (e) {
        case "TRENDING":
            P(XX);
            break;
        case "TRENDING_NEW":
            L(XX);
            break;
        case "DEX":
            D(XX);
            break;
        case "LIVE_PUMP":
            I(XX);
            break;
        case Zh.NEW:
        case Zh.ALMOST_BONDED:
        case Zh.RECENTLY_BONDED:
            M(e, XX)
        }
        return XX
    }
    ), [e, P, L, D, I, M])
      , [U,W] = y.useState(!1)
      , [V,H] = y.useState(null)
      , z = y.useCallback((e => {
        H(e.currentTarget),
        W((e => !e))
    }
    ), [])
      , $ = In({
        initialValues: B,
        enableReinitialize: !0,
        onSubmit: t => {
            const n = {
                ...XX,
                ...t
            };
            switch (Object.values(Qh).forEach((e => {
                Mae(e) ? n[e] = c.mapValues(t[e], (e => e ? Number(e) : null)) : Nae(e) ? n[e] = Array.isArray(t[e]) ? t[e] ?? [] : [] : Pae(e) && (n[e] = t[e] ?? !1)
            }
            )),
            e) {
            case "TRENDING":
                P(n);
                break;
            case "TRENDING_NEW":
                L(n);
                break;
            case "DEX":
                D(n);
                break;
            case "LIVE_PUMP":
                I(n);
                break;
            case Zh.NEW:
            case Zh.ALMOST_BONDED:
            case Zh.RECENTLY_BONDED:
                M(e, n)
            }
            W(!1)
        }
        ,
        validationSchema: Lae
    })
      , G = y.useCallback(( () => {
        W(!1),
        $.resetForm()
    }
    ), [$])
      , q = y.useCallback((e => {
        e.target && "BODY" === e.target.nodeName || e.target.classList.contains("disable-click-away") || (W(!1),
        $.resetForm())
    }
    ), [$])
      , K = y.useMemo(( () => Eae(B)), [B])
      , Y = y.useMemo(( () => e => ({
        width: n,
        height: n,
        p: .5,
        "&:hover": {
            backgroundColor: e.palette.background.buttonHover
        }
    })), [n]);
    return v.jsx(En, {
        value: $,
        children: v.jsx(S, {
            direction: "row",
            gap: 1,
            flexWrap: "wrap",
            children: v.jsx(re, {
                onClickAway: q,
                children: v.jsxs(C, {
                    position: "relative",
                    children: [v.jsx(GC, {
                        title: a,
                        offset: s,
                        children: v.jsx(F, {
                            sx: Y,
                            onClick: z,
                            children: v.jsx(xk, {
                                size: r
                            })
                        })
                    }), !!K && v.jsx(C, {
                        position: "absolute",
                        sx: Ase
                    }), v.jsx(Kae, {
                        isOpen: U,
                        anchorEl: V,
                        resetFilters: _,
                        handleClose: G,
                        chain: t
                    })]
                })
            })
        })
    })
}
))
  , Ase = e => ({
    background: e.palette.primary.main,
    borderRadius: "50%",
    width: 5,
    height: 5,
    top: 1,
    right: -1
})
  , wse = y.memo(( ({trenchMode: e, chain: t}) => {
    const {t: n} = we()
      , {solFilters: r, setSolFilter: a, bscFilters: s, setBscFilter: o} = JX()
      , l = K8(t, r, s)
      , i = K8(t, a, o)
      , [d,u] = y.useState(Ese(l, e) ?? "")
      , p = y.useRef(!1);
    y.useEffect(( () => {
        p.current || u(Ese(l, e) ?? "")
    }
    ), [l, e]);
    const h = y.useCallback((t => {
        i(e, {
            ...x.current[e],
            [Qh.TICKERS]: t ? [t] : null
        })
    }
    ), [i, e])
      , m = y.useMemo(( () => {
        const e = c.debounce((e => {
            p.current = !1,
            h(e)
        }
        ), 200);
        return t => {
            p.current = !0,
            e(t)
        }
    }
    ), [h])
      , g = y.useCallback((async e => {
        var t;
        const n = null == (t = e.target.value) ? void 0 : t.toLowerCase();
        u(n),
        m(n)
    }
    ), [m])
      , x = y.useRef(l);
    x.current = l;
    const b = y.useRef(d);
    b.current = d;
    const f = y.useCallback(( () => {
        h(b.current)
    }
    ), [h])
      , k = y.useCallback((e => {
        "Enter" === e.key && (e.stopPropagation(),
        e.currentTarget.blur())
    }
    ), [])
      , C = y.useCallback(( () => {
        var e;
        u(""),
        h(""),
        null == (e = A.current) || e.blur()
    }
    ), [u, h])
      , A = y.useRef(null);
    return v.jsx(je, {
        ref: A,
        size: "xsmall",
        placeholder: n("Search"),
        inputProps: Ise,
        sx: jse,
        name: Qh.TICKERS,
        value: d,
        onChange: g,
        onBlur: f,
        onKeyDown: k,
        endAdornment: v.jsx(We, {
            position: "end",
            children: v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 0,
                children: !!d && v.jsx(z, {
                    title: n("Clear"),
                    children: v.jsx(F, {
                        onClick: C,
                        sx: Tse,
                        children: v.jsx(Wy, {})
                    })
                })
            })
        })
    })
}
))
  , jse = e => {
    const t = "4.2em";
    return {
        flexGrow: 1,
        borderWidth: 1,
        height: 28,
        minWidth: t,
        width: t,
        maxWidth: "100%",
        px: 0,
        "& .MuiInputBase-input::placeholder": {
            opacity: 1
        },
        background: "transparent",
        transition: `width ${e.transitions.duration.shortest}ms ${e.transitions.easing.easeInOut}`,
        "& .MuiInputAdornment-positionEnd": {
            visibility: "hidden",
            maxWidth: 6,
            transition: `max-width ${e.transitions.duration.shortest}ms ${e.transitions.easing.easeInOut}`
        },
        "&:focus-within": {
            width: "8em",
            "& .MuiInputAdornment-positionEnd": {
                visibility: "visible",
                maxWidth: 24
            }
        }
    }
}
  , Tse = {
    width: 24,
    height: 24,
    p: 0
}
  , Ise = {
    inputMode: "text",
    "data-pseudotype": void 0,
    style: {
        fontWeight: 500
    },
    sx: {
        textAlign: "left",
        pl: 1.5,
        py: 1.5
    }
}
  , Ese = (e, t) => {
    const n = e[t];
    if (!n)
        return null;
    const r = n[Qh.TICKERS];
    return r && r.length ? r[0] : null
}
  , Mse = y.memo(( ({compact: e}) => {
    const {soonMode: t, toggleSoonMode: n} = xne()
      , {t: r} = we()
      , {buttonProps: a, popoverProps: s, callHandlerAndClose: o} = Fw({
        id: "soon-sort-selector"
    })
      , l = y.useCallback(( () => {
        o(),
        t === YX.M_CAP && n()
    }
    ), [t, n, o])
      , i = y.useMemo(( () => Pse({
        isSelected: t === YX.CURVE,
        isFirst: !0
    })), [t])
      , c = y.useCallback(( () => {
        o(),
        t === YX.CURVE && n()
    }
    ), [t, n, o])
      , d = y.useMemo(( () => Pse({
        isSelected: t === YX.M_CAP,
        isLast: !0
    })), [t])
      , u = y.useMemo(( () => v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        sx: Ose(e),
        children: [v.jsx(GC, {
            title: r("Sort by percent bonded"),
            children: v.jsx(V, {
                variant: "tertiary",
                size: "xxsmall",
                sx: i,
                onClick: l,
                children: "%"
            })
        }), v.jsx(Ee, {
            orientation: "vertical",
            flexItem: !0
        }), v.jsx(GC, {
            title: r("Sort by market cap"),
            children: v.jsx(V, {
                variant: "tertiary",
                size: "xxsmall",
                sx: d,
                onClick: c,
                children: "MC"
            })
        })]
    })), [r, i, d, l, c, e]);
    return e ? v.jsxs(v.Fragment, {
        children: [v.jsx(GC, {
            title: r("Sort"),
            offset: -5,
            children: v.jsx(S, {
                children: v.jsx(V, {
                    sx: Lse,
                    variant: "tertiary",
                    size: "xxsmall",
                    ...a,
                    children: v.jsx(wC, {})
                })
            })
        }), v.jsx(ae, {
            ...s,
            open: s.open,
            onClick: Ww,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            slotProps: Rse,
            children: u
        })]
    }) : u
}
))
  , Nse = 26
  , Pse = ({isSelected: e, isFirst: t, isLast: n}) => r => ({
    px: 0,
    height: Nse,
    width: 32.5,
    borderRadius: 0,
    border: "none",
    background: "transparent",
    color: e ? r.palette.primary.main : r.palette.text.label,
    "&:focus": {
        border: "none",
        background: "transparent"
    },
    "&:hover": {
        border: "none",
        background: r.palette.background.buttonHover
    },
    ...t && {
        pl: "3.25px"
    },
    ...n && {
        pr: "3.25px"
    }
})
  , Ose = e => t => ({
    border: e ? "none" : `1px solid ${t.palette.background.borderMain}`,
    borderRadius: 14,
    overflow: "hidden",
    backgroundColor: "transparent"
})
  , Lse = e => ({
    border: "none",
    borderRadius: 14,
    overflow: "hidden",
    minWidth: Nse,
    height: Nse,
    p: 0,
    background: "transparent",
    "&:hover": {
        backgroundColor: e.palette.background.buttonHover
    }
})
  , Rse = {
    paper: {
        sx: e => ({
            borderRadius: "14px",
            background: e.palette.background.default,
            border: `1px solid ${e.palette.background.borderMain}`
        })
    }
}
  , Dse = y.memo(( ({trenchMode: e, isPaused: t, isSync: n, onPauseClick: r, onResumeClick: a, compact: s=!1}) => {
    const {t: o} = we()
      , l = bw()
      , i = fw()
      , c = D()
      , {trenchesChain: d} = xne()
      , {selectedSoundEffects: u, setSelectedSoundEffect: p, soundEffectsEnabled: h, setSoundEffectEnabled: m, selectedBscSoundEffects: g, setSelectedBscSoundEffect: x, bscSoundEffectsEnabled: b, setBscSoundEffectEnabled: f} = JX()
      , C = y.useMemo(( () => {
        switch (d) {
        case Pd.BSC:
            return g;
        case Pd.SOLANA:
            return u
        }
    }
    ), [u, g, d])
      , A = y.useCallback(( (e, t) => {
        switch (d) {
        case Pd.BSC:
            x(e, t);
            break;
        case Pd.SOLANA:
            p(e, t)
        }
    }
    ), [p, x, d])
      , w = y.useMemo(( () => {
        switch (d) {
        case Pd.BSC:
            return b;
        case Pd.SOLANA:
            return h
        }
    }
    ), [h, b, d])
      , j = y.useCallback(( (e, t) => {
        switch (d) {
        case Pd.BSC:
            f(e, t);
            break;
        case Pd.SOLANA:
            m(e, t)
        }
    }
    ), [m, f, d])
      , [T,I,E,M] = y.useMemo(( () => [C[e] ?? !1, t => {
        A(t, e)
    }
    , w[e] ?? !1, t => {
        j(t, e)
    }
    ]), [C, A, j, w, e])
      , {visibleSections: N} = Cne()
      , P = y.useMemo(( () => ({
        gap: 0,
        pr: 1,
        pl: s ? 1 : R ? 1.5 : {
            xs: 1.5,
            lg: 2
        },
        pb: s ? 1 : {
            xs: 1,
            md: 1.5
        },
        pt: s ? 0 : {
            xs: 1,
            md: 1.5
        },
        minWidth: "max-content",
        width: "100%"
    })), [s]);
    return v.jsx(S, {
        sx: Use,
        children: v.jsx(S, {
            sx: Wse,
            className: "padre-no-scroll",
            children: v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                sx: P,
                children: [s && v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    pr: 1,
                    children: [v.jsx(oae, {}), v.jsx(gae, {})]
                }), l && !s ? v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    mr: {
                        xs: .25,
                        lg: 1
                    },
                    children: [v.jsx(k, {
                        variant: "h2",
                        color: "text.value",
                        noWrap: !0,
                        fontSize: 16,
                        fontWeight: 600,
                        children: o(Eee[e])
                    }), v.jsx(S, {
                        width: _se,
                        alignItems: "center",
                        justifyContent: "center",
                        flexShrink: 0,
                        children: t || !n ? v.jsx(ok, {
                            color: t ? c.palette.primary.main : c.palette.error.main,
                            size: _se
                        }) : null
                    })]
                }) : R ? v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: t ? a : r,
                    sx: Bse,
                    children: o(t ? "Resume" : "Pause")
                }) : null, v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    flexGrow: 1,
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: {
                            xs: .5,
                            lg: 1.5
                        },
                        flexShrink: 0,
                        flexGrow: 1,
                        children: [e === Zh.ALMOST_BONDED && l && v.jsx(Mse, {
                            compact: !i
                        }), l && N.has(vne.KEYWORDS_SEARCH) && v.jsx(Hse, {
                            children: v.jsx(Vse, {
                                children: v.jsx(wse, {
                                    trenchMode: e,
                                    chain: d
                                })
                            })
                        }), d === Pd.SOLANA && v.jsx(dz, {
                            tooltipOffset: -5
                        }), d === Pd.BSC && v.jsx(d0, {
                            tooltipOffset: -5
                        })]
                    }), v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        flexShrink: 0,
                        children: [v.jsx(ej, {
                            idKey: e,
                            selectedSoundEffect: T,
                            setSelectedSoundEffect: I,
                            soundEffectEnabled: E,
                            setSoundEffectEnabled: M,
                            size: 28,
                            iconSize: 18,
                            useIconButton: !0,
                            tooltipTitle: o("Sound alert"),
                            tooltipOffset: -6
                        }), v.jsx(S, {
                            children: v.jsx(Cse, {
                                filterMode: e,
                                chain: d,
                                iconSize: 16,
                                size: 28,
                                tooltipTitle: o("Filters"),
                                tooltipOffset: -6
                            })
                        })]
                    })]
                })]
            })
        })
    })
}
))
  , Bse = {
    ml: -1,
    mr: .5,
    px: 1.25,
    minWidth: 73
}
  , _se = 14
  , Use = e => {
    const t = e.palette.background.secondary
      , n = $t(t, 0);
    return {
        position: "relative",
        borderBottom: `1px solid ${e.palette.background.borderMain}`,
        "&:before, &:after": {
            content: '""',
            position: "absolute",
            top: 0,
            width: 12,
            height: "calc(100% - 1px)",
            pointerEvents: "none"
        },
        "&:before": {
            zIndex: 1,
            left: 0,
            background: `linear-gradient(to right, ${t} 0%, ${n} 100%), linear-gradient(to right, ${t} 0%, ${n} 50%)`
        },
        "&:after": {
            right: 0,
            background: `linear-gradient(to left, ${t} 0%, ${n} 100%), linear-gradient(to left, ${t} 0%, ${n} 50%)`
        }
    }
}
  , Wse = {
    overflowX: "auto",
    overflowY: "visible"
}
  , Fse = "trenches-table-header-search"
  , Vse = y.memo(B(S)({
    position: "relative",
    [`@container ${Fse} (width < 68px)`]: {
        display: "none"
    }
}))
  , Hse = y.memo(B(S)({
    flexGrow: 1,
    container: `${Fse} / inline-size`
}))
  , zse = "0x0000000000000000000000000000000000000000"
  , $se = {
    chain: Pd.SOLANA,
    address: qc,
    symbol: "SOL",
    name: "Wrapped SOL",
    decimals: 9,
    deployedAt: 0,
    deployedAtBlock: null,
    deployer: null,
    tokenType: null
}
  , Gse = {
    chain: Pd.SOLANA,
    address: Kc,
    symbol: "USDC",
    name: "USD Coin",
    decimals: 6,
    deployedAt: 0,
    deployedAtBlock: null,
    deployer: null,
    tokenType: 1
}
  , qse = {
    chain: Pd.SOLANA,
    address: Yc,
    symbol: "USDT",
    name: "Tether USD",
    decimals: 6,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Kse = {
    chain: Pd.SOLANA,
    address: Xc,
    symbol: "USD1",
    name: "World Liberty Financial USD",
    decimals: 6,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Yse = {
    chain: Pd.BSC,
    address: zse,
    symbol: "BNB",
    name: "Binance Coin",
    decimals: 18,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Xse = {
    chain: Pd.BSC,
    address: $c,
    symbol: "USD1",
    name: "World Liberty Financial USD",
    decimals: 18,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Qse = {
    chain: Pd.BSC,
    address: Hc,
    symbol: "USDC",
    name: "USD Coin",
    decimals: 18,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Zse = {
    chain: Pd.BSC,
    address: zc,
    symbol: "USDT",
    name: "Tether USD",
    decimals: 18,
    deployedAt: 0,
    deployedAtBlock: 0,
    deployer: null,
    tokenType: null
}
  , Jse = (e, t) => {
    if (e === Pd.SOLANA) {
        if (t === qc)
            return $se;
        if (t === Kc)
            return Gse;
        if (t === Yc)
            return qse;
        if (t === Xc)
            return Kse
    }
    if (e === Pd.BSC)
        switch (t) {
        case zse:
        case Vc:
            return Yse;
        case $c:
            return Xse;
        case zc:
            return Zse;
        case Hc:
            return Qse
        }
    return null
}
  , eoe = new hg(1e3)
  , toe = e => {
    const t = (null == Pu ? void 0 : Pu.uid) || null;
    if (!t)
        return;
    const n = {
        uid: t,
        baseTokenAddress: e.baseToken,
        chain: e.chain,
        poolAddress: e.poolAddress,
        quoteTokenAddress: e.quoteToken,
        walletAddress: e.walletAddress
    }
      , r = (e => [e.chain, e.baseToken, e.poolAddress, e.quoteToken, e.walletAddress].join("-"))(e)
      , a = eoe.get(r);
    a && a > i().unix() - 15 || (eoe.set(r, i().unix()),
    sm.warmUpCache(n).catch((e => {
        o(e)
    }
    )))
}
  , noe = {
    chain: Pd.SOLANA,
    address: qc,
    symbol: "SOL",
    name: "Wrapped SOL",
    decimals: 9,
    deployedAt: 0,
    deployedAtBlock: null,
    deployer: null,
    tokenType: null
}
  , roe = (Pd.SOLANA,
Kc)
  , aoe = (vc.SOLANA_SPL,
Pd.SOLANA,
Yc)
  , soe = (Pd.SOLANA,
Xc)
  , ooe = [Rc.METEORA_CURVE, Rc.METEORA_DAMM_V2, Rc.LAUNCH_LAB, Rc.RAYDIUM_CP];
function loe(e) {
    return e ? e.chain === Pd.SOLANA && Ej(e.quoteToken.address) && ooe.includes(e.protocol.type) ? noe : e.quoteToken : null
}
const ioe = ({type: e, chain: t, pumpfunAddress: n, raydiumAddress: r, meteoraAddress: a, fourMemeAddress: s, pancakeSwapAddress: o, tokenAddress: l}) => {
    switch (t) {
    case Pd.BSC:
        return fg(t, o ?? s ?? n, o ? null : {
            type: "fourmeme",
            tokenAddress: l
        });
    case Pd.SOLANA:
        return "heaven" !== e && "token-mill" !== e && "string" == typeof n && (r || a) ? fg(t, n, null) : null
    }
}
  , coe = e => {
    switch (e.chain) {
    case Pd.BSC:
        return yp({
            ...e,
            type: "fourmeme"
        });
    case Pd.SOLANA:
        {
            const t = e.type;
            return kp({
                ...e,
                type: t
            })
        }
    }
}
  , doe = e => {
    if ("meteora-curve" === e.type && !e.quoteTokenAddr)
        return null;
    const t = Jse(e.chain, e.quoteTokenAddr) ?? noe;
    return {
        chain: e.chain,
        marketAddress: e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress ?? e.pancakeSwapAddress ?? e.fourMemeAddress ?? e.pumpfunAddress,
        protocol: coe(e),
        createdAt: e.createdAt,
        baseToken: {
            chain: e.chain,
            address: e.tokenAddress,
            symbol: e.symbol,
            name: e.name,
            decimals: e.decimals ?? (e.chain === Pd.SOLANA ? 6 : 18),
            deployedAt: e.createdAt,
            deployedAtBlock: null,
            deployer: e.devAddress,
            tokenType: e.tokenType ?? (e.chain === Pd.SOLANA ? "heaven" === e.type ? vc.SOLANA_SPL_2022 : vc.SOLANA_SPL : null)
        },
        quoteToken: t,
        launchpad: e.type,
        launchpadAux: e.launchpadAux,
        preMigrationMarketId: ioe(e),
        realQuoteToken: e.realQuoteToken ?? null
    }
}
  , uoe = (e, t) => t !== Zh.RECENTLY_BONDED && e.bondedAt && "heaven" !== e.type && "token-mill" !== e.type && !e.raydiumAddress && !e.pumpSwapAddress && !e.meteoraAddress && !e.pancakeSwapAddress
  , poe = new Set([Vc, Wd])
  , hoe = y.memo(( ({isPerformingTrade: e, setIsPerformingTrade: t, isPerformingExtraTrade: n, setIsPerformingExtraTrade: r, setMouseOver: a, tokenAddress: s, tokenType: o, quoteTokenAddr: l, raydiumAddress: i, pumpSwapAddress: c, meteoraAddress: d, pumpfunAddress: u, fourMemeAddress: p, pancakeSwapAddress: h, symbol: m, padreAvatarUrl: g}) => {
    const {trenchesChain: x, selectedColor: b, selectedTextColor: f, trenchesButtonMode: A, quickBuyButtonExtraPadding: w, trenchesButtonEdges: j, quickBuyButtonTransparency: T, trenchesTileLayout: I, ultraBuyButton: E, showUltraGlow: M, showUltraBorder: N, showExtraButton: P, selectedExtraColor: O, selectedExtraTextColor: L, quickBuyExtraAction: D} = xne()
      , B = pK()
      , _ = pT()
      , {settings: U} = rf()
      , {exitStrategies: W} = KR()
      , {insufficientBalance: F, buttonDisplayValue: H, includeExitStrategies: z, selectedPreset: $, buttonValue: G, extraInsufficientBalance: q, extraButtonDisplayValue: K, extraIncludeExitStrategies: Y, extraSelectedPreset: X, extraButtonValue: Q} = (e => {
        const t = ZJ()
          , n = ZJ(!0)
          , r = uH()
          , a = uH(!0);
        return y.useMemo(( () => {
            switch (e) {
            case Pd.BSC:
                return {
                    ...t,
                    extraInsufficientBalance: n.insufficientBalance,
                    extraButtonDisplayValue: n.buttonDisplayValue,
                    extraIncludeExitStrategies: n.includeExitStrategies,
                    extraSelectedPreset: n.selectedPreset,
                    extraButtonValue: n.buttonValue
                };
            case Pd.SOLANA:
                return {
                    ...r,
                    extraInsufficientBalance: a.insufficientBalance,
                    extraButtonDisplayValue: a.buttonDisplayValue,
                    extraIncludeExitStrategies: a.includeExitStrategies,
                    extraSelectedPreset: a.selectedPreset,
                    extraButtonValue: a.buttonValue
                }
            }
        }
        ), [t, n, r, a, e])
    }
    )(x)
      , {performBuy: Z, hasAnyWallet: ee, selectedWalletsAddresses: te} = AD()
      , {performBuy: ne, hasAnyWallet: re, selectedWalletsAddresses: ae} = DJ()
      , se = y.useMemo(( () => K8(x, te.length, ae.length)), [ae.length, te.length, x])
      , oe = y.useMemo(( () => K8(x, ee, re)), [re, ee, x])
      , [le,ie] = JC(!1, 200, !1)
      , [ce,de] = JC(!1, 200, !1)
      , ue = y.useMemo(( () => {
        switch (x) {
        case Pd.BSC:
            {
                const e = h ?? p ?? u;
                return fg(x, e, p === e ? {
                    type: "fourmeme",
                    tokenAddress: s
                } : null)
            }
        case Pd.SOLANA:
            return fg(x, d ?? c ?? i ?? u, null)
        }
    }
    ), [p, d, h, c, u, i, s, x]);
    k$(x === Pd.SOLANA ? ue : null);
    const pe = y.useCallback(( () => {
        switch (D) {
        case KX.OPEN_MARKET:
            return void _({
                marketId: ue,
                tradePageOrigin: nT.TRACHES_POST_BUY
            });
        case KX.NEW_TAB_OPEN_MARKET:
            return void window.open(QE(ue, nT.TRACHES_POST_BUY) ?? "", "_blank")
        }
    }
    ), [D, ue, _])
      , he = y.useCallback((async e => {
        np.info("Trenches standard buy button clicked", {
            trenchesChain: x,
            buttonValue: G,
            tokenAddress: s
        }),
        e.stopPropagation(),
        e.preventDefault();
        const n = {
            originWidget: Dp.TRENCHES,
            buttonValue: G,
            insufficientBalance: F,
            quoteTokenAddr: l,
            marketId: ue
        };
        if (!G)
            return np.warn("Order hasn't been sent - missing button value", {
                orderInfo: n
            }),
            E && B({
                message: uu.quickBuyIsZero,
                type: "warning"
            }, "no-amount-error"),
            void pe();
        if (F)
            return np.warn("Order hasn't been sent - insufficient balance", {
                orderInfo: n
            }),
            E && B({
                message: uu.insufficientBalance,
                type: "warning"
            }, "no-balance-error"),
            void pe();
        t(!0),
        ((null == U ? void 0 : U.preventDoubleClick) ?? y$) && ie(!0);
        try {
            switch (x) {
            case Pd.BSC:
                if (zb($))
                    throw new Error("Inferno mode on BSC not supported");
                if (!l)
                    throw new Error("Missing quote currency on BSC");
                if (!poe.has(l))
                    return np.warn("Order hasn't been sent - unsupported bsc quote", {
                        orderInfo: n
                    }),
                    void B({
                        message: uu.quickBuyNotAvailable,
                        type: "error"
                    }, "perform-trade-error");
                ne({
                    value: G,
                    baseCurrency: s,
                    poolQuoteCurrency: l,
                    baseSymbol: m,
                    quoteSymbol: "BNB",
                    marketId: ue,
                    padreAvatarUrl: g,
                    presetName: $,
                    originWidget: Dp.TRENCHES,
                    exitStrategies: z && W.length ? W : null
                });
                break;
            case Pd.SOLANA:
                Z({
                    value: G,
                    baseCurrency: s,
                    baseTokenType: o,
                    poolQuoteCurrency: l ?? qc,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: m,
                    quoteSymbol: "SOL",
                    marketId: ue,
                    padreAvatarUrl: g,
                    presetName: $,
                    originWidget: Dp.TRENCHES,
                    exitStrategies: z && W.length ? W : null
                })
            }
            pe()
        } catch (fNe) {
            np.error("Order hasn't been sent - exception thrown during processing order", {
                e: fNe,
                orderInfo: n
            }),
            B({
                message: uu.unknownError,
                type: "error"
            }, "perform-trade-error")
        } finally {
            t(!1)
        }
    }
    ), [G, F, t, null == U ? void 0 : U.preventDoubleClick, E, pe, B, ie, x, ne, s, o, l, m, ue, g, $, z, W, Z])
      , me = y.useCallback((async e => {
        np.info("Trenches extra buy button clicked", {
            trenchesChain: x,
            extraButtonValue: Q,
            tokenAddress: s
        }),
        e.stopPropagation(),
        e.preventDefault();
        const t = {
            originWidget: Dp.TRENCHES,
            extraButtonValue: Q,
            extraInsufficientBalance: q,
            quoteTokenAddr: l,
            marketId: ue
        };
        if (!Q)
            return np.warn("Order hasn't been sent - missing button value", {
                orderInfo: t
            }),
            E && B({
                message: uu.quickBuyIsZero,
                type: "warning"
            }, "no-amount-error"),
            void pe();
        if (q)
            return np.warn("Order hasn't been sent - insufficient balance", {
                orderInfo: t
            }),
            E && B({
                message: uu.insufficientBalance,
                type: "warning"
            }, "no-balance-error"),
            void pe();
        r(!0),
        ((null == U ? void 0 : U.preventDoubleClick) ?? y$) && de(!0);
        try {
            switch (x) {
            case Pd.BSC:
                if (zb(X))
                    throw new Error("Inferno mode on BSC not supported");
                if (!l)
                    throw new Error("Missing quote currency on BSC");
                if (!poe.has(l))
                    return np.warn("Order hasn't been sent - bsc unsupported quote", {
                        orderInfo: t
                    }),
                    void B({
                        message: uu.quickBuyNotAvailable,
                        type: "error"
                    }, "perform-trade-error");
                ne({
                    value: Q,
                    baseCurrency: s,
                    poolQuoteCurrency: l,
                    baseSymbol: m,
                    quoteSymbol: "BNB",
                    marketId: ue,
                    padreAvatarUrl: g,
                    presetName: X,
                    originWidget: Dp.TRENCHES,
                    exitStrategies: Y && W.length ? W : null
                });
                break;
            case Pd.SOLANA:
                Z({
                    value: Q,
                    baseCurrency: s,
                    baseTokenType: o,
                    poolQuoteCurrency: l ?? qc,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: m,
                    quoteSymbol: "SOL",
                    marketId: ue,
                    padreAvatarUrl: g,
                    presetName: X,
                    originWidget: Dp.TRENCHES,
                    exitStrategies: Y && W.length ? W : null
                })
            }
            pe()
        } catch (fNe) {
            np.error("Order hasn't been sent - exception thrown during processing order", {
                e: fNe,
                orderInfo: t
            }),
            B({
                message: uu.unknownError,
                type: "error"
            }, "perform-trade-error")
        } finally {
            r(!1)
        }
    }
    ), [Q, q, r, null == U ? void 0 : U.preventDoubleClick, E, pe, B, de, x, X, ne, s, o, l, m, ue, g, Y, W, Z])
      , ge = y.useCallback(( () => {
        a(!0)
    }
    ), [a])
      , xe = y.useCallback(( () => {
        a(!1)
    }
    ), [a])
      , be = y.useMemo(( () => e => {
        const t = b ?? e.palette.success.main
          , n = f ?? (An(t, "#fff") > 4.5 ? "#ffffff" : "#111111")
          , r = A === zX.LARGE ? 1.5 : A === zX.MEGA ? 2 : 1;
        return {
            zIndex: 10,
            color: n,
            transition: "none",
            borderRadius: j === GX.ROUNDED ? 5 : .5,
            px: w >= 0 ? 1 : w >= -14 ? .5 : 0,
            minWidth: (90 + w) * r * (P ? foe : 1),
            height: 32 * r,
            backgroundColor: t,
            borderColor: Me(t, .08),
            opacity: lb(1 - .02 * T, {
                min: R ? .2 : 0,
                max: 1
            }),
            "&:hover": {
                borderColor: Me(t, .08),
                backgroundColor: Me(t, .15)
            },
            "&:focus": {
                borderColor: Me(t, .08),
                backgroundColor: Me(t, .15)
            },
            "&:disabled": {
                backgroundColor: e.palette.background.disabled,
                borderColor: e.palette.background.disabled,
                color: e.palette.text.label
            },
            "& .MuiButton-startIcon": {
                marginRight: w >= 0 ? "8px" : "2px"
            }
        }
    }
    ), [b, A, j, w, T, f, P])
      , fe = y.useMemo(( () => e => {
        const t = O ?? e.palette.success.main
          , n = L ?? (An(t, "#fff") > 4.5 ? "#ffffff" : "#111111")
          , r = A === zX.LARGE ? 1.5 : A === zX.MEGA ? 2 : 1;
        return {
            zIndex: 10,
            color: n,
            transition: "none",
            borderRadius: j === GX.ROUNDED ? 5 : .5,
            px: w >= 0 ? 1 : w >= -14 ? .5 : 0,
            minWidth: (90 + w) * r * foe,
            height: 32 * r,
            backgroundColor: t,
            borderColor: Me(t, .08),
            opacity: lb(1 - .02 * T, {
                min: R ? .2 : 0,
                max: 1
            }),
            "&:hover": {
                borderColor: Me(t, .08),
                backgroundColor: Me(t, .15)
            },
            "&:focus": {
                borderColor: Me(t, .08),
                backgroundColor: Me(t, .15)
            },
            "&:disabled": {
                backgroundColor: e.palette.background.disabled,
                borderColor: e.palette.background.disabled,
                color: e.palette.text.label
            },
            "& .MuiButton-startIcon": {
                marginRight: w >= 0 ? "8px" : "2px"
            }
        }
    }
    ), [O, A, j, w, T, L])
      , ve = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        e.stopPropagation())
    }
    ), [])
      , Se = y.useMemo(( () => e ? "Buying" : `${(H ?? 0) > 1 ? LI(H ?? 0, {
        collapseExponent: (H ?? 0) > 1e6,
        symbol: "",
        padSymbol: !0,
        symbolPosition: yI.END,
        noTrailingZeros: !1,
        maxPrecision: 3
    }) : H ?? 0}`), [H, e])
      , ye = y.useMemo(( () => n ? "Buying" : `${(K ?? 0) > 1 ? LI(K ?? 0, {
        collapseExponent: (K ?? 0) > 1e6,
        symbol: "",
        padSymbol: !0,
        symbolPosition: yI.END,
        noTrailingZeros: !1,
        maxPrecision: 3
    }) : K ?? 0}`), [K, n])
      , ke = y.useMemo(( () => e => ({
        display: "flex",
        height: "100%",
        borderLeft: "1px solid transparent",
        justifyContent: "flex-end",
        color: b ?? e.palette.success.main,
        ...N ? {
            border: `1px solid ${b ?? e.palette.success.main}`,
            borderRadius: "4px",
            height: `calc(100% - ${2 * boe}px)`
        } : {},
        "&:hover": {
            background: `${e.palette.text.value}08`,
            ...M ? {
                boxShadow: "0px 0px 40px #FFFFFF33"
            } : {
                backdropFilter: "blur(1px)"
            }
        }
    })), [b, N, M])
      , Ce = y.useMemo(( () => e => ({
        display: "flex",
        height: "100%",
        borderLeft: "1px solid transparent",
        justifyContent: "flex-end",
        color: O ?? e.palette.success.main,
        ...N ? {
            border: `1px solid ${O ?? e.palette.success.main}`,
            borderRadius: "4px",
            height: `calc(100% - ${2 * boe}px)`
        } : {},
        "&:hover": {
            background: `${e.palette.text.value}08`,
            ...M ? {
                boxShadow: "0px 0px 40px #FFFFFF33"
            } : {
                backdropFilter: "blur(1px)"
            }
        }
    })), [O, N, M]);
    return E ? v.jsxs(S, {
        gap: N ? .75 : 0,
        direction: "row",
        position: "absolute",
        height: "100%",
        width: `calc(${P ? xoe : goe} + ${w * (P ? foe : 1)}px)`,
        top: N ? boe : 0,
        right: N ? boe : 0,
        zIndex: 3,
        justifyContent: "flex-end",
        children: [P && v.jsx(C, {
            className: Nee,
            component: "span",
            width: "50%",
            sx: Ce,
            onClick: ce ? void 0 : me,
            onKeyDown: ve,
            alignItems: I === qX.MOXIA ? "flex-end" : "flex-start",
            children: v.jsxs(S, {
                direction: "row",
                gap: .5,
                alignItems: "center",
                pr: 1,
                pb: I === qX.MOXIA ? 1.5 : 0,
                pt: I === qX.ORIGINAL ? 1.5 : 0,
                children: [n ? v.jsx(J, {
                    color: "inherit",
                    size: moe
                }) : v.jsx(ay, {
                    color: "inherit",
                    size: 14
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "inherit",
                    fontWeight: wu.SEMIBOLD,
                    children: ye
                })]
            })
        }), v.jsx(C, {
            className: Nee,
            component: "span",
            width: P ? "50%" : "100%",
            sx: ke,
            onClick: le ? void 0 : he,
            onKeyDown: ve,
            alignItems: I === qX.MOXIA ? "flex-end" : "flex-start",
            children: v.jsxs(S, {
                direction: "row",
                gap: .5,
                alignItems: "center",
                pr: 1,
                pb: I === qX.MOXIA ? 1.5 : 0,
                pt: I === qX.ORIGINAL ? 1.5 : 0,
                children: [e ? v.jsx(J, {
                    color: "inherit",
                    size: moe
                }) : v.jsx(ay, {
                    color: "inherit",
                    size: 14
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "inherit",
                    fontWeight: wu.SEMIBOLD,
                    children: Se
                })]
            })
        })]
    }) : v.jsxs(S, {
        direction: "row",
        top: I === qX.ORIGINAL ? 11 : void 0,
        bottom: I === qX.MOXIA ? 7 : void 0,
        right: I === qX.ORIGINAL ? 9 : 7,
        position: "absolute",
        gap: .5,
        children: [P && v.jsx(GC, {
            disableHoverListener: !0,
            title: 0 === se ? "No wallet selected" : q ? "Insufficient balance" : !1 === oe ? "You don't have compatible wallets" : "",
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    className: Mee,
                    tabIndex: -1,
                    onKeyDown: ve,
                    variant: "secondary",
                    size: "xsmall",
                    color: "success",
                    sx: fe,
                    onClick: me,
                    onMouseOver: ge,
                    onMouseOut: xe,
                    disabled: ce || q || !se || !K || !1 === oe,
                    startIcon: n ? null : v.jsx(ay, {
                        color: "inherit",
                        size: 14
                    }),
                    endIcon: n ? v.jsx(J, {
                        color: "inherit",
                        size: moe
                    }) : null,
                    children: v.jsx(k, {
                        noWrap: !0,
                        variant: "paragraph1",
                        color: "inherit",
                        children: ye
                    })
                })
            })
        }), v.jsx(GC, {
            disableHoverListener: !0,
            title: 0 === se ? "No wallet selected" : F ? "Insufficient balance" : !1 === oe ? "You don't have compatible wallets" : "",
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    className: Mee,
                    tabIndex: -1,
                    onKeyDown: ve,
                    variant: "secondary",
                    size: "xsmall",
                    color: "success",
                    sx: be,
                    onClick: he,
                    onMouseOver: ge,
                    onMouseOut: xe,
                    disabled: le || F || !se || !H || !1 === oe,
                    startIcon: e ? null : v.jsx(ay, {
                        color: "inherit",
                        size: 14
                    }),
                    endIcon: e ? v.jsx(J, {
                        color: "inherit",
                        size: moe
                    }) : null,
                    children: v.jsx(k, {
                        noWrap: !0,
                        variant: "paragraph1",
                        color: "inherit",
                        children: Se
                    })
                })
            })
        })]
    })
}
))
  , moe = 14
  , goe = "33%"
  , xoe = "50%"
  , boe = 4
  , foe = 1.5
  , voe = y.memo(( ({formattedValue: e, valueColor: t, Icon: n, iconColor: r, tooltipTitle: a, trenchesFontMode: s, reverse: o=!0, trenchesTileLayout: l=qX.ORIGINAL, isMoxiaMainStat: i=!1, prefix: c, alignItems: d, forceSmall: u=!1}) => {
    const p = t ?? (l === qX.MOXIA ? "text.main" : "text.value")
      , h = y.useMemo(( () => !u && s === $X.LARGE_IMPORTANT_STATS), [s, u])
      , m = y.useMemo(( () => Coe(h, e)), [e, h])
      , g = y.useMemo(( () => ({
        ...h && i ? {
            fontSize: 16
        } : {},
        minWidth: o ? m : 0,
        direction: "ltr"
    })), [h, i, m, o]);
    return v.jsx(GC, {
        title: a,
        noEnterDelay: !1,
        children: v.jsxs(S, {
            direction: o ? "row-reverse" : "row",
            alignItems: d ?? (i && h ? "flex-end" : "center"),
            gap: koe,
            justifyContent: o ? "flex-start" : "flex-end",
            height: u ? 12 : void 0,
            children: [c && v.jsx(k, {
                variant: "paragraph3",
                color: r ?? "text.value",
                children: c
            }), "string" == typeof n ? v.jsx(k, {
                variant: h ? "paragraph1" : "paragraph3",
                color: r ?? "text.value",
                children: n
            }) : v.jsx(C, {
                display: "flex",
                children: v.jsx(n, {
                    color: r,
                    size: u ? 13 : h ? yoe : Soe
                })
            }), v.jsx(k, {
                variant: h && !i ? "paragraph2" : "paragraph3",
                color: p,
                fontWeight: h ? wu.MEDIUM : void 0,
                sx: g,
                children: e
            })]
        })
    })
}
))
  , Soe = 14
  , yoe = 16
  , koe = .25
  , Coe = (e, t) => [...t].reduce(( (t, n) => t + ("," === n || "." === n ? 4 : e ? 9 : 8)), 0)
  , Aoe = y.memo(( ({weightData: e, ...t}) => v.jsx(S, {
    gap: .5,
    ...t,
    children: v.jsx(k, {
        variant: "bodyMediumRegular",
        color: "text.meta",
        children: e.label
    })
})))
  , woe = y.memo(( ({leftWeight: e, rightWeight: t, barHeight: n=joe, hoverCursor: r="auto", ...a}) => {
    const s = D()
      , o = y.useMemo(( () => !e.value && !t.value), [e, t])
      , l = y.useMemo(( () => {
        if (!e.value && !t.value)
            return 0;
        if (null === e.value)
            return 0;
        if (null === t.value)
            return 100;
        const n = e.value + t.value;
        return e.value / n * Toe
    }
    ), [e, t])
      , [i,c] = y.useMemo(( () => {
        const n = [Ud, Ud];
        return null !== e.value && (n[0] = e.valueDisplayRenderer ? e.valueDisplayRenderer(e.value) : e.value),
        null !== t.value && (n[1] = t.valueDisplayRenderer ? t.valueDisplayRenderer(t.value) : t.value),
        n
    }
    ), [e, t]);
    return v.jsxs(S, {
        flex: "1 1 100%",
        gap: .5,
        ...a,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [e.label && v.jsx(Aoe, {
                weightData: e,
                alignItems: "start"
            }), t.label && v.jsx(Aoe, {
                weightData: t,
                alignItems: "end"
            })]
        }), v.jsxs(S, {
            position: "relative",
            height: 12,
            children: [v.jsx(Z, {
                disabled: o,
                value: l,
                max: Toe,
                sx: Eoe(s.palette.positive.main, s.palette.text.disabled, n || joe, r)
            }), v.jsx(Z, {
                disabled: o,
                value: Toe - l - Ioe,
                max: Toe,
                sx: {
                    ...Eoe(s.palette.negative.main, s.palette.text.disabled, n || joe, r),
                    transform: "rotate(180deg)"
                }
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [e.label && v.jsx(k, {
                color: null !== e.value ? s.palette.text.value : s.palette.text.label,
                variant: "paragraph3",
                ...Nu,
                children: i
            }), t.label && v.jsx(k, {
                color: null !== t.value ? s.palette.text.value : s.palette.text.label,
                variant: "paragraph3",
                ...Nu,
                children: c
            })]
        })]
    })
}
))
  , joe = "4px"
  , Toe = 100
  , Ioe = 1
  , Eoe = (e, t, n, r="auto") => ({
    position: "absolute",
    "&.MuiSlider-root": {
        paddingY: .5
    },
    "& .MuiSlider-thumb": {
        display: "none"
    },
    "& .MuiSlider-rail": {
        color: "transparent",
        height: n
    },
    "& .MuiSlider-track": {
        color: e,
        height: n,
        border: "none",
        transitionProperty: "left, bottom, width, height, color"
    },
    "&:hover": {
        cursor: r
    },
    "&.Mui-disabled": {
        "& .MuiSlider-rail": {
            color: "transparent"
        },
        "& .MuiSlider-track": {
            color: t,
            transitionProperty: "left, bottom, width, height, color",
            transitionDuration: "300ms"
        }
    }
})
  , Moe = y.memo(( ({totalBuys: e, totalSells: t, totalTxns: n}) => {
    const r = D()
      , a = vw()
      , {trenchesTileLayout: s} = xne();
    return v.jsx(GC, {
        title: v.jsxs(S, {
            gap: .5,
            minWidth: Ooe,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    ...Loe,
                    children: "Total txns"
                }), v.jsx(k, {
                    ...Loe,
                    color: "text.value",
                    children: OI(n, {
                        precision: 0,
                        symbol: ""
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    ...Loe,
                    children: "Buys"
                }), v.jsx(k, {
                    ...Loe,
                    color: "text.value",
                    children: OI(e, {
                        precision: 0,
                        symbol: ""
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    ...Loe,
                    children: "Sells"
                }), v.jsx(k, {
                    ...Loe,
                    color: "text.value",
                    children: OI(t, {
                        precision: 0,
                        symbol: ""
                    })
                })]
            })]
        }),
        children: v.jsxs(S, {
            direction: s !== qX.MOXIA || a ? "row" : "column",
            gap: s !== qX.MOXIA || a ? .5 : 0,
            alignItems: s !== qX.MOXIA || a ? "center" : "flex-end",
            width: s === qX.MOXIA ? void 0 : Noe,
            children: [v.jsx(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "flex-end",
                flexGrow: 1,
                children: v.jsxs(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    noWrap: !0,
                    children: [v.jsx("span", {
                        style: {
                            color: r.palette.text.label
                        },
                        children: "TX"
                    }), ` ${OI(n, {
                        collapseExponent: n >= 1e6,
                        precision: n >= 1e6 ? 2 : 0,
                        symbol: ""
                    })}`]
                })
            }), v.jsx(S, {
                width: Poe,
                mt: s !== qX.MOXIA || a ? 0 : -.5,
                children: v.jsx(woe, {
                    barHeight: "3px",
                    hoverCursor: "pointer",
                    leftWeight: {
                        value: e
                    },
                    rightWeight: {
                        value: t
                    }
                })
            })]
        })
    })
}
))
  , Noe = 200
  , Poe = 28
  , Ooe = 155
  , Loe = {
    variant: "paragraph3",
    color: "text.label"
}
  , Roe = y.memo(( ({totalDevMigrationsCount: e}) => {
    const {t: t} = we()
      , n = D()
      , {trenchesFontMode: r} = xne();
    return v.jsx(GC, {
        title: t("Number of bonded tokens created by the same dev"),
        children: v.jsxs(S, {
            ...Lee,
            minWidth: e >= 10 ? 26 : 20,
            justifyContent: "flex-start",
            alignItems: "center",
            children: [v.jsx(C, {
                display: "flex",
                width: 14,
                children: v.jsx(vf, {
                    size: 14 + (r === $X.LARGE_IMPORTANT_STATS ? 2 : 0),
                    color: e >= 2 ? n.palette.gold[500] : n.palette.text.label
                })
            }), v.jsx(k, {
                variant: r === $X.LARGE_IMPORTANT_STATS ? "paragraph2" : "paragraph3",
                color: e >= 2 ? n.palette.gold[500] : n.palette.text.value,
                fontWeight: r === $X.LARGE_IMPORTANT_STATS ? 500 : void 0,
                ...Nu,
                children: OI(e, {
                    precision: 0,
                    symbol: ""
                })
            })]
        })
    })
}
))
  , Doe = y.memo(( ({devFundTxnExchange: e, devFundTxnFromAddress: t, devFundTxnHash: n, devFundTxnSolAmount: r, devFundTxnTimestamp: a, originalTitle: s, devAddress: o, titleColor: l, emoji: c, customWalletName: d}) => {
    const {t: u} = we()
      , p = D()
      , h = y.useMemo(( () => n ? AA(n, Pd.SOLANA) : null), [n])
      , m = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        h && window.open(h, "_blank", "noopener,noreferrer")
    }
    ), [h])
      , g = y.useMemo(( () => ({
        color: p.palette.text.value
    })), [p.palette.text.value])
      , x = y.useMemo(( () => d ? {
        color: p.palette.gold[500]
    } : {
        ml: -.5
    }), [d, p.palette.gold]);
    return v.jsxs(S, {
        gap: .5,
        minWidth: Boe,
        divider: Foe,
        p: .25,
        onClick: Ww,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1.5,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [d && v.jsx(ZT, {
                    emoji: c ?? rI,
                    size: 14
                }), v.jsx(cA, {
                    address: o,
                    customName: d ?? oA(o, {
                        firstPartLength: 7,
                        finalPartLength: 6
                    }),
                    stopPropagation: !0,
                    preventDefault: !0,
                    labelSx: x,
                    labelVariant: "paragraph3",
                    hideIcon: !0,
                    maxWidth: 150
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                color: l,
                children: s
            })]
        }), null === t || null === r || null === a || null === n ? null : v.jsxs(S, {
            gap: .5,
            children: [v.jsx(k, {
                ..._oe,
                color: "text.label",
                children: u("Dev wallet funded")
            }), v.jsxs(S, {
                ...Uoe,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(k, {
                        ..._oe,
                        color: "text.label",
                        children: u("From")
                    }), v.jsx(C, {
                        component: "a",
                        href: h ?? "",
                        onClick: m,
                        target: "_blank",
                        sx: Woe,
                        children: v.jsx(tE, {
                            chain: Pd.SOLANA,
                            forceMonochromatic: !0,
                            defaultColor: "inherit",
                            size: 14
                        })
                    })]
                }), v.jsx(cA, {
                    stopPropagation: !0,
                    labelVariant: "paragraph3",
                    labelSx: g,
                    address: t,
                    customName: e ? `${e ? `(${b5(e)}) ` : ""} ${t}` : void 0,
                    hideIcon: !0
                })]
            }), v.jsxs(S, {
                ...Uoe,
                children: [v.jsx(k, {
                    ..._oe,
                    color: "text.label",
                    children: u("With")
                }), v.jsxs(k, {
                    ..._oe,
                    children: [`${UI(r.toFixed(3))}`, v.jsx(dk, {
                        size: 14
                    })]
                })]
            }), v.jsxs(S, {
                ...Uoe,
                pr: .25,
                children: [v.jsx(k, {
                    ..._oe,
                    color: "text.label",
                    children: u("On")
                }), v.jsxs(S, {
                    gap: .25,
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        ..._oe,
                        color: "text.label",
                        children: `${i(1e3 * a).format("MMM DD HH:mm")}`
                    }), v.jsx(mE, {
                        ..._oe,
                        gap: .25,
                        ts: a,
                        suffixAdornment: "ago"
                    })]
                })]
            })]
        })]
    })
}
))
  , Boe = 200
  , _oe = {
    variant: "paragraph3",
    color: "text.value",
    sx: {
        display: "flex",
        alignItems: "center"
    }
}
  , Uoe = {
    justifyContent: "space-between",
    gap: 1,
    direction: "row"
}
  , Woe = {
    display: "inline-flex",
    direction: "row",
    alignItems: "center",
    justifyContent: "center",
    height: 16,
    cursor: "pointer",
    textDecoration: "none",
    color: "text.label",
    transition: "200ms color ease-in-out",
    "&:hover": {
        color: "text.value"
    }
}
  , Foe = v.jsx(Ee, {
    flexItem: !0
})
  , Voe = y.memo(( ({freshWalletBuysSol: e, freshWalletBuysCount: t}) => {
    const {trenchesTileLayout: n, trenchesFontMode: r} = xne()
      , {t: a} = we();
    return v.jsx(voe, {
        formattedValue: NI(e, {
            symbol: "",
            precision: e > 10 ? 0 : 1
        }),
        tooltipTitle: v.jsxs(S, {
            gap: .5,
            minWidth: Hoe,
            children: [v.jsx(k, {
                ...zoe,
                color: "text.label",
                children: a("Fresh wallets buys")
            }), v.jsxs(S, {
                ...$oe,
                children: [v.jsx(k, {
                    ...zoe,
                    color: "text.label",
                    children: a("Volume")
                }), v.jsxs(k, {
                    ...zoe,
                    sx: {
                        display: "flex",
                        alignItems: "center",
                        gap: .25
                    },
                    children: [v.jsx(dk, {
                        size: 12
                    }), NI(e, {
                        symbol: "",
                        removeTrailingZerosPrecision: e >= 100 ? 0 : 1
                    })]
                })]
            }), v.jsxs(S, {
                ...$oe,
                children: [v.jsx(k, {
                    ...zoe,
                    color: "text.label",
                    children: a("Count")
                }), v.jsx(k, {
                    ...zoe,
                    children: t
                })]
            })]
        }),
        Icon: Mf,
        reverse: n === qX.ORIGINAL,
        trenchesFontMode: r
    })
}
))
  , Hoe = 150
  , zoe = {
    variant: "paragraph3",
    color: "text.value"
}
  , $oe = {
    direction: "row",
    justifyContent: "space-between",
    gap: 1
}
  , Goe = y.memo(( ({marketCapColor: e, fdvFormatted: t, compact: n=!1}) => {
    const r = D()
      , {trenchesTileLayout: a, trenchesFontMode: s} = xne()
      , {t: o} = we();
    return v.jsx(voe, {
        formattedValue: t,
        tooltipTitle: o("Market cap"),
        valueColor: e,
        Icon: "MC",
        iconColor: r.palette.text.label,
        trenchesFontMode: a === qX.ORIGINAL && n ? $X.NORMAL : s,
        reverse: a === qX.ORIGINAL && !n,
        trenchesTileLayout: a,
        isMoxiaMainStat: !n
    })
}
))
  , qoe = y.memo(( ({totalProHolders: e}) => {
    const {t: t} = we()
      , {trenchesTileLayout: n, trenchesFontMode: r} = xne();
    return v.jsx(voe, {
        formattedValue: NI(e, {
            symbol: "",
            precision: 0
        }),
        tooltipTitle: t("Pro holders"),
        Icon: qS,
        reverse: n === qX.ORIGINAL,
        trenchesFontMode: r
    })
}
))
  , Koe = y.memo(( ({formattedValue: e}) => {
    const {trenchesTileLayout: t, trenchesFontMode: n} = xne()
      , r = D()
      , {t: a} = we();
    return v.jsx(voe, {
        formattedValue: e,
        tooltipTitle: a("Total fees"),
        Icon: dk,
        iconColor: r.palette.text.label,
        trenchesFontMode: n,
        reverse: t === qX.ORIGINAL,
        trenchesTileLayout: t,
        prefix: "F",
        alignItems: t === qX.MOXIA ? "flex-end" : "center",
        forceSmall: t === qX.MOXIA
    })
}
))
  , Yoe = y.memo(( ({formattedValue: e}) => {
    const {trenchesTileLayout: t, trenchesFontMode: n} = xne()
      , r = D()
      , {t: a} = we();
    return v.jsx(voe, {
        formattedValue: e,
        tooltipTitle: a("Volume"),
        Icon: "V",
        iconColor: r.palette.text.label,
        trenchesFontMode: n,
        reverse: t === qX.ORIGINAL,
        trenchesTileLayout: t,
        isMoxiaMainStat: !0
    })
}
))
  , Xoe = (e, t, n) => {
    const r = D()
      , a = y.useMemo(( () => IA(e, n, r.palette.text.value)), [e, r.palette.text.value, n])
      , s = LI(e, {
        symbol: "$",
        padSymbol: !1,
        symbolPosition: yI.START,
        maxPrecision: e >= 1e4 ? 0 : 1,
        minPrecision: e >= 1e4 ? 0 : 1,
        collapseExponent: !0,
        desiredDigits: e >= 1e6 ? 2 : t ?? 1
    });
    return y.useMemo(( () => ({
        marketCapColor: a,
        fdvFormatted: s
    })), [a, s])
}
  , Qoe = (e, t) => LI(e, {
    symbol: "$",
    padSymbol: !1,
    symbolPosition: yI.START,
    maxPrecision: 0,
    minPrecision: 0,
    collapseExponent: !0,
    desiredDigits: e >= 1e6 ? 2 : t ?? 1
})
  , Zoe = e => {
    if (null === e)
        return null;
    if (e < .001)
        return "0";
    return LI(e, {
        symbol: "",
        collapseExponent: !0,
        maxPrecision: 3,
        removeTrailingZerosPrecision: 0
    })
}
  , Joe = y.memo(( ({totalHolders: e, fdvInUsd: t, volumeInUsd: n, totalProHolders: r, freshWalletBuysCount: a, freshWalletBuysSol: s, totalSolFees: o}) => {
    const {t: l} = we()
      , i = fw()
      , {visibleSections: c} = Cne()
      , {trenchesFontMode: d, statsDesiredDigits: u} = xne()
      , {marketCapThresholds: p} = bA()
      , h = Xoe(t, u, p)
      , m = Qoe(n, u)
      , g = Zoe(o);
    return v.jsxs(S, {
        gap: i ? Pee : .5,
        direction: i ? "row" : "column-reverse",
        children: [v.jsxs(S, {
            ...ele,
            children: [c.has(vne.MARKET_CAP) && v.jsx(Goe, {
                ...h
            }), c.has(vne.VOLUME) && v.jsx(Yoe, {
                formattedValue: m
            }), c.has(vne.GLOBAL_FEES) && null !== g && v.jsx(Koe, {
                formattedValue: g
            }), c.has(vne.TOTAL_HOLDERS) && v.jsx(voe, {
                formattedValue: NI(e, {
                    symbol: "",
                    precision: 0
                }),
                tooltipTitle: l("Total holders"),
                Icon: CS,
                trenchesFontMode: d
            })]
        }), v.jsxs(S, {
            ...ele,
            justifyContent: i ? "flex-end" : "flex-start",
            minHeight: c.has(vne.PRO_HOLDERS) || c.has(vne.FRESH_WALLET_BUYS) ? 15 : 0,
            children: [c.has(vne.FRESH_WALLET_BUYS) && !!s && v.jsx(Voe, {
                freshWalletBuysSol: s,
                freshWalletBuysCount: a
            }), c.has(vne.PRO_HOLDERS) && null !== r && r > 0 && v.jsx(qoe, {
                totalProHolders: r
            })]
        })]
    })
}
))
  , ele = {
    direction: "row",
    justifyContent: "flex-end",
    gap: Pee
}
  , tle = y.memo(( ({borderColor: e, color: t, Icon: n, formattedValue: r, tooltipTitle: a, iconSize: s=nle, prefixValue: o, height: l=rle, suffix: i, interactiveTooltipCallback: c}) => {
    const d = y.useMemo(( () => t => ({
        borderRadius: 3,
        px: "5px",
        gap: .5,
        border: `1px solid ${e ?? t.palette.background.borderMain}`,
        height: l
    })), [e, l]);
    return v.jsx(GC, {
        title: a ?? "",
        placement: "bottom",
        disableInteractive: !c,
        ...c || {},
        noEnterDelay: !1,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "center",
            sx: d,
            children: [v.jsx(n, {
                size: s,
                color: t
            }), o && v.jsx(k, {
                variant: "paragraph3",
                color: t,
                ...Nu,
                children: o
            }), o && null !== r && v.jsx(k, {
                variant: "paragraph3",
                color: t,
                ...Nu,
                children: hM
            }), v.jsx(k, {
                variant: "paragraph3",
                color: t,
                ...Nu,
                noWrap: !0,
                children: r
            }), i]
        })
    })
}
))
  , nle = 12
  , rle = 24
  , ale = y.memo(( ({backgroundColor: e, devHoldingPcnt: t, top10HoldingPcnt: n, insidersHoldingPcnt: r, bundlesHoldingPcntAth: a, bundlesHoldingPcntCurrent: s, totalBundlesCount: o, totalSolSpentInBundles: l, totalTokenBoughtInBundles: i, totalSupply: d, devHolding: u, devHoldingAth: p, totalDevMigrationsCount: h, isDexscreenerPaid: m, wasRecentlyBoostedOnDexscreener: g, groupHoldings: x, dexBannerUrl: b, snipersHoldingPcnt: f, totalSnipers: A, fdvInUsd: w, dexPaidAt: j, devFundTxnExchange: T, devFundTxnHash: I, devFundTxnFromAddress: E, devFundTxnSolAmount: M, devFundTxnTimestamp: N, devAddress: P, interactiveTooltipCallback: O}) => {
    const {t: L} = we()
      , R = D()
      , B = bw()
      , {trenchesTileLayout: _, statsDesiredDigits: U} = xne()
      , {marketCapThresholds: W} = bA()
      , F = y.useMemo(( () => _ === qX.MOXIA), [_])
      , {visibleSections: V} = Cne()
      , H = Xoe(w, U, W)
      , z = y.useMemo(( () => 0 === u || !!(p && 100 * u < p)), [u, p])
      , $ = V.has(vne.DEX_PAID) && m
      , G = V.has(vne.DEX_BOOSTED) && g && m
      , q = y.useMemo(( () => v.jsxs(S, {
        gap: .25,
        children: [G && v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: L("Token boosted on dexscreener in the last 24h")
        }), $ && v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                children: L("Dex paid")
            }), j && v.jsx(mE, {
                ts: j,
                variant: "inherit",
                color: "inherit"
            })]
        }), v.jsx(uE, {
            bannerUrl: b
        })]
    })), [L, G, $, j, b])
      , K = y.useMemo(( () => v.jsxs(S, {
        gap: .5,
        minWidth: cle,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: L("Bundles holding")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: c.isNil(s) ? Ud : jI(s, {
                    omitSign: !0
                })
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: L("Bundles ATH")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: c.isNil(a) ? Ud : jI(a, {
                    omitSign: !0
                })
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: L("Total bundles")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: null === o ? Ud : o.toFixed(0)
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: L("Bundled total")
            }), v.jsxs(k, {
                variant: "paragraph3",
                color: "text.value",
                sx: {
                    display: "flex",
                    alignItems: "center"
                },
                children: [v.jsx(dk, {
                    size: 14
                }), null === l ? Ud : OI(l, {
                    collapseExponent: !0,
                    symbol: ""
                })]
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: L("Bundled token")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: null !== i && d ? jI(i / d * 100, {
                    omitSign: !0
                }) : Ud
            })]
        })]
    })), [L, a, s, o, l, d, i])
      , Y = y.useMemo(( () => {
        if (!(null == x ? void 0 : x.length))
            return null;
        const e = c.maxBy(x, (e => e.rawTotalBalance));
        return e && 0 !== e.rawTotalBalance ? e : null
    }
    ), [x])
      , X = y.useMemo(( () => Y ? v.jsxs(S, {
        children: [v.jsxs(k, {
            variant: "paragraph3",
            children: [v.jsx("b", {
                children: d ? jI(100 * Y.rawTotalBalance / d, {
                    precision: 5,
                    omitSign: !0
                }) : "-"
            }), " ", "supply is held by"]
        }), v.jsxs(k, {
            variant: "paragraph3",
            children: ["your tracked wallets from ", v.jsx("b", {
                children: Y.name
            }), " group"]
        })]
    }) : ""), [Y, d])
      , {customWalletNames: Q, customWalletEmojis: Z} = rf()
      , {customWalletName: J, customWalletEmoji: ee} = y.useMemo(( () => ({
        customWalletName: Q[P] ?? null,
        customWalletEmoji: Z[P] ?? null
    })), [Z, Q, P]);
    return F ? v.jsxs(S, {
        direction: "row",
        gap: .5,
        height: mle,
        children: [V.has(vne.TOP_10_HOLDERS) && v.jsx(tle, {
            color: Number(n.toFixed(0)) > ple ? R.palette.error.main : R.palette.success.main,
            borderColor: e,
            Icon: Lv,
            formattedValue: jI(n, {
                omitSign: !0,
                precision: 0
            }),
            tooltipTitle: L("Top 10 holders"),
            iconSize: 14
        }), V.has(vne.DEV_HOLDING) && v.jsx(tle, {
            color: z ? R.palette.lavender[500] : R.palette.success.main,
            borderColor: e,
            Icon: Vv,
            formattedValue: z ? "DS" : jI(t, {
                omitSign: !0,
                precision: 0
            }),
            interactiveTooltipCallback: O,
            tooltipTitle: V.has(vne.FUNDED_TXN) ? v.jsx(Doe, {
                devFundTxnHash: I,
                devFundTxnFromAddress: E,
                devFundTxnSolAmount: M,
                devFundTxnTimestamp: N,
                devFundTxnExchange: T,
                devAddress: P,
                originalTitle: L(z ? "Dev sold" : "Dev holding"),
                titleColor: z ? R.palette.lavender[500] : R.palette.success.main,
                emoji: ee,
                customWalletName: J
            }) : L(z ? "Dev sold" : "Dev holding"),
            suffix: (V.has(vne.FUNDED_TXN) || J) && v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [J && v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    children: [v.jsx(ZT, {
                        emoji: ee ?? rI,
                        size: 14
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "gold.500",
                        children: iu(J, 7, 2)
                    })]
                }), T && V.has(vne.FUNDED_TXN) && v.jsx(f5, {
                    exchange: T,
                    size: gle
                }), N && V.has(vne.FUNDED_TXN) && v.jsx(mE, {
                    color: "text.value",
                    variant: "paragraph3",
                    fontWeight: 400,
                    fontSize: 12,
                    gap: .25,
                    ts: N
                })]
            })
        }), (V.has(vne.SNIPERS_HOLDING) || V.has(vne.SNIPERS_COUNT)) && v.jsx(tle, {
            color: null === f ? R.palette.success.main : f > hle ? R.palette.error.main : R.palette.success.main,
            borderColor: e,
            Icon: ES,
            formattedValue: V.has(vne.SNIPERS_HOLDING) ? f ? jI(f, {
                omitSign: !0,
                precision: 0
            }) : null : LI(A, {
                collapseExponent: !1,
                maxPrecision: 0,
                minPrecision: 0,
                symbol: ""
            }),
            tooltipTitle: V.has(vne.SNIPERS_HOLDING) && null !== f && V.has(vne.SNIPERS_COUNT) ? L("Snipers count & holdings") : V.has(vne.SNIPERS_HOLDING) && null !== f ? L("Snipers holdings") : L("Snipers count"),
            prefixValue: V.has(vne.SNIPERS_HOLDING) && V.has(vne.SNIPERS_COUNT) ? LI(A, {
                collapseExponent: !1,
                maxPrecision: 0,
                minPrecision: 0,
                symbol: ""
            }) : void 0
        }), V.has(vne.INSIDERS_HOLDING) && v.jsx(tle, {
            color: r >= ile ? R.palette.error.main : R.palette.success.main,
            borderColor: e,
            Icon: _v,
            formattedValue: jI(r, {
                omitSign: !0,
                precision: 0
            }),
            tooltipTitle: L("Insiders holding")
        }), V.has(vne.BUNDLES) && Number((s ?? 0).toFixed(0)) > 0 && v.jsx(tle, {
            color: (s ?? 0) > dle ? R.palette.error.main : (a ?? 0) > ule ? R.palette.warning.main : R.palette.success.main,
            borderColor: e,
            Icon: Uv,
            formattedValue: c.isNil(s) ? Ud : jI(s, {
                omitSign: !0,
                precision: 0
            }),
            tooltipTitle: K
        }), !(!$ && !G) && v.jsx(tle, {
            color: G ? R.palette.gold[500] : R.palette.success.main,
            borderColor: e,
            Icon: OS,
            formattedValue: G ? "Boost" : "Paid",
            tooltipTitle: q
        }), Y && v.jsx(tle, {
            color: R.palette.gold[500],
            Icon: iy,
            borderColor: e,
            formattedValue: d ? jI(100 * Y.rawTotalBalance / d, {
                precision: 0,
                omitSign: !0
            }) : "",
            tooltipTitle: X
        })]
    }) : v.jsxs(S, {
        direction: "row",
        gap: Pee,
        height: 15,
        children: [V.has(vne.TOP_10_HOLDERS) && v.jsx(GC, {
            title: L("Top 10 holders"),
            noEnterDelay: !1,
            children: v.jsxs(S, {
                ...ole,
                minWidth: 42,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    ...Nu,
                    children: "T10"
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    ...Nu,
                    children: jI(n, {
                        omitSign: !0,
                        precision: n >= 1 ? 0 : 1
                    })
                })]
            })
        }), V.has(vne.DEV_HOLDING) && v.jsx(GC, {
            title: L(z ? "Dev sold" : "Dev holding"),
            noEnterDelay: !1,
            children: v.jsxs(S, {
                ...ole,
                minWidth: z ? 14 : 40,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: z ? "error.main" : "text.label",
                    ...Nu,
                    children: z ? "DS" : "DH"
                }), !z && v.jsx(k, {
                    variant: "paragraph3",
                    color: "success.main",
                    ...Nu,
                    children: jI(t, {
                        omitSign: !0,
                        precision: t >= 1 ? 0 : 1
                    })
                })]
            })
        }), (V.has(vne.SNIPERS_HOLDING) || V.has(vne.SNIPERS_COUNT)) && null !== f && v.jsx(GC, {
            title: V.has(vne.SNIPERS_HOLDING) && V.has(vne.SNIPERS_COUNT) ? L("Snipers count & holdings") : V.has(vne.SNIPERS_HOLDING) ? L("Snipers holdings") : L("Snipers count"),
            noEnterDelay: !1,
            children: v.jsxs(S, {
                ...ole,
                minWidth: V.has(vne.SNIPERS_HOLDING) && V.has(vne.SNIPERS_COUNT) ? 52 : V.has(vne.SNIPERS_COUNT) ? 25 : 35,
                children: [v.jsx(ES, {
                    size: sle,
                    color: f > hle ? R.palette.error.main : void 0
                }), V.has(vne.SNIPERS_COUNT) && v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    ...Nu,
                    children: LI(A, {
                        collapseExponent: !1,
                        maxPrecision: 0,
                        minPrecision: 0,
                        symbol: ""
                    })
                }), V.has(vne.SNIPERS_HOLDING) && V.has(vne.SNIPERS_COUNT) && v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: hM
                }), V.has(vne.SNIPERS_HOLDING) && v.jsx(k, {
                    variant: "paragraph3",
                    color: f > hle ? "error.main" : "text.value",
                    ...Nu,
                    children: jI(f, {
                        omitSign: !0,
                        precision: 0
                    })
                })]
            })
        }), V.has(vne.INSIDERS_HOLDING) && Number(r.toFixed(1)) > 0 && v.jsx(GC, {
            title: L("Insiders holding"),
            noEnterDelay: !1,
            children: v.jsxs(S, {
                ...ole,
                children: [v.jsx(C, {
                    display: "flex",
                    minWidth: sle,
                    children: v.jsx(_v, {
                        size: sle,
                        color: r >= ile ? R.palette.error.main : R.palette.text.label
                    })
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: r >= ile ? "error.main" : "text.value",
                    ...Nu,
                    children: jI(r, {
                        omitSign: !0,
                        precision: r >= 1 ? 0 : 1
                    })
                })]
            })
        }), B && V.has(vne.BUNDLES) && Number((s ?? 0).toFixed(0)) > 0 && v.jsx(GC, {
            title: K,
            noEnterDelay: !1,
            children: v.jsxs(S, {
                ...ole,
                children: [v.jsx(C, {
                    display: "flex",
                    minWidth: sle,
                    children: v.jsx(Uv, {
                        size: sle,
                        color: (s ?? 0) > dle ? R.palette.error.main : (a ?? 0) > ule ? R.palette.warning.main : R.palette.text.label
                    })
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: (s ?? 0) > dle ? "error.main" : (a ?? 0) > ule ? "warning.main" : "text.value",
                    ...Nu,
                    children: c.isNil(s) ? Ud : jI(s, {
                        omitSign: !0,
                        precision: s >= 1 ? 0 : 1
                    })
                })]
            })
        }), V.has(vne.DEV_BONDED) && !!h && v.jsx(Roe, {
            totalDevMigrationsCount: h
        }), !(!$ && !G) && v.jsx(GC, {
            title: q,
            noEnterDelay: !1,
            children: v.jsx(C, {
                display: "flex",
                component: "span",
                sx: lle,
                children: v.jsx(OS, {
                    color: G ? R.palette.gold[500] : R.palette.success.main,
                    size: 14
                })
            })
        }), V.has(vne.EXTRA_MCAP_DISPLAY) && v.jsx(Goe, {
            ...H,
            compact: !0
        }), Y && v.jsx(GC, {
            title: X,
            noEnterDelay: !1,
            children: v.jsx(C, {
                display: "flex",
                width: sle,
                children: v.jsx(iy, {
                    size: sle,
                    color: R.palette.gold[500]
                })
            })
        })]
    })
}
))
  , sle = 12
  , ole = {
    direction: "row",
    minWidth: 35,
    gap: .5,
    alignItems: "center",
    justifyContent: "space-between"
}
  , lle = {
    mt: "1px",
    "&:hover": {
        cursor: "help"
    }
}
  , ile = 5
  , cle = 150
  , dle = 10
  , ule = 10
  , ple = 15
  , hle = 5
  , mle = 24
  , gle = 14
  , xle = y.memo(( ({name: e, symbol: t, tokenAddress: n, translatedName: r, translatedSymbol: a, compact: s=!1}) => {
    const o = D()
      , {allowCopyName: l} = xne()
      , [i,c] = JC(!1, ble)
      , d = y.useMemo(( () => null !== a && a !== t), [a, t])
      , u = y.useMemo(( () => null !== r && r !== e), [r, e])
      , p = d || u
      , h = y.useCallback((e => {
        e.stopPropagation(),
        QC && (ZC(t),
        c(!0))
    }
    ), [t, c]);
    return v.jsx(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        height: 18,
        children: v.jsxs(C, {
            display: "flex",
            alignItems: "center",
            gap: .5,
            position: "relative",
            children: [v.jsx(GC, {
                title: i ? v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    ...Nu,
                    children: ["Copied", v.jsx(G, {
                        sx: fle,
                        color: "success"
                    })]
                }) : e,
                children: v.jsx(k, {
                    variant: "h1",
                    color: "text.value",
                    ...Nu,
                    fontWeight: 500,
                    fontSize: s ? 14 : 16,
                    onClick: l ? h : void 0,
                    sx: vle,
                    noWrap: !0,
                    children: t
                })
            }), v.jsx(C, {
                display: "flex",
                mb: .25,
                pr: .75,
                children: v.jsx(wG, {
                    address: n,
                    customName: e,
                    hideIcon: !0,
                    typographyOverrides: Sle,
                    usePopper: !0,
                    forceStopPropagation: !0
                })
            }), p ? v.jsxs(C, {
                sx: yle,
                children: [d && a && v.jsx(k, {
                    variant: "paragraph3",
                    fontSize: 12,
                    fontWeight: 500,
                    color: o.palette.yellow[500],
                    noWrap: !0,
                    ...Nu,
                    children: a
                }), u && r && v.jsx(k, {
                    variant: "paragraph3",
                    fontSize: 11,
                    fontWeight: 400,
                    color: o.palette.yellow[500],
                    noWrap: !0,
                    ...Nu,
                    children: r
                })]
            }) : null]
        })
    })
}
))
  , ble = 6e3
  , fle = {
    fontSize: "1.5em"
}
  , vle = {
    pb: "1px",
    flexShrink: 0,
    overflow: "visible"
}
  , Sle = {
    variant: "h1",
    fontSize: 14,
    fontWeight: 400,
    flex: 1,
    overflow: "visible"
}
  , yle = {
    position: "absolute",
    left: 0,
    bottom: -8,
    display: "flex",
    alignItems: "flex-end",
    gap: .5,
    pointerEvents: "none",
    whiteSpace: "nowrap"
}
  , kle = y.memo(( ({address: e, marketAddress: t, Icon: n=Ale, iconSize: r=Cle}) => {
    const {settings: a} = rf()
      , s = y.useMemo(( () => lR(e, t ?? null, (null == a ? void 0 : a.twitterSearchExclusions) ?? zI)), [e, t, null == a ? void 0 : a.twitterSearchExclusions])
      , o = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        s && window.open(s, "_blank", "noopener,noreferrer")
    }
    ), [s])
      , l = y.useMemo(( () => ({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        width: r,
        height: r,
        cursor: s ? "pointer" : "default",
        textDecoration: "none",
        color: "text.label",
        "&:hover": {
            color: "primary.main"
        }
    })), [s, r]);
    return v.jsx(C, {
        component: "a",
        href: s || "",
        onClick: o,
        target: "_blank",
        sx: l,
        onAuxClick: o,
        children: v.jsx(n, {
            size: r,
            color: "inherit"
        })
    })
}
))
  , Cle = 16
  , Ale = cy
  , wle = y.memo(( ({trenchMode: e, createdAt: t, bondedAt: n}) => {
    const {trenchesTileLayout: r} = xne()
      , a = r !== qX.MOXIA && e === Zh.RECENTLY_BONDED && n
      , s = e === Zh.RECENTLY_BONDED && r === qX.MOXIA ? n : t;
    return v.jsxs(S, {
        ml: r === qX.MOXIA ? -.25 : 0,
        flexDirection: "row",
        alignItems: r === qX.MOXIA ? "flex-start" : "center",
        justifyContent: a ? "space-between" : "center",
        width: r === qX.MOXIA ? void 0 : "100%",
        minWidth: r === qX.MOXIA ? 30 : 28,
        children: [v.jsx(mE, {
            ts: s,
            isShort: !0,
            variant: r === qX.MOXIA ? "paragraph1" : "paragraph3",
            overwriteColors: !0,
            textAlign: r === qX.MOXIA ? "start" : "center",
            minWidth: 25
        }), a && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            sx: Tle,
            children: [v.jsx(vf, {
                size: 14,
                color: "inherit"
            }), v.jsx(mE, {
                ts: n ?? null,
                isShort: !0,
                variant: "paragraph3",
                textAlign: "center",
                sx: jle,
                color: "inherit"
            })]
        })]
    })
}
))
  , jle = {
    minWidth: 25,
    display: "flex",
    align: "center"
}
  , Tle = e => ({
    color: e.palette.gold[500],
    gap: .25
})
  , Ile = (e, t) => {
    const n = t ? 16 : 14;
    return e === roe || e === Hc ? v.jsx(GC, {
        title: "USDC pair",
        children: v.jsx(zy, {
            size: n
        })
    }) : e === aoe || e === zc ? v.jsx(GC, {
        title: "USDT pair",
        children: v.jsx($y, {
            size: n
        })
    }) : e === soe || e === $c ? v.jsx(GC, {
        title: "USD1 pair",
        children: v.jsx(Hy, {
            size: n
        })
    }) : null
}
  , Ele = y.memo(( ({isPermissioned: e, showTime: t, gazeType: n, launchpadAux: r, devAddress: a, isSocialsVisible: s, isQuickXSearchVisible: o, trenchMode: l, marketAddress: i, tokenAddress: c, quoteTokenAddress: d, tokenSocials: u, createdAt: p, bondedAt: h, socialsReuse: m, pumpFunNewsArticleId: g, mayhemUntilTs: x, interactiveTooltipCallback: b, isConfirmedBot: f}) => {
    const {trenchesFontMode: k} = xne()
      , C = y.useMemo(( () => k === $X.LARGE_IMPORTANT_STATS ? 16 : 14), [k]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        height: Mle,
        children: [t && v.jsx(wle, {
            createdAt: p,
            bondedAt: h,
            trenchMode: l
        }), s && Ile(d, k === $X.LARGE_IMPORTANT_STATS), s && v.jsx(wR, {
            isPermissioned: e,
            tokenAddress: c,
            showPumpfunLink: "pumpfun" === n,
            showLaunchlabLink: "launchlab" === n,
            showBoopLink: "boop" === n,
            showBagsLink: "meteora-curve" === n && "bags" === r,
            showBelieveLink: "meteora-curve" === n && "believe" === r,
            showFourmemeLink: "fourmeme" === n,
            showBonkLink: "launchlab" === n && "bonk" === r,
            showDaosLink: "daos" === r,
            tokenSocials: u,
            deployerAddress: a,
            preventDefault: !0,
            omitTwitterSearch: !0,
            omitAggregator: !0,
            tooltipTitle: m > 0 ? `Socials has been resued ${m} time${m > 1 ? "s" : ""}` : void 0,
            iconSize: C,
            interactiveTooltipCallback: b,
            pumpFunNewsArticleId: g,
            mayhemUntilTs: x ?? void 0,
            isConfirmedBot: f
        }), o && v.jsx(kle, {
            address: c,
            marketAddress: i ?? void 0,
            iconSize: C
        })]
    })
}
))
  , Mle = 18
  , Nle = y.memo(( ({backgroundColor: e, trenchMode: t, interactiveTooltipCallback: n, ...r}) => {
    var a;
    const s = vw()
      , {t: o} = we()
      , {visibleSections: l} = Cne()
      , {trenchesChain: i, avatarShape: c, trenchesFontMode: d, showAvatarReused: u, statsDesiredDigits: p} = xne()
      , {marketCapThresholds: h} = bA()
      , m = y.useMemo(( () => ({
        opacity: r.deprecated ? .5 : 1
    })), [r.deprecated])
      , g = y.useMemo(( () => ({
        chain: i,
        tokenAddress: r.tokenAddress,
        padreAvatarUrl: r.padreAvatarUrl,
        telegramUrl: r.telegramUrl || null,
        discordUrl: null,
        twitterUrl: r.twitterUrl || null,
        projectWebsiteUrl: r.projectWebsiteUrl || null,
        twitterReuse: r.twitterUsernameReuse ?? null,
        twitterLaunchMetadata: r.tweetCreatedAt ? {
            tweetCreatedAt: r.tweetCreatedAt
        } : null
    })), [r.padreAvatarUrl, r.telegramUrl, r.tokenAddress, r.twitterUrl, r.projectWebsiteUrl, r.twitterUsernameReuse, r.tweetCreatedAt, i])
      , x = Xoe(r.fdvInUsd, p, h)
      , b = Qoe(r.volumeInUsd, p)
      , f = Zoe(r.totalSolFees)
      , A = y.useMemo(( () => v.jsx(ale, {
        backgroundColor: e,
        devHoldingPcnt: r.devHoldingPcnt,
        top10HoldingPcnt: r.top10HoldingPcnt,
        insidersHoldingPcnt: r.insidersHoldingPcnt,
        bundlesHoldingPcntAth: r.bundlesHoldingPcntAth,
        bundlesHoldingPcntCurrent: r.bundlesHoldingPcntCurrent,
        totalBundlesCount: r.totalBundlesCount,
        totalSolSpentInBundles: r.totalSolSpentInBundles,
        totalTokenBoughtInBundles: r.totalTokenBoughtInBundles,
        totalSupply: r.totalSupply,
        devHolding: r.devHolding,
        devHoldingAth: r.devHoldingAth,
        totalDevMigrationsCount: r.totalDevMigrationsCount,
        isDexscreenerPaid: r.isDexscreenerPaid,
        dexBannerUrl: r.dexBannerUrl,
        wasRecentlyBoostedOnDexscreener: r.wasRecentlyBoostedOnDexscreener,
        groupHoldings: r.groupHoldings,
        snipersHoldingPcnt: r.snipersHoldingPcnt,
        totalSnipers: r.totalSnipers,
        fdvInUsd: 0,
        dexPaidAt: r.dexPaidAt,
        devFundTxnExchange: r.devFundTxnExchange,
        devFundTxnHash: r.devFundTxnHash,
        devFundTxnFromAddress: r.devFundTxnFromAddress,
        devFundTxnSolAmount: r.devFundTxnSolAmount,
        devFundTxnTimestamp: r.devFundTxnTimestamp,
        interactiveTooltipCallback: n,
        devAddress: r.devAddress
    })), [e, r.devHoldingPcnt, r.top10HoldingPcnt, r.insidersHoldingPcnt, r.bundlesHoldingPcntAth, r.bundlesHoldingPcntCurrent, r.totalBundlesCount, r.totalSolSpentInBundles, r.totalTokenBoughtInBundles, r.totalSupply, r.devHolding, r.devHoldingAth, r.totalDevMigrationsCount, r.isDexscreenerPaid, r.dexBannerUrl, r.wasRecentlyBoostedOnDexscreener, r.groupHoldings, r.snipersHoldingPcnt, r.totalSnipers, r.dexPaidAt, r.devFundTxnExchange, r.devFundTxnHash, r.devFundTxnFromAddress, r.devFundTxnSolAmount, r.devFundTxnTimestamp, n, r.devAddress])
      , w = y.useMemo(( () => uoe(r, t)), [r, t])
      , j = y.useMemo(( () => ({
        pointerEvents: "none"
    })), [])
      , T = y.useMemo(( () => qee(r.type)), [r.type])
      , I = y.useMemo(( () => ({
        width: {
            xs: `calc(100% - ${d === $X.LARGE_IMPORTANT_STATS ? 78 : 70}px)`,
            xl: `calc(100% - ${d === $X.LARGE_IMPORTANT_STATS ? 134 : 112}px)`
        },
        maxWidth: {
            xs: `calc(100% - ${d === $X.LARGE_IMPORTANT_STATS ? 78 : 70}px)`,
            xl: `calc(100% - ${d === $X.LARGE_IMPORTANT_STATS ? 134 : 112}px)`
        }
    })), [d])
      , E = y.useMemo(( () => l.has(vne.PROGRESS_LINE)), [l])
      , M = y.useMemo(( () => null !== r.translatedSymbol && r.translatedSymbol !== r.symbol || null !== r.translatedName && r.translatedName !== r.name), [r.name, r.symbol, r.translatedName, r.translatedSymbol]);
    return v.jsxs(S, {
        gap: .25,
        width: "100%",
        position: "relative",
        sx: m,
        children: [v.jsxs(S, {
            direction: "row",
            width: "100%",
            gap: 1,
            children: [v.jsxs(S, {
                gap: E ? .75 : .5,
                alignItems: "center",
                children: [T && v.jsx(Ote, {
                    name: r.name,
                    tokenAddress: r.tokenAddress,
                    avatarSize: E ? 61 : 74,
                    progressBarGap: E ? 6 : 2,
                    padreAvatarUrl: r.padreAvatarUrl,
                    isAvatarReused: u && r.isAvatarReused,
                    curveProgress: r.curveProgress,
                    chain: i,
                    hasBonded: !1,
                    protocol: T,
                    launchpad: r.type,
                    launchpadAux: r.launchpadAux,
                    shape: c,
                    devAddress: r.devAddress,
                    compact: E,
                    isHidden: r.isHidden,
                    isBlacklisted: r.isBlacklisted,
                    isHandleBlacklisted: r.isHandleBlacklisted,
                    twitterHandle: r.twitterHandle,
                    protocolMarkerSize: E ? 15 : 17,
                    protocolMarkerOffset: E ? c === Pte.SQUARE ? 7 : 2 : c === Pte.SQUARE ? 6 : 0,
                    avatarGap: E ? 0 : 3,
                    shadow: E,
                    subtleBorder: E,
                    migrationHide: t === Zh.RECENTLY_BONDED
                }), l.has(vne.PROGRESS_LINE) && v.jsx(S, {
                    alignItems: "center",
                    justifyContent: "center",
                    mb: .25,
                    mt: "-1px",
                    children: v.jsx(DM, {
                        migrated: !1,
                        curveProgress: r.curveProgress,
                        curveProgressAth: r.curveProgressAth,
                        launchpad: r.type,
                        launchpadAux: r.launchpadAux,
                        protocolType: r.protocol.type,
                        showAthIndicator: l.has(vne.PROGRESS_LINE_ATH)
                    })
                }), v.jsx(S, {
                    minHeight: 16,
                    children: l.has(vne.CA) && v.jsx(cA, {
                        address: r.tokenAddress,
                        labelVariant: "paragraph3",
                        preventDefault: !0,
                        stopPropagation: !0,
                        hideIcon: !0,
                        firstPartLength: 3,
                        finalPartLength: 4,
                        containerSx: Rle,
                        tooltipTitle: v.jsx(k, {
                            variant: "inherit",
                            color: "inherit",
                            children: r.tokenAddress
                        })
                    })
                })]
            }), v.jsxs(S, {
                gap: .75,
                width: "100%",
                children: [v.jsxs(S, {
                    gap: M ? Ole : 0,
                    position: "relative",
                    children: [v.jsxs(S, {
                        position: "relative",
                        width: "100%",
                        height: Lle,
                        children: [v.jsx(C, {
                            position: "absolute",
                            top: 0,
                            left: 0,
                            sx: I,
                            children: v.jsx(xle, {
                                name: r.name,
                                symbol: r.symbol,
                                tokenAddress: r.tokenAddress,
                                translatedName: r.translatedName,
                                translatedSymbol: r.translatedSymbol
                            })
                        }), v.jsxs(S, {
                            position: "absolute",
                            gap: .5,
                            right: 0,
                            top: d === $X.LARGE_IMPORTANT_STATS ? -2 : 2,
                            alignItems: "flex-end",
                            sx: j,
                            children: [v.jsx(S, {
                                sx: Ble,
                                children: v.jsxs(S, {
                                    direction: s ? "row-reverse" : "column",
                                    gap: s || d !== $X.LARGE_IMPORTANT_STATS ? Ple : .25,
                                    height: s ? Lle : void 0,
                                    sx: _le,
                                    className: Ree,
                                    children: [l.has(vne.MARKET_CAP) && v.jsx(Goe, {
                                        ...x
                                    }), l.has(vne.VOLUME) && v.jsx(Yoe, {
                                        formattedValue: b
                                    })]
                                })
                            }), v.jsx(S, {
                                sx: Ble,
                                children: v.jsxs(S, {
                                    alignItems: s || d !== $X.LARGE_IMPORTANT_STATS ? s || d === $X.LARGE_IMPORTANT_STATS ? "center" : "flex-end" : "flex-start",
                                    direction: s || d === $X.LARGE_IMPORTANT_STATS ? "row" : "column",
                                    gap: Ple,
                                    sx: _le,
                                    className: Ree,
                                    children: [v.jsx(C, {
                                        display: "flex",
                                        children: l.has(vne.GLOBAL_FEES) && null !== f && v.jsx(Koe, {
                                            formattedValue: f
                                        })
                                    }), l.has(vne.TXN_COUNT) && v.jsx(Moe, {
                                        totalBuys: r.totalBuys,
                                        totalSells: r.totalSells,
                                        totalTxns: r.totalTxns
                                    })]
                                })
                            })]
                        })]
                    }), v.jsxs(S, {
                        gap: Ple,
                        children: [v.jsxs(S, {
                            direction: s ? "row" : "column",
                            gap: s ? 1 : Ple,
                            children: [v.jsx(Ele, {
                                isPermissioned: r.isPermissioned ?? !1,
                                showTime: !0,
                                gazeType: r.type,
                                marketAddress: r.meteoraAddress ?? r.pumpSwapAddress ?? r.raydiumAddress ?? r.pumpfunAddress ?? null,
                                tokenAddress: r.tokenAddress,
                                quoteTokenAddress: r.quoteTokenAddr,
                                isSocialsVisible: l.has(vne.SOCIALS),
                                isQuickXSearchVisible: l.has(vne.QUICK_X_SEARCH),
                                socialsReuse: r.socialsReuse,
                                tokenSocials: g,
                                bondedAt: r.bondedAt,
                                createdAt: r.createdAt,
                                launchpadAux: r.launchpadAux,
                                devAddress: r.devAddress,
                                trenchMode: t,
                                pumpFunNewsArticleId: r.pumpFunNewsArticleId,
                                interactiveTooltipCallback: n,
                                mayhemUntilTs: r.mayhemUntil,
                                isConfirmedBot: r.isConfirmedBot ?? !1
                            }), v.jsxs(S, {
                                direction: "row",
                                gap: 1,
                                alignItems: "center",
                                height: Lle,
                                children: [l.has(vne.TOTAL_HOLDERS) && v.jsx(voe, {
                                    formattedValue: NI(r.totalHolders, {
                                        symbol: "",
                                        precision: 0
                                    }),
                                    tooltipTitle: o("Total holders"),
                                    Icon: CS,
                                    reverse: !1,
                                    trenchesFontMode: d
                                }), l.has(vne.PRO_HOLDERS) && null !== r.totalProHolders && v.jsx(qoe, {
                                    totalProHolders: r.totalProHolders
                                }), l.has(vne.DEV_BONDED) && !!r.totalDevMigrationsCount && v.jsx(Roe, {
                                    totalDevMigrationsCount: r.totalDevMigrationsCount
                                }), l.has(vne.EXTRA_MCAP_DISPLAY) && v.jsx(Goe, {
                                    ...x,
                                    compact: !0
                                }), l.has(vne.FRESH_WALLET_BUYS) && !!r.freshWalletBuysSol && v.jsx(Voe, {
                                    freshWalletBuysSol: r.freshWalletBuysSol,
                                    freshWalletBuysCount: r.freshWalletBuysCount
                                })]
                            })]
                        }), v.jsxs(S, {
                            direction: "row",
                            gap: .5,
                            mt: .25,
                            height: 16,
                            alignItems: "center",
                            children: [(null == (a = null == r ? void 0 : r.alphaMentionPublicUiGroups) ? void 0 : a.length) && v.jsx(tq, {
                                groupIds: r.alphaMentionPublicUiGroups
                            }), l.has(vne.TWITTER_USER_NAME) && r.twitterUrl && v.jsx(QM, {
                                twitterUrl: r.twitterUrl,
                                twitterHandle: r.twitterHandle,
                                maxWidth: 110
                            })]
                        })]
                    })]
                }), s && A]
            })]
        }), !s && A, w && v.jsxs(S, {
            position: "absolute",
            right: 10,
            bottom: 10,
            zIndex: 3,
            direction: "row",
            alignItems: "center",
            sx: Dle,
            children: [v.jsx(k, {
                variant: "h2",
                color: "text.label",
                noWrap: !0,
                children: "Migrating"
            }), v.jsx(D5, {})]
        })]
    })
}
), ( (e, t) => c.isEqual(e, t)))
  , Ple = .5
  , Ole = 1.75
  , Lle = 18
  , Rle = {
    p: 0,
    m: 0
}
  , Dle = e => ({
    color: e.palette.text.label
})
  , Ble = e => ({
    background: e.palette.background.secondary
})
  , _le = {
    pointerEvents: "none"
}
  , Ule = y.memo(( ({devFundTxnExchange: e, devFundTxnFromAddress: t, devFundTxnHash: n, devFundTxnSolAmount: r, devFundTxnTimestamp: a}) => {
    const {t: s} = we()
      , o = D()
      , l = y.useMemo(( () => n ? AA(n, Pd.SOLANA) : null), [n])
      , c = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        l && window.open(l, "_blank", "noopener,noreferrer")
    }
    ), [l])
      , d = y.useMemo(( () => ({
        color: o.palette.text.value
    })), [o.palette.text.value]);
    return null === t || null === r || null === a || null === n ? v.jsx(C, {
        component: "span"
    }) : v.jsx(GC, {
        disableInteractive: !1,
        title: v.jsxs(S, {
            gap: .5,
            minWidth: Vle,
            onClick: Ww,
            children: [v.jsx(k, {
                ...Hle,
                color: "text.label",
                children: s("Dev wallet funded")
            }), v.jsxs(S, {
                ...zle,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(k, {
                        ...Hle,
                        color: "text.label",
                        children: s("From")
                    }), v.jsx(C, {
                        component: "a",
                        href: l ?? "",
                        onClick: c,
                        target: "_blank",
                        sx: $le,
                        children: v.jsx(tE, {
                            chain: Pd.SOLANA,
                            forceMonochromatic: !0,
                            defaultColor: "inherit",
                            size: 14
                        })
                    })]
                }), v.jsx(cA, {
                    stopPropagation: !0,
                    labelVariant: "paragraph3",
                    labelSx: d,
                    address: t,
                    customName: e ? `${e ? `(${b5(e)}) ` : ""} ${t}` : void 0,
                    hideIcon: !0
                })]
            }), v.jsxs(S, {
                ...zle,
                children: [v.jsx(k, {
                    ...Hle,
                    color: "text.label",
                    children: s("With")
                }), v.jsxs(k, {
                    ...Hle,
                    children: [`${UI(r.toFixed(3))}`, v.jsx(dk, {
                        size: 14
                    })]
                })]
            }), v.jsxs(S, {
                ...zle,
                pr: .25,
                children: [v.jsx(k, {
                    ...Hle,
                    color: "text.label",
                    children: s("On")
                }), v.jsxs(S, {
                    gap: .25,
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        ...Hle,
                        color: "text.label",
                        children: `${i(1e3 * a).format("MMM DD HH:mm")}`
                    }), v.jsx(mE, {
                        ...Hle,
                        gap: .25,
                        ts: a,
                        suffixAdornment: "ago"
                    })]
                })]
            })]
        }),
        children: v.jsx(C, {
            component: "a",
            href: l ?? "",
            onClick: c,
            target: "_blank",
            sx: $le,
            children: v.jsxs(S, {
                gap: .5,
                direction: "row",
                alignItems: "center",
                children: [e ? v.jsx(f5, {
                    exchange: e,
                    size: Wle
                }) : v.jsx(tE, {
                    chain: Pd.SOLANA,
                    forceMonochromatic: !0,
                    defaultColor: "inherit"
                }), v.jsx(mE, {
                    variant: "paragraph3",
                    color: "inherit",
                    sx: Fle,
                    ts: a,
                    isShort: !0
                })]
            })
        })
    })
}
))
  , Wle = 15
  , Fle = {
    minWidth: 35
}
  , Vle = 185
  , Hle = {
    variant: "paragraph3",
    color: "text.value",
    sx: {
        display: "flex",
        alignItems: "center"
    }
}
  , zle = {
    justifyContent: "space-between",
    gap: 1,
    direction: "row"
}
  , $le = {
    display: "inline-flex",
    direction: "row",
    alignItems: "center",
    justifyContent: "center",
    height: 16,
    cursor: "pointer",
    textDecoration: "none",
    color: "text.label",
    transition: "200ms color ease-in-out",
    "&:hover": {
        color: "text.value"
    }
}
  , Gle = y.memo(( ({trenchMode: e, interactiveTooltipCallback: t, ...n}) => {
    const {visibleSections: r} = Cne()
      , {trenchesChain: a, avatarShape: s, showAvatarReused: o} = xne()
      , l = y.useMemo(( () => ({
        chain: a,
        tokenAddress: n.tokenAddress,
        padreAvatarUrl: n.padreAvatarUrl,
        telegramUrl: n.telegramUrl || null,
        discordUrl: null,
        twitterUrl: n.twitterUrl || null,
        projectWebsiteUrl: n.projectWebsiteUrl || null,
        twitterReuse: n.twitterUsernameReuse ?? null,
        twitterLaunchMetadata: n.tweetCreatedAt ? {
            tweetCreatedAt: n.tweetCreatedAt
        } : null
    })), [n.padreAvatarUrl, n.telegramUrl, n.tokenAddress, n.twitterUrl, n.projectWebsiteUrl, n.twitterUsernameReuse, n.tweetCreatedAt, a])
      , i = y.useMemo(( () => uoe(n, e)), [n, e])
      , c = y.useMemo(( () => ({
        opacity: n.deprecated ? .5 : 1
    })), [n.deprecated])
      , d = y.useMemo(( () => qee(n.type)), [n.type]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1.5,
        width: "100%",
        sx: c,
        children: [v.jsxs(S, {
            gap: .5,
            alignItems: "center",
            width: 74,
            children: [d && v.jsx(Ote, {
                name: n.name,
                tokenAddress: n.tokenAddress,
                avatarSize: 74,
                progressBarGap: 2,
                padreAvatarUrl: n.padreAvatarUrl,
                isAvatarReused: o && n.isAvatarReused,
                curveProgress: n.curveProgress,
                hasBonded: !1,
                chain: a,
                protocol: d,
                launchpad: n.type,
                launchpadAux: n.launchpadAux,
                shape: s,
                devAddress: n.devAddress,
                isHidden: n.isHidden,
                isBlacklisted: n.isBlacklisted,
                isHandleBlacklisted: n.isHandleBlacklisted,
                twitterHandle: n.twitterHandle,
                protocolMarkerSize: 17,
                protocolMarkerOffset: s === Pte.SQUARE ? 6 : 0,
                migrationHide: e === Zh.RECENTLY_BONDED
            }), v.jsx(wle, {
                createdAt: n.createdAt,
                bondedAt: n.bondedAt,
                trenchMode: e
            })]
        }), v.jsxs(S, {
            flexShrink: 1,
            justifyContent: "space-between",
            height: "100%",
            width: "100%",
            overflow: "hidden",
            children: [v.jsxs(S, {
                gap: 1,
                width: "100%",
                children: [v.jsxs(S, {
                    direction: "row",
                    width: "100%",
                    justifyContent: "space-between",
                    alignItems: "center",
                    gap: .5,
                    overflow: "hidden",
                    children: [v.jsxs(S, {
                        flexShrink: 1,
                        overflow: "hidden",
                        gap: .25,
                        children: [v.jsx(xle, {
                            name: n.name,
                            symbol: n.symbol,
                            tokenAddress: n.tokenAddress,
                            translatedName: null,
                            translatedSymbol: null
                        }), v.jsx(ale, {
                            devHoldingPcnt: n.devHoldingPcnt,
                            top10HoldingPcnt: n.top10HoldingPcnt,
                            insidersHoldingPcnt: n.insidersHoldingPcnt,
                            bundlesHoldingPcntAth: n.bundlesHoldingPcntAth,
                            bundlesHoldingPcntCurrent: n.bundlesHoldingPcntCurrent,
                            totalBundlesCount: n.totalBundlesCount,
                            totalSolSpentInBundles: n.totalSolSpentInBundles,
                            totalTokenBoughtInBundles: n.totalTokenBoughtInBundles,
                            totalSupply: n.totalSupply,
                            dexBannerUrl: n.dexBannerUrl,
                            devHolding: n.devHolding,
                            devHoldingAth: n.devHoldingAth,
                            totalDevMigrationsCount: n.totalDevMigrationsCount,
                            isDexscreenerPaid: n.isDexscreenerPaid,
                            wasRecentlyBoostedOnDexscreener: n.wasRecentlyBoostedOnDexscreener,
                            groupHoldings: n.groupHoldings,
                            snipersHoldingPcnt: n.snipersHoldingPcnt,
                            totalSnipers: n.totalSnipers,
                            fdvInUsd: n.fdvInUsd,
                            dexPaidAt: n.dexPaidAt,
                            devFundTxnExchange: n.devFundTxnExchange,
                            devFundTxnHash: n.devFundTxnHash,
                            devFundTxnFromAddress: n.devFundTxnFromAddress,
                            devFundTxnSolAmount: n.devFundTxnSolAmount,
                            devFundTxnTimestamp: n.devFundTxnTimestamp,
                            devAddress: n.devAddress,
                            interactiveTooltipCallback: t
                        })]
                    }), i && v.jsxs(S, {
                        flex: 1,
                        width: 100,
                        minWidth: 100,
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "flex-end",
                        sx: qle,
                        children: [v.jsx(k, {
                            variant: "h2",
                            color: "text.label",
                            noWrap: !0,
                            children: "Migrating"
                        }), v.jsx(D5, {})]
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: r.has(vne.PROGRESS_LINE) || r.has(vne.FUNDED_TXN) || r.has(vne.CA) ? "space-between" : "flex-end",
                    gap: 1,
                    height: 15,
                    children: [(r.has(vne.CA) || r.has(vne.FUNDED_TXN)) && v.jsxs(S, {
                        gap: 1,
                        direction: "row",
                        alignItems: "center",
                        height: 15,
                        children: [r.has(vne.CA) && v.jsx(cA, {
                            address: n.tokenAddress,
                            labelVariant: "paragraph3",
                            preventDefault: !0,
                            stopPropagation: !0,
                            hideIcon: !0,
                            firstPartLength: 3,
                            finalPartLength: 4,
                            containerSx: Yle,
                            tooltipTitle: v.jsx(k, {
                                variant: "inherit",
                                color: "inherit",
                                children: n.tokenAddress
                            })
                        }), r.has(vne.FUNDED_TXN) && v.jsx(Ule, {
                            devFundTxnExchange: n.devFundTxnExchange,
                            devFundTxnHash: n.devFundTxnHash,
                            devFundTxnFromAddress: n.devFundTxnFromAddress,
                            devFundTxnSolAmount: n.devFundTxnSolAmount,
                            devFundTxnTimestamp: n.devFundTxnTimestamp
                        })]
                    }), r.has(vne.PROGRESS_LINE) && v.jsx(IM, {
                        migratedPoolCreatedAt: n.pumpSwapCreatedAt ?? n.raydiumCreatedAt ?? n.meteoraCreatedAt ?? null,
                        requireMigratedPool: e !== Zh.RECENTLY_BONDED,
                        curveProgress: n.curveProgress,
                        curveProgressAth: n.curveProgressAth,
                        migrationPriceInUsd: n.migrationPriceInUsd,
                        priceInUsd: n.priceInUsd,
                        postMigrationPriceInUsdAtl: n.postMigrationPriceInUsdAtl,
                        postMigrationPriceInUsdAth: n.postMigrationPriceInUsdAth,
                        totalSupply: n.totalSupply ?? null,
                        decimals: null !== n.decimals ? n.decimals : "pumpfun" === n.type ? 6 : null,
                        showAthIndicator: r.has(vne.PROGRESS_LINE_ATH)
                    }), r.has(vne.TXN_COUNT) && v.jsx(Moe, {
                        totalBuys: n.totalBuys,
                        totalSells: n.totalSells,
                        totalTxns: n.totalTxns
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                width: "100%",
                justifyContent: "space-between",
                alignContent: "center",
                alignSelf: "flex-end",
                gap: .5,
                py: 1,
                overflow: "hidden",
                children: [r.has(vne.SOCIALS) || r.has(vne.TWITTER_USER_NAME) ? v.jsxs(S, {
                    gap: .75,
                    direction: Kle,
                    children: [r.has(vne.TWITTER_USER_NAME) && n.twitterUrl ? v.jsx(QM, {
                        twitterUrl: n.twitterUrl,
                        twitterHandle: n.twitterHandle
                    }) : v.jsx(C, {
                        minHeight: 16
                    }), v.jsx(Ele, {
                        isPermissioned: n.isPermissioned ?? !1,
                        showTime: !1,
                        gazeType: n.type,
                        marketAddress: n.meteoraAddress ?? n.pumpSwapAddress ?? n.raydiumAddress ?? n.pumpfunAddress ?? null,
                        tokenAddress: n.tokenAddress,
                        quoteTokenAddress: n.quoteTokenAddr,
                        isSocialsVisible: r.has(vne.SOCIALS),
                        isQuickXSearchVisible: r.has(vne.QUICK_X_SEARCH),
                        socialsReuse: n.socialsReuse,
                        tokenSocials: l,
                        bondedAt: n.bondedAt,
                        createdAt: n.createdAt,
                        launchpadAux: n.launchpadAux,
                        devAddress: n.devAddress,
                        trenchMode: e,
                        pumpFunNewsArticleId: n.pumpFunNewsArticleId,
                        interactiveTooltipCallback: t,
                        mayhemUntilTs: n.mayhemUntil,
                        isConfirmedBot: n.isConfirmedBot ?? !1
                    })]
                }) : v.jsx(C, {}), v.jsx(S, {
                    flexShrink: 1,
                    sx: Xle,
                    children: v.jsx(C, {
                        display: "flex",
                        alignItems: "center",
                        sx: Qle,
                        children: v.jsx(Joe, {
                            totalHolders: n.totalHolders,
                            fdvInUsd: n.fdvInUsd,
                            volumeInUsd: n.volumeInUsd,
                            totalProHolders: n.totalProHolders,
                            freshWalletBuysSol: n.freshWalletBuysSol,
                            freshWalletBuysCount: n.freshWalletBuysCount,
                            totalSolFees: n.totalSolFees
                        })
                    })
                })]
            })]
        })]
    })
}
), ( (e, t) => c.isEqual(e, t)))
  , qle = e => ({
    color: e.palette.text.label
})
  , Kle = {
    xs: "column",
    lg: "row"
}
  , Yle = {
    p: 0,
    m: 0
}
  , Xle = {
    direction: "lrt",
    overflow: "hidden",
    width: "100%"
}
  , Qle = {
    direction: "rtl"
}
  , Zle = y.memo(( ({rowHeight: e, trenchMode: t, interactiveTooltipCallback: n, compact: r, ...a}) => {
    const s = D()
      , {trenchesChain: o, trenchesTileLayout: l, launchpadBackgroundColor: i, showUltraBorder: d} = xne()
      , {protocolsRowColors: u} = bA()
      , {t: p} = we()
      , {selectedWalletsAddresses: h} = AD()
      , [m,g] = y.useState(!1)
      , [x,b] = y.useState(!1)
      , [f,A] = y.useState(!1)
      , w = f && !m && !x
      , j = y.useDeferredValue(a);
    y.useEffect(( () => {
        if (!w || !h.length)
            return;
        const e = () => {
            const e = Jse(o, o === Pd.SOLANA ? j.quoteTokenAddr ?? qc : j.quoteTokenAddr);
            e && c.forEach([...h].sort(), (t => {
                toe({
                    chain: o,
                    baseToken: j.tokenAddress,
                    poolAddress: j.meteoraAddress ?? j.pumpSwapAddress ?? j.raydiumAddress ?? j.pancakeSwapAddress ?? j.fourMemeAddress ?? j.pumpfunAddress,
                    quoteToken: e.address,
                    walletAddress: t
                })
            }
            ))
        }
        ;
        e();
        const t = setInterval(( () => {
            e()
        }
        ), 5e3);
        return () => {
            clearInterval(t)
        }
    }
    ), [w, j.tokenAddress, j.meteoraAddress, j.raydiumAddress, j.pumpSwapAddress, j.pumpfunAddress, h, o, j.pancakeSwapAddress, j.fourMemeAddress, j.quoteTokenAddr]);
    const T = pT()
      , I = y.useMemo(( () => {
        switch (o) {
        case Pd.BSC:
            {
                const e = j.pancakeSwapAddress ?? j.fourMemeAddress ?? j.pumpfunAddress;
                return fg(o, e, j.fourMemeAddress === e ? {
                    type: "fourmeme",
                    tokenAddress: j.tokenAddress
                } : null)
            }
        case Pd.SOLANA:
            return fg(o, j.meteoraAddress ?? j.pumpSwapAddress ?? j.raydiumAddress ?? j.pumpfunAddress, null)
        }
    }
    ), [j.fourMemeAddress, j.meteoraAddress, j.pancakeSwapAddress, j.pumpSwapAddress, j.pumpfunAddress, j.raydiumAddress, j.tokenAddress, o])
      , E = y.useMemo(( () => QE(I, r ? nT.TRENCHES_SIDE_PANEL : nT.TRENCHES)), [r, I])
      , M = y.useCallback((e => {
        if (e.metaKey || e.ctrlKey)
            return void (E && window.open(E, "_blank"));
        if (e.preventDefault(),
        !I)
            return;
        const t = doe(j);
        t && mT.set(I, t),
        T({
            marketId: I,
            tradePageOrigin: r ? nT.TRENCHES_SIDE_PANEL : nT.TRENCHES
        })
    }
    ), [I, j, T, E, r])
      , N = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation();
        let t = e.target
          , n = null;
        for (; t && t !== e.currentTarget; ) {
            if ("A" === t.tagName && t.hasAttribute("reflink")) {
                n = t.getAttribute("reflink");
                break
            }
            if (t.hasAttribute("aria-label")) {
                const e = t.getAttribute("aria-label");
                if ((null == e ? void 0 : e.startsWith("http://")) || (null == e ? void 0 : e.startsWith("https://"))) {
                    n = e;
                    break
                }
            }
            t = t.parentElement
        }
        return n ? window.open(n, "_blank") : window.open(E, "_blank"),
        !1
    }
    ), [E])
      , P = y.useCallback((e => {
        Mn && 1 === e.button && e.preventDefault()
    }
    ), [])
      , O = y.useMemo(( () => {
        if (!i)
            return null;
        return `${u[a.launchpadAux ?? a.type] ?? null ?? RM(!1, a.launchpadAux ?? a.type, a.protocol.type, s)[0]}19`
    }
    ), [a.launchpadAux, a.type, i, s, a.protocol.type, u])
      , L = y.useMemo(( () => t => ({
        position: "relative",
        textDecoration: "none",
        height: e,
        px: "9px",
        pt: l === qX.MOXIA ? "13px" : "12px",
        pb: l === qX.MOXIA ? "10px" : "3px",
        cursor: "pointer",
        width: "100%",
        borderBottom: O ? `1px solid ${O}` : `1px solid ${t.palette.background.borderMain}77`,
        ...O ? {
            backgroundColor: O,
            [`.${Ree}`]: {
                backgroundColor: O
            }
        } : {
            [`.${Ree}`]: {
                backgroundColor: t.palette.background.secondary
            }
        },
        ...R ? {} : {
            "&:hover": {
                ...O ? {
                    backgroundColor: Me(O, .25),
                    [`.${Ree}`]: {
                        backgroundColor: Me(O, .25)
                    }
                } : {
                    backgroundColor: t.palette.background.buttonDefault,
                    [`.${Ree}`]: {
                        backgroundColor: t.palette.background.buttonDefault
                    }
                },
                [`.${Nee}`]: d ? {} : {
                    borderLeftColor: t.palette.background.borderActive
                },
                [`.${Mee}`]: {
                    opacity: 1
                }
            }
        }
    })), [O, l, d, e])
      , B = y.useMemo(( () => {
        switch (l) {
        case qX.MOXIA:
            return v.jsx(Nle, {
                backgroundColor: O ?? void 0,
                trenchMode: t,
                interactiveTooltipCallback: n,
                ...j
            });
        case qX.ORIGINAL:
        default:
            return v.jsx(Gle, {
                trenchMode: t,
                interactiveTooltipCallback: n,
                ...j
            })
        }
    }
    ), [O, j, n, t, l])
      , _ = y.useMemo(( () => uoe(j, t)), [j, t])
      , U = y.useMemo(( () => {
        const e = t === Zh.RECENTLY_BONDED ? null : j.curveProgress
          , n = qee(j.type)
          , [r] = RM(!1, j.launchpadAux ?? j.type, (null == n ? void 0 : n.type) ?? j.protocol.type, s)
          , a = v$((null == n ? void 0 : n.type) ?? j.protocol.type, j.type, j.launchpadAux, o, !1);
        return _ ? v.jsx(k, {
            variant: "inherit",
            color: r ?? "inherit",
            children: "Migrating"
        }) : null === e ? v.jsx(k, {
            variant: "inherit",
            color: r ?? "inherit",
            children: a.name ?? ""
        }) : v.jsxs(S, {
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: "text.label",
                    children: p("B. Curve")
                }), v.jsx(k, {
                    variant: "inherit",
                    color: r ?? "inherit",
                    children: jI(e, {
                        omitSign: !0
                    })
                })]
            }), j.curveProgressAth ? v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: "text.label",
                    children: "ATH"
                }), v.jsx(k, {
                    color: "text.value",
                    variant: "inherit",
                    children: jI(j.curveProgressAth, {
                        omitSign: !0
                    })
                })]
            }) : null]
        })
    }
    ), [t, j.curveProgress, j.type, j.launchpadAux, j.protocol.type, j.curveProgressAth, s, _, p, o]);
    return v.jsx(GC, {
        placement: "top",
        disableInteractive: !0,
        title: U,
        children: v.jsxs(C, {
            component: "span",
            display: "block",
            alignItems: "center",
            sx: L,
            onClick: M,
            onAuxClick: N,
            onContextMenu: Mn ? Uw : N,
            onMouseDown: P,
            children: [j.deprecated && v.jsx(C, {
                sx: eie,
                children: v.jsx(k, {
                    textAlign: "center",
                    variant: "paragraph3",
                    color: "text.value",
                    sx: Jle,
                    children: "Feed is paused, this data is out of date"
                })
            }), !_ && (!j.isPermissioned || j.bondedAt) && v.jsx(hoe, {
                symbol: j.symbol,
                tokenAddress: j.tokenAddress,
                tokenType: j.tokenType,
                quoteTokenAddr: j.quoteTokenAddr,
                pumpfunAddress: j.pumpfunAddress,
                raydiumAddress: j.raydiumAddress,
                pumpSwapAddress: j.pumpSwapAddress,
                meteoraAddress: j.meteoraAddress,
                fourMemeAddress: j.fourMemeAddress,
                pancakeSwapAddress: j.pancakeSwapAddress,
                padreAvatarUrl: j.padreAvatarUrl,
                isPerformingTrade: m,
                setIsPerformingTrade: g,
                isPerformingExtraTrade: x,
                setIsPerformingExtraTrade: b,
                setMouseOver: A
            }), v.jsx(C, {
                display: "flex",
                component: "span",
                children: B
            })]
        })
    })
}
), ( (e, t) => e.volumeInUsd === t.volumeInUsd && c.isEqual(e, t)))
  , Jle = {
    width: "100%"
}
  , eie = {
    position: "absolute",
    left: "calc(50% - 110px)",
    top: 38,
    zIndex: 5,
    width: 220
}
  , tie = y.memo(( ({trenchMode: e, isSpaced: t, order: n, compact: r=!1, visibleColumnsCount: a, fullsize: s=!1, isFirstColumn: o, isLastColumn: l}) => {
    const i = bw()
      , c = fw()
      , d = vw()
      , {hiddenPairs: u, hiddenMigratedPairs: p} = SX()
      , {settings: h} = rf()
      , m = y.useMemo(( () => (null == h ? void 0 : h.devBlacklist) ? new Set(h.devBlacklist) : new Set([])), [null == h ? void 0 : h.devBlacklist])
      , g = y.useMemo(( () => (null == h ? void 0 : h.handlesBlacklist) ? new Set(h.handlesBlacklist.map((e => e.toLowerCase()))) : new Set([])), [null == h ? void 0 : h.handlesBlacklist])
      , {setSolFilter: x, solFilters: b, bscFilters: f, setBscFilter: A} = JX()
      , {trenchesChain: w, trenchesTileLayout: j, hideMode: T, pauseOnHover: I, soonMode: E} = xne()
      , M = K8(w, b, f)
      , N = K8(w, x, A)
      , P = ( (e, t) => {
        const n = mte(t === Pd.SOLANA ? e : null)
          , r = Ite(t === Pd.BSC ? e : null);
        return y.useMemo(( () => {
            switch (t) {
            case Pd.BSC:
                return {
                    state: r,
                    chain: t
                };
            case Pd.SOLANA:
                return {
                    state: n,
                    chain: t
                }
            }
        }
        ), [r, t, n])
    }
    )(y.useMemo(( () => ( (e, t) => {
        switch (e) {
        case Zh.NEW:
            return "new";
        case Zh.ALMOST_BONDED:
            return t === YX.CURVE ? "soon" : "soon-by-mc";
        case Zh.RECENTLY_BONDED:
            return "graduated"
        }
    }
    )(e, E)), [e, E]), w)
      , O = y.useCallback((t => {
        N(e, {
            ...XX,
            ...M[e],
            TICKERS: [t]
        })
    }
    ), [M, N, e])
      , L = XM((e => e.registerTrenchesNewSearch));
    y.useEffect(( () => {
        let t = () => {}
        ;
        if (e === Zh.NEW)
            return t = L(O),
            () => {
                t()
            }
    }
    ), [O, L, e]);
    const {i18n: D} = we()
      , B = y.useMemo(( () => P.state.data ? ( (e, t, n) => {
        if (!e)
            return null;
        if (0 === e.length)
            return [];
        const r = "fourMemeAddress"in e[0];
        return t === Pd.BSC && !r || t === Pd.SOLANA && r ? null : r ? Uee(e, n) : _ee(e, n)
    }
    )(P.state.data.orderedDisplayData, P.chain, D.resolvedLanguage ?? null) : null), [P, D.resolvedLanguage])
      , [_,U] = y.useState(!1)
      , [W,F] = y.useState(!1)
      , H = y.useMemo(( () => (_ || W) && (I || R)), [_, W, I])
      , z = y.useMemo(( () => ({
        onOpen: () => {
            F(!0)
        }
        ,
        onClose: () => {
            F(!1)
        }
    })), [])
      , $ = y.useCallback(( () => {
        U(!0)
    }
    ), [])
      , G = y.useCallback(( () => {
        U(!1)
    }
    ), [])
      , q = y.useCallback(( () => {
        R && U(!0)
    }
    ), [])
      , K = y.useCallback(( () => {
        R && U(!1)
    }
    ), [])
      , Y = y.useRef(null)
      , X = y.useRef(null)
      , Q = y.useRef([]);
    pM({
        target: Y,
        onInteractionStart: q,
        onInteractionStop: K
    });
    const [Z,J] = y.useState(!1)
      , ee = y.useRef(0)
      , te = y.useCallback(( () => {
        if (!X.current)
            return;
        const e = X.current
          , t = ee.current
          , n = 0 - t
          , r = performance.now()
          , a = s => {
            const o = s - r
              , l = Math.min(o / aie, 1)
              , i = t + n * l;
            e.scrollToPosition(i),
            l < 1 && requestAnimationFrame(a)
        }
        ;
        requestAnimationFrame(a)
    }
    ), [])
      , ne = y.useCallback(( ({scrollTop: e}) => {
        J(e > rie),
        0 === e && R && G(),
        ee.current = e
    }
    ), [G]);
    y.useEffect(( () => {
        H && Q.current.length || (Q.current = B || [])
    }
    ), [H, B]);
    const re = y.useMemo(( () => {
        const t = H && Q.current.length ? Wee(B ?? [], Q) : B;
        return T !== sne.SHOW_ALL && (u || m.size || g.size) ? t ? t.filter((t => {
            if (m.has(t.devAddress))
                return !1;
            if (t.twitterHandle && g.has(t.twitterHandle.toLowerCase()))
                return !1;
            const n = kX(t.tokenAddress, w);
            return T === sne.HIDE || e !== Zh.RECENTLY_BONDED ? !u || !u[n] : T !== sne.SHOW_MIGRATED || (!p || !p[n])
        }
        )) : null : $ee(t, u, m, g, w)
    }
    ), [H, B, u, m, p, g, T, e, w])
      , ae = y.useMemo(( () => re ? re.slice(0, pie) : null), [re])
      , se = y.useMemo(( () => j === qX.MOXIA ? d ? lie : iie : c ? sie : oie), [c, j, d]);
    y.useEffect(( () => {
        X.current && X.current.recomputeRowHeights()
    }
    ), [se]);
    const oe = y.useCallback((e => {
        e.stopPropagation(),
        te()
    }
    ), [te])
      , le = y.useMemo(( () => e => {
        const c = `1px solid ${e.palette.background.borderMain}`
          , d = e.shape.borderRadius * (s ? 0 : o || t ? 3 : 0)
          , u = e.shape.borderRadius * (s ? 0 : l || t ? 3 : 0);
        return {
            borderTopLeftRadius: {
                md: d
            },
            borderBottomLeftRadius: {
                md: d
            },
            borderTopRightRadius: {
                md: u
            },
            borderBottomRightRadius: {
                md: u
            },
            background: e.palette.background.secondary,
            flex: 1,
            height: s ? "100%" : void 0,
            mb: s ? 0 : {
                md: 2
            },
            pt: s ? 1 : 0,
            maxWidth: r ? void 0 : {
                xs: "100vw",
                md: void 0 !== a && 3 !== a ? `max(${uie}px, ${100 / a}vh)` : `calc(${100 / 3}vw - ${1 === n ? 12 : 6}px)`
            },
            ml: r ? 0 : i && (0 === n || t) ? 1 : 0,
            mr: r ? 0 : i && (2 === n || t) ? 1 : 0,
            borderRight: r || !i || n < (void 0 !== a ? a - 1 : 2) && !t ? "none" : c,
            borderLeft: r ? "none" : i ? c : "none",
            borderTop: r ? "none" : i ? c : "none",
            borderBottom: r ? "none" : i ? c : "none",
            overflow: "hidden"
        }
    }
    ), [s, r, a, n, i, t, o, l])
      , ie = y.useCallback((e => {
        e.currentTarget.getBoundingClientRect().right - e.clientX > 15 ? $() : G()
    }
    ), [$, G])
      , ce = y.useCallback(( () => {
        U(!1)
    }
    ), [U]);
    return v.jsxs(S, {
        position: "relative",
        sx: le,
        children: [v.jsx(Dse, {
            trenchMode: e,
            isPaused: H,
            isSync: P.state.isSync,
            onPauseClick: $,
            onResumeClick: G,
            compact: r
        }), v.jsx(S, {
            ref: Y,
            height: `calc(100% - ${t ? 37 : 38}px)`,
            sx: die,
            className: "padre-no-scroll",
            onMouseMove: ie,
            onMouseLeave: ce,
            children: ae ? ae.length ? v.jsx(mt, {
                children: ({height: t, width: n}) => v.jsx(gt, {
                    ref: e => {
                        X.current = e
                    }
                    ,
                    className: "padre-decorative-scroll",
                    height: t,
                    width: n,
                    rowHeight: se,
                     rowCount: ae.length,
                    rowRenderer: ({index: t, style: n}) => {
                        const a = ae[t];
                        return v.jsx("div", {
                            style: n,
                            children: v.jsx(Zle, {
                                rowHeight: se,
                                trenchMode: e,
                                interactiveTooltipCallback: z,
                                compact: r,
                                ...a
                            })
                        }, Bee(a))
                    }
                    ,
                    cellRangeRenderer: Ete,
                    overscanRowCount: 2,
                    onScroll: ne
                })
            }) : v.jsx(S, {
                width: "100%",
                height: "100%",
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: "No data to show"
                })
            }) : v.jsx(Km, {})
        }), Z && v.jsx(S, {
            position: "absolute",
            bottom: 20,
            left: `calc(50% - ${nie / 2}px)`,
            children: v.jsxs(V, {
                tabIndex: -1,
                onClick: oe,
                size: "small",
                variant: "tertiary",
                sx: cie,
                children: [v.jsx(C, {
                    display: "flex",
                    mt: "1px",
                    children: v.jsx(Rv, {
                        size: 18
                    })
                }), v.jsx(k, {
                    variant: "paragraph1",
                    children: "Back to top"
                })]
            })
        })]
    })
}
))
  , nie = 120
  , rie = 100
  , aie = 500
  , sie = 110
  , oie = 129
  , lie = 124
  , iie = 142
  , cie = e => ({
    display: "flex",
    backgroundColor: e.palette.background.primary,
    width: nie,
    height: 32,
    opacity: .9,
    gap: 1,
    alignItems: "center",
    pr: 1,
    pl: .75,
    borderRadius: 2,
    "&focus, &:hover": {
        backgroundColor: e.palette.background.buttonDefault
    }
})
  , die = {
    overflowY: "scroll",
    overflowX: "auto"
}
  , uie = 650
  , pie = 30
  , hie = e => {
    switch (e) {
    case "1m":
        return "1M";
    case "5m":
        return "5M";
    case "15m":
        return "15M"
    }
}
  , mie = e => e >= 3e4 ? "success.main" : e >= 1e4 ? "gold.500" : "text.value"
  , gie = y.memo(( ({summary: e, onClick: t}) => {
    const n = y.useMemo(( () => c.sum(e.tokens.map((e => e.m5VolumeInUsd ?? 0)))), [e.tokens])
      , r = y.useMemo(( () => mie(n)), [n]);
    return v.jsx(v.Fragment, {
        children: v.jsx(V, {
            onClick: t,
            variant: "tertiary",
            size: "xxsmall",
            sx: {
                px: 1,
                height: bu.XXSMALL,
                minWidth: bie
            },
            children: v.jsxs(S, {
                direction: "row",
                gap: .5,
                divider: v.jsx(Ee, {
                    flexItem: !0,
                    orientation: "vertical",
                    sx: {
                        my: .5
                    }
                }),
                sx: {
                    width: "100%",
                    overflow: "hidden"
                },
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: r,
                    noWrap: !0,
                    sx: {
                        flexShrink: 0
                    },
                    children: LI(n, {
                        collapseExponent: !0,
                        symbol: "$",
                        symbolPosition: yI.START,
                        padSymbol: !1,
                        removeTrailingZerosPrecision: 0,
                        maxPrecision: n >= 1e3 ? 2 : 0,
                        minPrecision: n >= 1e3 ? 2 : 0
                    })
                }), v.jsx(k, {
                    variant: "inherit",
                    noWrap: !0,
                    color: "text.label",
                    sx: {
                        flexGrow: 1,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap"
                    },
                    children: iu(e.substring, xie)
                }), v.jsx(k, {
                    variant: "inherit",
                    noWrap: !0,
                    sx: {
                        flexShrink: 0
                    },
                    children: e.frequency
                })]
            })
        })
    })
}
))
  , xie = 16
  , bie = 155
  , fie = y.memo(( ({popularSymbolData: e, chain: t, ...n}) => e ? v.jsx(kQ, {
    ...n,
    sxProps: {
        ...n.sxProps,
        alignItems: "center",
        justifyContent: "flex-start"
    },
    children: v.jsxs(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        children: [v.jsx(b_, {
            url: IE(t, e.mint),
            padreAvatarUrl: e.padreAvatarUrl,
            name: e.symbol ?? "?",
            size: vie,
            chain: t,
            protocolInfo: null
        }), v.jsx(GC, {
            title: e.name,
            children: v.jsx(k, {
                sx: {
                    textOverflow: "ellipsis",
                    overflow: "hidden",
                    whiteSpace: "nowrap",
                    ml: .25,
                    maxWidth: 65
                },
                variant: "paragraph3",
                noWrap: !0,
                children: iu(e.symbol, Sie)
            })
        }), v.jsx(cA, {
            maxWidth: 70,
            customName: e.name,
            address: e.mint,
            preventDefault: !0,
            stopPropagation: !0,
            isInTooltip: !0
        })]
    })
}) : v.jsx(CQ, {})))
  , vie = 18
  , Sie = 14
  , yie = y.memo(( ({popularSymbolData: e, ...t}) => {
    const {settings: n} = rf()
      , r = y.useMemo(( () => e ? {
        telegram: aR(e.telegramUrl),
        projectWebsite: e.projectWebsiteUrl && !sR(e.projectWebsiteUrl) ? oR(e.projectWebsiteUrl) : null,
        twitterSearch: lR(e.mint, e.meteoraAddress ?? e.pumpSwapAddress ?? e.raydiumAddress ?? null, (null == n ? void 0 : n.twitterSearchExclusions) ?? zI)
    } : null), [e, null == n ? void 0 : n.twitterSearchExclusions]);
    return e ? v.jsx(kQ, {
        ...t,
        sxProps: {
            ...t.sxProps,
            alignItems: "center",
            justifyContent: "flex-start"
        },
        children: v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [(null == r ? void 0 : r.telegram) && v.jsx(aE, {
                Icon: Ly,
                link: r.telegram,
                preventDefault: !0,
                useHref: !1,
                showTooltip: !0
            }), (null == r ? void 0 : r.projectWebsite) && v.jsx(aE, {
                Icon: yk,
                link: r.projectWebsite,
                preventDefault: !0,
                useHref: !1,
                showTooltip: !0
            }), (null == r ? void 0 : r.twitterSearch) && v.jsx(aE, {
                Icon: Hv,
                link: r.twitterSearch,
                preventDefault: !0,
                useHref: !1,
                showTooltip: !1
            })]
        })
    }) : v.jsx(CQ, {})
}
))
  , kie = y.memo(( ({popularSymbolData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        ...t.sxProps,
        alignItems: "center",
        justifyContent: "flex-end"
    },
    children: v.jsx(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        children: v.jsx(s$, {
            createdAt: e.createdAt,
            variant: "monospace2"
        })
    })
}) : v.jsx(CQ, {})))
  , Cie = y.memo(( ({popularSymbolData: e, ...t}) => {
    const {t: n} = we();
    if (!e)
        return v.jsx(CQ, {});
    const r = null !== e.bondedAt && null === e.raydiumAddress && null === e.pumpSwapAddress
      , a = null !== e.raydiumAddress || null !== e.pumpSwapAddress;
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            ...t.sxProps,
            alignItems: "center",
            justifyContent: "flex-end"
        },
        children: v.jsx(S, {
            direction: "row",
            gap: .5,
            mr: -.5,
            alignItems: "center",
            children: r || a ? v.jsx(GC, {
                title: n(r ? "Bonding" : "Already bonded"),
                children: v.jsx(C, {
                    component: "span",
                    sx: {
                        mt: r ? 0 : .25,
                        cursor: "help"
                    },
                    children: r ? v.jsx(J, {
                        size: Aie
                    }) : v.jsx(vf, {})
                })
            }) : null
        })
    })
}
))
  , Aie = 12
  , wie = e => ({
    ...sZ(e),
    sortingOrder: ["desc", "asc"],
    headerClass: lY,
    minWidth: 45
})
  , jie = {
    alignItems: "center"
}
  , Tie = e => e.pumpSwapAddress ?? e.raydiumAddress ?? e.meteoraAddress ?? null
  , Iie = ({key: e, t: t, chain: n}) => {
    switch (e) {
    case "mint":
        return {
            ...wie(e),
            headerName: t("Token"),
            sortable: !1,
            headerClass: void 0,
            cellRenderer: e => v.jsx(fie, {
                popularSymbolData: e.data,
                ...e,
                sxProps: jie,
                chain: n,
                href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
            }),
            minWidth: 210,
            flex: 3,
            valueGetter: ({data: e}) => e ? `${e.mint}-${Tie(e)}-${e.padreAvatarUrl}-${e.symbol}-${e.name}` : void 0
        };
    case "twitterUrl":
        return {
            ...wie(e),
            headerName: t("Socials"),
            sortable: !1,
            headerClass: void 0,
            cellRenderer: e => v.jsx(yie, {
                popularSymbolData: e.data,
                ...e,
                sxProps: jie,
                chain: n,
                href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
            }),
            minWidth: 65,
            maxWidth: 65,
            valueGetter: ({data: e}) => e ? `${e.mint}-${Tie(e)}` : void 0
        };
    case "fdvInUsd":
        return {
            ...wie(e),
            headerName: t("MCap"),
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    symbol: "$",
                    price: (null == (t = e.data) ? void 0 : t.fdvInUsd) ?? null,
                    ...e,
                    collapseExponent: !0,
                    sxProps: {
                        ...jie,
                        justifyContent: "flex-end"
                    },
                    href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
                })
            }
            ,
            minWidth: 75,
            maxWidth: 75,
            valueGetter: ({data: e}) => e ? `${e.fdvInUsd}-${e.mint}-${Tie(e)}` : void 0,
            comparator: lZ((e => e.fdvInUsd ?? null))
        };
    case "m5VolumeInUsd":
        return {
            ...wie(e),
            headerName: t("5M Vol"),
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    symbol: "$",
                    price: (null == (t = e.data) ? void 0 : t.m5VolumeInUsd) ?? null,
                    ...e,
                    collapseExponent: !0,
                    sxProps: {
                        ...jie,
                        justifyContent: "flex-end"
                    },
                    href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
                })
            }
            ,
            minWidth: 75,
            maxWidth: 75,
            valueGetter: ({data: e}) => e ? `${e.m5VolumeInUsd}-${e.mint}-${Tie(e)}` : void 0,
            comparator: lZ((e => e.m5VolumeInUsd ?? null))
        };
    case "createdAt":
        return {
            ...wie(e),
            headerName: t("Age"),
            sort: "desc",
            cellRenderer: e => v.jsx(kie, {
                popularSymbolData: e.data,
                ...e,
                sxProps: {
                    ...jie,
                    justifyContent: "flex-end"
                },
                chain: n,
                href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
            }),
            minWidth: 63,
            maxWidth: 63,
            valueGetter: ({data: e}) => e ? `${e.createdAt}-${e.mint}-${Tie(e)}` : void 0
        };
    case "bondedAt":
        return {
            ...wie(e),
            headerName: "",
            sortable: !1,
            cellRenderer: e => v.jsx(Cie, {
                popularSymbolData: e.data,
                ...e,
                sxProps: {
                    ...jie,
                    justifyContent: "flex-end"
                },
                chain: n,
                href: XE(n, e.data ? Tie(e.data) || e.data.mint : null, nT.TRENCHES_POPULAR_SYMBOLS)
            }),
            minWidth: 34,
            maxWidth: 34,
            valueGetter: ({data: e}) => e ? `${e.bondedAt}-${e.mint}-${Tie(e)}` : void 0
        };
    default:
        return {}
    }
}
  , Eie = e => e.mint
  , Mie = y.memo(( ({infos: e, chain: t}) => {
    const {t: n} = we()
      , r = y.useMemo(( () => ( (e, t) => [Iie({
        key: "mint",
        t: e,
        chain: t
    }), Iie({
        key: "twitterUrl",
        t: e,
        chain: t
    }), Iie({
        key: "fdvInUsd",
        t: e,
        chain: t
    }), Iie({
        key: "m5VolumeInUsd",
        t: e,
        chain: t
    }), Iie({
        key: "createdAt",
        t: e,
        chain: t
    }), Iie({
        key: "bondedAt",
        t: e,
        chain: t
    })])(n, t)), [n, t])
      , a = y.useMemo(( () => (e => e ?? [])(e)), [e])
      , s = y.useMemo(( () => oZ("trenches-vibing-table")), []);
    return e ? v.jsx(yQ, {
        rowData: a,
        isLoading: !e,
        columnDefs: r,
        getRowUniqueId: Eie,
        ...s
    }) : v.jsx(S, {
        height: "100%",
        width: "100%",
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "Symbol no longer vibing"
        })
    })
}
))
  , Nie = y.memo(( ({summary: e, chain: t}) => {
    const n = xw()
      , r = y.useMemo(( () => (null == e ? void 0 : e.tokens) ? c.sum(e.tokens.map((e => e.m5VolumeInUsd ?? 0))) : null), [null == e ? void 0 : e.tokens])
      , a = y.useMemo(( () => mie(r ?? 0)), [r]);
    return v.jsxs(S, {
        pt: 1,
        gap: 1,
        width: n ? Oie : Pie,
        sx: e => ({
            backgroundColor: e.palette.background.buttonDefault,
            border: `1px solid ${e.palette.background.borderMain}`
        }),
        children: [v.jsx(S, {
            className: "padre-no-scroll",
            gap: 1,
            children: v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                px: 2,
                gap: .5,
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    children: [v.jsx(k, {
                        ...Die,
                        children: (null == e ? void 0 : e.substring) ?? Ud
                    }), e && v.jsx(aE, {
                        Icon: Mk,
                        link: dR(e.substring),
                        preventDefault: !0,
                        useHref: !1,
                        showTooltip: !1
                    }), e && v.jsx(aE, {
                        Icon: Fy,
                        link: cR(e.substring),
                        preventDefault: !0,
                        useHref: !1,
                        showTooltip: !1
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    children: [v.jsx(k, {
                        ...Rie,
                        children: "Total 5m vol"
                    }), v.jsx(k, {
                        ...Die,
                        color: a,
                        children: null === r ? Ud : LI(r, {
                            collapseExponent: !0,
                            symbol: "$",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            removeTrailingZerosPrecision: 2
                        })
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    children: [v.jsx(k, {
                        ...Rie,
                        children: "Count"
                    }), v.jsx(k, {
                        ...Die,
                        children: (null == e ? void 0 : e.tokens.length) ?? Ud
                    })]
                })]
            })
        }), v.jsx(S, {
            height: Lie,
            className: "padre-no-scroll",
            children: v.jsx(Mie, {
                infos: (null == e ? void 0 : e.tokens) ?? null,
                chain: t
            })
        })]
    })
}
))
  , Pie = 325
  , Oie = 525
  , Lie = 225
  , Rie = {
    variant: "paragraph1",
    color: "text.label",
    noWrap: !0
}
  , Die = {
    variant: "paragraph1",
    color: "text.value",
    minWidth: 24
}
  , Bie = y.memo(( ({chain: e}) => {
    const {t: t} = we()
      , n = ( () => {
        const e = y.useCallback((e => Lm.subscribePopularSymbolSubstrings(e)), []);
        return yx(e)
    }
    )()
      , [r,a] = dx("padreV2-trenchesPopularSymbolsTimespan", "15m")
      , s = y.useCallback((e => {
        a(e.target.value)
    }
    ), [a])
      , [o,l] = y.useState(!1)
      , i = y.useCallback(( () => {
        l(!0)
    }
    ), [])
      , c = y.useCallback(( () => {
        l(!1)
    }
    ), [])
      , d = y.useRef(null);
    y.useEffect(( () => {
        o && d.current || (d.current = n || null)
    }
    ), [o, n]);
    const u = y.useMemo(( () => o && d.current ? d.current : n), [o, n])
      , {buttonProps: p, popoverProps: h} = Fw({
        id: "trenching-popular-symbol-popover",
        onClose: c,
        onOpen: i
    })
      , [m,g] = y.useState(null)
      , x = y.useMemo(( () => m && n ? n[r].find((e => e.substring === m)) ?? null : null), [m, n, r])
      , b = y.useCallback((async () => {
        h.onClose(),
        g(null)
    }
    ), [h]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            width: "100%",
            alignItems: "center",
            children: [v.jsx(Ee, {
                flexItem: !0,
                orientation: "vertical",
                sx: {
                    mt: .75,
                    mb: .75
                }
            }), v.jsx(z, {
                title: t("These words appear often in recently deployed pumpfun tokens"),
                children: v.jsx(C, {
                    component: "span",
                    sx: {
                        cursor: "help"
                    },
                    children: v.jsx(k, {
                        variant: "h2",
                        color: "text.main",
                        children: t("Vibing")
                    })
                })
            }), v.jsx(S, {
                children: v.jsx(it, {
                    sx: {
                        p: 0,
                        height: 28,
                        "& .MuiSvgIcon-root": {
                            fontSize: 20
                        }
                    },
                    value: r,
                    onChange: s,
                    notched: !1,
                    input: v.jsx(je, {}),
                    children: _ie.map((e => v.jsx(te, {
                        value: e,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            children: hie(e)
                        })
                    }, e)))
                })
            }), u && v.jsx(S, {
                overflow: "scroll",
                direction: "row",
                gap: .5,
                className: "padre-no-scroll",
                mr: 9.5,
                children: u[r].sort(( (e, t) => t.frequency - e.frequency)).map((e => v.jsx(gie, {
                    summary: e,
                    onClick: t => {
                        g((t => null === t ? e.substring : null)),
                        p.ref.current = t.currentTarget,
                        p.onClick()
                    }
                }, e.substring)))
            })]
        }), v.jsx(ae, {
            ...h,
            onClose: b,
            disablePortal: !0,
            onClick: e => {
                e.stopPropagation()
            }
            ,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            slotProps: {
                paper: {
                    className: "padre-no-scroll"
                }
            },
            children: v.jsx(Nie, {
                summary: x,
                chain: e
            })
        })]
    })
}
))
  , _ie = ["1m", "5m", "15m"]
  , Uie = y.memo(( ({compact: e=!1, hideLabel: t=!1, large: n=!1}) => {
    const {trenchesChain: r, setTrenchesChain: a} = xne()
      , {t: s} = we()
      , o = y.useCallback(( () => {
        a(Pd.SOLANA)
    }
    ), [a])
      , l = y.useCallback(( () => {
        a(Pd.BSC)
    }
    ), [a])
      , i = y.useMemo(( () => e => {
        const t = r === Pd.BSC ? e.palette.lavender[500] : e.palette.text.label;
        return {
            position: "absolute",
            bottom: -3,
            right: -15,
            display: "flex",
            alignItems: "center",
            borderRadius: 6,
            border: `1px solid ${t}80`,
            background: e.palette.background.default,
            color: t,
            px: "3px",
            height: 12
        }
    }
    ), [r]);
    return e ? v.jsx(S, {
        direction: "row",
        alignItems: "center",
        sx: Vie,
        children: [Pd.SOLANA, Pd.BSC].map((e => {
            const t = $ie(e, r === e);
            return v.jsx(F, {
                onClick: () => a(e),
                sx: Hie,
                children: v.jsxs(C, {
                    display: "flex",
                    position: "relative",
                    children: [v.jsx(t, {
                        size: zie
                    }), e === Pd.BSC && v.jsx(C, {
                        position: "absolute",
                        sx: i,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "inherit",
                            fontSize: 8,
                            children: "beta"
                        })
                    })]
                })
            }, e)
        }
        ))
    }) : v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        pl: .5,
        gap: 2,
        children: [!t && v.jsx(k, {
            variant: "h1",
            color: "text.main",
            noWrap: !0,
            sx: qie,
            children: s("Trenches")
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(F, {
                onClick: o,
                sx: Gie,
                size: "large",
                children: r === Pd.SOLANA ? v.jsx(dk, {
                    size: n ? Fie : Wie
                }) : v.jsx(Jv, {
                    size: n ? Fie : Wie
                })
            }), v.jsx(GC, {
                title: s("BSC support currently available in beta - some features may be limited."),
                children: v.jsx(C, {
                    display: "flex",
                    children: v.jsx(F, {
                        onClick: l,
                        sx: Gie,
                        children: v.jsxs(C, {
                            display: "flex",
                            position: "relative",
                            children: [r === Pd.BSC ? v.jsx(ak, {
                                size: n ? Fie : Wie
                            }) : v.jsx(rk, {
                                size: n ? Fie : Wie
                            }), v.jsx(C, {
                                position: "absolute",
                                sx: i,
                                children: v.jsx(k, {
                                    variant: "paragraph3",
                                    color: "inherit",
                                    fontSize: 8,
                                    children: "beta"
                                })
                            })]
                        })
                    })
                })
            })]
        })]
    })
}
))
  , Wie = 18
  , Fie = 24
  , Vie = {
    gap: .5
}
  , Hie = {
    p: .25,
    height: 30,
    width: 30
}
  , zie = 24
  , $ie = (e, t) => {
    switch (e) {
    case Pd.SOLANA:
        return t ? dk : Jv;
    case Pd.BSC:
        return t ? ak : rk
    }
}
  , Gie = {
    p: 0,
    height: 24,
    width: 24
}
  , qie = {
    fontSize: 20,
    fontWeight: 500
}
  , Kie = y.memo(( ({trenchMode: e, setTrenchMode: t}) => {
    const n = y.useCallback(( () => {
        t(Zh.NEW)
    }
    ), [t])
      , r = y.useCallback(( () => {
        t(Zh.ALMOST_BONDED)
    }
    ), [t])
      , a = y.useCallback(( () => {
        t(Zh.RECENTLY_BONDED)
    }
    ), [t]);
    return v.jsxs(S, {
        alignItems: "center",
        gap: .25,
        direction: "row",
        children: [v.jsx(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: e === Zh.NEW ? Xie : Yie,
            onClick: n,
            children: v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                noWrap: !0,
                children: Eee[Zh.NEW]
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: Qie
        }), v.jsx(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: e === Zh.ALMOST_BONDED ? Xie : Yie,
            onClick: r,
            children: v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                noWrap: !0,
                children: Eee[Zh.ALMOST_BONDED]
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: Qie
        }), v.jsx(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: e === Zh.RECENTLY_BONDED ? Xie : Yie,
            onClick: a,
            children: v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                noWrap: !0,
                children: Eee[Zh.RECENTLY_BONDED]
            })
        })]
    })
}
))
  , Yie = e => ({
    py: 0,
    px: .5,
    height: 22,
    minWidth: 24,
    color: e.palette.text.label,
    background: "transparent",
    border: "none",
    "&:focus": {
        background: "transparent",
        border: "none"
    },
    "&:hover": {
        background: e.palette.background.secondary,
        border: "none"
    }
})
  , Xie = e => ({
    ...Yie(e),
    color: e.palette.text.value,
    background: e.palette.background.buttonDefault,
    "&:focus": {
        background: e.palette.background.buttonDefault
    },
    "&:hover": {
        background: e.palette.background.buttonDefault
    }
})
  , Qie = {
    my: .75
}
  , Zie = y.memo(( ({trenchMode: e, setTrenchMode: t}) => {
    const {onTrenchesDock: n, trenchesDock: r, toggleTrenchesWidget: a} = J6()
      , s = y.useMemo(( () => e => ({
        px: .75,
        py: .75,
        gap: .5,
        width: "100%",
        borderBottom: `1px solid ${e.palette.background.borderMain}`
    })), [])
      , o = y.useCallback(( () => {
        n(r === K6.LEFT ? K6.RIGHT : K6.LEFT)
    }
    ), [n, r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: s,
        className: "padre-no-scroll",
        overflow: "scroll",
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(Kie, {
                trenchMode: e,
                setTrenchMode: t
            }), v.jsx(Uie, {
                hideLabel: !0
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            className: "no-drag",
            height: nce,
            children: [v.jsx(z, {
                title: `Dock ${(r === K6.LEFT ? K6.RIGHT : K6.LEFT).toLowerCase()}`,
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsx(V, {
                        ...tce,
                        onClick: o,
                        children: v.jsx(C, {
                            display: "flex",
                            sx: {
                                transform: r === K6.RIGHT ? "scaleX(-1)" : "none"
                            },
                            children: v.jsx(_f, {
                                size: ece
                            })
                        })
                    })
                })
            }, r), v.jsx(F, {
                onClick: a,
                sx: Jie,
                children: v.jsx(gy, {})
            })]
        })]
    })
}
))
  , Jie = {
    p: 0
}
  , ece = 18
  , tce = {
    variant: "tertiary",
    size: "xxsmall",
    sx: {
        p: 0,
        height: 24,
        width: 24,
        minWidth: 24,
        border: "none",
        background: "transparent"
    }
}
  , nce = 24
  , rce = Zh.NEW
  , ace = y.memo(( () => {
    const [e,t] = dx("padreV2-trenchesWidgetTrenchMode", rce);
    return v.jsx(cH, {
        contextId: "trenches-docked",
        children: v.jsxs(S, {
            height: "100%",
            overflow: "hidden",
            children: [v.jsx(Zie, {
                trenchMode: e,
                setTrenchMode: t
            }), v.jsx(S, {
                sx: sce,
                className: "padre-no-scroll",
                children: v.jsx(tie, {
                    trenchMode: e,
                    isSpaced: !1,
                    order: 0,
                    compact: !0,
                    fullsize: !0
                }, e)
            })]
        })
    })
}
))
  , sce = {
    overflowY: "scroll",
    width: "100%",
    height: "100%"
}
  , oce = y.memo(( () => {
    const {displayData: e} = a8()
      , t = yT()
      , {marketCapThresholds: n} = bA();
    return null === e ? v.jsx(S, {
        alignItems: "center",
        justifyContent: "center",
        width: "100%",
        height: "100%",
        children: v.jsx(Km, {})
    }) : e.length ? v.jsx(S, {
        height: "100%",
        children: v.jsx(mt, {
            children: ({height: r, width: a}) => v.jsx(gt, {
                className: "padre-no-scroll",
                height: r,
                width: a,
                rowHeight: 78,
                rowCount: e.length,
                itemData: e,
                rowRenderer: ({index: r, style: a, key: s}) => {
                    const o = e[r];
                    return v.jsx("div", {
                        style: a,
                        children: v.jsx(iq, {
                            marketCapColorThresholds: n,
                            onClick: () => {
                                t({
                                    tokenAddress: o.tokenAddress,
                                    chain: o.chain,
                                    tradePageOrigin: nT.ALPHA_TRACKER
                                })
                            }
                            ,
                            ...o
                        })
                    }, `${s}-${o.messageId}-${o.tokenAddress}`)
                }
                ,
                overscanRowCount: 2
            })
        })
    }) : v.jsx(S, {
        alignItems: "center",
        justifyContent: "center",
        width: "100%",
        height: "100%",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "No data to show"
        })
    })
}
));
var lce = (e => (e.DISCORD = "DISCORD",
e.TELEGRAM = "TELEGRAM",
e.TWITTER = "TWITTER",
e))(lce || {});
const ice = y.memo(( ({label: e, imageUrl: t, origin: n, showNotifications: r, toggleNotifications: a, showOnChart: s, toggleShowOnChart: o, showInTracker: l, toggleShowInTracker: i}) => {
    const c = D()
      , {t: d} = we()
      , u = y.useMemo(( () => {
        switch (n) {
        case lce.DISCORD:
            return v.jsx(PS, {});
        case lce.TELEGRAM:
            return v.jsx(Ly, {});
        case lce.TWITTER:
            return v.jsx(Mk, {});
        default:
            return v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                noWrap: !0,
                maxWidth: uce,
                children: n
            })
        }
    }
    ), [n]);
    return v.jsxs(C, {
        display: "flex",
        height: 34,
        minHeight: 34,
        minWidth: 382,
        alignItems: "center",
        justifyContent: "space-between",
        sx: cce,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            pl: .5,
            pr: .5,
            children: [v.jsx(C, {
                display: "flex",
                alignItems: "center",
                minWidth: uce,
                children: u
            }), v.jsx(C, {
                component: "img",
                src: t,
                sx: pce
            }), v.jsx(k, {
                variant: "paragraph3",
                noWrap: !0,
                maxWidth: dce,
                children: e
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1.25,
            children: [v.jsx(GC, {
                title: d(l ? r ? "Disable notifications" : "Enable notifications" : "Enable in tracker to show notifications"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    className: "no-drag",
                    children: v.jsx(V, {
                        disabled: !l,
                        onClick: a,
                        ...hce,
                        children: r && l ? v.jsx(jy, {
                            size: 16,
                            color: c.palette.primary.main
                        }) : v.jsx(Ey, {
                            size: 16
                        })
                    })
                })
            }), v.jsx(GC, {
                title: d(s ? "Hide on Chart" : "Show on Chart"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    className: "no-drag",
                    children: v.jsx(V, {
                        onClick: o,
                        ...hce,
                        children: v.jsx(my, {
                            size: 16,
                            color: s ? c.palette.primary.main : c.palette.text.label
                        })
                    })
                })
            }), v.jsx(GC, {
                title: d(l ? "Hide in Tracker" : "Show in Tracker"),
                children: v.jsx(C, {
                    display: "flex",
                    component: "span",
                    className: "no-drag",
                    children: v.jsx(V, {
                        onClick: i,
                        ...hce,
                        children: v.jsx(Vk, {
                            size: 16,
                            color: l ? c.palette.primary.main : c.palette.text.label
                        })
                    })
                })
            })]
        })]
    })
}
))
  , cce = e => ({
    gap: .25,
    px: 1,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonDefault
    }
})
  , dce = 212
  , uce = 32
  , pce = {
    borderRadius: "50%",
    height: 16,
    width: 16
}
  , hce = {
    size: "xxsmall",
    variant: "tertiary",
    sx: e => ({
        px: 0,
        width: 22,
        minWidth: 22,
        height: 22,
        color: e.palette.text.label,
        background: "transparent",
        border: "none",
        "&:hover": {
            border: "none",
            color: e.palette.text.value
        }
    })
}
  , mce = y.memo(( ({onChangeOnChart: e, onChangeOnTracker: t, onChangeNotifications: n}) => {
    const {alphaGroups: r} = JG()
      , {alphaGroupsSilenced: a, alphaGroupsHideOnChart: s, alphaGroupsHideOnLiveTrades: o} = a8()
      , l = y.useMemo(( () => r ? c.reduce(r, ( (e, t) => {
        const {name: n, imageUrl: r, id: l, origin: i, priority: c} = t
          , d = (e => {
            switch (e) {
            case Wu.DISCORD:
                return lce.DISCORD;
            case Wu.TELEGRAM:
                return lce.TELEGRAM;
            case Wu.TWITTER:
                return lce.TWITTER;
            default:
                return e
            }
        }
        )(i);
        return e.push({
            id: l,
            label: n,
            imageUrl: r,
            origin: d,
            showNotifications: !a || !0 !== a[l],
            showOnChart: !s || !0 !== s[l],
            showInTracker: !o || !0 !== o[l],
            priority: c
        }),
        e
    }
    ), []).sort(( (e, t) => e.priority !== t.priority ? t.priority - e.priority : e.label.localeCompare(t.label))) : null), [r, s, o, a]);
    return (null == l ? void 0 : l.length) ? v.jsx(S, {
        height: "100%",
        width: "100%",
        children: l.length ? v.jsx(mt, {
            children: ({height: r, width: a}) => v.jsx(C, {
                className: "padre-decorative-scroll",
                sx: {
                    width: a > 350 ? a : a - 2,
                    height: r - 2,
                    overflowX: "auto",
                    overflowY: "hidden"
                },
                children: v.jsx(C, {
                    sx: gce,
                    children: v.jsx(gt, {
                        className: "padre-no-scroll",
                        height: r,
                        width: Math.max(a, 350),
                        rowHeight: 32,
                        rowCount: l.length,
                        itemData: l,
                        rowRenderer: ({index: r, style: a}) => {
                            const s = l[r];
                            return v.jsx("div", {
                                style: a,
                                children: v.jsx(ice, {
                                    label: s.label,
                                    imageUrl: s.imageUrl,
                                    origin: s.origin,
                                    showNotifications: s.showNotifications,
                                    toggleNotifications: e => {
                                        e.stopPropagation(),
                                        n(s.id, !s.showNotifications)
                                    }
                                    ,
                                    showOnChart: s.showOnChart,
                                    toggleShowOnChart: t => {
                                        t.stopPropagation(),
                                        e(s.id, !s.showOnChart)
                                    }
                                    ,
                                    showInTracker: s.showInTracker,
                                    toggleShowInTracker: e => {
                                        e.stopPropagation(),
                                        t(s.id, !s.showInTracker)
                                    }
                                })
                            }, s.id)
                        }
                        ,
                        overscanRowCount: 5
                    })
                })
            })
        }) : v.jsx(S, {
            height: "100%",
            width: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: "No groups available"
            })
        })
    }) : v.jsx(Km, {})
}
))
  , gce = e => ({
    width: "max(350px, 100%)",
    "& .ReactVirtualized__Grid__innerScrollContainer > div:nth-of-type(odd)": {
        background: e.palette.background.secondary
    }
})
  , xce = y.memo(( () => {
    const e = Ax()
      , t = y.useCallback((async (t, n) => {
        if (e)
            try {
                await _m.updateAlphaMentionsUiGroupHideChartMarks(e, {
                    updates: {
                        [t]: !1 === n || null
                    }
                })
            } catch (fNe) {}
    }
    ), [e])
      , n = y.useCallback((async (t, n) => {
        if (e)
            try {
                await _m.updateAlphaMentionsUiGroupHideInTracker(e, {
                    updates: {
                        [t]: !1 === n || null
                    }
                })
            } catch (fNe) {}
    }
    ), [e])
      , r = y.useCallback((async (t, n) => {
        if (e)
            try {
                await _m.updateAlphaMentionsUiGroupHideNotifications(e, {
                    updates: {
                        [t]: !1 === n || null
                    }
                })
            } catch (fNe) {}
    }
    ), [e]);
    return v.jsx(S, {
        height: "100%",
        pb: .75,
        children: v.jsx(mce, {
            onChangeOnChart: t,
            onChangeOnTracker: n,
            onChangeNotifications: r
        })
    })
}
));
var bce = (e => (e.TRACKER = "TRACKER",
e.SETTINGS = "SETTINGS",
e))(bce || {});
const fce = {
    [bce.TRACKER]: n.t("Alpha Tracker"),
    [bce.SETTINGS]: n.t("Settings")
}
  , vce = "padreV2-alphaTrackerTab"
  , Sce = y.memo(( ({selectedTab: e, setSelectedTab: t, onDock: n, onUndock: r, onClose: a, isInModal: s=!1}) => {
    const o = D()
      , {t: l} = we()
      , {alertsEnabled: i, toggleAlertsEnabled: c, soundEffectEnabled: d, setSoundEffectEnabled: u, selectedSoundEffect: p, setSelectedSoundEffect: h, notificationsVolume: m, setNotificationsVolume: g, setNotificationsDuration: x, notificationsDuration: b} = a8();
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        justifyContent: "space-between",
        alignItems: "center",
        children: [v.jsx(S, {
            direction: "row",
            alignItems: "center",
            gap: .25,
            children: wce.map((n => {
                const r = n === e;
                return v.jsx(V, {
                    className: "no-drag",
                    onClick: () => {
                        t(n)
                    }
                    ,
                    variant: "tertiary",
                    size: "xxsmall",
                    sx: e => ({
                        px: .75,
                        pb: .25,
                        border: "none",
                        height: 24,
                        mt: "-2px",
                        backgroundColor: "transparent",
                        color: r ? e.palette.text.main : e.palette.text.label,
                        "&:hover": {
                            border: "none",
                            backgroundColor: "transparent",
                            color: r ? e.palette.text.main : e.palette.text.value
                        },
                        "&:focus": {
                            border: "none",
                            backgroundColor: "transparent"
                        }
                    }),
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "inherit",
                        noWrap: !0,
                        lineHeight: 1.1,
                        mt: "1px",
                        children: fce[n]
                    })
                }, n)
            }
            ))
        }), v.jsxs(S, {
            direction: "row",
            gap: .75,
            alignItems: "center",
            className: "no-drag",
            children: [i && v.jsx(C, {
                component: "span",
                children: v.jsx(pI, {
                    soundEffectEnabled: d,
                    selectedSoundEffect: p,
                    notificationsVolume: m,
                    setNotificationsVolume: g,
                    notificationsDuration: b,
                    setNotificationsDuration: x,
                    usePopper: !s,
                    isInFloatingWidget: !s
                })
            }), i && v.jsx(C, {
                component: "span",
                children: v.jsx(ej, {
                    idKey: "notifications",
                    soundEffectEnabled: d,
                    setSoundEffectEnabled: u,
                    selectedSoundEffect: p,
                    setSelectedSoundEffect: h,
                    volume: m,
                    usePopper: !s,
                    isInFloatingWidget: !s
                })
            }), v.jsx(GC, {
                title: l(i ? "Disable notification" : "Enable notifications"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...kce,
                        onClick: c,
                        children: i ? v.jsx(jy, {
                            size: yce,
                            color: o.palette.primary.main
                        }) : v.jsx(Ey, {
                            size: yce
                        })
                    })
                })
            }), v.jsx(C, {
                component: "span",
                children: v.jsx(S8, {})
            }), n && v.jsx(v.Fragment, {
                children: Cce.map((e => v.jsx(z, {
                    title: l("Dock {{side}}", {
                        side: e.toLowerCase()
                    }),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            ...kce,
                            onClick: () => {
                                n(e)
                            }
                            ,
                            children: v.jsx(C, {
                                display: "flex",
                                sx: {
                                    transform: e === K6.LEFT ? "scaleX(-1)" : "none"
                                },
                                children: v.jsx(_f, {
                                    size: yce
                                })
                            })
                        })
                    })
                }, e)))
            }), r && v.jsx(z, {
                title: l("Undock"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        ...kce,
                        onClick: r,
                        children: v.jsx(Rf, {
                            size: yce
                        })
                    })
                })
            }), a && v.jsx(F, {
                onClick: a,
                sx: Ace,
                children: v.jsx(gy, {})
            })]
        })]
    })
}
))
  , yce = 18
  , kce = {
    variant: "tertiary",
    size: "xxsmall",
    sx: {
        p: 0,
        height: 24,
        width: 24,
        minWidth: 24,
        border: "none",
        background: "transparent"
    }
}
  , Cce = [K6.LEFT, K6.RIGHT]
  , Ace = {
    p: 0
}
  , wce = [bce.TRACKER, bce.SETTINGS]
  , jce = y.memo(( ({closeAlphaTrackerWidget: e, internalIndex: t, onDock: n}) => {
    const [r,a] = dx(vce, bce.TRACKER)
      , s = y.useMemo(( () => v.jsx(Sce, {
        selectedTab: r,
        setSelectedTab: a,
        onDock: n
    })), [n, r, a]);
    return v.jsx(P8, {
        id: Y6.ALPHA_TRACKER,
        width: 400,
        height: 350,
        initialX: 425,
        initialY: window.innerHeight - 382,
        onClose: e,
        header: s,
        headerSx: Tce,
        internalIndex: t,
        resizeParams: Ice,
        hasModals: !0,
        smallHeaderGap: !0,
        children: v.jsxs(S, {
            className: "padre-no-scroll",
            overflow: "hidden",
            mt: 0,
            mb: -1,
            gap: 1,
            width: "100%",
            height: "100%",
            children: [r === bce.TRACKER && v.jsx(oce, {}), r === bce.SETTINGS && v.jsx(xce, {})]
        })
    })
}
))
  , Tce = {
    height: 22
}
  , Ice = {
    minWidth: 400,
    minHeight: 250
}
  , Ece = y.memo(( ({closeTrackedWalletsWidget: e, onUndock: t}) => {
    const [n,r] = dx(vce, bce.TRACKER);
    return v.jsxs(S, {
        gap: 1,
        height: "100%",
        py: .75,
        children: [v.jsx(S, {
            px: .5,
            children: v.jsx(Sce, {
                selectedTab: n,
                setSelectedTab: r,
                onUndock: t,
                onClose: e
            })
        }), v.jsxs(S, {
            className: "padre-no-scroll",
            overflow: "hidden",
            mt: 0,
            mb: -1,
            gap: 1,
            width: "100%",
            height: "100%",
            children: [n === bce.TRACKER && v.jsx(oce, {}), n === bce.SETTINGS && v.jsx(xce, {})]
        })]
    })
}
))
  , Mce = y.memo(( ({onClose: e}) => {
    const [t,n] = dx(vce, bce.TRACKER);
    return v.jsx(Sw, {
        desktopWidth: "max-content",
        open: !0,
        stackSx: Nce,
        onClose: e,
        children: v.jsxs(v.Fragment, {
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                py: 1,
                gap: 1,
                px: 2,
                children: [v.jsx(F, {
                    sx: Pce,
                    onClick: e,
                    children: v.jsx(ky, {})
                }), v.jsx(k, {
                    variant: "paragraph1",
                    children: "Alpha Tracker"
                })]
            }), v.jsx(Ee, {}), v.jsxs(S, {
                mt: 1,
                mx: 1.5,
                flexGrow: 1,
                gap: 1,
                children: [v.jsx(Sce, {
                    selectedTab: t,
                    setSelectedTab: n,
                    isInModal: !0
                }), t === bce.TRACKER && v.jsx(oce, {}), t === bce.SETTINGS && v.jsx(xce, {})]
            })]
        })
    })
}
))
  , Nce = {
    p: 0,
    zIndex: $w,
    height: "100%"
}
  , Pce = {
    px: .25,
    width: 28,
    height: 28
}
  , Oce = y.createContext({
    widgetsOrder: X6,
    toggleMostRecentWidget: c.noop
})
  , Lce = () => y.useContext(Oce)
  , Rce = ({children: e}) => {
    const t = xw()
      , {widgetsOrder: n, toggleMostRecentWidget: r} = Lce()
      , {pathname: a} = he()
      , [s,o] = dx("padreV2-floatingWidgetsPnlTrackerOpen", !1)
      , l = y.useCallback(( () => {
        o(!1)
    }
    ), [o])
      , i = y.useCallback(( () => {
        s || r(Y6.WATCHLIST),
        o((e => !e))
    }
    ), [s, o, r])
      , [c,d] = dx("padreV2-floatingWidgetsWatchlistOpen", !1)
      , u = y.useCallback(( () => {
        d(!1)
    }
    ), [d])
      , p = y.useCallback(( () => {
        c || r(Y6.WATCHLIST),
        d((e => !e))
    }
    ), [c, d, r])
      , [h,m] = dx("padreV2-floatingWidgetsTrackedWalletsOpen", !1)
      , g = y.useCallback(( () => {
        m(!1)
    }
    ), [m])
      , x = y.useCallback(( () => {
        h || r(Y6.TRACKED_WALLETS),
        m((e => !e))
    }
    ), [h, m, r])
      , [b,f] = dx("padreV2-floatingWidgetsTwitterTrackedOpenV2", !1)
      , S = y.useCallback(( () => {
        f(!1)
    }
    ), [f])
      , k = y.useCallback(( () => {
        b || r(Y6.TWITTER_TRACKER),
        f((e => !e))
    }
    ), [b, f, r])
      , [C,A] = dx("padreV2-floatingWidgetsAlphaTrackedOpen", !1)
      , w = y.useCallback(( () => {
        A(!1)
    }
    ), [A])
      , j = y.useCallback(( () => {
        C || r(Y6.ALPHA_TRACKER),
        A((e => !e))
    }
    ), [C, A, r])
      , [T,I] = dx("padreV2-floatingWidgetsTrenchesOpen", !1)
      , E = y.useCallback(( () => {
        T || r(Y6.TRENCHES),
        I((e => !e))
    }
    ), [T, I, r])
      , [M,N] = dx("padreV2-trackedWalletsDockV2", null)
      , [P,O] = dx("padreV2-twitterTrackerDock", null)
      , [L,R] = dx("padreV2-trenchesDock", Q6)
      , [D,B] = dx("padreV2-alphaTrackerDock", null)
      , _ = y.useCallback((e => {
        N(e)
    }
    ), [N])
      , U = y.useCallback(( () => {
        N(null)
    }
    ), [N])
      , W = y.useCallback((e => {
        O(e)
    }
    ), [O])
      , F = y.useCallback(( () => {
        O(null)
    }
    ), [O])
      , V = y.useCallback((e => {
        R(e)
    }
    ), [R])
      , H = y.useCallback((e => {
        B(e)
    }
    ), [B])
      , z = y.useCallback(( () => {
        B(null)
    }
    ), [B])
      , $ = y.useMemo(( () => ({
        isPnlTrackerWidgetOpen: s,
        togglePnlTrackerWidget: i,
        isWatchlistWidgetOpen: c,
        toggleWatchlistWidget: p,
        isTrackedWalletsWidgetOpen: h,
        toggleTrackedWalletsWidget: x,
        isTwitterTrackerWidgetOpen: b,
        toggleTwitterTrackerWidget: k,
        isTrenchesWidgetOpen: T,
        toggleTrenchesWidget: E,
        trackedWalletsDock: M,
        onTrackedWalletsUndock: U,
        twitterTrackerDock: P,
        onTwitterTrackerUndock: F,
        trenchesDock: L,
        onTrenchesDock: V,
        isAlphaTrackerWidgetOpen: C,
        toggleAlphaTrackerWidget: j,
        alphaTrackerDock: D,
        onAlphaTrackerUndock: z
    })), [s, i, c, p, h, x, b, k, T, E, M, U, P, F, L, V, C, j, D, z]);
    return v.jsx(p8, {
        isVisible: C,
        children: v.jsxs(Z6.Provider, {
            value: $,
            children: [e, t && s && v.jsx(u7, {
                closePnlTrackerWidget: l,
                internalIndex: n[Y6.PNL_TRACKER] ?? 0
            }), t && c && v.jsx(h7, {
                closeWatchlistWidget: u,
                internalIndex: n[Y6.WATCHLIST] ?? 0
            }), a !== tT.TRACKER && t && h && !M && v.jsx(_9, {
                closeTrackedWalletsWidget: g,
                internalIndex: n[Y6.TRACKED_WALLETS] ?? 0,
                onDock: _
            }), a !== tT.TRACKER && t && b && !P && v.jsx(vee, {
                closeTwitterTrackerWidget: S,
                internalIndex: n[Y6.TWITTER_TRACKER] ?? 0,
                onDock: W
            }), t && C && !D && v.jsx(jce, {
                closeAlphaTrackerWidget: w,
                internalIndex: n[Y6.ALPHA_TRACKER] ?? 0,
                onDock: H
            }), !t && C && v.jsx(Mce, {
                onClose: w
            })]
        })
    })
}
  , Dce = ({children: e}) => {
    const [t,n] = dx("padreV2-floatingWidgetsOrderV2", Object.keys(X6))
      , r = y.useMemo(( () => c.reduce(t, ( (e, t, n) => (e[t] = n,
    e)), {})), [t])
      , a = y.useCallback((e => {
        n((t => c.uniq([...t.filter((t => t !== e)), e])))
    }
    ), [n])
      , s = y.useMemo(( () => ({
        widgetsOrder: r,
        toggleMostRecentWidget: a
    })), [a, r]);
    return v.jsx(Oce.Provider, {
        value: s,
        children: e
    })
}
  , Bce = y.createContext({
    portfolioData: null,
    fullPortfolio: null,
    refreshFullPortfolio: () => {}
});
Bce.displayName = "PortfolioDataContext";
const _ce = e => (Object.values(e).forEach((e => {
    e.perTokenId && Object.keys(e.perTokenId).forEach((t => {
        const n = (e => {
            const [t,n] = e.split("-")
              , r = tg(t);
            return null === r ? null : {
                chain: r,
                tokenAddress: ng(n)
            }
        }
        )(t);
        !e.perTokenId || n && TD(n.chain) || delete e.perTokenId[t]
    }
    ))
}
)),
e)
  , Uce = (e, t) => {
    if ("init" === t.type)
        return _ce(t.snapshot);
    let n = e ? {
        ...e
    } : {};
    return "update" === t.type && ("wallet-init" === t.update.type && (n = {
        ...n,
        [t.update.wallet]: {
            ...n[t.update.wallet],
            perTokenId: c.pickBy(t.update.perTokenId, (e => TD(e.chain)))
        }
    }),
    "wallet-update" === t.update.type && t.update.updates.forEach((e => {
        var r;
        if (!TD(e.chain))
            return;
        const a = bg(e.chain, e.tokenAddress);
        n = {
            ...n,
            [t.update.wallet]: {
                ...n[t.update.wallet],
                perTokenId: {
                    ...(null == (r = n[t.update.wallet]) ? void 0 : r.perTokenId) || {},
                    [a]: e
                }
            }
        }
    }
    ))),
    n
}
  , Wce = () => {
    const e = Ax()
      , t = y.useCallback((t => e ? dm.subscribeUserOpenPortfolio(e, t) : {
        unsubscribe: () => {}
    }), [e]);
    return kx(t, Uce, {
        debounceDuration: 100
    })
}
  , Fce = (e, t) => {
    const n = Ax()
      , r = y.useCallback((r => n && e && t ? dm.subscribeUserSinglePosition(n, e, t, r) : {
        unsubscribe: () => {}
    }), [n, e, t]);
    return kx(r, Uce)
}
  , Vce = ({children: e}) => {
    const t = Ax()
      , n = Wce()
      , [r,a] = y.useState({
        status: ox.INITIAL
    })
      , s = y.useRef(t);
    s.current = t;
    const o = y.useRef(r);
    o.current = r;
    const l = y.useCallback((e => {
        t ? (e || [ox.INITIAL, ox.ERROR].includes(o.current.status)) && (async () => {
            a({
                status: ox.LOADING
            });
            try {
                const e = _ce(await dm.fetchFullPortfolio(t));
                s.current === t && a({
                    data: e,
                    status: ox.READY
                })
            } catch (fNe) {
                s.current === t && a({
                    status: ox.ERROR
                })
            }
        }
        )() : a({
            status: ox.INITIAL
        })
    }
    ), [t])
      , [i,d] = y.useState(n)
      , u = y.useMemo(( () => c.throttle((e => {
        d(e)
    }
    ), Hce)), []);
    y.useEffect(( () => (u(n),
    () => {
        u.cancel()
    }
    )), [n, u]);
    const p = y.useMemo(( () => ({
        portfolioData: i,
        fullPortfolio: r,
        refreshFullPortfolio: l
    })), [i, r, l]);
    return v.jsx(Bce.Provider, {
        value: p,
        children: e
    })
}
  , Hce = 1e3
  , zce = () => y.useContext(Bce)
  , $ce = Symbol("No market")
  , Gce = y.createContext({
    chainId: null,
    marketOrTokenId: null
});
Gce.displayName = "MarketAddressContext";
const qce = ({children: e}) => {
    const t = Nn()
      , {chainId: n, marketOrTokenId: r} = y.useMemo(( () => {
        const e = t[k$e.CHAIN] || null
          , n = t[k$e.MARKET_ADDRESS] || null
          , r = e ? tg(e) : null
          , a = r && n ? ( (e, t) => {
            if (e === Pd.BSC && t.startsWith("fm_")) {
                const n = t.split("_").slice(1);
                return fg(e, ng(n[0]), {
                    type: "fourmeme",
                    tokenAddress: ng(n[1])
                })
            }
            return fg(e, t, null)
        }
        )(r, n) : null;
        return {
            chainId: r,
            marketOrTokenId: a
        }
    }
    ), [t])
      , a = y.useMemo(( () => ({
        chainId: n,
        marketOrTokenId: r
    })), [n, r]);
    return v.jsx(Gce.Provider, {
        value: a,
        children: e
    })
}
  , Kce = (e, t) => {
    if (Array.isArray(t))
        return t
}
  , Yce = (e, t) => "init" === t.type ? t.snapshot : e ? ( (e, t) => {
    const n = t.baseTokenSocials ? m.mergeWith(m.cloneDeep(e.baseTokenSocials), t.baseTokenSocials, Kce) : e.baseTokenSocials
      , r = t.baseTokenDexBoost ? m.mergeWith(m.cloneDeep(e.baseTokenDexBoost ?? {}), t.baseTokenDexBoost, Kce) : e.baseTokenDexBoost
      , a = t.baseTokenTaxes ? m.mergeWith(m.cloneDeep(e.baseTokenTaxes ?? {}), t.baseTokenTaxes, Kce) : e.baseTokenTaxes
      , s = t.liquidityLock ? m.mergeWith(m.cloneDeep(e.liquidityLock ?? {}), t.liquidityLock, Kce) : e.liquidityLock
      , o = t.pumpFunGaze ? m.mergeWith(m.cloneDeep(e.pumpFunGaze ?? {}), t.pumpFunGaze, Kce) : e.pumpFunGaze
      , l = t.baseTokenAudit ? m.mergeWith(m.cloneDeep(e.baseTokenAudit ?? {}), t.baseTokenAudit, Kce) : e.baseTokenAudit
      , i = t.evaAuditInfo ? m.mergeWith(m.cloneDeep(e.evaAuditInfo ?? {}), t.evaAuditInfo, Kce) : e.evaAuditInfo;
    return {
        isPermissioned: t.isPermissioned ?? e.isPermissioned,
        marketId: t.marketId ?? e.marketId,
        baseTokenAddress: t.baseTokenAddress ?? e.baseTokenAddress,
        marketCreatedAt: t.marketCreatedAt ?? e.marketCreatedAt,
        marketProtocol: t.marketProtocol ?? e.marketProtocol,
        preMigrationMarketId: t.preMigrationMarketId ?? e.preMigrationMarketId,
        baseTokenTotalSupply: t.baseTokenTotalSupply ?? e.baseTokenTotalSupply,
        liquidityInUsdUi: t.liquidityInUsdUi ?? e.liquidityInUsdUi,
        basePriceInUsdUi: t.basePriceInUsdUi ?? e.basePriceInUsdUi,
        basePriceInQuoteUi: t.basePriceInQuoteUi ?? e.basePriceInQuoteUi,
        isLikelyUntaxed: t.isLikelyUntaxed ?? e.isLikelyUntaxed,
        baseTokenTaxes: a,
        baseTokenVaults: t.baseTokenVaults ?? e.baseTokenVaults,
        baseTokenSocials: n,
        baseTokenDexBoost: r,
        liquidityLock: s,
        burnedLiquidityPcnt: t.burnedLiquidityPcnt ?? e.burnedLiquidityPcnt,
        totalHolders: t.totalHolders ?? e.totalHolders,
        launchpadCurveProgress: t.launchpadCurveProgress ?? e.launchpadCurveProgress,
        pumpFunGaze: o,
        isLaunchpadCompleted: t.isLaunchpadCompleted ?? e.isLaunchpadCompleted,
        baseTokenAudit: l,
        clogPcnt: t.clogPcnt ?? e.clogPcnt,
        deployerHoldingPcnt: t.deployerHoldingPcnt ?? e.deployerHoldingPcnt,
        evaAuditInfo: i,
        cpQuoteInputs: e.cpQuoteInputs || t.cpQuoteInputs ? {
            baseReserve: "0",
            quoteReserve: "0",
            ...e.cpQuoteInputs ?? {},
            ...t.cpQuoteInputs ?? {}
        } : null,
        meteoraCurveQuoteInputs: t.meteoraCurveQuoteInputs ?? e.meteoraCurveQuoteInputs,
        translations: t.translations ?? e.translations ?? null
    }
}
)({
    ...e
}, t.update) : null
  , Xce = Vh.MCAP
  , Qce = () => y.useContext(ade)
  , Zce = N()(Pn((e => ({
    baseTokenDecimals: null,
    quoteTokenDecimals: null,
    originalMarketId: null,
    marketStats: null,
    basePriceInUsdUiRef: null,
    basePriceInQuoteUiRef: null,
    fdvInUsdUiRef: null,
    set: e
}))))
  , Jce = e => e.filter(Boolean).join(" | ")
  , ede = ({baseSymbol: e, directionIndicator: t, value: n}) => {
    if (!e || "string" != typeof n)
        return Jce(["Terminal", "Your Edge in Memecoin Trading"]);
    const r = tde(e, 7)
      , a = LI(n, {
        symbol: "$",
        padSymbol: !1,
        symbolPosition: yI.START,
        maxPrecision: 3,
        collapseExponent: !0
    });
    return Jce([[t ? `${r} ${t}` : r, a].join(" "), "Terminal"])
}
  , tde = (e, t=6) => e.substring(0, t)
  , nde = (e, t) => {
    const {settings: n} = rf()
      , r = y.useRef(null)
      , a = y.useRef(null)
      , s = Zce((e => e.set))
      , {i18n: o} = we();
    y.useEffect(( () => {
        r.current = null
    }
    ), [null == n ? void 0 : n.pageTitleMode]),
    y.useEffect(( () => () => {
        a.current = rde,
        document.title = a.current
    }
    ), [e]);
    const l = null == t ? void 0 : t.baseToken.symbol;
    y.useEffect(( () => (l && (a.current = ede({
        baseSymbol: l,
        directionIndicator: null,
        value: r.current ? String(r.current) : void 0
    }),
    document.title = a.current),
    () => {
        a.current = rde,
        document.title = a.current
    }
    )), [l]);
    const i = y.useRef(null)
      , d = y.useRef(null)
      , u = y.useRef(null)
      , p = (null == t ? void 0 : t.baseToken.decimals) ?? null
      , h = (null == t ? void 0 : t.quoteToken.decimals) ?? null
      , g = y.useCallback(( (s, l) => {
        const c = "init" === l.type ? l.snapshot : l.update;
        if (!e || s !== e)
            return a.current = rde,
            void (document.title = a.current);
        c.basePriceInUsdUi && (i.current = c.basePriceInUsdUi),
        c.baseTokenTotalSupply && (d.current = c.baseTokenTotalSupply);
        const h = r.current
          , g = ( (e, t, n, r) => {
            switch (n) {
            case Vh.PRICE:
                return e;
            case Vh.MCAP:
                return m.isNil(r) || !t || !e || isNaN(Number(t)) ? null : Number(e) * Number(t) / Math.pow(10, r);
            case Vh.NONE:
                return null
            }
        }
        )(i.current, d.current, (null == n ? void 0 : n.pageTitleMode) ?? Xce, p);
        r.current = g;
        const {translatedSymbol: x} = u.current ? jee(o.resolvedLanguage ?? null, u.current) : {
            translatedSymbol: null
        }
          , b = ede({
            baseSymbol: x ?? (null == t ? void 0 : t.baseToken.symbol),
            directionIndicator: null !== g && null !== h && g > h ? "" : "",
            value: g ? String(g) : void 0
        });
        b !== a.current && (a.current = b,
        document.title = a.current)
    }
    ), [e, null == n ? void 0 : n.pageTitleMode, p, o.resolvedLanguage, null == t ? void 0 : t.baseToken.symbol])
      , x = ( (e, t) => {
        const n = y.useRef(t);
        n.current = t;
        const r = y.useRef(e);
        r.current = e;
        const a = y.useRef(null)
          , s = y.useCallback((t => e ? um.onAutoMigratingMarketStatsUpdate(e, {
            onMessage: s => {
                r.current === e && (a.current = e,
                n.current && n.current(e, s),
                t.onMessage(s))
            }
            ,
            close: e => {
                t.close(e)
            }
        }) : {
            unsubscribe: () => {}
        }), [e])
          , o = kx(s, Yce, {
            debounceDuration: 50
        });
        return e && a.current === e ? {
            originalMarketId: e,
            stats: o
        } : null
    }
    )(e, g)
      , b = (null == x ? void 0 : x.stats) ?? null
      , f = (null == x ? void 0 : x.originalMarketId) ?? null
      , {tradePageOriginRef: v} = Qce()
      , S = pT();
    y.useEffect(( () => {
        e && (null == b ? void 0 : b.marketId) && f === e && e !== (null == b ? void 0 : b.marketId) && Math.abs(ZA() - b.marketCreatedAt) > 10 && S({
            marketId: null == b ? void 0 : b.marketId,
            navigationOptions: {
                replace: !0
            },
            tradePageOrigin: v.current ?? null
        })
    }
    ), [null == b ? void 0 : b.marketCreatedAt, e, f, null == b ? void 0 : b.marketId, S, v]);
    const k = y.useRef(null)
      , C = y.useRef(null)
      , A = y.useRef(null);
    y.useEffect(( () => {
        if (!b || !e || e !== f)
            return k.current = null,
            C.current = null,
            A.current = null,
            void s({
                baseTokenDecimals: null,
                quoteTokenDecimals: null,
                originalMarketId: null,
                marketStats: null,
                basePriceInUsdUiRef: k,
                basePriceInQuoteUiRef: C,
                fdvInUsdUiRef: A
            });
        k.current = (null == b ? void 0 : b.basePriceInUsdUi) ?? null,
        C.current = (null == b ? void 0 : b.basePriceInQuoteUi) ?? null,
        A.current = !b || c.isNil(p) || c.isNil(b.basePriceInUsdUi) || c.isNil(b.baseTokenTotalSupply) ? null : new sB({
            decimals: p
        },BigInt(b.baseTokenTotalSupply)).multiply(b.basePriceInUsdUi).toNumber(),
        s({
            baseTokenDecimals: p,
            quoteTokenDecimals: h,
            originalMarketId: e,
            marketStats: b,
            basePriceInUsdUiRef: k,
            basePriceInQuoteUiRef: C,
            fdvInUsdUiRef: A
        })
    }
    ), [s, e, b, p, h, f]),
    y.useEffect(( () => () => {
        k.current = null,
        C.current = null,
        A.current = null,
        s({
            baseTokenDecimals: null,
            quoteTokenDecimals: null,
            originalMarketId: null,
            marketStats: null,
            basePriceInUsdUiRef: k,
            basePriceInQuoteUiRef: C,
            fdvInUsdUiRef: A
        })
    }
    ), [s])
}
  , rde = ede({
    baseSymbol: void 0,
    directionIndicator: null,
    value: void 0
})
  , ade = y.createContext({
    originalStaticMarketInfo: null,
    originalMarketId: null,
    addressError: !1,
    chainId: null,
    tradePageOriginRef: {
        current: null
    }
});
ade.displayName = "MarketInfoContext";
const sde = ({children: e}) => {
    const {chainId: t, marketOrTokenId: n} = y.useContext(Gce)
      , r = AT()
      , a = y.useRef(null)
      , s = y.useRef(null);
    y.useEffect(( () => {
        if (r)
            return a.current = r,
            void (s.current = n ?? null);
        a.current && s.current && n && s.current !== n && (a.current = null,
        s.current = null)
    }
    ), [r, n]);
    const o = y.useMemo(( () => n ? mT.get(n) : null), [n])
      , l = (e => {
        var t;
        const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
          , [r,a] = y.useState(null)
          , s = y.useRef(null);
        return y.useEffect(( () => {
            let t = !1;
            if (n && e)
                return a(null),
                (async () => {
                    try {
                        const n = "" === e ? null : await vT({
                            query: e,
                            withDeepCacheWarm: !0
                        });
                        if (t)
                            return;
                        s.current = e,
                        a(n || $ce)
                    } catch (fNe) {
                        if (t)
                            return;
                        s.current = e,
                        a(null)
                    }
                }
                )(),
                () => {
                    t = !0
                }
        }
        ), [e, n]),
        r && s.current === e ? r : null
    }
    )(n ?? "")
      , i = o || l
      , c = y.useMemo(( () => i && i !== $ce ? fg(i.chain, i.marketAddress, i.protocol.type === Lc.FOUR_MEME ? {
        type: "fourmeme",
        tokenAddress: i.baseToken.address
    } : null) : null), [i])
      , d = y.useMemo(( () => {
        return i === $ce ? {
            originalStaticMarketInfo: null,
            originalMarketId: null,
            addressError: !0,
            chainId: t,
            tradePageOriginRef: a
        } : c && i ? (e = i.protocol.type,
        Bc[e] || Dc[e] ? {
            originalStaticMarketInfo: i,
            originalMarketId: c,
            addressError: !1,
            chainId: t,
            tradePageOriginRef: a
        } : {
            originalStaticMarketInfo: null,
            originalMarketId: null,
            addressError: !1,
            chainId: t,
            tradePageOriginRef: a
        }) : {
            originalStaticMarketInfo: null,
            originalMarketId: null,
            addressError: !1,
            chainId: t,
            tradePageOriginRef: a
        };
        var e
    }
    ), [c, i, t, a]);
    return nde(d.originalMarketId, d.originalStaticMarketInfo),
    v.jsx(ade.Provider, {
        value: d,
        children: e
    })
}
  , ode = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.basePriceInUsdUi) ?? null
}
))
  , lde = () => {
    const e = Zce.getState() ?? null
      , t = !(null == e ? void 0 : e.marketStats) || c.isNil(e.baseTokenDecimals) || c.isNil(e.marketStats.basePriceInUsdUi) || c.isNil(e.marketStats.baseTokenTotalSupply) ? null : new sB({
        decimals: e.baseTokenDecimals
    },BigInt(e.marketStats.baseTokenTotalSupply)).multiply(e.marketStats.basePriceInUsdUi).toNumber();
    return null === t ? null : LI(t, {
        collapseExponent: !0,
        symbol: "$",
        padSymbol: !1,
        symbolPosition: yI.START,
        desiredDigits: 3
    })
}
  , ide = () => {
    var e, t;
    const n = (null == (t = null == (e = Zce.getState()) ? void 0 : e.marketStats) ? void 0 : t.basePriceInUsdUi) ?? null;
    return null === n ? null : "$" + LI(n)
}
;
let cde = !1;
const dde = e => Zce((t => e ? t.marketStats ? t.marketStats.baseTokenAddress === e.baseToken.address ? t.marketStats.marketId : (cde || (cde = !0,
Ve("marketId mismatch between", {
    extra: {
        originalMarketId: vg(e),
        preMigration: t.marketStats.preMigrationMarketId,
        statsMarketId: t.marketStats.marketId,
        baseTokenAddress: t.marketStats.baseTokenAddress,
        originalBaseTokenAddress: e.baseToken.address
    }
})),
vg(e)) : e ? vg(e) : null : null))
  , ude = new hg(20);
let pde = !1;
const hde = e => Zce((t => e ? t.marketStats && t.marketStats.marketId !== vg(e) ? t.marketStats.baseTokenAddress === e.baseToken.address ? ( (e, t) => {
    const n = `${e}-${t.preMigrationMarketId ?? "no-pre-migration"}`;
    return ude.get(n) || (ude.set(n, t),
    t)
}
)(t.marketStats.marketId, {
    preMigrationMarketId: t.marketStats.preMigrationMarketId,
    createdAt: t.marketStats.marketCreatedAt,
    protocol: t.marketStats.marketProtocol,
    baseToken: e.baseToken,
    quoteToken: e.quoteToken,
    chain: e.chain,
    marketAddress: mg(t.marketStats.marketId).marketAddress,
    launchpad: e.launchpad,
    launchpadAux: e.launchpadAux,
    realQuoteToken: e.realQuoteToken ?? null
}) : (pde || (pde = !0,
Ve("marketId mismatch between", {
    extra: {
        originalMarketId: vg(e),
        preMigration: t.marketStats.preMigrationMarketId,
        statsMarketId: t.marketStats.marketId,
        baseTokenAddress: t.marketStats.baseTokenAddress,
        originalBaseTokenAddress: e.baseToken.address
    }
})),
e) : e : null))
  , mde = () => Zce((e => e.basePriceInUsdUiRef))
  , gde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.basePriceInQuoteUi) ?? null
}
))
  , xde = () => Zce((e => e.basePriceInQuoteUiRef))
  , bde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.liquidityInUsdUi) ?? null
}
))
  , fde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenVaults) ?? null
}
))
  , vde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenTotalSupply) ?? null
}
))
  , Sde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.totalHolders) ?? null
}
))
  , yde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenDexBoost) ?? null
}
), c.isEqual)
  , kde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenSocials) ?? null
}
), c.isEqual)
  , Cde = (e, t) => {
    const n = (e => "pumpfun" === e ? 0 : 100)(e);
    return Zce((e => !(!e.marketStats || null === e.marketStats.liquidityInUsdUi) && e.marketStats.liquidityInUsdUi < n))
}
  , Ade = () => Zce((e => e.baseTokenDecimals ?? null))
  , wde = () => Zce((e => {
    var t, n, r;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenTaxes) ? (null == (r = null == (n = e.marketStats) ? void 0 : n.baseTokenTaxes) ? void 0 : r.buyPercent) ?? null : null
}
))
  , jde = () => Zce((e => {
    var t, n, r;
    return (null == (t = e.marketStats) ? void 0 : t.baseTokenTaxes) ? (null == (r = null == (n = e.marketStats) ? void 0 : n.baseTokenTaxes) ? void 0 : r.sellPercent) ?? null : null
}
))
  , Tde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.pumpFunGaze) ?? null
}
), c.isEqual)
  , Ide = () => Zce((e => {
    var t, n;
    return e.marketStats ? e.marketStats.preMigrationMarketId && e.marketStats.preMigrationMarketId !== e.marketStats.marketId ? e.marketStats.marketCreatedAt : e.marketStats.marketProtocol.type === Rc.HEAVEN ? (null == (t = e.marketStats.pumpFunGaze) ? void 0 : t.bondedAt) ?? null : e.marketStats.marketProtocol.type === Rc.TOKEN_MILL ? (null == (n = e.marketStats.pumpFunGaze) ? void 0 : n.bondedAt) ?? null : null : null
}
))
  , Ede = e => Zce((t => {
    var n, r, a;
    return (null == (n = null == e ? void 0 : e.baseToken) ? void 0 : n.deployer) ?? (null == (a = null == (r = t.marketStats) ? void 0 : r.baseTokenAudit) ? void 0 : a.deployerAddress) ?? null
}
))
  , Mde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.burnedLiquidityPcnt) ?? null
}
), c.isEqual)
  , Nde = () => Zce((e => {
    var t;
    return (null == (t = e.marketStats) ? void 0 : t.cpQuoteInputs) ?? null
}
), c.isEqual)
  , Pde = (e, t) => {
    if ("init" === t.type) {
        return {
            wrapper: {
                lookup: new Map(On(t.snapshot.orders)),
                orderIds: new Set(Object.keys(t.snapshot.orders))
            }
        }
    }
    if (!e)
        throw new Error("Connection error, update msg without init message");
    const {updated: n, deleted: r} = t.update
      , {orderIds: a, lookup: s} = e.wrapper;
    let o = !1;
    return n.forEach((e => {
        s.has(e.def.orderId) || (o = !0),
        a.add(e.def.orderId),
        s.set(e.def.orderId, e)
    }
    )),
    r.forEach((e => {
        o = !0,
        a.delete(e.def.orderId),
        s.delete(e.def.orderId)
    }
    )),
    {
        wrapper: {
            lookup: s,
            orderIds: o ? new Set(Array.from(a)) : a
        }
    }
}
  , Ode = (e, t, n, r, a, s) => {
    const o = Ax()
      , l = y.useCallback((l => !o || s.skip ? {
        unsubscribe: () => {}
    } : sm.subscribeOrdersSmart(o, e, t, n, r, a, l)), [o, e, t, n, r, a, s.skip]);
    return kx(l, Pde)
}
  , Lde = N((e => ({
    wrapped: null,
    callbacks: {
        ref: new Set
    },
    addCallback: t => e((e => (e.callbacks.ref.add(t),
    {
        ...e,
        callbacks: {
            ref: e.callbacks.ref
        }
    }))),
    removeCallback: t => e((e => (e.callbacks.ref.delete(t),
    {
        ...e,
        callbacks: {
            ref: e.callbacks.ref
        }
    }))),
    setWrapped: t => e((e => ({
        ...e,
        wrapped: t((null == e ? void 0 : e.wrapped) ?? null)
    })))
})))
  , Rde = (e, t) => {
    const n = Ax()
      , r = Lde()
      , a = y.useRef(r);
    a.current = r,
    y.useEffect(( () => {
        a.current.setWrapped(( () => null))
    }
    ), [e, t]);
    const s = y.useCallback((r => ke(n) || ke(e) || ke(t) ? {
        unsubscribe: () => {}
    } : sm.subscribeTrailingPrices(n, e, t, null, r)), [n, e, t])
      , o = y.useMemo(( () => {
        return e = a.current,
        (t, n) => {
            const r = t || e;
            return "init" === n.type ? (r.setWrapped(( () => ({
                lookup: new Map(On(n.snapshot.trailingPrices))
            }))),
            r) : (r.setWrapped((e => {
                const t = (null == e ? void 0 : e.lookup) ?? new Map;
                return n.update.updated.forEach((e => {
                    t.set(e.orderId, e),
                    r.callbacks.ref.forEach((t => {
                        t(e)
                    }
                    ))
                }
                )),
                n.update.deleted.forEach(( ({orderId: e}) => {
                    t.delete(e)
                }
                )),
                {
                    lookup: t
                }
            }
            )),
            r)
        }
        ;
        var e
    }
    ), []);
    return kx(s, o)
}
  , Dde = y.createContext({
    openOrders: null,
    areCancelledHidden: !1,
    toggleCancelledHidden: c.noop
});
Dde.displayName = "OrdersContext";
const Bde = y.memo(( ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , [n,r] = Mx("padreV2-ordersHideCancelled", !1)
      , a = y.useCallback(( () => {
        r((e => !e))
    }
    ), [r])
      , s = (null == t ? void 0 : t.protocol.type) && ooe.includes(t.protocol.type) ? qc : null == t ? void 0 : t.quoteToken.address
      , o = Ode("open", null, (null == t ? void 0 : t.chain) ?? null, (null == t ? void 0 : t.baseToken.address) ?? null, s ?? null, {
        skip: null === t
    });
    Rde((null == t ? void 0 : t.chain) ?? null, (null == t ? void 0 : t.baseToken.address) ?? null);
    const l = y.useMemo(( () => ({
        openOrders: o,
        areCancelledHidden: n,
        toggleCancelledHidden: a
    })), [o, n, a]);
    return v.jsx(Dde.Provider, {
        value: l,
        children: e
    })
}
))
  , _de = () => y.useContext(Dde)
  , Ude = (e, t) => c.reduce(t, ( (e, t) => {
    const [n,r,a] = t
      , s = ng(n)
      , o = ng(r);
    return e[s] = e[s] ? {
        ...e[s],
        [o]: a
    } : {
        [o]: a
    },
    e
}
), {
    ...e
})
  , Wde = (e, t) => "init" === t.type ? Ude({}, t.snapshot) : Ude(e ?? {}, t.update)
  , Fde = {
    rawAmount: "0"
}
  , Vde = {
    symbol: "MOCK",
    address: "0xMOCK",
    decimals: 18
}
  , Hde = y.createContext({
    selectedWalletsAddresses: [],
    compatibleWallets: [],
    baseCurrencyProperties: Vde,
    quoteCurrencyForExecutionProperties: Vde,
    toggleSelectedWalletAddress: c.noop,
    setSelectedWalletsAddresses: c.noop,
    ethSubOrgId: null,
    solSubOrgId: null,
    credentialIds: [],
    refreshBalances: async () => {}
    ,
    compatibleWalletsAddresses: [],
    isLoadingInitialState: !0
});
Hde.displayName = "OrderWalletContext";
const zde = (e, t, n) => n && n[e] ? {
    rawAmount: n[e]
} : t && t[e] ? t[e] : null
  , $de = ({children: e, chainId: t, baseCurrencyProperties: n, quoteCurrencyForExecutionProperties: r}) => {
    const a = pK()
      , {lastSelectedWalletsPerChain: s, setLastSelectedWalletsPerChain: o} = OD()
      , l = UD((e => e.wallets))
      , [i,d] = y.useState([])
      , u = y.useMemo(( () => l ? i.filter((e => {
        const t = ng(e);
        return (l || []).some((e => ng(e.publicAddress) === t))
    }
    )) : i), [i, l])
      , p = y.useCallback(( (e, n=!1) => {
        if (!t)
            return;
        const r = ED(t)
          , s = gc(r)
          , l = ng(e)
          , i = n ? [l] : u.includes(l) ? u.filter((e => e !== l)) : [...u, l];
        i.length > s ? a({
            message: gu(r),
            snackName: pu.tooManyWallets,
            type: "error"
        }, "max-wallets-error") : (d(i),
        o((e => ({
            ...e,
            [t]: i
        }))))
    }
    ), [t, a, u, o])
      , {wallets: h, ethSubOrgId: m, solSubOrgId: g, credentialIds: x, state: b} = UD((e => e))
      , [f,S] = y.useMemo(( () => {
        const e = (h || []).filter(( ({walletType: e}) => !!t && ED(t) === e));
        return [e, c.uniq(e.map(( ({publicAddress: e}) => e)))]
    }
    ), [h, t])
      , k = y.useMemo(( () => t === Pd.SOLANA ? [] : (null == n ? void 0 : n.address) && (null == r ? void 0 : r.address) ? c.uniq([n.address, r.address, Wd]) : []), [null == n ? void 0 : n.address, null == r ? void 0 : r.address, t])
      , {tokenBalances: C, refresh: A} = BJ({
        chainId: t,
        walletAddresses: S,
        tokenAddresses: k
    })
      , {solBalances: w} = y.useContext(zD)
      , j = y.useMemo(( () => t !== Pd.SOLANA ? null : w), [t, w])
      , [I,E] = y.useMemo(( () => {
        if (t !== Pd.SOLANA || !n || !r)
            return [null, null];
        const e = f.map((e => ng(e.publicAddress)))
          , a = ru(r.address);
        return ( (e, t, n) => {
            const r = c.uniq(e);
            return [YA(n ? [...r, ...r] : r), YA([...Array(r.length).fill(t), ...n ? Array(r.length).fill(n) : []])]
        }
        )(e, n.address, a ? null : r.address)
    }
    ), [n, t, f, r])
      , M = ( (e, t) => {
        const n = y.useCallback((n => e && t ? Tm.subscribeSolTokenBalancesV2(e, t, n) : {
            unsubscribe: () => {}
        }), [t, e]);
        return kx(n, Wde)
    }
    )(I, E)
      , N = y.useMemo(( () => {
        if (!t || !n || !r)
            return null;
        const e = t === Pd.SOLANA ? Gc : Wd
          , a = f.map((a => {
            const s = ng(a.publicAddress)
              , o = t === Pd.SOLANA && M ? M[s] ?? null : null
              , l = t === Pd.SOLANA && j ? j[s] ?? null : null
              , i = C ? C[a.publicAddress] ?? null : null
              , c = zde(ng(n.address), i, o)
              , d = zde(ru(r.address) && t === Pd.SOLANA ? e : r.address, i, ru(r.address) ? l : o)
              , u = zde(e, i, l);
            return {
                wallet: a,
                balances: {
                    base: c ?? {
                        ...Fde,
                        isLoading: !0
                    },
                    quoteForExecution: d ?? {
                        ...Fde,
                        isLoading: !0
                    },
                    native: u ?? {
                        ...Fde,
                        isLoading: !0
                    }
                }
            }
        }
        ));
        return T(a, [e => Number(e.balances.base.rawAmount), e => Number(e.balances.quoteForExecution.rawAmount)], ["desc", "desc"])
    }
    ), [n, t, f, C, r, M, j]);
    y.useEffect(( () => {
        if (!t || !u.length)
            return;
        const e = t === Pd.SOLANA ? su : au
          , {fitleredAddresses: n, shouldOverride: r} = c.reduce(u, ( (t, n) => e.test(n) ? (t.fitleredAddresses.push(n),
        t) : (t.shouldOverride = !0,
        t)), {
            shouldOverride: !1,
            fitleredAddresses: []
        });
        r && d(n)
    }
    ), [t, u]);
    const [P,O] = y.useState(!1);
    y.useEffect(( () => {
        O(!1)
    }
    ), [t]),
    y.useEffect(( () => {
        !P && h && t && b && b === BD.READY && (d(s[t] ?? []),
        O(!0))
    }
    ), [t, s, u.length, h, b, P]);
    const L = y.useMemo(( () => ({
        selectedWalletsAddresses: u,
        toggleSelectedWalletAddress: p,
        setSelectedWalletsAddresses: d,
        compatibleWallets: N,
        baseCurrencyProperties: n,
        quoteCurrencyForExecutionProperties: r,
        ethSubOrgId: m,
        solSubOrgId: g,
        credentialIds: x,
        refreshBalances: A,
        compatibleWalletsAddresses: f,
        isLoadingInitialState: !P
    })), [u, p, P, N, n, r, m, g, x, A, f]);
    return v.jsx(Hde.Provider, {
        value: L,
        children: e
    })
}
  , Gde = () => y.useContext(Hde);
var qde = (e => (e.SELECTED = "SELECTED",
e.ALL = "ALL",
e))(qde || {});
const Kde = y.createContext({
    portfolioData: null,
    allPortfolioData: null,
    sumMode: qde.ALL,
    setSumMode: c.noop
})
  , Yde = ({children: e}) => {
    const [t,n] = Mx("padreV2-positionSumMode", qde.ALL)
      , {selectedWalletsAddresses: r, compatibleWalletsAddresses: a} = Gde()
      , {originalStaticMarketInfo: s} = Qce()
      , o = s ? bg(s.chain, s.baseToken.address) : null
      , l = Fce(YA(r.sort()), o)
      , i = Fce(t === qde.ALL ? YA(a.map((e => ng(e.publicAddress))).sort()) : null, o)
      , c = y.useMemo(( () => ({
        portfolioData: l,
        allPortfolioData: i,
        sumMode: t,
        setSumMode: n
    })), [i, l, n, t]);
    return v.jsx(Kde.Provider, {
        value: c,
        children: e
    })
}
  , Xde = () => y.useContext(Kde)
  , Qde = 250
  , Zde = {
    [nc.GREATER]: "Above",
    [nc.LOWER]: "Below"
}
  , Jde = $h.CORK
  , eue = y.memo(( ({currentDirection: e, setDirection: t}) => {
    const {t: n} = we()
      , r = y.useCallback((e => v.jsx(k, {
        variant: "paragraph3",
        color: "text.value",
        children: n(Zde[e])
    })), [n]);
    return v.jsx(it, {
        size: "medium",
        value: e,
        renderValue: r,
        children: tue.map((e => v.jsx(te, {
            disableTouchRipple: !0,
            disableRipple: !0,
            value: e,
            sx: nue,
            onClick: () => {
                t(e)
            }
            ,
            children: v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                children: n(Zde[e])
            })
        }, e)))
    })
}
))
  , tue = [nc.GREATER, nc.LOWER]
  , nue = e => ({
    pl: 1.75,
    height: 35,
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderSubtle}`,
    "&:hover": {
        bgcolor: e.palette.background.tertiary
    },
    ":last-child": {
        borderBottom: "none"
    }
})
  , rue = "padreV2-addPriceAlertLastDirection"
  , aue = "padreV2-addPriceAlertLastType"
  , sue = y.memo(( ({tokenInfo: e}) => {
    const {t: t} = we()
      , n = D()
      , {marketCapThresholds: r} = bA()
      , a = y.useMemo(( () => [bg(e.chain, e.address)]), [e.chain, e.address])
      , s = J1(a)
      , [o,l] = y.useMemo(( () => {
        if (!s)
            return [null, !0];
        const t = s[bg(e.chain, e.address)];
        return t ? [t.fdvInUsdUi, !1] : [null, !0]
    }
    ), [e.address, e.chain, s])
      , {values: i, errors: c, touched: d, setFieldValue: u, handleBlur: p, submitForm: h, isSubmitting: m} = Tn()
      , [,g] = dx(rue, nc.GREATER)
      , [,x] = dx(aue, "usd-mkt-cap")
      , b = y.useCallback(( (e, t) => {
        u("type", t),
        x(t)
    }
    ), [u, x])
      , f = y.useCallback((e => {
        u("direction", e),
        g(e)
    }
    ), [u, g])
      , A = y.useCallback((e => {
        const t = QR(e.target.value);
        u("targetValue", t)
    }
    ), [u])
      , w = y.useCallback((e => {
        m || c.targetValue || !i.targetValue || "Enter" === e.key && (e.preventDefault(),
        h())
    }
    ), [c.targetValue, m, h, i.targetValue])
      , j = y.useMemo(( () => null === o ? n.palette.text.label : IA(Number(o) || 0, r, n.palette.text.value)), [o, r, n.palette.text.label, n.palette.text.value])
      , T = y.useMemo(( () => pZ(t, due)), [t]);
    return v.jsxs(S, {
        gap: 2,
        justifyContent: "center",
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "center",
                justifyContent: "center",
                children: [v.jsx(b_, {
                    url: IE(e.chain, e.address),
                    padreAvatarUrl: null,
                    name: e.symbol,
                    size: oue,
                    protocolInfo: null,
                    chain: e.chain,
                    hideHoverAvatar: !0,
                    markerIcon: v.jsx(Sz, {
                        chain: e.chain,
                        size: lue
                    }),
                    markerSize: lue
                }), v.jsx(k, {
                    variant: "h1",
                    color: "text.value",
                    children: iu(e.symbol, iue)
                }), v.jsx(k, {
                    variant: "h1",
                    fontWeight: 400,
                    color: "text.label",
                    children: iu(e.symbol, cue)
                })]
            }), l ? v.jsx(Ie, {
                width: 60,
                height: 14
            }) : v.jsx(k, {
                variant: "h1",
                color: null === o ? "text.label" : j,
                children: null === o ? Ud : LI(o, {
                    collapseExponent: !0,
                    symbol: "$",
                    symbolPosition: yI.START,
                    padSymbol: !1,
                    desiredDigits: 3,
                    noTrailingZeros: !0
                })
            })]
        }), v.jsx(IH, {
            size: "small",
            value: i.type,
            onChange: b,
            items: T
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            children: [v.jsx(S, {
                minWidth: 85,
                children: v.jsx(eue, {
                    currentDirection: i.direction,
                    setDirection: f
                })
            }), v.jsx(je, {
                name: "targetValue",
                placeholder: "0",
                value: i.targetValue,
                onChange: A,
                onKeyDown: w,
                onBlur: p,
                error: d.targetValue && !!c.targetValue,
                fullWidth: !0,
                startAdornment: v.jsx(We, {
                    position: "start",
                    sx: hue,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        color: "text.label",
                        children: `${t("Target")} ${"usd-mkt-cap" === i.type ? t("Mkt Cap") : t("Price")}`
                    })
                }),
                endAdornment: v.jsx(We, {
                    position: "end",
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        children: "$"
                    })
                }),
                sx: uue,
                size: "xlarge",
                inputProps: pue
            })]
        }), v.jsx(GC, {
            title: c.targetValue ?? "",
            children: v.jsx(C, {
                component: "span",
                display: "flex",
                children: v.jsx(V, {
                    variant: "primary",
                    onClick: h,
                    disabled: m || !!c.targetValue || !i.targetValue,
                    size: "small",
                    fullWidth: !0,
                    endIcon: m ? v.jsx(J, {
                        size: 14
                    }) : void 0,
                    startIcon: m ? v.jsx(C, {
                        width: 14
                    }) : void 0,
                    children: t("Set Price Alert")
                })
            })
        })]
    })
}
))
  , oue = 20
  , lue = 10
  , iue = 20
  , cue = 30
  , due = [{
    value: "usd-mkt-cap",
    label: "Alert by Mkt Cap"
}, {
    value: "usd-price",
    label: "Alert by Price"
}]
  , uue = e => ({
    height: 40,
    background: e.palette.background.secondary,
    border: `1px solid ${e.palette.background.borderMain}`,
    "& .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&:hover .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
        border: "none"
    }
})
  , pue = {
    style: {
        textAlign: "right"
    }
}
  , hue = {
    ml: -.5
}
  , mue = y.memo(( ({addTokenInfo: e, onClose: t}) => {
    const {t: n} = we()
      , r = Ax()
      , [a] = dx(rue, nc.GREATER)
      , s = y.useRef(a)
      , [o] = dx(aue, "usd-mkt-cap")
      , l = y.useRef(o)
      , i = pK()
      , c = y.useCallback((async (n, {setSubmitting: a}) => {
        if (!r)
            return;
        const s = Number(n.targetValue);
        if (!isNaN(s)) {
            a(!0);
            try {
                await Wm.createTokenAlert({
                    type: n.type,
                    uid: r,
                    definedOn: {
                        type: "marketId",
                        marketId: e.marketId
                    },
                    direction: n.direction,
                    targetValue: s
                }),
                i({
                    message: pu.priceAlertCreationSuccess,
                    type: "success"
                }, "price-alert-creation-success"),
                t()
            } catch (fNe) {
                i({
                    message: uu.unknownError,
                    snackName: pu.priceAlertCreationFailed,
                    type: "error"
                }, "price-alert-creation-error")
            } finally {
                a(!1)
            }
        }
    }
    ), [e.marketId, t, r, i])
      , d = y.useMemo(( () => ({
        type: l.current ?? "usd-mkt-cap",
        direction: s.current ?? nc.GREATER,
        targetValue: ""
    })), [])
      , u = y.useMemo(( () => gue(n)), [n]);
    return v.jsx(Ln, {
        initialValues: d,
        validationSchema: u,
        onSubmit: c,
        validateOnMount: !0,
        validateOnChange: !0,
        children: v.jsx(Rn, {
            children: v.jsx(sue, {
                tokenInfo: e
            })
        })
    })
}
))
  , gue = e => Qe().shape({
    targetValue: qe().required(e("Please enter target value")).test("is-valid-number", e("Target value must be a valid number"), (e => !isNaN(Number(e)))).test("is-positive", e("Target value must be positive"), (e => {
        const t = Number(e);
        return !isNaN(t) && t > 0
    }
    ))
})
  , xue = ({isOpen: e, onClose: t, addTokenInfo: n, openOverviewModal: r}) => {
    const {t: a} = we()
      , s = y.useCallback(( () => {
        r(),
        t()
    }
    ), [t, r]);
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        desktopWidth: bue,
        minDesktopWidth: bue,
        stackSx: vue,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [v.jsxs(C, {
                    display: "flex",
                    alignItems: "center",
                    gap: .5,
                    onClick: s,
                    sx: yue,
                    children: [v.jsx(ky, {}), v.jsx(k, {
                        variant: "h2",
                        children: a("Create price alert")
                    })]
                }), v.jsx(F, {
                    onClick: t,
                    sx: Sue,
                    children: v.jsx(kS, {})
                })]
            }), v.jsx(Ee, {
                flexItem: !0,
                sx: fue
            }), v.jsx(mue, {
                addTokenInfo: n,
                onClose: t
            })]
        })
    })
}
  , bue = 375
  , fue = {
    mx: -2
}
  , vue = {
    p: 2,
    zIndex: 1305
}
  , Sue = {
    p: .5
}
  , yue = {
    "&:hover": {
        cursor: "pointer"
    }
}
  , kue = "telegram-login-script"
  , Cue = () => {
    const [e,t] = y.useState(!1)
      , n = y.useCallback((n => {
        window.Telegram && !e && (t(!0),
        window.Telegram.Login.auth({
            bot_id: Du.TELEGRAM_BOT_ID,
            request_access: "write"
        }, (e => {
            n(e).catch((e => {
                o(e)
            }
            )).finally(( () => t(!1)))
        }
        )))
    }
    ), [e]);
    return y.useEffect(( () => {
        if (document.getElementById(kue))
            return;
        const e = document.createElement("script");
        return e.id = kue,
        e.src = "https://telegram.org/js/telegram-widget.js",
        e.async = !0,
        document.body.appendChild(e),
        () => {
            document.body.removeChild(e)
        }
    }
    ), []),
    y.useMemo(( () => ({
        isAuthorizing: e,
        setIsAuthorizing: t,
        authorize: n
    })), [e, n])
}
  , Aue = () => {
    var e, t;
    const {t: n} = we()
      , r = D()
      , {authorize: a, isAuthorizing: s, setIsAuthorizing: o} = Cue()
      , {telegram: l} = q6()
      , i = y.useMemo(( () => null !== l.notificationsSettings), [l])
      , c = y.useCallback(( () => {
        a((async e => {
            if (e)
                return l.subscribe(e).then(( () => l.refresh()));
            o(!1)
        }
        ))
    }
    ), [a, o, l])
      , d = y.useCallback((async () => {
        o(!0),
        await l.unsubscribe(),
        await l.refresh(),
        o(!1)
    }
    ), [o, l]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "h4",
                children: n("Telegram")
            }), i ? v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 2,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    children: [v.jsx(vy, {
                        color: r.palette.positive.main
                    }), (null == (e = l.notificationsSettings) ? void 0 : e.firstName) && v.jsx(k, {
                        variant: "bodyRegular",
                        color: "text.meta",
                        children: null == (t = l.notificationsSettings) ? void 0 : t.firstName
                    })]
                }), v.jsx(V, {
                    variant: "tertiary",
                    sx: jue,
                    disabled: s,
                    onClick: d,
                    children: n("Unlink")
                })]
            }) : v.jsx(V, {
                variant: "secondary",
                sx: wue,
                disabled: s,
                onClick: c,
                endIcon: v.jsx(Cy, {
                    color: s ? r.palette.text.disabled : r.palette.primary.main
                }),
                children: n("Link now")
            })]
        })
    })
}
  , wue = {
    py: .5,
    pr: 1,
    pl: 1.5
}
  , jue = {
    py: .5,
    px: 1.5
}
  , Tue = y.createContext({
    openOverviewModal: c.noop,
    openAddAlertModal: c.noop,
    closeModals: c.noop,
    priceAlerts: null,
    createPriceAlert: async () => {}
    ,
    removePriceAlert: async () => !1
})
  , Iue = () => y.useContext(Tue)
  , Eue = 32
  , Mue = y.memo(( ({chain: e, address: t, symbol: n, name: r, marketId: a}) => {
    const s = xw()
      , {closeModals: o} = Iue()
      , {openAddAlertModal: l} = Iue()
      , i = y.useCallback(( () => {
        l({
            chain: e,
            address: t,
            symbol: n,
            name: r,
            marketId: a
        })
    }
    ), [t, e, a, r, l, n])
      , c = pT()
      , d = y.useCallback(( () => {
        c({
            marketId: a,
            tradePageOrigin: nT.PRICE_ALERTS
        }),
        s || o()
    }
    ), [c, a, s, o]);
    return v.jsxs(S, {
        direction: "row",
        height: Eue,
        alignItems: "center",
        justifyContent: "space-between",
        children: [v.jsxs(C, {
            display: "flex",
            gap: .75,
            alignItems: "center",
            justifyContent: "center",
            onClick: d,
            sx: Due,
            children: [v.jsx(b_, {
                url: IE(e, t),
                padreAvatarUrl: null,
                name: n,
                size: Nue,
                protocolInfo: null,
                chain: e,
                hideHoverAvatar: !0,
                markerIcon: v.jsx(Sz, {
                    chain: e,
                    size: Pue
                }),
                markerSize: Pue
            }), v.jsx(k, {
                variant: "h1",
                color: "text.value",
                children: iu(n, Oue)
            }), v.jsx(k, {
                variant: "h1",
                fontWeight: 400,
                color: "text.label",
                children: iu(n, Lue)
            })]
        }), v.jsx(V, {
            onClick: i,
            variant: "tertiary",
            sx: Rue,
            children: v.jsx(XS, {})
        })]
    })
}
))
  , Nue = 20
  , Pue = 10
  , Oue = 20
  , Lue = 30
  , Rue = e => ({
    minWidth: Eue,
    minHeight: Eue,
    width: Eue,
    height: Eue,
    background: e.palette.background.primary,
    p: 0
})
  , Due = {
    ml: .25,
    "&:hover": {
        cursor: "pointer"
    }
}
  , Bue = y.memo(( ({data: e}) => {
    const {t: t} = we()
      , n = D()
      , r = xw()
      , a = pK()
      , s = NA(e.isPaused)
      , [o,l] = y.useState(null);
    y.useEffect(( () => {
        s !== e.isPaused && l(null)
    }
    ), [e.isPaused, s]);
    const i = y.useCallback((async (t, n) => {
        l(!n);
        try {
            n ? await Wm.unpauseTokenAlert(e.alertId) : await Wm.pauseTokenAlert(e.alertId)
        } catch (fNe) {}
    }
    ), [e.alertId])
      , [c,d] = y.useState(!1)
      , [u,p] = y.useState(!1)
      , [h,m] = y.useState(!1)
      , [g,x] = y.useState(e.type)
      , b = y.useCallback(( () => {
        x((e => "usd-mkt-cap" === e ? "usd-price" : "usd-mkt-cap"))
    }
    ), [])
      , [f,A] = y.useState(e.direction)
      , w = y.useCallback(( () => {
        A((e => e === nc.GREATER ? nc.LOWER : nc.GREATER))
    }
    ), [])
      , [j,T] = y.useState(e.targetValue.toString())
      , I = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e);
        T(t)
    }
    ), [])
      , E = y.useCallback(( () => {
        d(!0),
        x(e.type),
        A(e.direction),
        T(e.targetValue.toString())
    }
    ), [e.direction, e.targetValue, e.type])
      , M = y.useCallback(( () => {
        d(!1)
    }
    ), [])
      , N = y.useCallback((async () => {
        try {
            m(!0),
            await Wm.deleteTokenAlert(e.alertId),
            a({
                message: pu.priceAlertDeleteSuccess,
                type: "success"
            }, "price-alert-delete-success")
        } catch (fNe) {
            m(!1),
            a({
                message: uu.unknownError,
                snackName: pu.priceAlertDeleteFailed,
                type: "error"
            }, "price-alert-delete-error")
        }
    }
    ), [e.alertId, a])
      , P = y.useCallback((async () => {
        const t = Number(j)
          , n = isNaN(t) ? null : t >= 0 ? t : null;
        if (e.type !== g || e.direction !== f || null !== n && e.targetValue !== n)
            try {
                p(!0),
                await Wm.updateTokenAlert({
                    alertId: e.alertId,
                    type: g,
                    direction: f,
                    targetValue: n ?? e.targetValue
                }),
                a({
                    message: uu.priceAlertUpdateSuccess,
                    type: "success"
                }, "price-alert-update-success"),
                d(!1)
            } catch (fNe) {
                a({
                    message: pu.unknownError,
                    snackName: uu.priceAlertUpdateFailed,
                    type: "error"
                }, "price-alert-update-error")
            } finally {
                p(!1)
            }
        else
            d(!1)
    }
    ), [a, e.alertId, e.direction, e.targetValue, e.type, f, j, g])
      , O = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        P())
    }
    ), [P]);
    return v.jsxs(S, {
        sx: Uue,
        height: 61,
        justifyContent: "space-between",
        direction: "row",
        children: [v.jsxs(S, {
            gap: .75,
            pt: c ? 1.25 : 0,
            children: [v.jsxs(S, {
                direction: "row",
                height: _ue,
                alignItems: "center",
                gap: .5,
                children: [!c && v.jsx(C, {
                    display: "flex",
                    height: _ue,
                    sx: (c ? f : e.direction) === nc.GREATER ? void 0 : Wue,
                    children: v.jsx(ty, {
                        size: _ue,
                        color: (c ? f : e.direction) === nc.GREATER ? n.palette.success.main : n.palette.error.main
                    })
                }), c ? v.jsxs(S, {
                    direction: "row",
                    gap: .75,
                    children: [v.jsxs(V, {
                        sx: que,
                        size: "xxsmall",
                        variant: "tertiary",
                        onClick: b,
                        children: [t("usd-mkt-cap" === g ? "MC" : "Price"), v.jsx(oy, {
                            size: 14,
                            color: "inherit"
                        })]
                    }), v.jsxs(V, {
                        sx: que,
                        size: "xxsmall",
                        variant: "tertiary",
                        onClick: w,
                        children: [f === nc.GREATER ? t("above") : t("below"), v.jsx(oy, {
                            size: 14,
                            color: "inherit"
                        })]
                    }), v.jsx(je, {
                        value: j,
                        onChange: I,
                        onKeyDown: O,
                        size: "xsmall",
                        placeholder: "0",
                        sx: Kue,
                        inputProps: Gue,
                        "data-pseudotype": "numberLike",
                        inputMode: "decimal",
                        startAdornment: v.jsx(We, {
                            position: "start",
                            sx: $ue,
                            children: v.jsx(S, {
                                alignItems: "center",
                                children: v.jsx(k, {
                                    variant: "paragraph1",
                                    color: "text.value",
                                    noWrap: !0,
                                    ...Nu,
                                    children: "$"
                                })
                            })
                        })
                    })]
                }) : v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: `${"usd-mkt-cap" === e.type ? t("MC") : t("Price")} ${e.direction === nc.GREATER ? t("above") : t("below")} ${LI(e.targetValue, {
                        collapseExponent: !0,
                        symbol: "$",
                        padSymbol: !1,
                        symbolPosition: yI.START,
                        removeTrailingZerosPrecision: 1
                    })}`
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1.5,
                    children: [!c && v.jsx(F, {
                        onClick: E,
                        sx: Fue,
                        disabled: u || h,
                        children: v.jsx(Ky, {})
                    }), !c && !h && v.jsx(GC, {
                        title: t("Delete price alert"),
                        children: v.jsx(F, {
                            onClick: N,
                            sx: zue,
                            disabled: u || h,
                            children: v.jsx(wS, {
                                color: "inherit"
                            })
                        })
                    }), (u || h) && v.jsx(J, {
                        size: 16,
                        color: h ? "negative" : "inherit"
                    })]
                })]
            }), !c && v.jsx(mE, {
                variant: "paragraph3",
                fontWeight: 400,
                ts: e.lastTriggeredAt ?? e.createdAt,
                prefixAdornment: e.lastTriggeredAt ? `${t("Triggered")} ` : `${t("Created")} `,
                suffixAdornment: ` ${t("ago")}`,
                color: "text.label"
            })]
        }), c ? v.jsxs(S, {
            direction: "row",
            gap: 1,
            mt: .25,
            children: [!u && !h && v.jsx(GC, {
                title: t("Cancel changes"),
                children: r ? v.jsx(V, {
                    sx: Hue,
                    onClick: M,
                    size: "xsmall",
                    variant: "tertiary",
                    children: t("Cancel")
                }) : v.jsx(F, {
                    onClick: M,
                    sx: Vue,
                    children: v.jsx(kS, {
                        size: 22
                    })
                })
            }), v.jsx(GC, {
                title: t("Save alert"),
                children: r ? v.jsx(V, {
                    sx: Hue,
                    onClick: P,
                    disabled: u || h,
                    size: "xsmall",
                    variant: "secondary",
                    children: t("Save")
                }) : v.jsx(F, {
                    onClick: P,
                    sx: Vue,
                    disabled: u || h,
                    children: v.jsx(cS, {
                        size: 22,
                        color: n.palette.primary.main
                    })
                })
            })]
        }) : v.jsx(Ue, {
            onChange: i,
            color: o ?? e.isPaused ? "neutral" : "positive",
            size: "medium",
            checked: !(o ?? e.isPaused)
        })]
    })
}
))
  , _ue = 18
  , Uue = e => ({
    background: e.palette.background.primary,
    borderRadius: "4px",
    px: 1.5,
    pt: 1.5
})
  , Wue = {
    transform: "scaleY(-1)"
}
  , Fue = {
    p: "1px",
    width: 18,
    height: 18
}
  , Vue = {
    p: .25,
    width: 32,
    height: 32
}
  , Hue = {
    px: .75,
    height: 32,
    width: 54,
    borderRadius: "16px"
}
  , zue = e => ({
    ...Fue,
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.error.main
    }
})
  , $ue = {
    width: 6
}
  , Gue = {
    style: {
        maxWidth: 70,
        textAlign: "start"
    },
    inputMode: "decimal"
}
  , que = {
    py: 0,
    px: .25,
    minWidth: 65,
    height: 32,
    gap: .25
}
  , Kue = {
    height: 32,
    pr: 0,
    pl: .5,
    minWidth: 100
}
  , Yue = y.memo(( ({displayData: e}) => v.jsxs(S, {
    gap: 1,
    pt: 2,
    children: [v.jsx(Mue, {
        chain: e.token.chain,
        address: e.token.address,
        symbol: e.token.symbol,
        name: e.token.name,
        marketId: e.definedOn.marketId
    }), e.alerts.map((e => v.jsx(Bue, {
        data: e
    }, e.alertId)))]
})))
  , Xue = y.memo(( () => {
    const {t: e} = we()
      , t = xw()
      , {priceAlerts: n} = Iue()
      , [r,a] = y.useMemo(( () => {
        if (!n)
            return [null, () => 0];
        const e = (e => {
            const t = c.reduce(Object.values(e.alertsLookup), ( (e, t) => {
                const n = e[t.definedOn.marketId];
                return e[t.definedOn.marketId] = n ? {
                    ...n,
                    alerts: [...n.alerts, {
                        alertId: t.alertId,
                        createdAt: t.createdAt,
                        direction: t.direction,
                        type: t.type,
                        targetValue: t.targetValue,
                        lastTriggeredAt: t.lastTriggeredAt,
                        isPaused: t.isPaused
                    }],
                    mostRecentCretaedAt: t.createdAt > n.mostRecentCretaedAt ? t.createdAt : n.mostRecentCretaedAt
                } : {
                    token: t.token,
                    definedOn: t.definedOn,
                    alerts: [{
                        alertId: t.alertId,
                        createdAt: t.createdAt,
                        direction: t.direction,
                        type: t.type,
                        targetValue: t.targetValue,
                        lastTriggeredAt: t.lastTriggeredAt,
                        isPaused: t.isPaused
                    }],
                    mostRecentCretaedAt: t.createdAt
                },
                e
            }
            ), {});
            return c.reduce(Object.values(t), ( (e, t) => t.alerts.length ? (e.push({
                ...t,
                alerts: [...t.alerts].sort(( (e, t) => t.createdAt - e.createdAt))
            }),
            e) : e), [])
        }
        )(n);
        return [e, t => t.index >= e.length ? 0 : Eue + 69 * e[t.index].alerts.length + 16]
    }
    ), [n]);
    return v.jsx(S, {
        height: t ? Que : "calc(100vh - 194px)",
        children: null === r ? v.jsx(Km, {}) : r.length ? v.jsx(Zue, {
            priceAlertsDisplayData: r,
            getRowHeight: a
        }) : v.jsx(S, {
            width: "100%",
            height: "100%",
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(k, {
                variant: "paragraph3",
                textAlign: "center",
                color: "text.label",
                children: e("You don't have any price alerts")
            })
        })
    })
}
))
  , Que = 425
  , Zue = y.memo(( ({priceAlertsDisplayData: e, getRowHeight: t}) => {
    const n = y.useRef(null);
    return y.useEffect(( () => {
        var e;
        null == (e = n.current) || e.recomputeRowHeights()
    }
    ), [t]),
    v.jsx(mt, {
        children: ({height: r, width: a}) => v.jsx(gt, {
            ref: n,
            className: "padre-no-scroll",
            height: r,
            width: a,
            rowHeight: t,
            rowCount: e.length,
            itemData: e,
            rowRenderer: ({index: t, style: n}) => {
                const r = e[t]
                  , a = r.definedOn.marketId;
                return v.jsx("div", {
                    style: n,
                    children: v.jsx(Yue, {
                        displayData: r
                    })
                }, a)
            }
            ,
            overscanRowCount: 2
        })
    })
}
))
  , Jue = y.memo(( () => v.jsxs(S, {
    children: [v.jsx(Aue, {}), v.jsx(Ee, {
        flexItem: !0,
        sx: epe
    }), v.jsx(Xue, {})]
})))
  , epe = {
    mt: 2
}
  , tpe = ({isOpen: e, onClose: t, soundEffectEnabled: n, setSoundEffectEnabled: r, notificationsVolume: a, setNotificationsVolume: s, notificationsDuration: o, setNotificationsDuration: l, selectedSoundEffect: i, setSelectedSoundEffect: c, priceAlertsCount: d}) => {
    const {t: u} = we();
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        desktopWidth: npe,
        minDesktopWidth: npe,
        stackSx: ape,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                maxHeight: "100%",
                children: [v.jsx(k, {
                    variant: "h2",
                    children: u("Price alerts")
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    children: [v.jsxs(S, {
                        direction: "row",
                        gap: .5,
                        children: [v.jsx(C, {
                            component: "span",
                            children: v.jsx(pI, {
                                soundEffectEnabled: n,
                                selectedSoundEffect: i,
                                notificationsVolume: a,
                                setNotificationsVolume: s,
                                notificationsDuration: o,
                                setNotificationsDuration: l,
                                usePopper: !0
                            })
                        }), v.jsx(C, {
                            component: "span",
                            children: v.jsx(ej, {
                                idKey: "notifications",
                                soundEffectEnabled: n,
                                setSoundEffectEnabled: r,
                                selectedSoundEffect: i,
                                setSelectedSoundEffect: c,
                                volume: a,
                                usePopper: !0
                            })
                        })]
                    }), v.jsx(F, {
                        onClick: t,
                        sx: spe,
                        children: v.jsx(kS, {})
                    })]
                })]
            }), v.jsx(Ee, {
                flexItem: !0,
                sx: rpe
            }), v.jsx(Jue, {}), v.jsx(Ee, {
                flexItem: !0,
                sx: rpe
            }), v.jsx(S, {
                direction: "row",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: null === d ? "text.label" : d >= Qde ? "warning.main" : "text.label",
                    children: `${d ?? Ud}/250 ${u("alerts")}`
                })
            })]
        })
    })
}
  , npe = 500
  , rpe = {
    mx: -2
}
  , ape = {
    p: 2,
    zIndex: 1302
}
  , spe = {
    p: .5
}
  , ope = (e, t) => {
    if ("init" === t.type) {
        return {
            alertsLookup: t.snapshot
        }
    }
    e || (e = {
        alertsLookup: {}
    });
    const n = c.reduce(t.update.updates, ( (e, t) => (e[t.alertId] = t,
    e)), e.alertsLookup);
    return c.forEach(t.update.deletes, (e => {
        delete n[e]
    }
    )),
    {
        alertsLookup: n
    }
}
  , lpe = () => "listening"
  , ipe = ({children: e}) => {
    const {t: t} = we()
      , n = Ax()
      , r = pK()
      , a = ( () => {
        const e = Ax()
          , t = y.useCallback((t => e ? Wm.subscribeTokenAlerts(e, t) : {
            unsubscribe: () => {}
        }), [e]);
        return kx(t, ope)
    }
    )()
      , [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        o(!0)
    }
    ), [])
      , i = y.useCallback(( () => {
        o(!1)
    }
    ), [])
      , [d,u] = y.useState(null)
      , p = y.useMemo(( () => a ? Object.keys(a.alertsLookup).length : null), [a])
      , h = y.useCallback((e => {
        null !== p && (p >= Qde ? r({
            message: t("Reached limit of {{limit}} alerts", {
                limit: Qde
            }),
            type: "warning"
        }, "price-alerts-limit-reached") : u(e))
    }
    ), [t, r, p])
      , m = y.useCallback(( () => {
        u(null)
    }
    ), [])
      , g = y.useCallback(( () => {
        m(),
        i()
    }
    ), [m, i])
      , x = y.useCallback((async ({targetValue: e, direction: a, type: s, marketId: o}) => {
        if (null !== p && n && !(e <= 0))
            if (p >= Qde)
                r({
                    message: t("Reached limit of {{limit}} alerts", {
                        limit: Qde
                    }),
                    type: "warning"
                }, "price-alerts-limit-reached");
            else
                try {
                    await Wm.createTokenAlert({
                        type: s,
                        uid: n,
                        definedOn: {
                            type: "marketId",
                            marketId: o
                        },
                        direction: a,
                        targetValue: e
                    }),
                    r({
                        message: pu.priceAlertCreationSuccess,
                        type: "success"
                    }, "price-alert-creation-success")
                } catch (fNe) {
                    r({
                        message: uu.unknownError,
                        snackName: pu.priceAlertCreationFailed,
                        type: "error"
                    }, "price-alert-creation-error")
                }
    }
    ), [r, p, t, n])
      , b = y.useCallback((async e => {
        if (!n || !e)
            return !1;
        try {
            return await Wm.deleteTokenAlert(e),
            r({
                message: pu.priceAlertDeleteSuccess,
                type: "success"
            }, "price-alert-delete-success"),
            !0
        } catch (fNe) {
            return r({
                message: uu.unknownError,
                snackName: pu.priceAlertDeleteFailed,
                type: "error"
            }, "price-alert-delete-error"),
            !1
        }
    }
    ), [r, n])
      , f = pT()
      , S = y.useCallback((e => {
        f({
            marketId: e,
            tradePageOrigin: nT.SNACK_PRICE_ALERT
        })
    }
    ), [f])
      , [k,C] = Mx("padreV2-priceAlertsSoundEnabled", !1)
      , [A,w] = Mx("padreV2-priceAlertsVolume", 100)
      , [j,T] = Mx("padreV2-priceAlertsNotificationsDuration", 5)
      , [I,E] = Mx("padreV2-priceAlertsSound", Jde)
      , M = y.useRef(I);
    M.current = I;
    const N = y.useRef(A);
    N.current = A;
    const P = y.useRef(j);
    P.current = j;
    const O = y.useRef(k);
    O.current = k;
    const L = y.useCallback((e => {
        ( (e, t, n, r, a, s, o) => {
            c.forEach(e, (e => {
                const {alertBaseInfo: l, triggeredValue: i} = e;
                n && nw.play(r, a);
                const c = () => {
                    o(l.definedOn.marketId)
                }
                ;
                "visible" === document.visibilityState && t({
                    alertBaseInfo: l,
                    triggeredValue: i,
                    navigateToMarketPage: c,
                    variant: lK.PRICE_ALERT
                }, "price-alert-snack", {
                    autoHideDuration: 1e3 * lb(s, {
                        min: 1,
                        max: 10
                    })
                })
            }
            ))
        }
        )(e, r, O.current, M.current, N.current, P.current, S)
    }
    ), [r, S])
      , R = y.useRef(L);
    y.useEffect(( () => {
        R.current = L
    }
    ), [L]),
    (e => {
        const t = Ax()
          , n = y.useCallback((n => t ? Wm.subscribeRecentNotifications(t, {
            onMessage: t => {
                e.current && "update" === t.type && e.current(t.update.newNotifications),
                n.onMessage(t)
            }
            ,
            close: e => {
                n.close && n.close(e)
            }
        }) : {
            unsubscribe: () => {}
        }), [e, t]);
        kx(n, lpe)
    }
    )(R);
    const D = y.useMemo(( () => ({
        openOverviewModal: l,
        openAddAlertModal: h,
        closeModals: g,
        priceAlerts: a,
        createPriceAlert: x,
        removePriceAlert: b
    })), [l, h, g, a, x, b]);
    return v.jsxs(Tue.Provider, {
        value: D,
        children: [e, s && v.jsx(tpe, {
            isOpen: !0,
            onClose: i,
            soundEffectEnabled: k,
            setSoundEffectEnabled: C,
            notificationsVolume: A,
            setNotificationsVolume: w,
            notificationsDuration: j,
            setNotificationsDuration: T,
            selectedSoundEffect: I,
            setSelectedSoundEffect: E,
            priceAlertsCount: p
        }), d && v.jsx(xue, {
            isOpen: !0,
            onClose: m,
            addTokenInfo: d,
            openOverviewModal: l
        })]
    })
}
  , cpe = y.createContext({
    openModal: c.noop,
    toggleIsNeeded: c.noop,
    pumpFunNews: null
})
  , dpe = () => y.useContext(cpe)
  , upe = y.memo(( ({isSelected: e, onClick: t}) => {
    const n = y.useMemo(( () => t => ({
        width: ppe,
        height: ppe,
        borderRadius: "50%",
        cursor: "pointer",
        transition: "all 0.2s ease",
        bgcolor: e ? JE : t.palette.text.label,
        transform: e ? "scale(1.25)" : "scale(1)"
    })), [e]);
    return v.jsx(C, {
        onClick: t,
        sx: n
    })
}
))
  , ppe = 9
  , hpe = y.memo(( ({news: e, onRedirectCallback: t}) => {
    const n = bw()
      , [r,a] = y.useState(0)
      , s = y.useMemo(( () => (null == e ? void 0 : e.length) ? Math.min(Math.max(r, 0), e.length - 1) : 0), [r, null == e ? void 0 : e.length])
      , o = null == e ? void 0 : e[s]
      , l = s > 0 ? e[s - 1] : null
      , i = s < e.length - 1 ? e[s + 1] : null
      , c = y.useCallback(( () => {
        s < e.length - 1 && a((e => e + 1))
    }
    ), [s, e.length])
      , d = y.useCallback((e => a(e)), [])
      , u = y.useCallback(( () => {
        s > 0 && a((e => Math.max(0, e - 1)))
    }
    ), [s]);
    return e && 0 !== e.length ? v.jsxs(S, {
        gap: 1.25,
        alignItems: "center",
        width: "100%",
        children: [v.jsxs(C, {
            sx: mpe,
            children: [!n && v.jsx(Cpe, {
                item: l,
                onClick: u
            }), v.jsx(Cpe, {
                item: o ?? null,
                prominent: !0,
                onRedirectCallback: t
            }), !n && v.jsx(Cpe, {
                item: i,
                onClick: c
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            justifyContent: "center",
            alignItems: "center",
            children: [0 === s ? v.jsx(C, {
                width: bpe
            }) : v.jsx(F, {
                onClick: u,
                sx: Spe,
                children: v.jsx(ZS, {
                    size: fpe
                })
            }), e.map(( (e, t) => v.jsx(upe, {
                isSelected: t === s,
                onClick: () => {
                    d(t)
                }
            }, t))), s >= e.length - 1 ? v.jsx(C, {
                width: bpe
            }) : v.jsx(F, {
                onClick: c,
                sx: vpe,
                children: v.jsx(ZS, {
                    size: fpe
                })
            })]
        })]
    }) : null
}
))
  , mpe = e => ({
    width: "100%",
    display: {
        xs: "grid",
        md: "flex"
    },
    gridTemplateColumns: {
        xs: "6% 88% 6%",
        sm: "10% 80% 10%",
        md: void 0
    },
    justifyContent: "center",
    alignItems: "stretch",
    columnGap: e.spacing(1.25),
    overflow: "hidden"
})
  , gpe = {
    transform: "none"
}
  , xpe = "8px"
  , bpe = 26
  , fpe = 22
  , vpe = {
    p: (bpe - fpe) / 16,
    height: bpe,
    width: bpe
}
  , Spe = {
    ...vpe,
    transform: "scaleX(-1)"
}
  , ype = {
    display: "-webkit-box",
    WebkitLineClamp: 5,
    WebkitBoxOrient: "vertical",
    overflow: "hidden",
    textOverflow: "ellipsis",
    lineHeight: 1.4,
    minHeight: "7em"
}
  , kpe = {
    width: "100%",
    fontWeight: 600,
    lineHeight: 1.2,
    display: "-webkit-box",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minHeight: "2.4em"
}
  , Cpe = y.memo(( ({item: e, prominent: t=!1, onRedirectCallback: n=c.noop, onClick: r}) => {
    const a = bw()
      , s = D()
      , {t: o} = we()
      , l = yT()
      , i = y.useCallback((t => {
        e && (0 === t.button && (t.stopPropagation(),
        t.preventDefault()),
        l({
            chain: ZE,
            tokenAddress: null == e ? void 0 : e.mint,
            tradePageOrigin: nT.PUMP_NEWS
        }),
        n())
    }
    ), [e, l, n])
      , {marketCapThresholds: d} = bA()
      , u = y.useMemo(( () => e && null !== e.fdvUsd ? IA(e.fdvUsd, d, s.palette.text.value) : null), [e, d, s.palette.text.value])
      , p = y.useMemo(( () => ({
        visibility: t ? "visible" : "hidden"
    })), [t])
      , h = y.useMemo(( () => ({
        ...p,
        border: `1px solid ${JE}54`,
        borderRadius: xpe
    })), [p])
      , m = y.useMemo(( () => ({
        ...kpe,
        ...p
    })), [p])
      , g = y.useMemo(( () => ({
        ...ype,
        ...p
    })), [p])
      , x = y.useMemo(( () => e => ({
        width: "100%",
        height: Ape,
        borderRadius: 2,
        p: 2,
        gap: 1,
        background: e.palette.background.buttonDefault,
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-between",
        minHeight: 220,
        overflow: "hidden",
        ...r ? {
            "&:hover": {
                cursor: "pointer",
                background: e.palette.background.buttonHover
            }
        } : {}
    })), [r]);
    return e ? v.jsx(S, {
        flex: t ? 2 : 1,
        alignItems: "center",
        sx: gpe,
        children: a ? v.jsxs(S, {
            gap: 0,
            width: "100%",
            justifyContent: "space-between",
            height: wpe,
            sx: Npe,
            component: "a",
            target: "_blank",
            href: QE(e.marketId, nT.PUMP_NEWS) ?? XE(ZE, e.mint, nT.PUMP_NEWS) ?? "#",
            onClick: i,
            children: [v.jsxs(S, {
                gap: 1.75,
                width: "100%",
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    justifyContent: "space-between",
                    children: [v.jsx(GC, {
                        title: e.headline,
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            fontSize: 18,
                            fontWeight: 700,
                            color: JE,
                            noWrap: !0,
                            sx: Epe,
                            maxWidth: Ipe,
                            children: e.headline
                        })
                    }), e.createdAt && v.jsx(mE, {
                        ts: e.createdAt,
                        variant: "paragraph1",
                        fontSize: 18,
                        fontWeight: 700,
                        color: `${JE}A8`,
                        sx: p,
                        suffixAdornment: " ago",
                        noWrap: !0
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 2,
                    children: [v.jsxs(S, {
                        width: 134,
                        gap: .75,
                        children: [v.jsx(C, {
                            display: "flex",
                            sx: h,
                            children: v.jsx(b_, {
                                url: IE(ZE, e.mint),
                                padreAvatarUrl: null,
                                name: e.symbol,
                                size: 130,
                                chain: ZE,
                                protocolInfo: null,
                                borderRadius: xpe,
                                hideBorder: !0,
                                hideHoverAvatar: !0,
                                alwaysShowPointer: !0
                            })
                        }), v.jsx(S, {
                            height: jpe,
                            justifyContent: "center",
                            children: v.jsx(k, {
                                variant: "h2",
                                color: "text.value",
                                ...Nu,
                                noWrap: !0,
                                maxWidth: 132,
                                children: e.symbol
                            })
                        }), v.jsx(S, {
                            direction: "row",
                            gap: .5,
                            height: jpe,
                            children: null !== e.fdvUsd && v.jsxs(v.Fragment, {
                                children: [v.jsx(k, {
                                    variant: "paragraph1",
                                    color: "text.label",
                                    children: o("MCap")
                                }), v.jsx(k, {
                                    variant: "paragraph1",
                                    color: u ?? "text.value",
                                    ...Nu,
                                    children: LI(e.fdvUsd, {
                                        collapseExponent: !0,
                                        desiredDigits: 3,
                                        padSymbol: !1,
                                        symbolPosition: yI.START
                                    })
                                })]
                            })
                        })]
                    }), v.jsx(S, {
                        className: "padre-decorative-scroll",
                        sx: Mpe,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            fontWeight: 400,
                            fontSize: 16,
                            lineHeight: 1.5,
                            whiteSpace: "pre-line",
                            children: e.preview
                        })
                    })]
                })]
            }), v.jsx(Ee, {
                orientation: "horizontal",
                flexItem: !0,
                sx: Ppe
            })]
        }) : v.jsxs(S, {
            sx: x,
            gap: 1.25,
            width: "100%",
            onClick: r,
            children: [v.jsx(C, {
                display: "flex",
                justifyContent: "center",
                children: v.jsx(C, {
                    component: "a",
                    target: "_blank",
                    href: QE(e.marketId, nT.PUMP_NEWS) ?? XE(ZE, e.mint, nT.PUMP_NEWS) ?? "#",
                    onClick: i,
                    display: "flex",
                    sx: h,
                    children: v.jsx(b_, {
                        url: IE(ZE, e.mint),
                        padreAvatarUrl: null,
                        name: e.symbol,
                        size: 100,
                        chain: ZE,
                        protocolInfo: null,
                        borderRadius: xpe,
                        hideBorder: !0,
                        hideHoverAvatar: !0,
                        alwaysShowPointer: !0
                    })
                })
            }), v.jsx(k, {
                variant: "h2",
                textAlign: "center",
                color: JE,
                sx: m,
                children: e.headline
            }), v.jsx(k, {
                variant: "paragraph1",
                fontWeight: 400,
                sx: g,
                children: e.preview
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                gap: .5,
                height: 18,
                children: [e.fdvUsd ? v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        sx: p,
                        height: 18,
                        children: o("MCap")
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: u ?? "text.value",
                        ...Nu,
                        sx: p,
                        children: LI(e.fdvUsd, {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    })]
                }) : v.jsx(C, {
                    height: 18
                }), e.createdAt && v.jsx(mE, {
                    ts: e.createdAt,
                    variant: "paragraph1",
                    color: `${JE}A8`,
                    sx: p,
                    suffixAdornment: " ago",
                    noWrap: !0
                })]
            }), v.jsx(S, {
                direction: "row",
                gap: 1,
                width: "100%",
                alignItems: "center",
                justifyContent: "center",
                sx: p,
                children: v.jsx(V, {
                    href: QE(e.marketId, nT.PUMP_NEWS) ?? XE(ZE, e.mint, nT.PUMP_NEWS) ?? "#",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    fullWidth: !0,
                    variant: "primary",
                    size: "xsmall",
                    sx: Tpe,
                    onClick: i,
                    children: "Trade now"
                })
            })]
        })
    }) : v.jsx(C, {
        flex: 1
    })
}
))
  , Ape = 350
  , wpe = 234
  , jpe = 18
  , Tpe = {
    alignItems: "center",
    display: "flex",
    p: 0,
    lineHeight: 1.5,
    maxWidth: 300,
    background: JE,
    borderColor: JE,
    "&:hover, &:focus": {
        background: Me(JE, .1),
        borderColor: Me(JE, .1)
    }
}
  , Ipe = 430
  , Epe = {
    "&:hover": {
        cursor: "help"
    }
}
  , Mpe = {
    overflowX: "hidden",
    overflowY: "scroll",
    maxHeight: 192
}
  , Npe = e => ({
    px: 1,
    pt: 1,
    borderRadius: "6px",
    textDecoration: "none",
    "&:hover": {
        background: e.palette.background.buttonDefault,
        cursor: "pointer"
    }
})
  , Ppe = {
    mx: -1
}
  , Ope = y.memo(( ({onClickCallback: e, ...t}) => {
    const n = D()
      , r = yT()
      , {marketCapThresholds: a} = bA()
      , s = y.useMemo(( () => null !== t.fdvUsd ? IA(t.fdvUsd, a, n.palette.text.value) : null), [a, t.fdvUsd, n.palette.text.value])
      , o = y.useCallback((n => {
        0 === n.button && (n.stopPropagation(),
        n.preventDefault()),
        r({
            chain: ZE,
            tokenAddress: t.mint,
            tradePageOrigin: nT.PUMP_NEWS_HISTORICAL
        }),
        e && e()
    }
    ), [r, t.mint, e]);
    return v.jsxs(S, {
        sx: Rpe,
        component: "a",
        target: "_blank",
        href: QE(t.marketId, nT.PUMP_NEWS_HISTORICAL) ?? XE(ZE, t.mint, nT.PUMP_NEWS_HISTORICAL) ?? "#",
        onClick: o,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            children: [v.jsx(C, {
                display: "flex",
                sx: Bpe,
                children: v.jsx(b_, {
                    url: IE(ZE, t.mint),
                    padreAvatarUrl: null,
                    name: t.symbol ?? "?",
                    size: Lpe,
                    chain: ZE,
                    protocolInfo: null,
                    borderRadius: "8px",
                    hideBorder: !0,
                    hideHoverAvatar: !0,
                    alwaysShowPointer: !0
                })
            }), v.jsxs(S, {
                justifyContent: "space-between",
                gap: .5,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: JE,
                    sx: Dpe,
                    children: t.headline
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    sx: Dpe,
                    children: t.preview
                })]
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            pl: .25,
            children: [v.jsx(k, {
                variant: "h2",
                color: "text.value",
                ...Nu,
                noWrap: !0,
                maxWidth: 125,
                children: t.symbol
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "flex-end",
                gap: .5,
                children: [t.createdAt && v.jsx(mE, {
                    ts: t.createdAt,
                    variant: "paragraph3",
                    color: `${JE}A8`
                }), t.fdvUsd && v.jsxs(v.Fragment, {
                    children: [t.createdAt && v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: hM
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: s ?? "text.value",
                        ...Nu,
                        children: LI(t.fdvUsd, {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    })]
                })]
            })]
        })]
    })
}
))
  , Lpe = 60
  , Rpe = e => ({
    p: 1.25,
    gap: 1,
    borderRadius: 2,
    textDecoration: "none",
    height: 102,
    width: {
        xs: "100%",
        md: 308
    },
    minWidth: {
        md: 308
    },
    background: e.palette.background.buttonDefault,
    "&:hover": {
        background: e.palette.background.buttonActive,
        cursor: "pointer"
    }
})
  , Dpe = {
    display: "-webkit-box",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical",
    overflow: "hidden",
    textOverflow: "ellipsis",
    lineHeight: 1.1
}
  , Bpe = {
    pointerEvents: "none"
}
  , _pe = y.memo(( ({news: e, onClose: t}) => {
    const {t: n} = we()
      , r = bw();
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: n("Historical")
        }), v.jsx(S, {
            direction: r ? "row" : "column",
            sx: Upe,
            className: "padre-decorative-scroll",
            children: e.map((e => v.jsx(Ope, {
                onClickCallback: t,
                ...e
            }, e.articleId)))
        })]
    })
}
))
  , Upe = {
    gap: 1,
    overflowX: {
        xs: "hidden",
        md: "scroll"
    },
    overflowY: {
        xs: "scroll",
        md: "hidden"
    }
}
  , Wpe = y.memo(( ({pumpFunNews: e, onClose: t}) => {
    const {featuredNews: n, historicalNews: r} = y.useMemo(( () => {
        const t = Object.values(e).sort(( (e, t) => t.createdAt - e.createdAt));
        return {
            featuredNews: t.slice(0, 3) ?? [],
            historicalNews: t.slice(3) ?? []
        }
    }
    ), [e]);
    return v.jsxs(Dn, {
        gap: 1,
        flexGrow: 1,
        width: "100%",
        children: [v.jsx(hpe, {
            news: n,
            onRedirectCallback: t
        }), v.jsx(_pe, {
            news: r,
            onClose: t
        })]
    })
}
))
  , Fpe = y.memo(( ({onClose: e}) => {
    const {t: t} = we()
      , {pumpFunNews: n} = dpe()
      , r = y.useMemo(( () => {
        if (n)
            return !!Object.keys(n).length
    }
    ), [n]);
    return v.jsxs(S, {
        gap: 1,
        flexGrow: 1,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            px: .75,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(Lk, {}), v.jsx(k, {
                    variant: "h2",
                    children: t("News")
                })]
            }), v.jsx(F, {
                onClick: e,
                sx: Hpe,
                children: v.jsx(kS, {})
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: Vpe
        }), v.jsx(S, {
            sx: zpe,
            className: "padre-no-scroll",
            children: null === n ? v.jsx(S, {
                flexGrow: 1,
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(Km, {})
            }) : r ? v.jsx(Wpe, {
                pumpFunNews: n,
                onClose: e
            }) : v.jsx(S, {
                flexGrow: 1,
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    children: "No recent news at this moment"
                })
            })
        })]
    })
}
))
  , Vpe = {
    mx: -1
}
  , Hpe = {
    p: .5
}
  , zpe = {
    overflowX: "hidden",
    overflowY: "scroll",
    flexGrow: 1
}
  , $pe = y.memo(( ({isOpen: e, onClose: t}) => v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: Gpe,
    maxDesktopWidth: 550,
    minDesktopHeight: 474,
    maxDesktopHeight: 474,
    children: v.jsx(Fpe, {
        onClose: t
    })
})))
  , Gpe = {
    p: 1
}
  , qpe = (e, t) => {
    if ("init" === t.type)
        return c.reduce(t.snapshot.entries, ( (e, t) => (e[t.articleId] = t,
        e)), {});
    if (!e)
        return {};
    const n = {
        ...e
    };
    return t.update.deletes.forEach((e => {
        delete n[e]
    }
    )),
    t.update.additions.forEach((e => {
        n[e.articleId] = e
    }
    )),
    t.update.updates.forEach((e => {
        const t = e.articleId;
        n[t] && (n[t] = {
            ...n[t],
            ...e
        })
    }
    )),
    n
}
  , Kpe = ({children: e}) => {
    const [t,n] = y.useState(!1)
      , [r,a] = JC(!1, Ype)
      , s = y.useCallback(( () => {
        a(!0)
    }
    ), [a])
      , o = (e => {
        const t = Ax()
          , n = y.useCallback((n => t && e ? $m.subscribeAllNews(n) : {
            unsubscribe: () => {}
        }), [t, e]);
        return kx(n, qpe)
    }
    )(t || r)
      , l = y.useCallback(( () => {
        n(!0)
    }
    ), [])
      , i = y.useCallback(( () => {
        n(!1)
    }
    ), [])
      , c = y.useMemo(( () => ({
        openModal: l,
        toggleIsNeeded: s,
        pumpFunNews: o
    })), [l, o, s]);
    return v.jsxs(cpe.Provider, {
        value: c,
        children: [e, t && v.jsx($pe, {
            isOpen: t,
            onClose: i
        })]
    })
}
  , Ype = 5e3
  , Xpe = y.createContext({
    openModal: c.noop
})
  , Qpe = y.memo(( ({dayNews: e, selectedIndex: t, setSelectedIndex: n}) => {
    const r = y.useCallback(( () => {
        n(Math.max(0, t - 1))
    }
    ), [t, n])
      , a = y.useCallback(( () => {
        n(Math.max(0, Math.min(e.news.length - 1, t + 1)))
    }
    ), [e.news.length, t, n]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "center",
        gap: 1,
        children: [v.jsx(C, {
            width: Zpe,
            height: Zpe,
            children: v.jsx(F, {
                sx: ehe,
                onClick: r,
                children: v.jsx(C, {
                    display: "flex",
                    sx: the,
                    children: v.jsx(ZS, {
                        size: Zpe - 8 * Jpe
                    })
                })
            })
        }), v.jsx(S, {
            direction: "row",
            gap: .75,
            alignItems: "center",
            children: e.news.map(( (e, r) => v.jsx(nhe, {
                onClick: () => {
                    n(r)
                }
                ,
                isCurrentIndex: r === t,
                alreadySeen: r < t,
                tooltipTitle: e.title ?? ""
            }, r)))
        }), v.jsx(C, {
            width: Zpe,
            height: Zpe,
            children: v.jsx(F, {
                sx: ehe,
                onClick: a,
                children: v.jsx(C, {
                    display: "flex",
                    children: v.jsx(ZS, {
                        size: Zpe - 8 * Jpe
                    })
                })
            })
        })]
    })
}
))
  , Zpe = 28
  , Jpe = .5
  , ehe = {
    p: Jpe,
    width: Zpe,
    height: Zpe
}
  , the = {
    transform: "scaleX(-1)"
}
  , nhe = y.memo(( ({onClick: e, isCurrentIndex: t, alreadySeen: n, tooltipTitle: r}) => {
    const a = y.useMemo(( () => e => ({
        width: she,
        [`.${rhe}`]: {
            background: t || n ? e.palette.primary.main : e.palette.text.label
        },
        "&:hover": {
            cursor: "pointer",
            [`.${rhe}`]: {
                background: t || n ? e.palette.primary[300] : e.palette.text.value
            }
        }
    })), [n, t])
      , s = y.useMemo(( () => ({
        borderRadius: "50%",
        width: ahe,
        height: ahe,
        transform: `scale(${t ? she / ahe : 1})`,
        transition: "transform 0.3s ease"
    })), [t]);
    return v.jsx(GC, {
        title: r,
        children: v.jsx(C, {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            onClick: e,
            sx: a,
            children: v.jsx(C, {
                sx: s,
                className: rhe
            })
        })
    })
}
))
  , rhe = "dot-inner-display"
  , ahe = 9
  , she = 12
  , ohe = y.memo(( ({onClose: e, saveValues: t, initialValues: n}) => {
    const [r,a] = y.useState(n.description ?? "")
      , [s,o] = y.useState(n.title ?? "")
      , [l,i] = y.useState(n.mediaUrl)
      , c = y.useCallback(( () => {
        t({
            description: r,
            title: s,
            mediaUrl: l
        }),
        e()
    }
    ), [r, l, t, s, e]);
    return v.jsx(Sw, {
        open: !0,
        onClose: e,
        stackSx: lhe,
        minDesktopWidth: 400,
        maxDesktopWidth: 400,
        children: v.jsxs(S, {
            gap: 2.5,
            children: [v.jsx(k, {
                variant: "paragraph1",
                children: "News Generator"
            }), v.jsx(S, {
                direction: "row",
                gap: 2,
                width: "100%",
                children: v.jsxs(S, {
                    gap: .75,
                    flex: 1,
                    alignItems: "center",
                    divider: ihe,
                    children: [v.jsx(X5, {
                        value: r,
                        setValue: a,
                        label: "Description",
                        multiline: !0
                    }), v.jsx(X5, {
                        value: s,
                        setValue: o,
                        label: "Title"
                    }), v.jsx(X5, {
                        value: l,
                        setValue: i,
                        label: "Media URL"
                    })]
                })
            }), v.jsx(V, {
                size: "xsmall",
                onClick: c,
                fullWidth: !0,
                children: "Save and close"
            })]
        })
    })
}
))
  , lhe = {
    p: 2,
    zIndex: Kw
}
  , ihe = v.jsx(Ee, {
    flexItem: !0,
    sx: e => ({
        borderColor: e.palette.background.borderActive,
        mx: -2
    })
})
  , che = y.memo(( ({url: e}) => {
    const t = y.useMemo(( () => e.endsWith(".mp4")), [e])
      , n = y.useRef(null);
    return y.useEffect(( () => {
        if (!t)
            return;
        const e = n.current;
        if (!e)
            return;
        try {
            e.pause()
        } catch (fNe) {
            return
        }
        const r = new IntersectionObserver((t => {
            for (const n of t) {
                if (n.intersectionRatio >= .95)
                    e.play().catch(( () => {}
                    ));
                else
                    try {
                        e.pause()
                    } catch (fNe) {
                        return
                    }
            }
        }
        ),{
            threshold: [0, .25, .5, .75, .95, 1]
        });
        return r.observe(e),
        () => {
            r.disconnect()
        }
    }
    ), [t, e]),
    t ? v.jsx(C, {
        sx: uhe,
        children: v.jsxs("video", {
            ref: n,
            width: "100%",
            height: "100%",
            muted: !0,
            loop: !0,
            playsInline: !0,
            preload: "metadata",
            style: dhe,
            children: [v.jsx("source", {
                src: e,
                type: "video/mp4"
            }), "Your browser does not support the video tag."]
        })
    }) : v.jsx(C, {
        sx: uhe,
        component: "img",
        width: "100%",
        src: e,
        alt: "Image"
    })
}
))
  , dhe = {
    display: "block",
    width: "100%",
    height: "100%",
    objectFit: "cover"
}
  , uhe = e => ({
    aspectRatio: 16 / 9,
    borderRadius: 1,
    border: `1px solid ${e.palette.background.borderSubtle}`,
    overflow: "hidden"
})
  , phe = y.memo(( ({mediaUrl: e, title: t, description: n, omitPadding: r=!1}) => v.jsxs(S, {
    gap: 1.5,
    width: "100%",
    pb: r ? 0 : 3,
    height: r ? "100%" : void 0,
    children: [v.jsx(che, {
        url: e.replace("http://", "https://")
    }), v.jsx(k, {
        variant: "h1",
        fontWeight: 600,
        fontSize: 18,
        color: "primary.main",
        textAlign: "center",
        mt: 2,
        children: t
    }), v.jsx(k, {
        variant: "paragraph1",
        textAlign: "center",
        sx: hhe,
        children: n
    })]
})))
  , hhe = {
    minHeight: 32
}
  , mhe = y.memo(( ({news: e, onClose: t}) => {
    const {t: n} = we()
      , [r,a] = y.useMemo(( () => {
        const t = e.sort(( (e, t) => t.id - e.id))
          , [n,...r] = t;
        return [n, r]
    }
    ), [e])
      , s = F5()
      , [o,l] = y.useState(!1)
      , c = y.useCallback(( () => {
        l(!0)
    }
    ), [])
      , d = y.useCallback(( () => {
        l(!1)
    }
    ), [])
      , [u,p] = y.useState(null)
      , [h,m] = y.useState(0);
    y.useEffect(( () => {
        h >= r.news.length && m(0)
    }
    ), [r.news.length, h]);
    const g = y.useMemo(( () => u || (h >= r.news.length ? r.news[0] : r.news[h])), [r.news, h, u])
      , x = y.useRef(null)
      , [b,f] = y.useState(!0)
      , A = () => {
        if (x.current) {
            const e = x.current.scrollTop;
            f(0 === e)
        }
    }
    ;
    y.useEffect(( () => {
        const e = x.current;
        if (e)
            return e.addEventListener("scroll", A),
            () => e.removeEventListener("scroll", A)
    }
    ), []);
    const w = y.useMemo(( () => e => ({
        height: yhe,
        borderTop: `1px solid ${e.palette.background.borderMain}`,
        background: e.palette.background.secondary,
        opacity: b ? 1 : 0,
        transition: "opacity 0.3s ease"
    })), [b])
      , j = y.useMemo(( () => ({
        height: yhe,
        opacity: b ? 1 : 0,
        transition: "opacity 0.3s ease"
    })), [b])
      , T = y.useCallback(( () => {
        m((e => Math.max(0, e - 1)))
    }
    ), [])
      , I = y.useCallback(( () => {
        h >= r.news.length - 1 ? t() : m((e => e + 1))
    }
    ), [r.news.length, t, h]);
    return v.jsx(Sw, {
        open: !0,
        maxDesktopHeight: ghe,
        desktopWidth: xhe,
        minDesktopWidth: xhe,
        minDesktopHeight: ghe,
        onClose: t,
        stackSx: bhe,
        children: v.jsxs(S, {
            gap: 5.25,
            position: "relative",
            sx: She,
            className: "padre-no-scroll",
            overflow: "auto",
            height: "100%",
            ref: x,
            children: [v.jsxs(S, {
                height: `calc(100% - ${yhe}px)`,
                minHeight: `calc(100% - ${yhe}px)`,
                gap: 2.5,
                children: [v.jsx(phe, {
                    ...g,
                    omitPadding: !0
                }, g.mediaUrl), v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    justifyContent: "center",
                    pb: 2,
                    pt: 1,
                    children: [s && !R && v.jsx(C, {
                        width: 50
                    }), v.jsx(Qpe, {
                        dayNews: r,
                        selectedIndex: h,
                        setSelectedIndex: m
                    }), s && !R && v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        onClick: c,
                        sx: fhe,
                        children: "ANG"
                    })]
                })]
            }), a.map((e => {
                const t = i(e.dateFormatted).format("DD MMM, YYYY");
                return v.jsxs(S, {
                    pt: .75,
                    gap: 2,
                    children: [t && v.jsx(k, {
                        textAlign: "center",
                        color: "text.label",
                        variant: "paragraph2",
                        fontSize: 14,
                        children: t
                    }), v.jsx(S, {
                        gap: 6,
                        divider: vhe,
                        children: e.news.map((e => y.createElement(phe, {
                            ...e,
                            key: e.mediaUrl
                        })))
                    })]
                }, e.id)
            }
            )), v.jsx(S, {
                position: "absolute",
                width: "100%",
                bottom: 0,
                alignItems: "center",
                justifyContent: "center",
                sx: w,
                children: !!a.length && v.jsx(V, {
                    sx: khe,
                    onClick: () => {
                        if (x.current && x.current.children.length > 1) {
                            const e = x.current.children[1];
                            e && e.scrollIntoView({
                                behavior: "smooth"
                            })
                        }
                    }
                    ,
                    children: v.jsx(k, {
                        variant: "paragraph2",
                        fontSize: 14,
                        color: "inherit",
                        children: n("Show previous update")
                    })
                })
            }), v.jsxs(S, {
                direction: "row",
                position: "absolute",
                width: "100%",
                bottom: 0,
                alignItems: "center",
                justifyContent: "space-between",
                sx: j,
                children: [0 === h ? v.jsx(C, {}) : v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    sx: Che,
                    onClick: T,
                    children: n("Back")
                }), v.jsx(V, {
                    variant: "primary",
                    size: "xxsmall",
                    sx: Che,
                    onClick: I,
                    children: h >= r.news.length - 1 ? n("Finish") : n("Next")
                })]
            }), o && s && !R && v.jsx(ohe, {
                onClose: d,
                saveValues: p,
                initialValues: u ?? g
            })]
        })
    })
}
))
  , ghe = 684
  , xhe = 810
  , bhe = {
    p: 2.5,
    pb: 0,
    height: "100%"
}
  , fhe = {
    opacity: 0,
    px: .5,
    width: 50,
    "&:hover": {
        opacity: 1
    }
}
  , vhe = v.jsx(Ee, {
    flexItem: !0,
    sx: e => ({
        borderColor: e.palette.background.borderMain,
        mx: -2,
        mt: -3
    })
})
  , She = {
    overflowY: "scroll",
    overflowX: "hidden"
}
  , yhe = 48
  , khe = e => ({
    border: "none",
    zIndex: 1,
    p: 0,
    mt: -.5,
    color: "text.label",
    textDecoration: "underline",
    textUnderlineOffset: "3px",
    textDecorationColor: e.palette.text.label,
    backgroundColor: "transparent",
    "&:hover": {
        color: "text.value",
        backgroundColor: "transparent",
        textDecoration: "underline",
        textDecorationColor: e.palette.text.value
    },
    "&:focus": {
        backgroundColor: "transparent",
        textDecoration: "underline",
        textDecorationColor: e.palette.text.label
    }
})
  , Che = {
    display: "flex",
    alignItems: "center",
    borderRadius: 4,
    fontWeight: 600,
    fontSize: 15,
    lineHeight: 1
}
  , Ahe = () => {
    const e = Ax()
      , [t,n] = JC(!1, jhe)
      , [r,a] = dx("padreV2-recentNews", null)
      , s = ( () => {
        const e = Ax()
          , t = y.useCallback((t => e ? zm.subscribeAllNewsCurrentVersion(t) : {
            unsubscribe: () => {}
        }), [e]);
        return yx(t)
    }
    )()
      , [o,l] = y.useState({
        status: ox.INITIAL
    })
      , i = y.useCallback((async () => {
        if (e)
            try {
                const e = await Vm.getAllNews("en");
                l({
                    data: e,
                    status: ox.READY
                }),
                a(e)
            } catch (fNe) {
                l({
                    status: ox.ERROR
                })
            }
    }
    ), [a, e]);
    return y.useEffect(( () => {
        let t = !1;
        if (e && o.status !== ox.READY && s) {
            if (!s || !r || s.version !== r.version)
                return (async () => {
                    try {
                        if (o.status === ox.ERROR && (await Hu(whe),
                        t))
                            return;
                        await i()
                    } catch (fNe) {
                        if (t)
                            return;
                        l({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    t = !0
                }
                ;
            l({
                data: r,
                status: ox.READY
            })
        }
    }
    ), [e, o.status, i, s, r]),
    y.useEffect(( () => {
        o.status === ox.READY && s && !t && o.data.version !== s.version && (n(!0),
        i())
    }
    ), [s, o, i, t, n]),
    o
}
  , whe = 15e3
  , jhe = 3e5
  , The = ({disabled: e, children: t}) => {
    const n = Ax()
      , [r,a] = y.useState(!1)
      , [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        a(!1)
    }
    ), [])
      , i = Ahe()
      , {settings: d, updateLastSeenNewsId: u} = rf()
      , p = y.useMemo(( () => n ? (null == d ? void 0 : d.lastSeenNewsId) ?? null : null), [n, null == d ? void 0 : d.lastSeenNewsId])
      , h = y.useMemo(( () => i.status !== ox.READY ? null : i.data.allNews), [i])
      , m = y.useCallback(( () => {
        if (!h)
            return;
        const e = c.max(h.map((e => e.id))) ?? 0;
        p !== e && u(e),
        a(!0)
    }
    ), [h, p, u]);
    y.useEffect(( () => {
        if (!p || !h || s)
            return;
        const e = c.max(h.map((e => e.id))) ?? 0;
        p < e && (u(e),
        a(!0)),
        o(!0)
    }
    ), [h, p, i, d, u, s]);
    const g = y.useMemo(( () => ({
        openModal: m
    })), [m]);
    return v.jsxs(Xpe.Provider, {
        value: g,
        children: [t, r && null !== p && !e && h && h.length && v.jsx(mhe, {
            news: h,
            onClose: l
        })]
    })
}
  , Ihe = {
    vertical: "top",
    horizontal: "center"
}
  , Ehe = {
    vertical: "top",
    horizontal: "center"
}
  , Mhe = y.createContext({
    desktopAnchor: Ihe,
    setDesktopAnchor: c.noop,
    mobileBelowHeader: !0,
    toggleMobileBelowHeader: c.noop,
    mobileBelowTokenInfo: !1,
    toggleMobileBelowTokenInfo: c.noop,
    setCurrentPathname: c.noop
})
  , Nhe = () => y.useContext(Mhe)
  , Phe = () => {
    const {pathname: e} = he()
      , [t,n,r,a] = y.useMemo(( () => {
        const t = w$e.find((t => !!t.path && e.startsWith(t.path)));
        return t && e !== tT.HOME ? [t.path || null, t.hideBottomBar, t.hideHeader, t.requiresAccountReady] : [null, !0, !0]
    }
    ), [e]);
    return {
        currentPath: t,
        hideBottomBar: n,
        hideHeader: r,
        requiresAccountReady: a
    }
}
  , Ohe = y.memo(( ({chain: e, insufficientBalanceSol: t, insufficientBalanceBsc: n, presetValuesSol: r, presetValuesBsc: a, selectedWalletsAddressesSol: s, selectedWalletsAddressesBsc: o}) => {
    const l = y.useMemo(( () => Y8(e, r, a)), [e, a, r]);
    return v.jsxs(S, {
        gap: 1,
        pb: .5,
        divider: v.jsx(Ee, {
            flexItem: !0,
            sx: {
                mx: -1
            }
        }),
        children: [Y8(e, t, n) && v.jsx(k, {
            variant: "paragraph3",
            textAlign: "center",
            color: "text.label",
            children: "Insufficient funds"
        }), "Inferno" === l ? v.jsxs(S, {
            direction: "row",
            justifyContent: "center",
            gap: .5,
            children: [v.jsx(Cf, {
                size: 14
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "originalPrimary.main",
                children: "Inferno mode"
            })]
        }) : v.jsx(gM, {
            presetValues: l,
            chain: Pd.SOLANA
        }), v.jsxs(S, {
            gap: .5,
            direction: "row",
            alignItems: "center",
            children: [v.jsx(iy, {
                size: 14
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                noWrap: !0,
                children: Y8(e, `Buying on ${s.length} wallet${s.length > 1 ? "s" : ""}`, `Buying on ${o.length} wallet${o.length > 1 ? "s" : ""}`)
            })]
        })]
    })
}
))
  , Lhe = y.memo(( () => {
    const {t: e} = we()
      , t = pK()
      , n = yT()
      , r = pT()
      , a = xw()
      , s = bw()
      , o = D()
      , {exitStrategies: l} = KR()
      , {insufficientBalance: i, buttonDisplayValue: c, selectedPreset: d, buttonValue: u} = uH()
      , {performBuy: p, selectedWalletsAddresses: h} = AD()
      , {insufficientBalance: m, buttonDisplayValue: g, includeExitStrategies: x, selectedPreset: b, buttonValue: f} = ZJ()
      , {performBuy: A, selectedWalletsAddresses: w} = DJ()
      , {settings: j} = rf()
      , [T,I] = y.useState(!1)
      , E = y.useCallback((async e => {
        if (T)
            return;
        I(!0);
        const a = e.metaKey || e.ctrlKey;
        try {
            const e = await navigator.clipboard.readText()
              , [s] = X$(e);
            if (s) {
                if (s.toLowerCase() === s) {
                    const e = await K$(s, !1, !1, !1, hz.BEST_MATCH, Pd.SOLANA, []);
                    if (!e.length)
                        return I(!1),
                        void t({
                            message: pu.clipboardCouldntDetermine,
                            type: "warning"
                        }, "clipboard-check-search-failed");
                    const n = fg(e[0].chain, e[0].market.address, null);
                    if (a) {
                        const e = QE(n, nT.PASTE_CA);
                        window.open(e, "_blank")
                    } else
                        r({
                            marketId: n,
                            tradePageOrigin: nT.PASTE_CA
                        });
                    return void I(!1)
                }
                if (a) {
                    const e = XE(Pd.SOLANA, s, nT.PASTE_CA);
                    window.open(e, "_blank")
                } else
                    n({
                        tokenAddress: s,
                        chain: Pd.SOLANA,
                        tradePageOrigin: nT.PASTE_CA
                    });
                return void I(!1)
            }
            const [o] = Y$(e);
            if (!o)
                return I(!1),
                void t({
                    message: pu.clipboardCouldntDetermine,
                    type: "warning"
                }, "clipboard-check-search-failed");
            try {
                const e = await K$(o, !1, !1, !1, hz.BEST_MATCH, null, []);
                if (!e.length)
                    return I(!1),
                    void t({
                        message: pu.clipboardCouldntDetermine,
                        type: "warning"
                    }, "clipboard-check-search-failed");
                const n = fg(e[0].chain, e[0].market.address, e[0].market.protocol.type === Lc.FOUR_MEME ? {
                    type: "fourmeme",
                    tokenAddress: e[0].baseToken.address
                } : null);
                if (a) {
                    const e = QE(n, nT.PASTE_CA);
                    window.open(e, "_blank")
                } else
                    r({
                        marketId: n,
                        tradePageOrigin: nT.PASTE_CA
                    });
                I(!1)
            } catch (fNe) {
                t({
                    message: pu.unknownError,
                    type: "error"
                }, "clipboard-check-search-failed")
            }
            I(!1)
        } catch (W$e) {
            t({
                message: uu.clipboardEnableAccess,
                snackName: pu.clipboardUnavailable,
                type: "error"
            }, "clipboard-check-failed"),
            I(!1)
        }
    }
    ), [t, r, n, T])
      , M = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault()
    }
    ), [])
      , [N,P] = y.useState(null);
    k$(N && N.chain === Pd.SOLANA && N.marketId ? N.marketId : null);
    const O = y.useRef();
    y.useEffect(( () => {
        O.current = N ? N.address : null
    }
    ), [N]);
    const L = y.useRef(!1)
      , R = y.useRef(!1);
    y.useEffect(( () => {
        if (Bn)
            return;
        if (!a)
            return;
        const e = setInterval(( () => {
            R.current || navigator.clipboard && document.hasFocus() && (L.current || (L.current = !0,
            (async () => {
                try {
                    const e = await navigator.clipboard.readText();
                    if (e.length > Dhe)
                        return void P(null);
                    const [t] = X$(e)
                      , [n] = Y$(e)
                      , r = ( (e, t) => e || t ? e ? {
                        normalizedAddress: ng(e),
                        chain: Pd.SOLANA
                    } : t ? {
                        normalizedAddress: ng(t),
                        chain: Pd.BSC
                    } : null : null)(t ?? null, n ?? null);
                    if (!r)
                        return void P(null);
                    if (O.current === r.normalizedAddress)
                        return;
                    const a = await vT({
                        query: bg(r.chain, r.normalizedAddress),
                        withDeepCacheWarm: !1
                    });
                    if (!a)
                        return;
                    P({
                        address: ng(a.baseToken.address),
                        symbol: a.baseToken.symbol,
                        name: a.baseToken.name,
                        marketQuoteAddress: a.quoteToken.address,
                        quoteForExecutionAddress: loe(a).address,
                        quoteSymbol: a.quoteToken.symbol,
                        chain: a.chain,
                        marketId: fg(a.chain, a.marketAddress, a.protocol.type === Lc.FOUR_MEME ? {
                            type: "fourmeme",
                            tokenAddress: a.baseToken.address
                        } : null),
                        tokenType: a.baseToken.tokenType
                    })
                } catch (fNe) {
                    (fNe instanceof Error ? fNe.message : String(fNe)).toLowerCase().includes("permission denied") && (R.current = !0)
                } finally {
                    L.current = !1
                }
            }
            )()))
        }
        ), Rhe);
        return () => clearInterval(e)
    }
    ), [a]);
    const B = y.useCallback((e => {
        if (N)
            return 0 !== e.button || e.metaKey || e.ctrlKey ? void 0 : (e.preventDefault(),
            e.stopPropagation(),
            r({
                marketId: N.marketId,
                tradePageOrigin: nT.PASTE_CA
            }),
            !1)
    }
    ), [N, r])
      , [_,U] = y.useState(!1)
      , W = y.useCallback((async () => {
        if (!N)
            return void np.warn("Order hasn't been sent - clipboard button missing token", {
                buttonValueSol: u,
                buttonValueBsc: f,
                originWidget: Dp.PASTE_CA
            });
        const e = {
            originWidget: Dp.PASTE_CA,
            buttonValueSol: u,
            buttonValueBsc: f,
            currentClipboardToken: N
        };
        U(!0);
        try {
            switch (N.chain) {
            case Pd.SOLANA:
                {
                    if (!u)
                        return np.warn("Order hasn't been sent - clipboard button sol missing value", {
                            orderInfo: e
                        }),
                        null;
                    const t = N.marketQuoteAddress
                      , n = N.quoteForExecutionAddress;
                    await p({
                        value: u,
                        baseCurrency: N.address,
                        baseTokenType: N.tokenType,
                        poolQuoteCurrency: t,
                        quoteForExecutionCurrency: n,
                        baseSymbol: N.symbol,
                        quoteSymbol: N.quoteSymbol,
                        marketId: N.marketId,
                        padreAvatarUrl: null,
                        presetName: d,
                        originWidget: Dp.PASTE_CA,
                        exitStrategies: l.length ? l : null
                    });
                    break
                }
            case Pd.BSC:
                {
                    if (!f)
                        return np.warn("Order hasn't been sent - clipboard button bsc missing value", {
                            orderInfo: e
                        }),
                        null;
                    const t = N.marketQuoteAddress
                      , n = N.quoteForExecutionAddress;
                    await A({
                        value: f,
                        baseCurrency: N.address,
                        poolQuoteCurrency: t,
                        baseSymbol: N.symbol,
                        quoteSymbol: N.quoteSymbol,
                        marketId: N.marketId,
                        padreAvatarUrl: null,
                        presetName: b,
                        originWidget: Dp.PASTE_CA,
                        exitStrategies: x && l.length && t === n ? l : null
                    });
                    break
                }
            default:
                np.warn("Order hasn't been sent - clipboard button not available", {
                    orderInfo: e
                }),
                t({
                    message: uu.quickBuyNotAvailable,
                    type: "error"
                }, "clipboard-unsupported-quick-buy")
            }
        } catch (fNe) {
            np.error("Order hasn't been sent - exception thrown during processing order", {
                e: fNe,
                orderInfo: e
            })
        } finally {
            U(!1)
        }
    }
    ), [f, u, N, t, l, x, A, p, b, d])
      , F = y.useMemo(( () => {
        if ("Inferno" === d)
            return "Inferno";
        return ((((null == j ? void 0 : j.orderPresets) || Bx)[Pd.SOLANA] || Bx[Pd.SOLANA])[xc.BUY] || Bx[Pd.SOLANA][xc.BUY])[d] || Bx[Pd.SOLANA][xc.BUY][d]
    }
    ), [d, null == j ? void 0 : j.orderPresets])
      , H = y.useMemo(( () => ((((null == j ? void 0 : j.orderPresets) || Bx)[Pd.BSC] || Bx[Pd.BSC])[xc.BUY] || Bx[Pd.BSC][xc.BUY])[b] || Bx[Pd.BSC][xc.BUY][b]), [b, null == j ? void 0 : j.orderPresets]);
    return QC ? N && a ? v.jsxs(S, {
        direction: "row",
        children: [v.jsx(GC, {
            title: v.jsx(Ohe, {
                chain: N.chain,
                insufficientBalanceSol: i,
                insufficientBalanceBsc: m,
                presetValuesSol: F,
                presetValuesBsc: H,
                selectedWalletsAddressesSol: h,
                selectedWalletsAddressesBsc: w
            }),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    size: "xsmall",
                    variant: "secondary",
                    color: "success",
                    onClick: W,
                    disabled: _ || Y8(N.chain, !!i || !u, !!m || !f),
                    sx: Vhe,
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        children: [v.jsx(ay, {
                            color: "inherit",
                            size: _he
                        }), v.jsx(k, {
                            variant: "inherit",
                            color: "inherit",
                            children: _ ? v.jsx(J, {
                                color: "inherit",
                                size: _he
                            }) : Y8(N.chain, c, g)
                        })]
                    })
                })
            })
        }), v.jsx(V, {
            component: "a",
            href: XE(N.chain, N.address, nT.PASTE_CA),
            onClick: B,
            size: "xsmall",
            variant: "tertiary",
            sx: Hhe,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [v.jsx(By, {}), v.jsx(b_, {
                    url: IE(N.chain, N.address),
                    name: N.name,
                    chain: N.chain,
                    padreAvatarUrl: null,
                    protocolInfo: null,
                    size: Uhe,
                    alwaysShowBorder: !0,
                    hideHoverAvatar: !0,
                    alwaysShowPointer: !0
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: iu(N.symbol, 16, 2)
                })]
            })
        })]
    }) : v.jsx(GC, {
        title: T ? "" : e("Open token from clipboard"),
        children: v.jsx(C, {
            component: "span",
            children: v.jsx(V, {
                disabled: T,
                size: "xsmall",
                onClick: E,
                onMouseDown: M,
                variant: "tertiary",
                sx: Fhe,
                children: T ? v.jsx(J, {
                    size: Whe,
                    color: "inherit"
                }) : v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    children: [v.jsx(C, {
                        display: "flex",
                        children: v.jsx(By, {
                            size: Bhe,
                            color: o.palette.text.value
                        })
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        lineHeight: "16px",
                        children: s ? e("Paste CA") : "CA"
                    })]
                })
            })
        })
    }) : null
}
))
  , Rhe = 100
  , Dhe = 2e3
  , Bhe = 20
  , _he = 16
  , Uhe = 14
  , Whe = 16
  , Fhe = {
    px: 1,
    py: 0,
    gat: .5,
    borderRadius: "16px",
    borderColor: "transparent",
    "&:hover": {
        borderColor: "transparent"
    }
}
  , Vhe = {
    display: "flex",
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    borderTopLeftRadius: "16px",
    borderBottomLeftRadius: "16px",
    pr: 1,
    pl: .5,
    minWidth: 56,
    borderColor: "transparent",
    "&.Mui-disabled": {
        borderColor: "transparent",
        borderRight: "1px solid transparent",
        cursor: "help",
        pointerEvents: "auto"
    },
    "&:hover": {
        borderColor: "transparent"
    }
}
  , Hhe = e => ({
    borderTopRightRadius: "16px",
    borderBottomRightRadius: "16px",
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0,
    pl: 1,
    pr: 1.5,
    borderColor: "transparent",
    borderLeft: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        borderColor: "transparent",
        borderLeft: `1px solid ${e.palette.background.borderMain}`
    }
})
  , zhe = (e, t, n) => t === rg.INDIGO ? "#06070B" : n === Xh.INDIGO ? Gt(e.palette.background.primary, .55) : e.palette.background.primary
  , $he = ({isOpen: e, onClose: t, anchor: n="right", backgroundColor: r="background.secondary", width: a="min(100vw, 324px)", height: s="100%", children: o}) => {
    const l = lxe()
      , i = y.useMemo(( () => ({
        border: e => `1px solid ${e.palette.background.borderMain}`,
        borderTop: {
            md: 0
        },
        borderBottom: 0,
        ["right" === n ? "borderRight" : "borderLeft"]: 0
    })), [n])
      , c = y.useMemo(( () => ({
        "&.MuiDrawer-root .MuiDrawer-paper": {
            marginTop: l - 2 + "px"
        }
    })), [l]);
    return v.jsx(_n, {
        disableEnforceFocus: !0,
        disableRestoreFocus: !0,
        variant: "temporary",
        anchor: n,
        open: e,
        onClose: t,
        PaperProps: {
            sx: {
                background: r,
                backgroundImage: "none",
                height: `calc(${s} - ${l - 2}px)`
            }
        },
        slotProps: {
            backdrop: {
                sx: {
                    mt: l - 2 + "px",
                    height: `calc(100% - ${l - 2}px)`
                }
            }
        },
        sx: c,
        children: v.jsx(S, {
            className: "padre-no-scroll",
            width: a,
            height: s,
            overflow: "auto",
            ...i,
            children: o
        })
    })
}
  , Ghe = () => {
    const {user: e} = VK()
      , [t,n] = y.useState();
    return y.useEffect(( () => {
        (async () => {
            const t = await sf((null == e ? void 0 : e.uid) || "", af);
            n(t)
        }
        )()
    }
    ), [null == e ? void 0 : e.uid]),
    t
}
  , qhe = new Set(["ce1290364ae0e51a526dec1a0f63e27a96756d57a6a7b3ebfa88d94f73d6c368", "409fcb2f8715aebbca86b0f54da3b66a1adbbd03e112381f47d137600e2be4c3", "642a1e25a7ed93e028cb7f30916f253f49f26a950e5d5a147ac7bfd32c7f652c", "52be2de64e1a83b8c9eb7b7f49833efe40c06e5b0f54e9236d34b01d15f2be0b", "b585360bdd4192e656c4e2e0fde94d775a3fe3b37f8d386530f9476e42e8945e", "8aa5d6cecd43b1dc961c705352c153829fdb9f7f6ed3a653ff47b16ab4567322", "2b4d8be67683f9f12f3d5e0e1b168ae9e6a2201478cfbe7ae90c6f4c56c2d5a2", "1be74af1fba67e610f71f454ba112efbc3431029d2951ef09674a6f859e9b207", "8873f4eea4634ad72b960a901c7d47fe2f1dcd19e42fccf4b36fb0ab214a2d1b", "63d0dc8680f09de2c6aaa72d2d8c65fa706482f85ded4b0dcb3f4d7b25445e8f", "ba59ac76dfbeda9420bd509dfcce1686a6504b18ea7fae6931371787f54ea58b", "d28b125a1d028692a8986a22c20ca99a7c92e734e3192ccc30f20e7de8151b49", "1fa28a405f03a1b1149b682c648390ee866147a7e6828f3e9d8bc651e24bd06d", "c44c74d89a0414ae038cc1a11f411f9fcffd5b96e8e83b101d49ed2cc95bd120", "d0a3fe8b124ace78d8d15a7bd00c27bc07c34ae6ca613206c547b4f2fc19a665", "5ea0e1808ff48cc0edbdf80ccbe6de84fad3fb733711079d80315091ae9daefe", "3fcffbf5dd27d1ac02f9d457ef7ea744a4a5dff3e97ae072e691351b27965abd", "c576454f8aa774aed45efebc3396ffa0522d214774d655a7439b61e0d8f85c1c", "fdbc1e737ce3470e9031ade814be1211137f9aaddb6934c916b6e37b84bad8ba", "f0d5ed992f4fbd0afd102e6a07827e88a6cd088bb87d038acd9972dfee6c7bda", "3f18226f35090a2311559b269e149fad1d039da6cac40e941d7d856e663c4aeb", "7008cb7144e95e5a0b1e62b4779911316c35a7ecd353aca30468f60c9a7882d6", "c3e1059eff81b7b44ab971b205cb57a5fb6614f5571e5060b3f7bff21424ca01", "c54a474ad828a24b0bbcc3c8a77e5b0ee1e97bcab1dd599fb31401a32576d93e", "4ca5c8bc8ed4febfd96fd24255507ced8ca973343273f1d3e0a23e23fe0ac37c", "87816e0466003cd09e49de6411ce17b4171993ea3f3365e70224ba2340a5d5e8", "10681387e659d6d7899176ac4b21481d1a3c1fe619a365870ad805d4a1182c5e", "d82dcbf8fab108242b087a8b194cf37f0660f23a4130f78842622721656b9c70"])
  , Khe = y.memo(( ({label: e, grayOut: t=!1}) => v.jsx(C, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    sx: e => ({
        minWidth: Yhe,
        minHeight: Yhe,
        backgroundColor: t ? e.palette.background.borderMain : e.palette.primary.background,
        borderRadius: 1,
        p: .5
    }),
    children: v.jsx(k, {
        variant: "labelSmall",
        color: t ? "text.label" : "primary.main",
        children: e
    })
})))
  , Yhe = 24
  , Xhe = e => ({
    color: "text.label",
    bgcolor: "background.secondary",
    border: `1px solid ${e.palette.background.borderMain}`,
    boxShadow: "none",
    ":first-of-type": {
        borderTopLeftRadius: Qhe,
        borderTopRightRadius: Qhe
    },
    ":last-child": {
        borderBottomLeftRadius: Qhe,
        borderBottomRightRadius: Qhe
    },
    "&.Mui-disabled": {
        bgcolor: "background.secondary"
    }
})
  , Qhe = "4px"
  , Zhe = ({Icon: e, IconComponent: t, showIconBg: n=!1, iconColor: r=!0, name: a, nameTypographyOverrides: s={}, indicator: o, grayOutIndicator: l, onClick: i, onAccordionExpand: c, setIsExpandedState: d, hideExpandIcon: u=!1, disabled: p=!1, initiallyOpen: h=!1, children: m}) => {
    const g = D()
      , [x,b] = y.useState(h)
      , f = y.useCallback(( () => {
        b((e => !e))
    }
    ), []);
    y.useEffect(( () => {
        d && d(x)
    }
    ), [x, d]),
    y.useEffect(( () => {
        x && c && c()
    }
    ), [x, c]);
    const C = y.useMemo(( () => u ? void 0 : i ? v.jsx(Cy, {
        size: 18
    }) : v.jsx(Sy, {
        size: 18
    })), [u, i])
      , A = y.useMemo(( () => ({
        backgroundColor: n ? g.palette.primary.background : "none",
        borderRadius: "50%"
    })), [n, g.palette.primary.background]);
    return v.jsxs(Un, {
        disabled: p,
        disableGutters: !0,
        expanded: x,
        onChange: i ?? f,
        sx: Xhe,
        children: [v.jsx(Wn, {
            sx: m && !i ? Jhe : eme,
            expandIcon: C,
            children: v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                width: "100%",
                height: "100%",
                children: [v.jsxs(S, {
                    direction: "row",
                    width: "100%",
                    gap: 1,
                    alignItems: "center",
                    children: [v.jsx(S, {
                        direction: "row",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        minWidth: n ? 32 : 18,
                        width: n ? 32 : 18,
                        height: n ? 32 : 18,
                        style: A,
                        children: t ?? v.jsx(e, {
                            ...r ? {
                                color: p ? g.palette.text.disabled : g.palette.primary.main
                            } : {},
                            size: 18
                        })
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...s,
                        noWrap: !0,
                        children: a
                    })]
                }), v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    mr: .5,
                    children: o && v.jsx(Khe, {
                        label: o,
                        grayOut: l
                    })
                })]
            })
        }), m && v.jsx(Fn, {
            sx: tme,
            children: m
        })]
    })
}
  , Jhe = e => ({
    px: 1.5,
    "&:hover": {
        background: e.palette.background.hover
    }
})
  , eme = {
    px: 1.5,
    "& .MuiAccordionSummary-content, & .MuiAccordionSummary-expandIconWrapper": {
        cursor: "default"
    }
}
  , tme = {
    py: 1,
    px: 1.5,
    pt: 0
}
  , nme = ({user: e, onClick: t}) => {
    const {t: n} = we()
      , [r,a] = Mx("padreV2-userUidAnonimize", !1)
      , s = y.useCallback((e => {
        e.stopPropagation(),
        a((e => !e)),
        t && t()
    }
    ), [a, t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        width: "100%",
        children: [v.jsxs(S, {
            children: [v.jsx(lA, {
                showContent: !r,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    noWrap: !0,
                    maxWidth: rme,
                    height: 14,
                    children: e.email || e.displayName
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    mt: .25,
                    children: "ID:"
                }), v.jsx(cA, {
                    labelSx: lme,
                    address: e.uid,
                    stopPropagation: !0,
                    containerSx: ime,
                    copyIconSize: ame,
                    anonimize: r
                })]
            })]
        }), v.jsx(GC, {
            title: n(r ? "Show sensitive info" : "Hide sensitive info"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(F, {
                    onClick: s,
                    sx: ome,
                    children: r ? v.jsx(Ek, {
                        size: sme
                    }) : v.jsx(Tk, {
                        size: sme
                    })
                })
            })
        })]
    })
}
  , rme = 200
  , ame = 14
  , sme = 14
  , ome = {
    p: 0
}
  , lme = {
    fontSize: "10px",
    color: "text.label"
}
  , ime = {
    py: .25,
    alignItems: "flex-end",
    color: "text.label"
}
  , cme = ({text: e}) => v.jsx(C, {
    display: "flex",
    sx: dme,
    children: v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        sx: ume,
        children: e
    })
})
  , dme = e => ({
    backgroundColor: e.palette.background.buttonDefault,
    borderRadius: 1,
    py: 1,
    px: 1.5
})
  , ume = {
    width: "100%"
}
  , pme = () => {
    const {t: e} = we();
    return v.jsxs(S, {
        gap: 2,
        children: [v.jsx(cme, {
            text: e("Get help, share feedback and be the first to know about all updates")
        }), v.jsx(cme, {
            width: "100%",
            text: v.jsxs(S, {
                gap: .5,
                width: "100%",
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    textAlign: "center",
                    children: e("Or chat to our support")
                }), v.jsx(V, {
                    variant: "tertiary",
                    fullWidth: !0,
                    endIcon: v.jsx(PS, {
                        color: "inherit"
                    }),
                    href: LC,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    size: "xsmall",
                    children: e("Discord Support")
                })]
            })
        })]
    })
}
  , hme = () => {
    const {t: e} = we()
      , t = Ax()
      , n = PA({
        refreshRate: 1e3,
        immediateRunAfterPageBecomesVisible: !0
    })
      , [r,a] = y.useState({
        status: ox.INITIAL
    })
      , [s,o] = y.useState(0)
      , l = y.useCallback(( () => {
        o((e => e + 1))
    }
    ), [o]);
    if (y.useEffect(( () => {
        if (!t || !s)
            return;
        let e = !1;
        return (async () => {
            try {
                a({
                    status: ox.LOADING
                });
                const n = await tm.generateOtp({
                    uid: t
                });
                if (e)
                    return;
                a({
                    status: ox.READY,
                    data: n
                })
            } catch (W$e) {
                if (e)
                    return;
                a({
                    status: ox.ERROR
                })
            }
        }
        )(),
        () => {
            e = !0
        }
    }
    ), [t, s]),
    r.status === ox.ERROR)
        return v.jsx(pQ, {
            message: e("Something went wrong")
        });
    const i = r.status === ox.READY ? r.data.expiresAt - n.unix() : 0
      , c = i && i > 59 ? `${Math.floor(i / 60)}m ${i % 60}s` : `${i}s`
      , d = r.status === ox.READY ? `${window.location.protocol}//${window.location.hostname}/?otp=${r.data.otp}` : "";
    return v.jsx(S, {
        gap: .5,
        pt: 1,
        children: i > 0 && d ? v.jsxs(S, {
            display: "flex",
            flexDirection: "column",
            alignContent: "center",
            justifyContent: "center",
            flexGrow: 1,
            width: "100%",
            children: [v.jsx(k, {
                noWrap: !0,
                color: "text.secondary",
                variant: "labelLarge",
                textAlign: "center",
                children: i > 0 ? e("Code expires in {{time}}", {
                    time: c
                }) : e("Generate new QR code")
            }), v.jsx(C, {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                py: 5,
                sx: {
                    background: "white"
                },
                children: v.jsx(Vn, {
                    value: d,
                    size: 200
                })
            })]
        }) : v.jsx(V, {
            size: "small",
            onClick: l,
            variant: "secondary",
            disabled: r.status === ox.LOADING,
            children: e("Show QR Code")
        })
    })
}
  , mme = () => {
    window.open(DC, "_blank")
}
  , gme = () => {
    window.open("https://padre.gg/tos", "_blank")
}
  , xme = e => "kol" === e.type ? {
    type: "kol",
    kolName: e.kolName,
    lastUpdateTs: e.lastUpdateTs,
    totalTradingUsers: e.totalTradingUsers,
    totalSignUps: e.totalSignUps,
    availableRewardsInUsd: e.availableRewardsInUsd,
    lastTradeTs: e.lastTradeTs,
    totalTradesMade: e.totalTradesMade
} : {
    type: "regular",
    refCode: e.refCode,
    lastUpdateTs: e.lastUpdateTs,
    totalTradingUsers: e.totalTradingUsers,
    totalSignUps: e.totalSignUps,
    volumeInUsd: e.volumeInUsd,
    availableRewardsInUsd: e.availableRewardsInUsd
}
  , bme = ({isOpen: e, onClose: t}) => {
    const {t: n} = we()
      , r = D()
      , a = xw()
      , s = bw()
      , o = Ghe()
      , l = ( () => {
        const {user: e} = VK()
          , [t,n] = y.useState();
        return y.useEffect(( () => {
            (async () => {
                const t = await sf((null == e ? void 0 : e.uid) || "", qhe);
                n(t)
            }
            )()
        }
        ), [null == e ? void 0 : e.uid]),
        t
    }
    )()
      , i = F5()
      , {openModal: c} = q6()
      , {user: d, loading: u, initSignOut: p} = VK()
      , {watched: h} = p$()
      , {openModal: m} = y.useContext(Xpe)
      , {openOverviewModal: g} = Iue()
      , x = y.useCallback(( () => {
        g(),
        a || t()
    }
    ), [t, a, g])
      , b = y.useCallback(( () => {
        c(H6.SETTINGS)
    }
    ), [c])
      , f = y.useCallback(( () => {
        c(H6.WATCHLIST)
    }
    ), [c])
      , k = cT()
      , A = y.useCallback(( () => {
        p(k),
        t()
    }
    ), [p, k, t])
      , w = y.useCallback(( () => {
        const e = null == d ? void 0 : d.uid;
        e && (ym.updateSettings(e, {
            syncedLocalStorage: {}
        }).then(( () => localStorage.clear())).catch((t => {
            np.error("Failed to clear user's local cache", {
                uid: e,
                err: t
            })
        }
        )),
        t())
    }
    ), [d, t])
      , j = ( () => {
        const e = me()
          , [t] = xe();
        return y.useCallback(( ({navigationOptions: n, keepSearchParams: r}) => {
            e({
                pathname: `${tT.REWARDS}`,
                search: r ? t.toString() : ""
            }, n)
        }
        ), [e, t])
    }
    )()
      , T = y.useCallback(( () => {
        j({}),
        t()
    }
    ), [j, t])
      , {toggleAlphaTrackerWidget: I} = J6()
      , E = y.useCallback(( () => {
        I(),
        t()
    }
    ), [t, I])
      , {openModal: M} = dpe()
      , [N,P] = y.useState(0)
      , O = y.useCallback(( () => {
        P((e => e + 1))
    }
    ), [])
      , L = y.useMemo(( () => d ? v.jsx(nme, {
        user: d,
        onClick: O
    }) : null), [d, O]);
    return v.jsx($he, {
        isOpen: e,
        onClose: t,
        children: u ? null : L ? v.jsxs(S, {
            ...fme,
            position: "relative",
            flexGrow: 1,
            children: [v.jsx(Zhe, {
                Icon: $S,
                showIconBg: !0,
                name: L,
                nameTypographyOverrides: yme,
                hideExpandIcon: !0
            }), v.jsx(S, {
                children: v.jsx(Zhe, {
                    Icon: KS,
                    name: n("Sign in on mobile"),
                    children: v.jsx(hme, {})
                })
            }), v.jsxs(S, {
                children: [!s && v.jsx(Zhe, {
                    Icon: ny,
                    name: n("Rewards"),
                    onClick: T
                }), !a && v.jsx(Zhe, {
                    Icon: dy,
                    name: n("Watchlist"),
                    onClick: f,
                    indicator: h.length.toString(),
                    grayOutIndicator: !0
                }), v.jsx(Zhe, {
                    Icon: Ey,
                    name: n("Price Alerts"),
                    onClick: x
                }), v.jsx(Zhe, {
                    Icon: bS,
                    name: n("What's new"),
                    onClick: m
                }), !a && v.jsx(Zhe, {
                    Icon: Lk,
                    name: n("News"),
                    onClick: M
                }), !a && v.jsx(Zhe, {
                    Icon: uy,
                    name: n("Alpha Tracker"),
                    onClick: E
                })]
            }), v.jsxs(S, {
                children: [!s && v.jsx(Zhe, {
                    Icon: Ny,
                    name: n("Preferences"),
                    onClick: b
                }), v.jsx(Zhe, {
                    Icon: IS,
                    name: n("Support"),
                    children: v.jsx(pme, {})
                }), v.jsx(Zhe, {
                    Icon: HS,
                    name: n("Privacy Policy"),
                    onClick: mme
                }), v.jsx(Zhe, {
                    Icon: HS,
                    name: n("Terms of Service"),
                    onClick: gme
                }), N >= 6 && v.jsx(Zhe, {
                    Icon: wS,
                    IconComponent: v.jsx(wS, {
                        color: r.palette.error.main,
                        size: 18
                    }),
                    name: n("Reset Local Cache"),
                    nameTypographyOverrides: {
                        color: "error.main"
                    },
                    onClick: w,
                    hideExpandIcon: !0
                }), v.jsx(Zhe, {
                    Icon: FS,
                    name: n("Sign out"),
                    onClick: A,
                    hideExpandIcon: !0
                })]
            }), l && v.jsx(C, {
                position: "absolute",
                bottom: 4,
                right: 4,
                sx: Sme,
                children: v.jsx(WS, {
                    size: vme
                })
            }), o && v.jsx(C, {
                position: "absolute",
                bottom: 4,
                right: 16,
                sx: Sme,
                children: v.jsx(WS, {
                    size: vme
                })
            }), i && v.jsx(C, {
                position: "absolute",
                bottom: 4,
                right: 28,
                sx: Sme,
                children: v.jsx(WS, {
                    size: vme
                })
            })]
        }) : v.jsx(S, {
            ...fme,
            children: v.jsx(Zhe, {
                Icon: $S,
                name: n("Login"),
                onClick: k,
                hideExpandIcon: !0
            })
        })
    })
}
  , fme = {
    p: 1.5,
    gap: 1.5
}
  , vme = 10
  , Sme = {
    opacity: .2,
    display: "flex",
    alignItems: "center"
}
  , yme = {
    sx: {
        width: "100%",
        display: "flex",
        height: 40,
        my: -.5,
        pl: .5,
        ml: -.5
    }
};
var kme = (e => (e.OPEN_POSITIONS = "OPEN_POSITIONS",
e.RECENT = "RECENT",
e.WATCHLIST = "WATCHLIST",
e))(kme || {})
  , Cme = (e => (e.LAST_ACTIVITY = "LAST ACTIVITY",
e.PNL_PERCENTAGE = "PNL PERCENTAGE",
e.SIZE = "SIZE",
e))(Cme || {})
  , Ame = (e => (e.SYMBOL = "SYMBOL",
e.MARKET_CAP = "MARKET CAP",
e.PRICE = "PRICE",
e))(Ame || {});
const wme = (e, t) => {
    if ("init" === t.type)
        return {
            allEntries: t.snapshot.allEntries.filter((e => TD(_p(e))))
        };
    const [n,r,a] = t.update
      , s = new Map((null == e ? void 0 : e.allEntries.map((e => [Bp(e), e]))) ?? []);
    n.forEach((e => {
        TD(_p(e)) && s.set(Bp(e), e)
    }
    )),
    r.forEach((e => {
        const t = Bp(e)
          , n = s.get(t);
        n && s.set(t, ( (e, t) => {
            const [n,r,...a] = t
              , [s,...o] = e;
            if (n !== s)
                return e;
            let l = 0;
            const i = [...o];
            for (let c = 0; c < o.length; c++)
                r & 1 << c && (i[c] = a[l++]);
            return [s, ...i]
        }
        )(n, e))
    }
    )),
    a.forEach((e => {
        s.delete(e)
    }
    ));
    return {
        allEntries: Array.from(s.values())
    }
}
  , jme = e => {
    switch (e) {
    case Cme.PNL_PERCENTAGE:
        return "unrealizedPnl";
    case Cme.LAST_ACTIVITY:
        return "recent";
    case Cme.SIZE:
        return "usdValue"
    }
}
;
function Tme(e, t, n=P) {
    const r = y.useRef(null)
      , a = y.useRef(new Map);
    if (!e)
        return r.current = null,
        a.current = new Map,
        null;
    const s = r.current
      , o = a.current;
    if (!s) {
        r.current = e.slice();
        const n = new Map;
        for (const e of r.current)
            n.set(t(e), e);
        return a.current = n,
        r.current
    }
    const l = s;
    l.length = e.length;
    const i = new Map;
    for (let c = 0; c < e.length; c++) {
        const r = e[c]
          , a = t(r)
          , s = o.get(a);
        s && n(s, r) ? (l[c] = s,
        i.set(a, s)) : (l[c] = r,
        i.set(a, r))
    }
    return a.current = i,
    l
}
const Ime = [kme.RECENT, kme.OPEN_POSITIONS, kme.WATCHLIST]
  , Eme = {
    [kme.OPEN_POSITIONS]: "Positions",
    [kme.RECENT]: "Recent",
    [kme.WATCHLIST]: "Watchlist"
}
  , Mme = {
    [kme.RECENT]: e => v.jsx(mf, {
        icon: Ho,
        isStroke: !0,
        ...e
    }),
    [kme.OPEN_POSITIONS]: e => v.jsx(mf, {
        icon: zo,
        isStroke: !0,
        ...e
    }),
    [kme.WATCHLIST]: dy
}
  , Nme = kme.RECENT
  , Pme = [Cme.LAST_ACTIVITY, Cme.PNL_PERCENTAGE, Cme.SIZE]
  , Ome = {
    [Cme.LAST_ACTIVITY]: "Last Activity",
    [Cme.PNL_PERCENTAGE]: "PNL %",
    [Cme.SIZE]: "Size"
}
  , Lme = Cme.LAST_ACTIVITY
  , Rme = m6.DESC
  , Dme = Ame.MARKET_CAP
  , Bme = m6.DESC
  , _me = [Ame.MARKET_CAP, Ame.PRICE, Ame.SYMBOL]
  , Ume = {
    [Ame.MARKET_CAP]: "Market Cap",
    [Ame.PRICE]: "Price",
    [Ame.SYMBOL]: "Symbol"
}
  , Wme = -10
  , Fme = "bottom"
  , Vme = y.memo(( ({chain: e, size: t=Hme, extraMargin: n=!1, color: r}) => {
    const a = e === Pd.SOLANA ? dk : e === Pd.BSC ? ak : Ay;
    return v.jsx(C, {
        width: t,
        height: t,
        mt: n ? "-2px" : "-1px",
        children: v.jsx(a, {
            size: t,
            color: r
        })
    })
}
))
  , Hme = 15
  , zme = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    const r = e ? t === uZ.USD ? e.valueUsd : e.valueNative : null;
    return e && null !== r ? v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsx(S, {
            gap: .5,
            alignItems: "flex-end",
            children: v.jsxs(k, {
                variant: "monospace1",
                sx: {
                    gap: .25,
                    display: "flex",
                    alignItems: "center"
                },
                height: 15,
                children: [LI(r, {
                    symbol: t === uZ.USD ? "$" : "",
                    collapseExponent: !0,
                    maxPrecision: t === uZ.USD ? 2 : 3,
                    padSymbol: !1,
                    symbolPosition: yI.START
                }), t === uZ.NATIVE && v.jsx(Vme, {
                    chain: e.chain
                })]
            })
        })
    }) : v.jsx(CQ, {})
}
))
  , $me = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    if (!e)
        return v.jsx(CQ, {});
    const r = t === uZ.USD ? e.costUsd : e.costNative;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsxs(k, {
            variant: "monospace1",
            color: "text.value",
            sx: {
                display: "flex",
                alignItems: "center",
                gap: .25
            },
            children: [null === r ? Ud : LI(r, {
                collapseExponent: !0,
                symbol: t === uZ.USD ? "$" : "",
                padSymbol: !1,
                symbolPosition: yI.START
            }), t === uZ.NATIVE && null !== r && v.jsx(Vme, {
                chain: e.chain
            })]
        })
    })
}
))
  , Gme = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    const r = D();
    if (!e)
        return v.jsx(CQ, {});
    const a = t === uZ.USD ? e.unrealizedPnlUsd : e.unrealizedPnlNative;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsxs(S, {
            gap: .25,
            direction: "row",
            alignItems: "center",
            height: 15,
            children: [e.wasExternallyTraded ? v.jsx(k, {
                variant: "monospace1",
                children: Ud
            }) : v.jsx(RZ, {
                value: a || 0,
                formattedDisplay: a ? OI(a, {
                    collapseExponent: !0,
                    symbol: t === uZ.USD ? "$" : "",
                    precision: t === uZ.USD ? 2 : 3
                }) : Ud,
                variant: "monospace1"
            }), t === uZ.NATIVE && !!a && v.jsx(Vme, {
                chain: e.chain,
                color: a > 0 ? r.palette.success.main : r.palette.negative.main
            })]
        })
    })
}
))
  , qme = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    const r = e ? t === uZ.USD ? e.soldUsd : null == e ? void 0 : e.soldNative : null;
    return e && null !== r ? v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsxs(k, {
            variant: "monospace1",
            color: "text.primary",
            children: [LI(r, {
                collapseExponent: !0,
                symbol: t === uZ.USD ? "$" : "",
                padSymbol: !1,
                symbolPosition: yI.START
            }), t === uZ.NATIVE && null !== r && v.jsx(Vme, {
                chain: e.chain,
                extraMargin: !0
            })]
        })
    }) : v.jsx(CQ, {})
}
))
  , Kme = ({tokenAddress: e, chain: t, isVisibleWhileShown: n, iconSize: r=16}) => {
    const {t: a} = we()
      , {hiddenPairs: s, showPair: o, hidePair: l} = SX()
      , i = y.useMemo(( () => !!s && !!s[kX(e, t)]), [t, s, e])
      , c = i ? Ek : Tk
      , d = y.useCallback((n => {
        n.stopPropagation(),
        n.preventDefault(),
        i ? o(e, t) : l(e, t)
    }
    ), [t, l, i, o, e]);
    return v.jsx(C, {
        children: (n || i) && v.jsx(GC, {
            title: a(i ? "Show" : "Hide"),
            children: v.jsx(F, {
                onClick: d,
                sx: Yme,
                children: v.jsx(c, {
                    size: r,
                    color: "inherit"
                })
            })
        })
    })
}
  , Yme = {
    p: 1
}
  , Xme = y.memo(( ({portfolioDisplayData: e, ...t}) => {
    const {userStats: n} = rH()
      , r = y.useMemo(( () => {
        if (!e)
            return !1;
        const t = ng(e.tokenAddress);
        return !(ru(t) || t === Fd)
    }
    ), [e]);
    if (!e || n.status !== ox.READY)
        return null;
    const a = !e.wasExternallyTraded && e.investedUsd && null !== e.totalPnlUsd ? {
        symbol: e.tokenSymbol || "",
        chain: e.chain,
        profitAmount: e.totalPnlUsd,
        profitNative: e.totalPnlNative,
        profitPercentage: e.totalPnlPercentageUsd || 0,
        investedAmount: e.investedUsd,
        investedNative: e.investedNative,
        remainingNative: e.valueNative,
        remainingAmount: e.valueUsd ?? 0,
        refCode: "kol" === n.data.type ? n.data.kolName : null,
        holdTime: e.holdTime,
        multiplier: ((e.totalPnlPercentageUsd || 0) / 100 + 1).toFixed((e.totalPnlPercentageUsd || 0) / 100 + 1 > .1 ? 2 : 4)
    } : null;
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            ...t.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsxs(S, {
            direction: "row",
            gap: .5,
            children: [a && v.jsx(i4, {
                imageData: a
            }), r && v.jsx(Kme, {
                tokenAddress: e.tokenAddress,
                chain: e.chain,
                isVisibleWhileShown: !0,
                buttonLike: !0
            })]
        })
    })
}
))
  , Qme = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    if (!e)
        return v.jsx(CQ, {});
    const r = t === uZ.USD ? e.pnlPercentageUsd : e.pnlPercentageNative;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: e.wasExternallyTraded || null === r ? v.jsx(k, {
            variant: "monospace1",
            children: Ud
        }) : v.jsx(RZ, {
            value: r,
            formattedDisplay: r ? jI(r, {
                collapseExponent: !0
            }) : Ud,
            variant: "monospace1"
        })
    })
}
))
  , Zme = y.memo(( ({portfolioDisplayData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        ...t.sxProps,
        justifyContent: "flex-end",
        alignItems: "center"
    },
    children: v.jsx(k, {
        variant: "monoRegular",
        color: "text.primary",
        children: null === e.holdingAmount ? Ud : LI(e.holdingAmount, {
            collapseExponent: !0,
            symbol: ""
        })
    })
}) : v.jsx(CQ, {})))
  , Jme = y.memo(( ({portfolioDisplayData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        ...t.sxProps,
        justifyContent: "flex-end",
        alignItems: "center"
    },
    children: v.jsx(S, {
        gap: .5,
        alignItems: "flex-end",
        children: v.jsx(mE, {
            isShort: !0,
            ts: e.lastActivityTs ?? null,
            variant: "monoRegular",
            sx: ege,
            lineHeight: 1
        })
    })
}) : v.jsx(CQ, {})))
  , ege = {
    gap: .75,
    display: "flex",
    alignItems: "center"
}
  , tge = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    const r = D();
    if (!e)
        return v.jsx(CQ, {});
    const a = t === uZ.USD ? e.totalPnlUsd : e.totalPnlNative;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: v.jsxs(S, {
            gap: .25,
            direction: "row",
            height: 15,
            alignItems: "center",
            children: [e.wasExternallyTraded ? v.jsx(k, {
                variant: "monospace1",
                children: Ud
            }) : v.jsx(RZ, {
                value: a || 0,
                formattedDisplay: a ? OI(a, {
                    collapseExponent: !0,
                    symbol: t === uZ.USD ? "$" : "",
                    precision: t === uZ.USD ? 2 : 3
                }) : Ud,
                variant: "monospace1"
            }), t === uZ.NATIVE && !!a && v.jsx(Vme, {
                extraMargin: !0,
                chain: e.chain,
                color: a > 0 ? r.palette.success.main : r.palette.negative.main
            })]
        })
    })
}
))
  , nge = y.memo(( ({portfolioDisplayData: e, currencyMode: t, ...n}) => {
    if (!e)
        return v.jsx(CQ, {});
    const r = t === uZ.USD ? e.totalPnlPercentageUsd : e.totalPnlPercentageNative;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            ...n.sxProps,
            justifyContent: "flex-end",
            alignItems: "center"
        },
        children: e.wasExternallyTraded || null === r ? v.jsx(k, {
            variant: "monospace1",
            children: Ud
        }) : v.jsx(RZ, {
            value: r,
            formattedDisplay: r ? jI(r, {
                collapseExponent: !0
            }) : Ud,
            variant: "monospace1"
        })
    })
}
));
var rge = (e => (e.OVERVIEW = "Overview",
e.OPEN_POSITIONS = "OpenPositions",
e.CLOSED_POSITIONS = "ClosedPosition",
e.TRADES = "Trades",
e.ORDERS = "Orders",
e))(rge || {})
  , age = (e => (e.PERCENT = "Percent",
e.DURATION = "Duration",
e.USD = "Usd",
e))(age || {});
const sge = "padreV2-portfolioWalletsStorageKey"
  , oge = e => ({
    ...sZ(e),
    headerClass: lY,
    minWidth: 72
})
  , lge = e => {
    const t = ng(e);
    return !(!ru(t) && t !== Fd)
}
  , ige = e => {
    if (e && !lge(e.tokenAddress))
        return XE(e.chain, e.tokenAddress, nT.PORTFOLIO)
}
  , cge = ({key: e, isDesktop: t, isOpen: r, currencyMode: a, onNativeMarketRowClick: s}) => {
    switch (e) {
    case "tokenSymbol":
        return {
            ...oge(e),
            headerName: n.t("Asset"),
            cellRenderer: e => e.data ? v.jsx(EQ, {
                tokenAddress: e.data.tokenAddress,
                tokenSymbol: e.data.tokenSymbol,
                tokenName: e.data.tokenName || void 0,
                chain: e.data.chain,
                tokenSocials: null,
                deployer: null,
                forceSmall: !0,
                ...e,
                href: ige(e.data),
                onRowClick: lge(e.data.tokenAddress) ? s : void 0
            }) : v.jsx(CQ, {}),
            headerClass: void 0,
            pinned: t || !r ? null : "left",
            valueGetter: ({data: e}) => e ? `${e.tokenSymbol}-${e.tokenAddress}-${e.tokenName}-${e.chain}` : void 0,
            flex: t ? 1.5 : 1,
            minWidth: 87,
            maxWidth: t || !r ? void 0 : 130
        };
    case "holdingAmount":
        return {
            ...oge(e),
            headerName: n.t("Amount"),
            cellRenderer: e => {
                var t;
                return v.jsx(Zme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => e.holdingAmount ?? null))
        };
    case "costUsd":
        return {
            ...oge(e),
            headerName: n.t("Cost"),
            cellRenderer: e => {
                var t;
                return v.jsx($me, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => a === uZ.USD ? e.costUsd ?? null : e.costNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.costUsd : e.costNative}-${e.tokenAddress}` : void 0
        };
    case "valueUsd":
        return {
            ...oge(e),
            headerName: n.t("Remaining"),
            cellRenderer: e => {
                var t;
                return v.jsx(zme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            minWidth: 85,
            comparator: lZ((e => a === uZ.USD ? e.valueUsd ?? null : e.valueNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.valueUsd : e.valueNative}-${e.tokenAddress}` : void 0
        };
    case "soldUsd":
        return {
            ...oge(e),
            headerName: n.t("Sold"),
            cellRenderer: e => {
                var t;
                return v.jsx(qme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => a === uZ.USD ? e.soldUsd ?? null : e.soldNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.soldUsd : e.soldNative}-${e.tokenAddress}` : void 0
        };
    case "unrealizedPnlUsd":
        return {
            ...oge(e),
            headerName: n.t("PNL"),
            cellRenderer: e => {
                var t;
                return v.jsx(Gme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => e.wasExternallyTraded ? null : a === uZ.USD ? e.unrealizedPnlUsd ?? null : e.unrealizedPnlNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.unrealizedPnlUsd : e.unrealizedPnlNative}-${e.tokenAddress}-${e.wasExternallyTraded}` : void 0
        };
    case "totalPnlUsd":
        return {
            ...oge(e),
            headerName: n.t("PNL"),
            cellRenderer: e => {
                var t;
                return v.jsx(tge, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                  href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => e.wasExternallyTraded ? null : a === uZ.USD ? e.totalPnlUsd ?? null : e.totalPnlNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.totalPnlUsd : e.totalPnlNative}-${e.tokenAddress}-${e.wasExternallyTraded}` : void 0
        };
    case "pnlPercentageUsd":
        return {
            ...oge(e),
            headerName: n.t("PNL %"),
            headerComponent: qQ,
            headerComponentParams: {
                tooltipTitle: n.t("% values may vary depending on the currency denomination, as exchange rates between USD and native currencies fluctuate.")
            },
            cellRenderer: e => {
                var t;
                return v.jsx(Qme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => e.wasExternallyTraded ? null : a === uZ.USD ? e.pnlPercentageUsd ?? null : e.pnlPercentageNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.pnlPercentageUsd : e.pnlPercentageNative}-${e.tokenAddress}-${e.wasExternallyTraded}` : void 0
        };
    case "totalPnlPercentageUsd":
        return {
            ...oge(e),
            headerName: n.t("PNL %"),
            headerComponent: qQ,
            headerComponentParams: {
                tooltipTitle: n.t("% values may vary depending on the currency denomination, as exchange rates between USD and native currencies fluctuate.")
            },
            cellRenderer: e => {
                var t;
                return v.jsx(nge, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            comparator: lZ((e => e.wasExternallyTraded ? null : a === uZ.USD ? e.totalPnlPercentageUsd ?? null : e.totalPnlPercentageNative ?? null)),
            valueGetter: ({data: e}) => e ? `${e.chain}-${a === uZ.USD ? e.totalPnlPercentageUsd : e.totalPnlPercentageNative}-${e.tokenAddress}-${e.wasExternallyTraded}` : void 0
        };
    case "lastActivityTs":
        return {
            ...oge(e),
            headerName: n.t("Activity"),
            sort: "desc",
            cellRenderer: e => {
                var t;
                return v.jsx(Jme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            minWidth: 80,
            valueGetter: ({data: e}) => e ? `${e.lastActivityTs}-${e.chain}-${e.tokenAddress}` : void 0,
            comparator: lZ((e => e.lastActivityTs ?? null))
        };
    case "tokenAddress":
        return {
            ...oge(e),
            headerName: n.t("Actions"),
            sortable: !1,
            cellRenderer: e => {
                var t;
                return v.jsx(Xme, {
                    portfolioDisplayData: e.data,
                    currencyMode: a,
                    ...e,
                    href: ige(e.data),
                    onRowClick: lge((null == (t = e.data) ? void 0 : t.tokenAddress) ?? "") ? s : void 0
                })
            }
            ,
            minWidth: 100,
            maxWidth: 100,
            valueGetter: ({data: e}) => e ? `${e.totalPnlPercentageUsd}-${e.chain}-${e.totalPnlUsd}-${e.totalPnlPercentageUsd}-${e.investedUsd}-${e.tokenSymbol}-${e.tokenAddress}-${e.wasExternallyTraded}` : void 0
        };
    default:
        return {}
    }
}
  , dge = ({isDesktop: e, isOpen: t, currencyMode: n, onNativeMarketRowClick: r}) => {
    switch (t) {
    case !0:
        return [cge({
            key: "tokenSymbol",
            isDesktop: e,
            isOpen: t,
            currencyMode: n,
            onNativeMarketRowClick: r
        }), cge({
            key: "costUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "valueUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "unrealizedPnlUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "pnlPercentageUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "holdingAmount",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "lastActivityTs",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "tokenAddress",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        })];
    case !1:
        return [cge({
            key: "tokenSymbol",
            isDesktop: e,
            isOpen: t,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "totalPnlUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "totalPnlPercentageUsd",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "lastActivityTs",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        }), cge({
            key: "tokenAddress",
            isDesktop: e,
            onNativeMarketRowClick: r,
            currencyMode: n
        })]
    }
}
  , uge = "padreV2-portfolioExcludeDust"
  , pge = "padreV2-portfolioShowHidden"
  , hge = "padreV2-portfolioShowScams"
  , mge = "padreV2-portfolioOnlyPurchasedTokens"
  , gge = "padreV2-portfolioAggregatePositions"
  , xge = "padreV2-portfolioModeV2"
  , bge = rge.OPEN_POSITIONS
  , fge = "padreV2-portfolioPositionsCurrencyMode"
  , vge = uZ.USD
  , Sge = e => `${e.tokenAddress}-${e.chain}-${e.walletName}-${e.walletAddress}`
  , yge = e => e.orderId
  , kge = {
    [Ame.SYMBOL]: "symbol",
    [Ame.MARKET_CAP]: "value",
    [Ame.PRICE]: "price"
}
  , Cge = 15
  , Age = e => {
    switch (e) {
    case kme.OPEN_POSITIONS:
        return nT.TOP_BAR_POSITIONS;
    case kme.RECENT:
        return nT.TOP_BAR_RECENTS;
    case kme.WATCHLIST:
        return nT.TOP_BAR_WATCHLIST;
    default:
        throw new Error(`Unknown mode ${e}`)
    }
}
  , wge = y.memo(( ({padreAvatarUrl: e, chain: t, symbol: n, name: r, address: a, value: s, isPercentValue: o, walletAddress: l, valueInUsd: i, mode: c, extraActionLabel: d, onExtraActionClick: u}) => {
    const {t: p} = we()
      , h = y.useMemo(( () => XE(t, a, Age(c))), [a, t, c])
      , {buttonProps: m, popoverProps: g} = Fw({
        id: `${a}-${t}-${l}-popover`
    })
      , {hidePair: x} = SX()
      , b = yT()
      , {setLastSelectedWalletsPerChain: f} = OD()
      , A = y.useCallback(( () => {
        ST({
            query: bg(t, a),
            withDeepCacheWarm: !1
        })
    }
    ), [a, t])
      , w = ( () => {
        const [e,t] = JC(!1, 200)
          , n = y.useRef(!1);
        return y.useEffect(( () => {
            n.current = e
        }
        ), [e]),
        y.useEffect(( () => {
            const e = e => {
                n.current && e.preventDefault()
            }
            ;
            return document.addEventListener("contextmenu", e),
            () => {
                document.removeEventListener("contextmenu", e)
            }
        }
        ), []),
        y.useCallback(( () => {
            n.current = !0,
            t(!0)
        }
        ), [t])
    }
    )()
      , j = y.useCallback(( () => {
        h && (window.open(h, "_blank", "noopener,noreferrer"),
        g.onClose())
    }
    ), [h, g])
      , T = y.useCallback((e => {
        0 === e.button && (e.ctrlKey || e.metaKey ? j() : (l && f((e => ({
            ...e,
            [t]: [ng(l)]
        }))),
        b({
            chain: t,
            tokenAddress: a,
            tradePageOrigin: Age(c)
        }))),
        1 === e.button && j(),
        2 === e.button && (w(),
        e.preventDefault(),
        e.stopPropagation(),
        m.onClick())
    }
    ), [c, a, m, t, b, j, f, l, w])
      , I = y.useCallback(( () => {
        x(a, t),
        g.onClose()
    }
    ), [a, t, x, g])
      , E = y.useCallback(( () => {
        u && (u(),
        g.onClose())
    }
    ), [u, g]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(C, {
            ref: m.ref,
            display: "flex",
            alignItems: "center",
            onMouseDown: T,
            onMouseEnter: A,
            sx: Pge,
            children: [v.jsx(S, {
                flex: `0 0 ${Ege + 2}px`,
                alignItems: "center",
                justifyContent: "center",
                children: ru(a) ? v.jsx(Sz, {
                    size: Ege,
                    chain: t,
                    chainBorder: !0
                }) : v.jsx(b_, {
                    size: Ege,
                    url: IE(t, a),
                    name: n,
                    chain: t,
                    padreAvatarUrl: e,
                    hideHoverAvatar: !e,
                    protocolInfo: null,
                    borderRadius: "4px",
                    alwaysShowPointer: !0
                })
            }), v.jsx(GC, {
                title: r,
                offset: Wme,
                placement: Fme,
                children: v.jsx(Rge, {
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        noWrap: !0,
                        children: iu(n, Ige)
                    })
                })
            }), null !== i && v.jsx(GC, {
                title: p("Value"),
                offset: Wme,
                placement: Fme,
                children: v.jsx(Rge, {
                    minWidth: jge,
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.value",
                        noWrap: !0,
                        children: LI(i < .001 ? 0 : i, {
                            desiredDigits: 3,
                            collapseExponent: !0,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    })
                })
            }), v.jsx(GC, {
                title: p(o ? "PNL" : "MCap"),
                offset: Wme,
                placement: Fme,
                children: v.jsx(Rge, {
                    children: v.jsx(RZ, {
                        value: o ? s : 0,
                        defaultColor: "text.value",
                        formattedDisplay: o ? jI(s, {
                            precision: 1,
                            collapseExponent: !0
                        }) : OI(s, {
                            collapseExponent: !0,
                            symbol: "$",
                            symbolPosition: yI.START
                        }),
                        variant: "paragraph3",
                        minWidth: Tge,
                        noWrap: !0
                    })
                })
            })]
        }), v.jsx(ae, {
            ...g,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: Mge,
            transformOrigin: Nge,
            children: v.jsx(ee, {
                elevation: 1,
                sx: Lge,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    children: [v.jsx(te, {
                        value: "never",
                        sx: Oge,
                        onClick: j,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.value",
                            children: "Open in new tab"
                        })
                    }), !d && !u && v.jsx(te, {
                        value: "never",
                        sx: Oge,
                        onClick: I,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.value",
                            children: "Hide token"
                        })
                    }), d && u && v.jsx(te, {
                        value: "never",
                        sx: Oge,
                        onClick: E,
                        children: v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.value",
                            children: d
                        })
                    })]
                })
            })
        })]
    })
}
))
  , jge = 34
  , Tge = 54
  , Ige = 20
  , Ege = 12
  , Mge = {
    vertical: "bottom",
    horizontal: "center"
}
  , Nge = {
    vertical: "top",
    horizontal: "center"
}
  , Pge = {
    gap: .5,
    userSelect: "none",
    cursor: "pointer",
    minHeight: Ege + 2
}
  , Oge = e => ({
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    }
})
  , Lge = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , Rge = y.memo(y.forwardRef(( (e, t) => v.jsx(C, {
    ref: t,
    component: "span",
    display: "flex",
    alignItems: "center",
    height: 24,
    ...e
}))))
  , Dge = y.memo(( ({showModeShortcuts: e, mode: t, setMode: n, isSettingsModalOpen: r, openSettingsModal: a}) => {
    const {t: s} = we();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        ml: "-4px",
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            pr: 1,
            children: [e && Ime.map((e => {
                const r = Mme[e]
                  , a = s(Eme[e]);
                return v.jsx(GC, {
                    title: a,
                    offset: Wme,
                    placement: Fme,
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(_ge, {
                            $active: e === t,
                            onClick: () => n(e),
                            children: v.jsx(r, {
                                color: "inherit",
                                size: 16
                            })
                        })
                    })
                }, e)
            }
            )), v.jsx(GC, {
                title: s("Settings"),
                offset: Wme,
                placement: Fme,
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(_ge, {
                        onClick: a,
                        $active: r,
                        children: v.jsx(Ny, {})
                    })
                })
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: Bge
        })]
    })
}
))
  , Bge = {
    my: .75
}
  , _ge = y.memo(B((e => v.jsx(V, {
    variant: "tertiary",
    size: "xxsmall",
    ...e
})), {
    shouldForwardProp: e => !String(e).startsWith("$")
})(( ({theme: e, $active: t}) => ({
    border: "none",
    padding: 0,
    height: 24,
    minWidth: 24,
    color: t ? e.palette.text.secondary : e.palette.text.label,
    transitionProperty: "color background-color",
    transitionDuration: `${e.transitions.duration.shortest}ms`,
    transitionTimingFunction: e.transitions.easing.easeInOut,
    "&, &:focus, &.Mui-disabled, &.Mui-disabled:hover": {
        backgroundColor: "transparent"
    },
    "&:hover": {
        backgroundColor: e.palette.background.buttonDefault
    }
}))))
  , Uge = y.memo(( ({isOpen: e, onClose: t, mode: n, setMode: r, positionSort: a, setPositionSort: s, positionsSortDirection: o, togglePositionsSortDirection: l, aggregatePositions: i, toggleAggregatePositions: c, hideValue: d, toggleHideValue: u, showModeShortcuts: p, toggleShowModeShortcuts: h, watchlistSort: m, setWatchlistSort: g, watchlistSortDirection: x, toggleWatchlistSortDirection: b}) => {
    const {t: f} = we()
      , y = D();
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        stackSx: Wge,
        children: v.jsxs(S, {
            children: [v.jsxs(Fge, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: f("Ticker bar settings")
                }), v.jsx(F, {
                    sx: {
                        p: 0
                    },
                    onClick: t,
                    children: v.jsx(kS, {
                        color: y.palette.text.value
                    })
                })]
            }), v.jsx(Ee, {}), v.jsxs(Fge, {
                children: [v.jsxs(Vge, {
                    children: [v.jsx(Gge, {
                        children: f("Display mode")
                    }), v.jsx(S, {
                        alignItems: "flex-end",
                        children: v.jsx(it, {
                            value: n,
                            size: "xsmall",
                            renderValue: () => v.jsx(S, {
                                mt: "2px",
                                children: v.jsx(qge, {
                                    mode: n,
                                    isSelected: !0
                                })
                            }),
                            sx: {
                                width: txe
                            },
                            children: Ime.map((e => v.jsx(te, {
                                value: e,
                                onClick: () => r(e),
                                dense: !0,
                                disableRipple: !0,
                                children: v.jsx(qge, {
                                    mode: e,
                                    isSelected: e === n
                                })
                            }, e)))
                        })
                    })]
                }), v.jsxs(zge, {
                    onClick: h,
                    children: [v.jsx(Gge, {
                        children: f("Show display mode shortcuts")
                    }), v.jsx($ge, {
                        checked: p,
                        onChange: h
                    })]
                })]
            }), v.jsx(Ee, {}), v.jsxs(Fge, {
                children: [v.jsxs(Vge, {
                    children: [v.jsx(Gge, {
                        children: f("Sort {{mode}} by", {
                            mode: f("Watchlist")
                        })
                    }), v.jsxs(Hge, {
                        children: [v.jsx(it, {
                            value: m,
                            size: "xsmall",
                            renderValue: () => v.jsx(S, {
                                mt: "4px",
                                children: v.jsx(Yge, {
                                    sort: m,
                                    isSelected: !0
                                })
                            }),
                            sx: {
                                width: txe - nxe - rxe
                            },
                            children: _me.map((e => v.jsx(Qge, {
                                value: e,
                                onClick: () => g(e),
                                children: v.jsx(Yge, {
                                    sort: e,
                                    isSelected: e === m
                                })
                            }, e)))
                        }), v.jsx(Zge, {
                            sortDirection: x,
                            toggleDirection: b
                        })]
                    })]
                }), v.jsxs(Vge, {
                    children: [v.jsx(Gge, {
                        children: f("Sort {{mode}} by", {
                            mode: f("Positions")
                        })
                    }), v.jsxs(Hge, {
                        children: [v.jsx(it, {
                            value: a,
                            size: "xsmall",
                            renderValue: () => v.jsx(S, {
                                mt: "4px",
                                children: v.jsx(Kge, {
                                    sort: a,
                                    isSelected: !0
                                })
                            }),
                            sx: {
                                width: txe - nxe - rxe
                            },
                            children: Pme.map((e => v.jsx(Qge, {
                                value: e,
                                onClick: () => s(e),
                                children: v.jsx(Kge, {
                                    sort: e,
                                    isSelected: e === a
                                })
                            }, e)))
                        }), v.jsx(Zge, {
                            sortDirection: o,
                            toggleDirection: l
                        })]
                    })]
                }), v.jsxs(zge, {
                    onClick: c,
                    children: [v.jsx(Gge, {
                        children: f("Show positions separately for each wallet")
                    }), v.jsx($ge, {
                        checked: !i,
                        onChange: c
                    })]
                }), v.jsxs(zge, {
                    onClick: u,
                    children: [v.jsx(Gge, {
                        children: f("Show position value")
                    }), v.jsx($ge, {
                        checked: !d,
                        onChange: u
                    })]
                })]
            })]
        })
    })
}
))
  , Wge = {
    p: 0
}
  , Fge = e => v.jsx(S, {
    gap: 2,
    px: Jge,
    py: exe,
    ...e
})
  , Vge = e => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    gap: 1,
    justifyContent: "space-between",
    minHeight: axe,
    ...e
})
  , Hge = e => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    gap: `${rxe}px`,
    ...e
})
  , zge = B((e => v.jsx(te, {
    disableRipple: !0,
    ...e
})))(( () => ({
    minHeight: `${axe}px !important`,
    background: "none !important",
    padding: 0,
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center"
})))
  , $ge = e => v.jsx(S, {
    width: nxe,
    height: nxe,
    justifyContent: "center",
    alignItems: "center",
    children: v.jsx(UR, {
        size: "small",
        onClick: Ww,
        ...e
    })
})
  , Gge = e => v.jsx(k, {
    variant: "paragraph3",
    color: "text.label",
    ...e
})
  , qge = ({mode: e, isSelected: t}) => {
    const n = Mme[e]
      , r = Eme[e];
    return v.jsx(Xge, {
        Icon: n,
        labelKey: r,
        isSelected: t
    })
}
  , Kge = ({sort: e, isSelected: t}) => {
    const n = Ome[e];
    return v.jsx(Xge, {
        labelKey: n,
        isSelected: t
    })
}
  , Yge = ({sort: e, isSelected: t}) => {
    const n = Ume[e];
    return v.jsx(Xge, {
        labelKey: n,
        isSelected: t
    })
}
  , Xge = ({Icon: e, labelKey: t, isSelected: n}) => {
    const {t: r} = we()
      , a = r(t);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        sx: e => ({
            color: n ? e.palette.text.value : e.palette.text.label,
            transition: `color ${e.transitions.duration.shortest}ms`
        }),
        children: [e && v.jsx(e, {
            color: "inherit"
        }), v.jsx(k, {
            variant: "paragraph3",
            sx: {
                color: "inherit"
            },
            children: a
        })]
    })
}
  , Qge = e => v.jsx(te, {
    disableRipple: !0,
    dense: !0,
    ...e
})
  , Zge = ({sortDirection: e, toggleDirection: t}) => {
    const {t: n} = we();
    return v.jsx(GC, {
        title: e === m6.ASC ? n("Ascending") : n("Descending"),
        placement: Fme,
        offset: Wme,
        children: v.jsx(V, {
            size: "xsmall",
            variant: "tertiary",
            sx: {
                minWidth: nxe,
                p: 0
            },
            onClick: t,
            children: v.jsx(S, {
                justifyContent: "center",
                alignItems: "center",
                sx: t => ({
                    transform: `scaleY(${e === m6.DESC ? 1 : -1})`,
                    transition: `transform ${t.transitions.duration.shortest}ms ${t.transitions.easing.easeInOut}`
                }),
                children: v.jsx(ey, {
                    color: "inherit"
                })
            })
        })
    })
}
  , Jge = 3
  , exe = 2
  , txe = 150
  , nxe = 32
  , rxe = 8
  , axe = nxe
  , sxe = y.memo(( ({isBelowNav: e=!1}) => {
    const {t: t} = we()
      , {hiddenPairs: n} = SX()
      , [r,a] = Mx("padreV2-topBarMode", Nme)
      , [s,o] = Mx("padreV2-topBarShowModeShortcuts", true)
      , l = y.useCallback(( () => {
        o((e => !e))
    }
    ), [o])
      , [i,d] = Mx("padreV2-topBarPositionsSortMode", Lme)
      , [u,p] = Mx("padreV2-topBarPositionsSortDirection", Rme)
      , h = y.useCallback(( () => {
        p((e => e === m6.ASC ? m6.DESC : m6.ASC))
    }
    ), [p])
      , m = (e => {
        const t = Ax()
          , n = y.useCallback((n => t ? dm.subscribeUserOpenPortfolioStats(t, jme(e), n) : {
            unsubscribe: () => {}
        }), [t, e]);
        return kx(n, wme)
    }
    )(i)
      , [g,x] = Mx("padreV2-topBarAggregatePositions", !0)
      , b = y.useCallback(( () => {
        x((e => !e))
    }
    ), [x])
      , [f,C] = Mx("padreV2-topBarShowValue", !1)
      , A = y.useCallback(( () => {
        C((e => !e))
    }
    ), [C])
      , w = Tme(y.useMemo(( () => r !== kme.OPEN_POSITIONS ? null : ( (e, t, n, r, a, s) => {
        if (!e || !t)
            return null;
        const o = [];
        return e.allEntries.forEach((e => {
            const n = _p(e)
              , r = e[2];
            if (t[kX(r, n)])
                return;
            const a = e[8];
            if (a <= 1)
                return;
            const l = (e => e[6])(e)
              , i = {
                padreAvatarUrl: null,
                chain: n,
                symbol: Wp(e),
                name: Fp(e),
                address: ng(r),
                value: l,
                isPercentValue: !0,
                walletAddress: Up(e),
                lastActiveTs: Vp(e),
                valueInUsd: s ? null : a,
                marketId: null
            };
            o.push([i, a])
        }
        )),
        Object.values(c.reduce(o, ( (e, [t,r]) => {
            const s = a ? `${t.address}-${t.chain}` : `${t.address}-${t.chain}-${t.walletAddress}`
              , o = e[s];
            if (!a || !o) {
                const a = n === Cme.LAST_ACTIVITY ? t.lastActiveTs : n === Cme.PNL_PERCENTAGE ? t.value : r;
                return e[s] = [{
                    ...t,
                    currentWeight: r
                }, a],
                e
            }
            const l = r + o[0].currentWeight;
            if (!l)
                return e;
            const i = (t.value * r + o[0].value * o[0].currentWeight) / l
              , c = n === Cme.LAST_ACTIVITY ? Math.max(t.lastActiveTs, o[1]) : n === Cme.PNL_PERCENTAGE ? i : r + o[1];
            return e[s] = [{
                ...t,
                walletAddress: null,
                value: i,
                valueInUsd: o[0].valueInUsd ? (o[0].valueInUsd || 0) + (t.valueInUsd || 0) : 0,
                currentWeight: l
            }, c],
            e
        }
        ), {})).sort(( (e, t) => {
            const [n,a] = r === m6.ASC ? t : e
              , [s,o] = r === m6.ASC ? e : t;
            return null === a && null !== o ? 1 : null !== a && null === o ? -1 : null !== a && null !== o && a !== o ? o - a : s.value - n.value
        }
        )).slice(0, Cge).map(( ([e]) => e))
    }
    )(m, n, i, u, g, f)), [r, m, n, i, u, g, f]), (e => `${e.address}-${e.chain}-${e.walletAddress}`), P)
      , {history: j, removeFromHistory: T} = fz()
      , I = y.useMemo(( () => j.map(( ({baseAddress: e, chain: t}) => bg(t, e)))), [j])
      , E = J1(I)
      , M = y.useMemo(( () => r !== kme.RECENT ? null : ( (e, t) => {
        const n = c.uniqBy(e.sort(( (e, t) => t.seenAtTs - e.seenAtTs)), (e => `${e.baseAddress}-${e.chain}`)).slice(0, Cge);
        return c.reduce(n, ( (e, n) => {
            var r;
            const a = bg(n.chain, n.baseAddress)
              , s = (null == (r = null == t ? void 0 : t[a]) ? void 0 : r.fdvInUsdUi) ?? 0
              , o = {
                padreAvatarUrl: null,
                chain: n.chain,
                symbol: n.baseSymbol,
                name: n.baseName,
                address: ng(n.baseAddress),
                value: s,
                isPercentValue: !1,
                walletAddress: null,
                valueInUsd: null,
                marketId: n.marketId
            };
            return e.push(o),
            e
        }
        ), [])
    }
    )(j, E)), [r, j, E])
      , N = Tme(M, (e => `${e.address}-${e.chain}`), P)
      , {watched: O, remove: L} = p$()
      , [R,B] = Mx("padreV2-topBarWatchlistSortMode", Dme)
      , [_,U] = Mx("padreV2-topBarWatchlistSortDirection", Bme)
      , W = y.useCallback(( () => {
        U((e => e === m6.ASC ? m6.DESC : m6.ASC))
    }
    ), [U])
      , F = y.useMemo(( () => r !== kme.WATCHLIST ? null : ( (e, t, n) => c.reduce(e.filter((e => !!e.tokenInfo && !!e.fastStats)), ( (e, t) => {
        var n, r, a, s;
        const o = {
            padreAvatarUrl: null,
            chain: t.chain,
            symbol: (null == (n = t.tokenInfo) ? void 0 : n.symbol) ?? "",
            name: (null == (r = t.tokenInfo) ? void 0 : r.name) ?? "",
            address: ng(t.tokenAddress),
            value: (null == (a = t.fastStats) ? void 0 : a.fdvInUsdUi) ?? 0,
            price: (null == (s = t.fastStats) ? void 0 : s.priceInUsdUi) ?? 0,
            isPercentValue: !1,
            walletAddress: null,
            valueInUsd: null,
            marketId: null
        };
        return e.push(o),
        e
    }
    ), []).sort(( (e, r) => {
        const a = kge[t]
          , s = n === m6.ASC ? e : r
          , o = n === m6.ASC ? r : e;
        return t === Ame.SYMBOL ? String(s[a]).localeCompare(String(o[a])) : Number(s[a] || 0) - Number(o[a] || 0)
    }
    )).slice(0, Cge))(O, R, _)), [r, O, R, _])
      , V = Tme(F, (e => `${e.address}-${e.chain}`), P)
      , [H,z] = y.useState(!1)
      , $ = y.useCallback(( () => {
        z(!0)
    }
    ), [])
      , G = y.useCallback(( () => {
        z(!1)
    }
    ), [])
      , q = y.useMemo(( () => {
        switch (r) {
        case kme.OPEN_POSITIONS:
            return w;
        case kme.RECENT:
            return N;
        case kme.WATCHLIST:
            return V;
        default:
            return null
        }
    }
    ), [r, w, N, V])
      , {pathname: K} = he()
      , {colorSkin: Y, defaultThemeSkin: X} = Vb()
      , Q = D()
      , Z = y.useMemo(( () => K.startsWith(tT.TRADE) ? Q.palette.background.primary : zhe(Q, Y, X)), [K, Q, Y, X]);
    return v.jsxs(v.Fragment, {
        children: [v.jsxs(oxe, {
            $isBelowNav: e,
            $backgroundColor: Z,
            children: [v.jsx(Dge, {
                showModeShortcuts: s,
                mode: r,
                setMode: a,
                isSettingsModalOpen: H,
                openSettingsModal: $
            }), q ? v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.25,
                px: 1.5,
                overflow: "scroll",
                className: "padre-no-scroll",
                children: q.map((e => {
                    const n = r === kme.OPEN_POSITIONS ? void 0 : t("Remove" + (r === kme.WATCHLIST ? " from watchlist" : ""))
                      , a = r !== kme.OPEN_POSITIONS ? () => {
                        r === kme.WATCHLIST ? L(e.chain, ng(e.address)) : e.marketId && T(e.marketId)
                    }
                    : void 0;
                    return v.jsx(wge, {
                        extraActionLabel: n,
                        onExtraActionClick: a,
                        mode: r,
                        ...e
                    }, `${e.address}-${e.chain}-${e.walletAddress}`)
                }
                ))
            }) : v.jsx(S, {
                direction: "row",
                alignItems: "center",
                children: v.jsxs(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    noWrap: !0,
                    children: [t("Loading"), v.jsx(D5, {})]
                })
            })]
        }), v.jsx(Uge, {
            isOpen: H,
            onClose: G,
            mode: r,
            setMode: a,
            positionSort: i,
            setPositionSort: d,
            positionsSortDirection: u,
            togglePositionsSortDirection: h,
            aggregatePositions: g,
            toggleAggregatePositions: b,
            hideValue: f,
            toggleHideValue: A,
            showModeShortcuts: s,
            toggleShowModeShortcuts: l,
            watchlistSort: R,
            setWatchlistSort: B,
            watchlistSortDirection: _,
            toggleWatchlistSortDirection: W
        })]
    })
}
))
  , oxe = y.memo(B((e => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    ...e
})), {
    shouldForwardProp: e => !String(e).startsWith("$")
})(( ({theme: e, $isBelowNav: t, $backgroundColor: n}) => ({
    width: "100%",
    height: 28,
    backgroundColor: n || e.palette.background.primary,
    borderBottom: t ? "none" : `1px solid ${e.palette.background.borderMain}`,
    borderTop: t ? `1px solid ${e.palette.background.borderMain}` : "none",
    paddingLeft: e.spacing(2),
    textWrap: "nowrap"
}))))
  , lxe = () => {
    const e = xw()
      , t = fw()
      , {hideHeader: n} = Phe()
      , [r] = Mx(DR, !0)
      , {settings: a} = rf()
      , s = y.useMemo(( () => e && (a ? a.showTopBar ?? !0 : r)), [e, a, r]);
    return y.useMemo(( () => n ? 0 : (t ? 62 : 56) + (e && s ? 29 : 0)), [n, s, e, t])
}
  , ixe = () => l(( () => import("./AccountSettingsModalContent-CnhZp-9U.js")), __vite__mapDeps([0, 1, 2, 3, 4]))
  , cxe = y.memo(( () => {
    const {t: e} = we()
      , t = D()
      , {colorSkin: n, defaultThemeSkin: r, font: a} = Vb()
      , s = xw()
      , o = bw()
      , {desktopNavigationOrder: l} = rf()
      , {user: i} = VK()
      , {lastViewedPortfolioTab: c} = _H()
      , d = ( () => {
        const e = me()
          , [t] = xe();
        return y.useCallback(( ({navigationOptions: n, keepSearchParams: r}) => {
            e({
                pathname: `${tT.TRENCHES}`,
                search: r ? t.toString() : ""
            }, n)
        }
        ), [e, t])
    }
    )()
      , [u,p] = Mx(DR, LR)
      , [h,m] = Mx(BR, RR)
      , {settings: g} = rf()
      , x = y.useMemo(( () => s && (g ? g.showTopBar ?? LR : u)), [s, g, u])
      , b = y.useMemo(( () => s && (g ? g.topBarPosition ?? RR : h)), [s, g, h])
      , f = y.useCallback(( () => {
        d({})
    }
    ), [d]);
    mG("t", f, {
        requireOutsideInput: !0
    }),
    y.useEffect(( () => {
        g && void 0 !== g.showTopBar && u !== g.showTopBar && p(g.showTopBar)
    }
    ), [u, p, g]),
    y.useEffect(( () => {
        g && void 0 !== g.topBarPosition && b !== g.topBarPosition && m(g.topBarPosition)
    }
    ), [u, p, m, g, b]);
    const A = cT()
      , w = lxe()
      , {openModal: j} = q6()
      , T = y.useCallback(( () => {
        j(H6.SETTINGS)
    }
    ), [j])
      , {currentPath: I} = Phe()
      , {isAccountOverviewDrawerOpen: E, toggleAccountOverviewDrawer: M} = q6()
      , N = y.useCallback(( () => {
        M(!1)
    }
    ), [M])
      , P = y.useCallback(( () => {
        N()
    }
    ), [N])
      , O = w - (8 * (s ? 4 : 2) - 2)
      , L = y.useMemo(( () => ( (e, t) => sT(rT(e), t))(c, l)), [c, l])
      , R = y.useMemo(( () => e => ({
        height: e.spacing(w - 1 + "px"),
        overflow: "scroll",
        width: "100%",
        position: "absolute",
        top: 0,
        px: x ? 0 : 2,
        pt: x ? b === Hh.TOP ? 0 : -.5 : s ? 1.75 : 1,
        gap: .5,
        backgroundColor: zhe(e, n, r),
        borderBottom: `1px solid ${e.palette.background.borderMain}`,
        zIndex: 1201
    })), [n, r, w, x, s, b])
      , B = y.useCallback(( () => {
        i ? M(!E) : A()
    }
    ), [E, A, M, i])
      , {trenchesChain: _} = xne();
    return v.jsxs(C, {
        "data-testid": "top-bar",
        className: "padre-no-scroll",
        sx: R,
        children: [x && b === Hh.TOP && v.jsx(sxe, {}), v.jsx(S, {
            justifyContent: "center",
            height: O,
            width: "100%",
            px: x ? 2 : 0,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsxs(S, {
                    "data-testid": "header-nav-bar",
                    direction: "row",
                    gap: 1,
                    alignItems: "center",
                    flexGrow: s ? 0 : 1,
                    children: [v.jsx(C, {
                        display: "flex",
                        alignItems: "center",
                        "aria-label": "Terminal Home",
                        component: Hn,
                        to: tT.TRENCHES,
                        mt: x || !s ? 0 : .25,
                        children: v.jsx(gK, {
                            height: s ? 18 : 20,
                            isSmall: !s
                        })
                    }), o && L.map((t => v.jsx(H, {
                        to: t.path,
                        component: Hn,
                        sx: e => ({
                            textDecoration: "none",
                            display: "flex",
                            px: 1.5,
                            mt: "1px",
                            height: 28,
                            minHeight: 28,
                            alignItems: "center",
                            ...I === t.path ? {
                                color: e.palette.primary.main,
                                "&:hover": {
                                    background: `${e.palette.primary.main}1A`,
                                    borderRadius: "4px"
                                }
                            } : {
                                color: e.palette.text.value,
                                "&:hover": {
                                    color: e.palette.primary.main,
                                    background: `${e.palette.primary.main}1A`,
                                    borderRadius: "4px"
                                }
                            }
                        }),
                        children: v.jsx(k, {
                            variant: "paragraph1",
                            color: "inherit",
                            fontSize: 14,
                            lineHeight: 1.2,
                            mt: a === ku.PADRE_PLEX ? "3px" : "1px",
                            noWrap: !0,
                            children: e(t.label)
                        })
                    }, t.path)))]
                }), s ? v.jsxs(S, {
                    direction: "row",
                    width: "100%",
                    height: O,
                    gap: 2,
                    justifyContent: "end",
                    alignItems: "center",
                    children: [v.jsx(Lhe, {}), v.jsx(S, {
                        flex: 1,
                        direction: "row",
                        justifyContent: "end",
                        sx: mxe,
                        children: v.jsx(vG, {
                            onSearchModalOpenCallback: P
                        })
                    }), v.jsx(f0, {
                        chain: _,
                        isHeader: !0
                    }), v.jsx(GK, {
                        iconSize: dxe
                    }), o && v.jsx(V, {
                        variant: "tertiary",
                        size: "xsmall",
                        onClick: T,
                        sx: hxe,
                        onMouseEnter: ixe,
                        children: v.jsx(Ny, {
                            color: t.palette.text.value,
                            size: uxe
                        })
                    }), v.jsx(C, {
                        position: "relative",
                        display: "inline-block",
                        children: v.jsx(V, {
                            size: "xsmall",
                            variant: "tertiary",
                            onClick: B,
                            sx: hxe,
                            children: v.jsx($S, {
                                color: t.palette.text.value,
                                size: pxe
                            })
                        })
                    })]
                }) : v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    alignItems: "center",
                    pr: 1,
                    mr: -2,
                    children: [v.jsx(f0, {
                        chain: _,
                        isHeader: !0
                    }), v.jsx(Lhe, {}), v.jsx(vG, {
                        onSearchModalOpenCallback: P
                    }), v.jsx(GK, {
                        iconSize: dxe
                    }), v.jsx(V, {
                        size: "xsmall",
                        variant: "tertiary",
                        onClick: B,
                        sx: hxe,
                        children: v.jsx($S, {
                            color: t.palette.text.value,
                            size: pxe
                        })
                    })]
                })]
            })
        }), v.jsx(bme, {
            isOpen: E,
            onClose: N
        }), x && b === Hh.BELOW_NAV && v.jsx(sxe, {
            isBelowNav: !0
        })]
    })
}
))
  , dxe = 18
  , uxe = 18
  , pxe = 20
  , hxe = {
    p: 0,
    borderRadius: "16px",
    borderColor: "transparent",
    "&:hover, &:focus": {
        borderColor: "transparent"
    }
}
  , mxe = {
    maxWidth: {
        sm: 120,
        md: 160,
        lg: 205
    }
}
  , gxe = y.memo(( ({message: e, color: t, onHideCallback: n, forceOpen: r}) => {
    const a = D()
      , [s,o] = y.useState(!0)
      , [l,c] = dx("padreV2-lastDismissedGlobalMessage", null)
      , d = y.useCallback(( () => {
        e && c({
            message: e,
            ts: i().unix()
        }),
        n(),
        o(!0)
    }
    ), [e, c, n]);
    return y.useEffect(( () => {
        e && t && (l && l.message === e && l.ts + 43200 > i().unix() || o(!1))
    }
    ), [t, l, e, o]),
    !e || s && !r || !t ? null : v.jsxs(C, {
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        sx: {
            top: 0,
            zIndex: 1300,
            width: "100%",
            bgcolor: `${t}.main`,
            py: 1,
            px: 3,
            gap: 1
        },
        children: ["warning" === t && v.jsx(C, {
            minWidth: xxe,
            display: "flex",
            children: v.jsx(wk, {
                color: a.palette.background.default,
                size: xxe
            })
        }), "error" === t && v.jsx(C, {
            minWidth: xxe,
            display: "flex",
            children: v.jsx(Ck, {
                color: a.palette.background.default,
                size: xxe
            })
        }), v.jsx(k, {
            variant: "h1",
            sx: e => ({
                color: e.palette.background.default
            }),
            children: e
        }), "warning" === t || "error" === t ? v.jsx(C, {
            width: xxe
        }) : null, v.jsx(F, {
            size: "small",
            onClick: d,
            sx: e => ({
                position: "absolute",
                right: 6,
                top: 2,
                "&:hover": {
                    color: e.palette.background.buttonHover,
                    backgroundColor: "transparent"
                },
                "&:focus": {
                    color: e.palette.background.buttonHover,
                    backgroundColor: "transparent"
                }
            }),
            children: v.jsx(kS, {
                color: a.palette.background.default
            })
        })]
    })
}
))
  , xxe = 20
  , bxe = () => y.useMemo(( () => zn && (!0 === window.navigator.standalone || window.matchMedia("(display-mode: standalone)").matches) ? fxe : 0), [])
  , fxe = 18
  , vxe = {
    "&:hover": {
        cursor: "help"
    }
}
  , Sxe = y.memo(( ({value: e, Icon: t, tooltipTitle: n, precision: r=2, symbol: a, width: s=yxe, color: o}) => {
    const l = D()
      , i = bw()
      , c = y.useMemo(( () => ({
        minWidth: s
    })), [s]);
    return v.jsx(GC, {
        title: n,
        children: v.jsxs(S, {
            gap: .5,
            direction: "row",
            alignItems: "center",
            justifyContent: "center",
            sx: vxe,
            children: [v.jsx(t, {
                color: o ?? l.palette.text.label,
                size: i ? kxe : Cxe
            }), v.jsx(k, {
                variant: "paragraph3",
                color: o ?? "text.label",
                sx: c,
                lineHeight: 1,
                fontWeight: 400,
                children: null === e ? v.jsx(Ie, {
                    width: s,
                    variant: "rounded"
                }) : LI(e, {
                    collapseExponent: e > 1e3 && 0 !== r,
                    minPrecision: r,
                    maxPrecision: r + 1,
                    symbol: a,
                    padSymbol: !1,
                    symbolPosition: yI.START
                })
            })]
        })
    })
}
))
  , yxe = 40
  , kxe = 14
  , Cxe = 12
  , Axe = [Pd.SOLANA, Pd.BSC, Pd.ETH_MAINNET]
  , wxe = y.memo(( () => {
    const {t: e} = we()
      , t = fw()
      , {chainStats: n} = FV()
      , {lastViewedChain: r} = _H()
      , a = y.useMemo(( () => {
        return t ? Axe : [(e = r,
        e === Pd.BASE ? Pd.ETH_MAINNET : e)];
        var e
    }
    ), [t, r]);
    return v.jsx(S, {
        direction: "row",
        gap: Ixe,
        children: a.map((t => {
            var r;
            const a = (null == (r = null == n ? void 0 : n.perChain[t]) ? void 0 : r.stats.nativePriceInUsdUi) ?? null
              , s = a && a > 1e3 ? Txe : jxe
              , [o,l] = Exe(t);
            return v.jsx(Sxe, {
                value: a,
                Icon: o,
                tooltipTitle: e("Current {{currency}} value", {
                    currency: GD(t)
                }),
                symbol: "$",
                width: s,
                color: l,
                precision: a && a > 1e3 ? 0 : 2
            }, t)
        }
        ))
    })
}
))
  , jxe = 34
  , Txe = 28
  , Ixe = {
    xs: .75,
    md: 1.25
}
  , Exe = e => {
    switch (e) {
    case Pd.SOLANA:
        return [dk, "#86F0AD"];
    case Pd.BSC:
        return [ak, d_(e)];
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return [Df, d_(Pd.ETH_MAINNET)];
    default:
        throw new Error(`Unknown chain ${e}`)
    }
}
  , Mxe = y.memo(( ({chain: e, gasUi: t, tipUi: n, pumpfunBondUi: r}) => {
    const {t: a} = we();
    return v.jsxs(S, {
        direction: "row",
        gap: Pxe,
        children: [e === Pd.SOLANA && null !== r && v.jsx(Sxe, {
            value: r,
            Icon: aS,
            tooltipTitle: a("Estimated PumpFun Bond Market Cap"),
            symbol: "$"
        }), e !== Pd.SOLANA && v.jsx(Sxe, {
            value: t,
            Icon: wy,
            tooltipTitle: a("Gas price"),
            precision: 1,
            width: Nxe
        }), e === Pd.SOLANA && v.jsx(Sxe, {
            value: n,
            Icon: _k,
            tooltipTitle: a("Current network tip")
        })]
    })
}
))
  , Nxe = 24
  , Pxe = {
    xs: .75,
    md: 1.25
}
  , Oxe = () => {
    const {lastViewedChain: e} = _H()
      , {chainStats: t} = FV()
      , n = y.useMemo(( () => {
        if (!t)
            return null;
        const n = t.perChain[e] || null;
        return n ? {
            gasUi: n.stats.gasUi,
            tipUi: "solana" === n.type ? n.stats.tipUi : null,
            pumpfunBondUi: e === Pd.SOLANA ? (r = n.stats.nativePriceInUsdUi,
            4.108802412590318e-7 * r * 1e9) : null
        } : null;
        var r
    }
    ), [t, e]);
    return v.jsx(Mxe, {
        chain: e,
        gasUi: (null == n ? void 0 : n.gasUi) ?? null,
        tipUi: (null == n ? void 0 : n.tipUi) ?? null,
        pumpfunBondUi: (null == n ? void 0 : n.pumpfunBondUi) ?? null
    })
}
  , Lxe = y.memo(( () => {
    const {i18n: e} = we()
      , t = y.useMemo(( () => Dxe.find((t => t.code === e.resolvedLanguage)) ?? Dxe[0]), [e.resolvedLanguage])
      , {buttonProps: n, popoverProps: r} = Fw({
        id: "language-select"
    })
      , a = y.useCallback((n => {
        t.code !== n && e.changeLanguage(n).then(( () => {
            setTimeout(( () => window.location.reload()), 0)
        }
        )).catch((e => {}
        ))
    }
    ), [e, t.code]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            variant: "tertiary",
            size: "xxsmall",
            sx: Bxe,
            ...n,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    noWrap: !0,
                    mt: .25,
                    children: Rxe(t.code)
                }), v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    noWrap: !0,
                    fontWeight: 400,
                    children: `${t.label}`
                })]
            })
        }), v.jsx(ae, {
            ...r,
            onClick: Ww,
            anchorOrigin: Uxe,
            transformOrigin: Wxe,
            children: v.jsx(ee, {
                elevation: 1,
                sx: _xe,
                className: "no-drag padre-no-scroll",
                children: Dxe.map((e => {
                    const n = t.code === e.code;
                    return v.jsx(te, {
                        value: e.code,
                        onClick: () => {
                            a(e.code),
                            r.onClose()
                        }
                        ,
                        sx: Fxe,
                        children: v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            children: [v.jsx(k, {
                                variant: "inherit",
                                color: "inherit",
                                noWrap: !0,
                                mt: .25,
                                children: Rxe(e.code)
                            }), v.jsx(k, {
                                variant: "paragraph3",
                                color: n ? "text.value" : "text.label",
                                children: e.label
                            })]
                        })
                    }, e.code)
                }
                ))
            })
        })]
    })
}
))
  , Rxe = e => {
    switch (e) {
    case "en":
        return "";
    case "zh":
        return "";
    case "es":
        return "";
    case "pt":
        return "";
    case "ja":
        return "";
    default:
        return ""
    }
}
  , Dxe = [{
    code: "en",
    label: "English"
}, {
    code: "zh",
    label: ""
}]
  , Bxe = e => ({
    p: .25,
    height: 24,
    minWidth: 40,
    background: "transparent",
    border: "none",
    color: e.palette.text.label,
    "&:focus": {
        background: "transparent",
        border: "none"
    },
    "&:hover": {
        background: "transparent",
        border: "none",
        color: e.palette.text.value
    }
})
  , _xe = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    p: 0
})
  , Uxe = {
    vertical: "top",
    horizontal: "center"
}
  , Wxe = {
    vertical: "bottom",
    horizontal: "center"
}
  , Fxe = {
    px: 1
}
  , Vxe = y.memo(( ({Icon: e, label: t, isActive: n, onClick: r, smallGap: a=!1, onMouseEnter: s}) => {
    const o = y.useMemo(( () => e => {
        const t = e.palette.text.value
          , r = e.palette.text.label;
        return {
            display: "flex",
            color: n ? t : r,
            height: Hxe,
            px: .5,
            gap: a ? .25 : .5,
            border: "none",
            backgroundColor: "transparent",
            justifyContent: "flex-start",
            borderRadius: 0,
            "&:hover": {
                backgroundColor: "transparent",
                color: t,
                [`.${Gxe}`]: {
                    color: e.palette.text.value
                }
            },
            "&:focus": {
                backgroundColor: "transparent"
            },
            "&.Mui-active": {
                backgroundColor: "transparent"
            },
            [`.${Gxe}`]: {
                color: n ? t : r
            }
        }
    }
    ), [n, a]);
    return v.jsxs(V, {
        size: "xxsmall",
        variant: "tertiary",
        sx: o,
        onClick: r,
        onMouseEnter: s,
        children: [v.jsx(C, {
            display: "flex",
            className: Gxe,
            children: v.jsx(e, {
                size: zxe,
                color: "inherit"
            })
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            noWrap: !0,
            fontWeight: $xe,
            children: t
        })]
    })
}
))
  , Hxe = 28
  , zxe = 14
  , $xe = 400
  , Gxe = "bottom-bar-button-icon";
var qxe = (e => (e.NO_CONNECTION = "NO_CONNECTION",
e.CONNECTING = "CONNECTING",
e.POOR = "POOR",
e.STABLE = "STABLE",
e))(qxe || {});
const Kxe = (e, t) => e ? (window._padre_lastMxMsgMs ?? 0) > t - 4500 ? qxe.STABLE : (window._padre_lastMxMsgMs ?? 0) > t - 7e3 ? qxe.POOR : qxe.CONNECTING : qxe.NO_CONNECTION
  , Yxe = y.memo(( () => {
    const [e,t] = y.useState(navigator.onLine)
      , n = y.useRef(e);
    n.current = e,
    y.useEffect(( () => {
        const e = () => t(navigator.onLine);
        return window.addEventListener("online", e),
        window.addEventListener("offline", e),
        () => {
            window.removeEventListener("online", e),
            window.removeEventListener("offline", e)
        }
    }
    ), []);
    const [r,a] = y.useState(Kxe(e, 0))
      , s = y.useRef(r);
    return s.current = r,
    y.useEffect(( () => {
        const e = setInterval(( () => {
            const e = Kxe(n.current, +i());
            e !== s.current && a(e)
        }
        ), 250);
        return () => {
            clearInterval(e)
        }
    }
    ), []),
    v.jsx(Xxe, {
        connectionStrength: r
    })
}
))
  , Xxe = y.memo(( ({connectionStrength: e}) => {
    const t = D()
      , {color: n, label: r, IconComponent: a, tooltipTitle: s} = y.useMemo(( () => Zxe(e, t)), [e, t]);
    return v.jsx(GC, {
        title: s,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .75,
            sx: {
                "&:hover": {
                    cursor: s ? "help" : "auto"
                }
            },
            children: [v.jsx(a, {
                size: Qxe,
                color: n
            }), v.jsx(k, {
                color: n,
                variant: "paragraph3",
                minWidth: Jxe,
                fontWeight: 400,
                children: r
            })]
        })
    })
}
))
  , Qxe = 12
  , Zxe = (e, t) => {
    switch (e) {
    case qxe.NO_CONNECTION:
        return {
            color: t.palette.error.main,
            label: n.t("Disconnected"),
            IconComponent: Gv,
            tooltipTitle: n.t("Unable to connect. Check your internet connection")
        };
    case qxe.CONNECTING:
        return {
            color: t.palette.text.primary,
            label: n.t("Connecting"),
            IconComponent: $v,
            tooltipTitle: n.t("Connecting to Terminal Servers")
        };
    case qxe.POOR:
        return {
            color: t.palette.warning.main,
            label: n.t("Poor"),
            IconComponent: zv,
            tooltipTitle: ""
        };
    case qxe.STABLE:
        return {
            color: t.palette.originalGreen.main,
            label: n.t("Stable"),
            IconComponent: Gv,
            tooltipTitle: ""
        }
    }
}
  , Jxe = 42
  , ebe = y.memo(( () => {
    const [e,t] = y.useState(0);
    y.useEffect(( () => {
        let e = performance.now();
        const n = setInterval(( () => {
            const n = performance.now()
              , r = n - e;
            e = n,
            t(Math.max(r - 1e3, 0))
        }
        ), 1e3);
        return () => clearInterval(n)
    }
    ), []);
    const n = D()
      , r = y.useMemo(( () => e < 20 ? n.palette.originalGreen.main : e < 50 ? n.palette.warning.main : n.palette.error.main), [e, n]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        children: v.jsxs(k, {
            color: r,
            variant: "paragraph3",
            minWidth: 36,
            fontWeight: 400,
            children: [Math.round(e), " ms"]
        })
    })
}
))
  , tbe = y.memo(( () => {
    const [e,t] = y.useState(0);
    y.useEffect(( () => {
        let e, n = 0, r = performance.now();
        const a = () => {
            n++;
            const s = performance.now();
            s - r >= 1e3 && (t(1e3 * n / (s - r)),
            n = 0,
            r = s),
            e = requestAnimationFrame(a)
        }
        ;
        return e = requestAnimationFrame(a),
        () => cancelAnimationFrame(e)
    }
    ), []);
    const n = D()
      , r = y.useMemo(( () => e > 55 ? n.palette.text.label : e > 30 ? n.palette.warning.main : n.palette.error.main), [e, n]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        children: v.jsxs(k, {
            color: r,
            variant: "paragraph3",
            minWidth: 45,
            fontWeight: 400,
            children: [Math.round(e), " FPS"]
        })
    })
}
))
  , nbe = y.memo(( ({message: e, color: t, toggleForceOpenGlobalMessage: n}) => {
    const {t: r} = we()
      , a = D()
      , s = xw()
      , o = bw()
      , {pathname: l} = he()
      , {openModal: i} = q6()
      , c = Ghe()
      , {isPnlTrackerWidgetOpen: d, togglePnlTrackerWidget: u, isWatchlistWidgetOpen: p, toggleWatchlistWidget: h, isTrackedWalletsWidgetOpen: m, toggleTrackedWalletsWidget: g, isTwitterTrackerWidgetOpen: x, toggleTwitterTrackerWidget: b, isTrenchesWidgetOpen: f, toggleTrenchesWidget: k, isAlphaTrackerWidgetOpen: A, toggleAlphaTrackerWidget: w} = J6()
      , {setLastViewedMobileTrackerTab: j} = _H()
      , {openOverviewModal: T} = Iue()
      , I = y.useCallback(( () => {
        R && !s ? i(H6.WATCHLIST) : h()
    }
    ), [i, s, h])
      , E = ( () => {
        const e = me()
          , [t] = xe();
        return y.useCallback(( ({navigationOptions: n, keepSearchParams: r}) => {
            e({
                pathname: `${tT.TRACKER}`,
                search: r ? t.toString() : ""
            }, n)
        }
        ), [e, t])
    }
    )()
      , M = y.useCallback(( () => {
        if (R && !s) {
            if (j("WALLET_TRACKER"),
            l === tT.TRACKER)
                return;
            E({})
        } else
            g()
    }
    ), [E, l, j, s, g])
      , N = y.useCallback(( () => {
        if (R && !s) {
            if (j("X_TRACKER"),
            l === tT.TRACKER)
                return;
            E({})
        } else
            b()
    }
    ), [E, l, j, s, b])
      , {openModal: P, toggleIsNeeded: O} = dpe()
      , L = y.useMemo(( () => s ? v.jsx(Ee, {
        flexItem: !0,
        orientation: "vertical",
        sx: {
            my: .75
        }
    }) : null), [s]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            sx: obe,
            className: "padre-no-scroll",
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                divider: L,
                sx: lbe,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    height: "100%",
                    gap: .75,
                    divider: cbe,
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .75,
                        children: [v.jsx(Yxe, {}), v.jsx(tbe, {})]
                    }), c && v.jsx(ebe, {}), e && t && (R ? v.jsx(F, {
                        onClick: n,
                        sx: ibe,
                        children: "error" === t ? v.jsx(Ck, {
                            color: a.palette.error.main,
                            size: sbe
                        }) : v.jsx(wk, {
                            color: a.palette.warning.main,
                            size: sbe
                        })
                    }) : v.jsx(z, {
                        title: e,
                        children: v.jsx(C, {
                            minWidth: sbe,
                            display: "flex",
                            sx: {
                                "&:hover": {
                                    cursor: "help"
                                }
                            },
                            children: "error" === t ? v.jsx(Ck, {
                                color: a.palette.error.main,
                                size: sbe
                            }) : v.jsx(wk, {
                                color: a.palette.warning.main,
                                size: sbe
                            })
                        })
                    }))]
                }), s && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .75,
                    children: [v.jsx(Vxe, {
                        Icon: py,
                        label: r("Watchlist"),
                        isActive: (!R || s) && p,
                        onClick: I
                    }), v.jsx(Vxe, {
                        Icon: iy,
                        label: r("Wallets"),
                        isActive: (!R || s) && m,
                        onClick: M
                    }), v.jsx(Vxe, {
                        Icon: my,
                        label: r("PnL"),
                        isActive: (!R || s) && d,
                        onClick: u
                    }), v.jsx(Vxe, {
                        Icon: Mk,
                        label: r("Feed"),
                        isActive: (!R || s) && x,
                        onClick: N
                    }), v.jsx(Vxe, {
                        Icon: MS,
                        label: r("Trenches"),
                        isActive: !R && f,
                        onClick: k
                    }), v.jsx(Vxe, {
                        Icon: uy,
                        label: r("Alpha"),
                        isActive: !R && A,
                        onClick: w,
                        smallGap: !0
                    }), v.jsx(Vxe, {
                        Icon: Ey,
                        label: r("Price Alerts"),
                        isActive: !1,
                        onClick: T,
                        smallGap: !0
                    }), v.jsx(Vxe, {
                        Icon: sS,
                        label: r("News"),
                        isActive: !1,
                        onClick: P,
                        onMouseEnter: O
                    })]
                }), v.jsx(wxe, {})]
            }), s && v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.25,
                height: abe,
                children: [o && v.jsxs(v.Fragment, {
                    children: [v.jsx(Oxe, {}), v.jsx(Ee, {
                        flexItem: !0,
                        orientation: "vertical",
                        sx: dbe
                    })]
                }), v.jsx(aE, {
                    iconSize: rbe,
                    Icon: TS,
                    link: "https://docs.padre.gg/",
                    showTooltip: !0
                }), v.jsx(aE, {
                    iconSize: rbe,
                    Icon: Mk,
                    link: "https://twitter.com/PadreApp",
                    showTooltip: !0
                }), v.jsx(aE, {
                    iconSize: rbe,
                    Icon: PS,
                    link: "https://discord.gg/padreapp",
                    showTooltip: !0
                }), v.jsx(Lxe, {})]
            })]
        })
    })
}
))
  , rbe = 14
  , abe = 28
  , sbe = 14
  , obe = {
    pl: 1.25,
    pr: {
        xs: .75,
        sm: 1.25
    },
    py: .5,
    gap: 1,
    height: 28,
    overflowY: "hidden",
    overflowX: "scroll"
}
  , lbe = {
    gap: 1,
    height: abe,
    width: "100%",
    justifyContent: {
        xs: "space-between",
        sm: "flex-start"
    }
}
  , ibe = {
    p: 0
}
  , cbe = v.jsx(Ee, {
    flexItem: !0,
    orientation: "vertical",
    sx: {
        mr: .25,
        my: .75
    }
})
  , dbe = {
    my: .75
}
  , ube = ({includeOffset: e}={
    includeOffset: !0
}) => {
    const t = xw()
      , n = bw()
      , {hideBottomBar: r} = Phe()
      , a = bxe();
    return y.useMemo(( () => {
        if (r)
            return 0;
        const s = e ? a : 0;
        return n ? 28 + s : t ? pbe + s : hbe + s
    }
    ), [r, n, e, a, t])
}
  , pbe = 79
  , hbe = 51
  , mbe = y.memo(( () => {
    const e = me()
      , {mobileNavigationOrder: t} = rf()
      , {lastViewedPortfolioTab: n} = _H()
      , {currentPath: r} = Phe()
      , [a,s] = y.useState("");
    y.useEffect(( () => {
        r && r !== a && s(r)
    }
    ), [r, a]);
    const o = y.useMemo(( () => ( (e, t) => sT(oT.map((t => rT(e).find((e => e.path === t)))).filter((e => !!e)), t))(n, t)), [n, t]);
    return v.jsx(C, {
        "data-testid": "bottom-bar",
        height: 51,
        component: "footer",
        display: "flex",
        position: "relative",
        sx: xbe,
        children: v.jsx(ot, {
            value: !(!r || !gbe(r, o)) && r,
            onChange: (e, t) => {
                s(t)
            }
            ,
            sx: {
                width: "100%"
            },
            TabIndicatorProps: {
                style: {
                    top: 0,
                    bottom: "unset"
                }
            },
            children: o.map((t => {
                if (!t.showInBottomBar)
                    return null;
                const {path: n, label: a, Icon: s} = t;
                return v.jsx(lt, {
                    onClick: () => {
                        r !== n && e(n)
                    }
                    ,
                    label: a,
                    icon: v.jsx(s, {
                        fontSize: "small",
                        color: "inherit"
                    }),
                    value: n,
                    sx: {
                        minHeight: 51,
                        color: "text.label",
                        fontSize: 12,
                        py: 0
                    },
                    disableRipple: !0,
                    disableTouchRipple: !0
                }, n)
            }
            ))
        })
    })
}
))
  , gbe = (e, t) => t.some((t => t.path === e && t.showInBottomBar))
  , xbe = e => ({
    zIndex: 1200,
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    backgroundColor: e.palette.background.primary
})
  , bbe = y.memo(( () => {
    const e = xw()
      , t = bw()
      , n = bxe()
      , r = ( () => {
        const e = y.useCallback((e => Om.subscribeGlobalMessage(e)), []);
        return yx(e)
    }
    )()
      , [a,s] = y.useState(!1)
      , o = y.useCallback(( () => {
        s(!1)
    }
    ), [])
      , l = y.useCallback(( () => {
        s((e => !e))
    }
    ), [])
      , i = y.useMemo(( () => e => ({
        pb: `${n}px`,
        borderTop: t ? `1px solid ${e.palette.background.borderMain}` : "none"
    })), [n, t]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(gxe, {
            message: (null == r ? void 0 : r.value) ?? null,
            color: (null == r ? void 0 : r.color) ?? null,
            onHideCallback: o,
            forceOpen: a
        }), v.jsxs(C, {
            position: "fixed",
            bottom: e ? 0 : n,
            width: "100%",
            children: [!t && v.jsx(mbe, {}), e && v.jsx(C, {
                sx: i,
                children: v.jsx(nbe, {
                    message: (null == r ? void 0 : r.value) ?? null,
                    color: (null == r ? void 0 : r.color) ?? null,
                    toggleForceOpenGlobalMessage: l
                })
            })]
        })]
    })
}
));
var fbe = (e => (e.LOADING = "LOADING",
e.REFRESH_PAGE = "REFRESH_PAGE",
e.SIGN_IN = "SIGN_IN",
e.SETUP_VELVET = "SETUP_VELVET",
e.HANDLE_INITIALIZE_USER = "HANDLE_INITIALIZE_USER",
e.ALL_SET = "ALL_SET",
e))(fbe || {});
const vbe = () => {
    const {user: e, loading: t} = VK()
      , {hasApiAuthenticator: n, apiStamper: r, isContextLoading: a} = YT()
      , {state: s, wallets: o, hiddenWallets: l} = UD((e => e))
      , i = ((null == o ? void 0 : o.length) || (null == l ? void 0 : l.length) || 0) > 0;
    return t ? "LOADING" : e ? a || s === BD.INITIALIZING ? "LOADING" : n && !r ? "SETUP_VELVET" : i || n && r ? s === BD.ERROR ? "REFRESH_PAGE" : s !== BD.READY ? "HANDLE_INITIALIZE_USER" : "ALL_SET" : "SETUP_VELVET" : "SIGN_IN"
}
  , Sbe = "rk"
  , ybe = "padreV2-referredBy"
  , kbe = "padreV2-referredBy-hack";
function Cbe(e) {
    return (null == e ? void 0 : e.toLowerCase().trim()) ?? null
}
const Abe = e => {
    localStorage.setItem(ybe, Cbe(e))
}
  , wbe = "v1migrate"
  , jbe = "padreV2-v1migration"
  , Tbe = e => {
    localStorage.setItem(jbe, e)
}
  , Ibe = () => {
    localStorage.removeItem(jbe)
}
  , Ebe = () => {
    const e = ( () => {
        const e = pK()
          , {closeSnackbar: t} = ft()
          , n = y.useRef(null);
        return y.useCallback(( () => {
            n.current && t(n.current),
            n.current = e({
                variant: lK.NEW_APP_VERSION
            }, "", {
                persist: !0
            })
        }
        ), [e, t])
    }
    )()
      , t = XG;
    return y.useCallback(( (n, r) => {
        const [a] = n.split(".")
          , [s] = r.split(".");
        return a === s ? e : t
    }
    ), [e, t])
}
  , Mbe = () => {
    const e = ( () => {
        const e = y.useCallback((e => Om.subscribeAppVersion(e)), []);
        return yx(e)
    }
    )()
      , [t,n] = ux("padreV2-appVersion", null)
      , r = Ebe();
    y.useEffect(( () => {
        e && e.version !== t && (t && r(e.version, t)(),
        n(e.version))
    }
    ), [e, t, n, r])
}
  , Nbe = y.memo(( ({hasTopBar: e=!1, hasBottomBar: t=!1, requiresAccountReady: n=!1, children: r}) => {
    const a = ube()
      , s = lxe()
      , {colorSkin: o, defaultThemeSkin: l} = Vb()
      , {trackedWalletsDock: i, isTrackedWalletsWidgetOpen: c, toggleTrackedWalletsWidget: d, onTrackedWalletsUndock: u, twitterTrackerDock: p, isTwitterTrackerWidgetOpen: h, toggleTwitterTrackerWidget: m, onTwitterTrackerUndock: g, trenchesDock: x, isTrenchesWidgetOpen: b, isAlphaTrackerWidgetOpen: f, alphaTrackerDock: k, onAlphaTrackerUndock: C, toggleAlphaTrackerWidget: A} = J6()
      , {pathname: w, search: j, hash: T} = he()
      , {registerReferralCode: I} = hf();
    Mbe();
    const E = vbe()
      , M = y.useMemo(( () => e => ({
        background: w.startsWith(tT.TRADE) ? e.palette.background.primary : zhe(e, o, l),
        [`.${Lbe}`]: {
            background: e.palette.divider,
            position: "relative",
            width: "3px",
            height: "100%",
            transition: "background 100ms ease",
            zIndex: zw,
            "&::before": {
                content: '""',
                position: "absolute",
                top: "50%",
                left: "3px",
                transform: "translate(-50%, -50%)",
                width: "1px",
                height: "20px",
                background: e.palette.text.label,
                zIndex: 1239
            },
            "&:hover": {
                background: e.palette.text.primary
            }
        }
    })), [o, l, w]);
    if (n && E !== fbe.ALL_SET && E !== fbe.LOADING && !w.startsWith(tT.SIGN_IN)) {
        const e = new URLSearchParams(j)
          , t = Cbe(e.get(Sbe));
        I(t);
        const n = e.get(wbe) || null;
        e.delete(Sbe),
        e.delete(wbe);
        const r = [w, e.toString(), T].filter(Boolean).join("")
          , a = j.includes(lT) ? `${tT.SIGN_IN}${j}${T}` : `${tT.SIGN_IN}?${ge({
            [lT]: r,
            ...t ? {
                [Sbe]: t
            } : {},
            ...n ? {
                [wbe]: n
            } : {}
        })}`;
        return v.jsx(T$e, {
            path: a
        })
    }
    const N = b && w !== tT.TRENCHES;
    return v.jsxs(v.Fragment, {
        children: [e && v.jsx(cxe, {}), v.jsx(S, {
            height: "100%",
            pt: e ? `${s}px` : 0,
            pb: t ? `${a}px` : 0,
            sx: M,
            children: v.jsxs($n, {
                direction: "horizontal",
                autoSaveId: "padreV2-widgetsDockPanesV3",
                children: [N && x === K6.LEFT && v.jsxs(v.Fragment, {
                    children: [v.jsx(Gn, {
                        id: "trenches-left",
                        order: 1,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(ace, {})
                    }), v.jsx(qn, {
                        className: Lbe
                    })]
                }), f && k === K6.LEFT && v.jsxs(v.Fragment, {
                    children: [v.jsx(Gn, {
                        id: "alpha-tracker-left",
                        order: 2,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(Ece, {
                            closeTrackedWalletsWidget: A,
                            onUndock: C
                        })
                    }), v.jsx(qn, {
                        className: Lbe
                    })]
                }), h && p === K6.LEFT && v.jsxs(v.Fragment, {
                    children: [v.jsx(Gn, {
                        id: "twitter-tracker-left",
                        order: 3,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(kee, {
                            closeTwitterTrackerWidget: m,
                            onUndock: g
                        })
                    }), v.jsx(qn, {
                        className: Lbe
                    })]
                }), c && i === K6.LEFT && v.jsxs(v.Fragment, {
                    children: [v.jsx(Gn, {
                        id: "tracked-wallets-left",
                        order: 4,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(V9, {
                            closeTrackedWalletsWidget: d,
                            onUndock: u
                        })
                    }), v.jsx(qn, {
                        className: Lbe
                    })]
                }), v.jsx(Gn, {
                    id: "main-page",
                    order: 5,
                    defaultSize: 100,
                    minSize: 30,
                    children: v.jsx(S, {
                        height: "100%",
                        children: r
                    })
                }), c && i === K6.RIGHT && v.jsxs(v.Fragment, {
                    children: [v.jsx(qn, {
                        className: Lbe
                    }), v.jsx(Gn, {
                        id: "tracked-wallets-right",
                        order: 6,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(V9, {
                            closeTrackedWalletsWidget: d,
                            onUndock: u
                        })
                    })]
                }), h && p === K6.RIGHT && v.jsxs(v.Fragment, {
                    children: [v.jsx(qn, {
                        className: Lbe
                    }), v.jsx(Gn, {
                        id: "twitter-tracker-right",
                        order: 7,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(kee, {
                            closeTwitterTrackerWidget: m,
                            onUndock: g
                        })
                    })]
                }), f && k === K6.RIGHT && v.jsxs(v.Fragment, {
                    children: [v.jsx(qn, {
                        className: Lbe
                    }), v.jsx(Gn, {
                        id: "alpha-tracker-right",
                        order: 8,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(Ece, {
                            closeTrackedWalletsWidget: A,
                            onUndock: C
                        })
                    })]
                }), N && x === K6.RIGHT && v.jsxs(v.Fragment, {
                    children: [v.jsx(qn, {
                        className: Lbe
                    }), v.jsx(Gn, {
                        id: "trenches-right",
                        order: 9,
                        defaultSize: Obe,
                        minSize: Pbe,
                        children: v.jsx(ace, {})
                    })]
                })]
            })
        }), t && v.jsx(bbe, {})]
    })
}
))
  , Pbe = 15
  , Obe = 20
  , Lbe = "resize-handle-class"
  , Rbe = y.memo(( () => {
    const {hideBottomBar: e, hideHeader: t, requiresAccountReady: n} = Phe()
      , {pathname: r} = he()
      , {setCurrentPathname: a} = Nhe();
    y.useEffect(( () => {
        a(r)
    }
    ), [r, a]);
    const s = y.useMemo(( () => v.jsx(bG, {
        isActive: !t,
        children: v.jsx(Nbe, {
            hasTopBar: !t,
            hasBottomBar: !e,
            requiresAccountReady: n,
            children: v.jsx(Kn, {})
        })
    })), [t, e, n]);
    return v.jsx(SA, {
        children: v.jsx(hw, {
            children: v.jsx(Ow, {
                children: v.jsx(mU, {
                    children: v.jsx(n6, {
                        children: v.jsx($D, {
                            children: v.jsx(UJ, {
                                children: v.jsx(Vce, {
                                    children: v.jsx($6, {
                                        children: v.jsx(ipe, {
                                            children: v.jsx(dI, {
                                                children: v.jsx(kD, {
                                                    children: v.jsx(tH, {
                                                        children: v.jsx(zJ, {
                                                            children: v.jsx(cH, {
                                                                contextId: "outerConfig",
                                                                children: v.jsx(dH, {
                                                                    contextId: "trenchesExtra",
                                                                    children: v.jsx(XJ, {
                                                                        contextId: "outerConfig",
                                                                        children: v.jsx(QJ, {
                                                                            contextId: "trenchesExtra",
                                                                            children: v.jsx(kne, {
                                                                                children: v.jsx(mne, {
                                                                                    children: v.jsx(eq, {
                                                                                        children: v.jsx(Dce, {
                                                                                            children: v.jsx(Rce, {
                                                                                                children: v.jsx(The, {
                                                                                                    disabled: !n,
                                                                                                    children: v.jsx(Kpe, {
                                                                                                        children: s
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    })
}
))
  , Dbe = ({onDrag: e, onDragStart: t, onDragEnd: n, getHandleWrapperSx: r, pane: a, isActive: s, vertical: o}) => {
    const l = y.useRef(null);
    return v.jsx(Yn, {
        onDrag: e,
        onStart: t,
        onStop: n,
        nodeRef: l,
        children: v.jsx(C, {
            sx: r(!!a.isHandleReversed),
            ref: l,
            children: v.jsx(Ee, {
                sx: s ? Bbe : _be,
                orientation: o ? "horizontal" : "vertical"
            })
        })
    })
}
  , Bbe = e => ({
    borderColor: e.palette.background.borderActive,
    borderBottomWidth: 1,
    borderRightWidth: 1
})
  , _be = e => ({
    borderColor: e.palette.background.borderMain,
    borderBottomWidth: 1,
    borderRightWidth: 1
})
  , Ube = ({storageKey: e, panes: t, vertical: n, reversed: r, forceInitialSize: a=!1, maxHeightLast: s=!1}) => {
    const [o,l] = y.useState(void 0)
      , i = y.useRef(null)
      , [d,u] = y.useState(zbe(t))
      , [p,h] = y.useState(Hbe(t));
    y.useEffect(( () => {
        h((e => {
            const n = Hbe(t);
            return c.isEqual(n, e) ? e : n
        }
        )),
        u((e => {
            const n = zbe(t);
            return c.isEqual(n, e) ? e : n
        }
        ))
    }
    ), [t]),
    y.useEffect(( () => {
        const e = new ResizeObserver(( () => {
            var e;
            const t = null == (e = i.current) ? void 0 : e.getBoundingClientRect();
            t && l(n ? t.height : t.width)
        }
        ));
        return i.current && e.observe(i.current),
        () => {
            e.disconnect()
        }
    }
    ), [n]);
    const [m,g] = dx(e, Wbe(t.length - 1, p, a));
    y.useEffect(( () => {
        !m.length && t.length > 1 && p.length >= t.length && g(Wbe(t.length - 1, p))
    }
    ), [m, t, p, g]);
    const [x,b] = y.useState(Wbe(t.length - 1, m || p));
    y.useEffect(( () => {
        b((e => {
            if (!o)
                return e;
            const n = m.map(( (n, r) => {
                const a = e[r]
                  , s = d[r] || Vbe
                  , l = Array.from(Array(t.length)).reduce(( (e, t, n) => {
                    if (n === r)
                        return e;
                    return e + (m[n] ?? d[n] ?? Vbe)
                }
                ), 0)
                  , i = Math.max(o, c.sum(d)) - l;
                return c.isNil(n) ? c.isNil(a) ? a : Fbe(a, s, i) : Fbe(n, s, i)
            }
            ));
            return c.isEqual(n, e) ? e : n
        }
        ))
    }
    ), [b, m, t.length, o, d]);
    const f = y.useCallback((e => (t, a) => {
        R || t.preventDefault(),
        g((t => {
            if (!o)
                return t;
            let s = Math.max(o, c.sum(d)) - c.sum(t.slice(0, e));
            const l = [...t]
              , i = t[e] ?? 0
              , u = Math.max(0, i + (n ? r ? -a.deltaY : a.deltaY : r ? -a.deltaX : a.deltaX))
              , p = d.slice(e + 1)
              , h = d[e] ?? Vbe;
            l[e] = Fbe(u, h, s - c.sum(p));
            for (let n = e + 1; n < t.length; n++) {
                s -= l[n - 1] || 0;
                const e = d.slice(n + 1);
                l[n] = Fbe(l[n] ?? d[n] ?? Vbe, d[n] ?? Vbe, s - c.sum(e))
            }
            return c.isEqual(l, t) ? t : l
        }
        ))
    }
    ), [g, o, d, n, r])
      , [k,A] = y.useState(!1)
      , w = y.useCallback(( () => {
        A(!0)
    }
    ), [])
      , j = y.useCallback(( () => {
        A(!1)
    }
    ), [])
      , T = y.useMemo(( () => n ? "row-resize" : "col-resize"), [n])
      , I = D()
      , E = y.useMemo(( () => e => ( ({vertical: e, activeCursorName: t, dividerColor: n, handleColor: r, highlightColor: a, reversed: s}) => {
        const o = "100ms ease";
        return {
            "&.MuiBox-root": {
                position: "relative",
                zIndex: 2,
                cursor: t,
                color: n,
                transition: `color ${o}`,
                "&:before, &:after": {
                    content: '""',
                    position: "absolute"
                },
                "&:before": {
                    color: "inherit",
                    transform: `translate(${e ? "-50%, 0" : "0, -50%"})`,
                    backgroundColor: "currentColor",
                    opacity: 0,
                    ...e ? {
                        ...s ? {
                            bottom: "50%"
                        } : {
                            top: "50%"
                        },
                        left: "50%",
                        borderRadius: s ? "8px 8px 0 0" : "0 0 8px 8px",
                        width: "52px",
                        height: "20px"
                    } : {
                        ...s ? {
                            right: "50%"
                        } : {
                            left: "50%"
                        },
                        top: "50%",
                        borderRadius: s ? "8px 0 0 8px" : "0 8px 8px 0",
                        width: "20px",
                        height: "52px"
                    },
                    transition: `opacity ${o}}`
                },
                "&:after": {
                    content: '""',
                    position: "absolute",
                    color: r,
                    backgroundColor: "currentColor",
                    ...e ? {
                        ...s ? {
                            bottom: 3
                        } : {
                            top: 3
                        },
                        left: "50%",
                        width: "20px",
                        height: "1px",
                        transform: "translateX(-50%)"
                    } : {
                        top: "50%",
                        ...s ? {
                            right: 3
                        } : {
                            left: 3
                        },
                        width: "1px",
                        height: "20px",
                        transform: "translateY(-50%)"
                    }
                },
                "&:hover": {
                    "&, &:after": {
                        color: a
                    },
                    "&:before": {
                        opacity: .1
                    }
                }
            }
        }
    }
    )({
        reversed: e,
        vertical: !!n,
        activeCursorName: T,
        dividerColor: I.palette.divider,
        handleColor: I.palette.text.meta,
        highlightColor: I.palette.text.primary
    })), [n, T, I.palette.divider, I.palette.text]);
    return v.jsx(S, {
        ref: i,
        height: "100%",
        width: "100%",
        direction: n ? r ? "column-reverse" : "column" : r ? "row-reverse" : "row",
        sx: {
            cursor: k ? T : void 0,
            ...k ? {
                zIndex: 1241,
                "&::before": {
                    zIndex: zw,
                    content: "''",
                    position: "fixed",
                    inset: 0
                }
            } : {}
        },
        alignItems: "stretch",
        children: t.map(( (e, r) => {
            const a = r >= t.length - 1
              , o = f(r)
              , l = x[r] ?? void 0
              , i = a && null == l ? t[r].size : l
              , d = {
                ...c.isNil(i) || a ? {
                    flexGrow: 1,
                    flexBasis: "1px"
                } : {},
                overflow: "hidden",
                sx: {
                    position: "relative",
                    display: "flex",
                    flexDirection: "column"
                }
            };
            return v.jsxs(y.Fragment, {
                children: [v.jsx(C, {
                    ...d,
                    style: n ? {
                        height: s && r === t.length - 1 ? "100%" : i,
                        maxHeight: s && r === t.length - 1 ? "100%" : i
                    } : {
                        width: i
                    },
                    children: e.content
                }), r < t.length - 1 && v.jsx(Dbe, {
                    onDrag: o,
                    onDragStart: w,
                    onDragEnd: j,
                    getHandleWrapperSx: E,
                    pane: e,
                    vertical: n,
                    isActive: k
                })]
            }, r)
        }
        ))
    })
}
  , Wbe = (e, t=[], n=!1) => 0 === e && n ? t.length ? [t[0] ?? null] : [] : Array.from(Array(e)).fill(null).map(( (e, n) => {
    const r = t[n];
    return c.isNil(r) ? e : r ?? null
}
))
  , Fbe = (e, t, n) => Math.max(t, Math.min(n, e))
  , Vbe = 100
  , Hbe = e => e.map(( ({size: e}) => e ?? null))
  , zbe = e => e.map(( ({minSize: e}) => e ?? Vbe))
  , $be = y.createContext({
    hasChartRendered: !1,
    setHasChartRendered: c.noop
});
$be.displayName = "TradePageContext";
const Gbe = ({children: e}) => {
    const [t,n] = y.useState(!1)
      , r = y.useMemo(( () => ({
        hasChartRendered: t,
        setHasChartRendered: n
    })), [t, n]);
    return v.jsx($be.Provider, {
        value: r,
        children: e
    })
}
  , qbe = () => y.useContext($be)
  , Kbe = 1.5
  , Ybe = (e, t) => K8(t, e ? "minmax(215px, 1fr) repeat(4, 85px) 200px" : "minmax(235px, 1fr) repeat(4, 100px) 200px 120px", e ? "minmax(215px, 1fr) repeat(3, 85px) 200px" : "minmax(235px, 1fr) repeat(3, 100px) 200px 120px")
  , Xbe = (e, t) => K8(t, e ? 845 : 1070, e ? 760 : 970)
  , Qbe = y.memo(( ({compact: e, chain: t}) => {
    const {t: n} = we()
      , r = y.useMemo(( () => n => ({
        borderBottom: `1px solid ${n.palette.background.borderMain}`,
        pl: Kbe,
        pr: 2.75,
        height: e ? 32 : 48,
        minHeight: e ? 32 : 48,
        gap: 1,
        minWidth: Xbe(e, t)
    })), [t, e])
      , a = y.useMemo(( () => Ybe(e, t)), [e, t])
      , s = y.useMemo(( () => (e ? Jbe : efe).filter((e => t === Pd.SOLANA || !Zbe.has(e)))), [t, e]);
    return v.jsx(C, {
        position: "sticky",
        top: 0,
        zIndex: 3,
        display: "grid",
        gridTemplateColumns: a,
        alignItems: "center",
        sx: r,
        children: s.map(( (t, r) => v.jsx(C, {
            display: "flex",
            children: v.jsx(k, {
                color: "text.label",
                variant: e ? "paragraph3" : "paragraph1",
                children: t ? n(t) : ""
            })
        }, r)))
    })
}
))
  , Zbe = new Set(["Liquidity"])
  , Jbe = ["Pair info", "Market Cap", "Liquidity", "Volume", "Txns", "Token info"]
  , efe = [...Jbe, ""]
  , tfe = y.memo(( ({interactiveTooltipCallback: e, compact: t, ...n}) => {
    const r = D()
      , a = y.useMemo(( () => ({
        chain: Pd.SOLANA,
        tokenAddress: n.tokenAddress,
        padreAvatarUrl: n.padreAvatarUrl,
        telegramUrl: n.telegramUrl || null,
        discordUrl: null,
        twitterUrl: n.twitterUrl || null,
        projectWebsiteUrl: n.projectWebsiteUrl || null,
        twitterReuse: n.twitterUsernameReuse ?? null,
        twitterLaunchMetadata: null
    })), [n.padreAvatarUrl, n.telegramUrl, n.tokenAddress, n.twitterUrl, n.projectWebsiteUrl, n.twitterUsernameReuse])
      , s = y.useMemo(( () => qee(n.type)), [n.type])
      , o = y.useMemo(( () => null !== n.translatedSymbol && n.translatedSymbol !== n.symbol || null !== n.translatedName && n.translatedName !== n.name), [n.name, n.symbol, n.translatedName, n.translatedSymbol]);
    return v.jsxs(C, {
        display: "flex",
        width: "100%",
        gap: 1.5,
        alignItems: "center",
        overflow: "clip",
        children: [s && v.jsx(C, {
            display: "flex",
            alignItems: "center",
            minWidth: t ? 32 : 56,
            height: (t ? 48 : 88) - 1,
            children: v.jsx(Ote, {
                name: n.name,
                tokenAddress: n.tokenAddress,
                avatarSize: t ? 32 : 56,
                progressBarGap: 2,
                padreAvatarUrl: n.padreAvatarUrl,
                isAvatarReused: !1,
                curveProgress: n.curveProgress,
                chain: Pd.SOLANA,
                hasBonded: null !== n.migrationTime,
                protocol: s,
                launchpad: n.type,
                launchpadAux: n.launchpadAux,
                shape: Pte.SQUARE,
                devAddress: n.devAddress,
                compact: t,
                isHidden: n.isHidden,
                isBlacklisted: n.isBlacklisted,
                isHandleBlacklisted: n.isHandleBlacklisted,
                twitterHandle: n.twitterHandle,
                trending: !0,
                protocolMarkerSize: t ? 15 : 19,
                protocolMarkerOffset: t ? 5 : 8,
                avatarGap: t ? 0 : 3,
                migrationHide: null !== n.migrationTime,
                protocolMarkerInnerIconSize: t ? 10 : 13,
                actionButtonSize: t ? c_.MINI : c_.NORMAL
            })
        }), v.jsxs(S, {
            gap: (t ? 0 : 1) + (o ? .75 : 0),
            children: [v.jsx(xle, {
                name: n.name,
                symbol: n.symbol,
                tokenAddress: n.tokenAddress,
                translatedName: n.translatedName,
                translatedSymbol: n.translatedSymbol,
                compact: t
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "flex-end",
                    mt: "2px",
                    children: [v.jsx(mE, {
                        ts: n.createdAt,
                        isShort: !0,
                        variant: "paragraph1",
                        overwriteColors: !0
                    }), n.bondedAt && v.jsx(ZS, {
                        size: 14,
                        color: r.palette.text.value
                    }), n.bondedAt && v.jsx(C, {
                        display: "flex",
                        mt: "-1px",
                        children: v.jsx(vf, {
                            size: 14,
                            color: r.palette.gold[500]
                        })
                    }), n.bondedAt && v.jsx(mE, {
                        ts: n.bondedAt,
                        isShort: !0,
                        variant: "paragraph1",
                        overwriteColors: !0
                    })]
                }), v.jsx(wR, {
                    isPermissioned: n.isPermissioned,
                    tokenAddress: n.tokenAddress,
                    showPumpfunLink: "pumpfun" === n.type,
                    showLaunchlabLink: "launchlab" === n.type,
                    showBoopLink: "boop" === n.type,
                    showBagsLink: "meteora-curve" === n.type && "bags" === n.launchpadAux,
                    showBelieveLink: "meteora-curve" === n.type && "believe" === n.launchpadAux,
                    showFourmemeLink: !1,
                    showBonkLink: "launchlab" === n.type && "bonk" === n.launchpadAux,
                    showDaosLink: "daos" === n.launchpadAux,
                    tokenSocials: a,
                    deployerAddress: n.devAddress,
                    preventDefault: !0,
                    omitTwitterSearch: !0,
                    omitAggregator: !0,
                    tooltipTitle: n.socialsReuse > 0 ? `Socials has been resued ${n.socialsReuse} time${n.socialsReuse > 1 ? "s" : ""}` : void 0,
                    iconSize: 16,
                    interactiveTooltipCallback: e,
                    pumpFunNewsArticleId: n.pumpFunNewsArticleId,
                    mayhemUntilTs: n.mayhemUntil ?? void 0,
                    isConfirmedBot: n.isConfirmedBot
                }), v.jsx(kle, {
                    address: n.tokenAddress,
                    marketAddress: n.meteoraAddress ?? n.pumpSwapAddress ?? n.raydiumAddress ?? n.pumpfunAddress,
                    Icon: cy
                })]
            })]
        })]
    })
}
))
  , nfe = y.memo(( ({fdvUsd: e, deltaPct: t, compact: n}) => {
    const {marketCapThresholds: r} = bA()
      , {fdvFormatted: a} = Xoe(null === e || isNaN(Number(e)) ? 0 : Number(e), 2, r);
    return v.jsxs(S, {
        gap: n ? .5 : .75,
        children: [v.jsx(k, {
            color: "text.value",
            variant: n ? "paragraph2" : "h2",
            children: a
        }), null !== t && v.jsx(k, {
            variant: "paragraph3",
            fontWeight: n ? 400 : 500,
            color: 0 == +t ? "text.value" : t > 0 ? "success.main" : "error.main",
            children: jI(t, {
                precision: 1
            })
        })]
    })
}
))
  , rfe = y.memo(( ({liquidityInUsd: e, compact: t}) => {
    const n = Qoe(null === e || isNaN(Number(e)) ? 0 : Number(e), 2);
    return v.jsx(k, {
        color: "text.value",
        variant: t ? "paragraph2" : "h2",
        children: null === e ? Ud : n
    })
}
))
  , afe = y.memo(( ({volume: e, compact: t}) => {
    const n = Qoe(null === e || isNaN(Number(e)) ? 0 : Number(e), 2);
    return v.jsx(k, {
        color: "text.value",
        variant: t ? "paragraph2" : "h2",
        children: null === e || isNaN(Number(e)) ? Ud : n
    })
}
))
  , sfe = y.memo(( ({totalTxns: e, sellTxns: t, buyTxns: n, compact: r}) => v.jsxs(S, {
    gap: r ? .5 : .75,
    children: [v.jsx(k, {
        color: "text.value",
        variant: r ? "paragraph2" : "h2",
        children: null === e ? Ud : LI(e, {
            collapseExponent: !0,
            desiredDigits: 2,
            noTrailingZeros: !0
        })
    }), null !== t && null !== n && v.jsxs(S, {
        direction: "row",
        gap: .5,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "success.main",
            fontWeight: r ? 400 : 500,
            children: LI(n, {
                collapseExponent: !0,
                desiredDigits: 2,
                noTrailingZeros: !0
            })
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            fontWeight: r ? 400 : 500,
            children: "/"
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "error.main",
            fontWeight: r ? 400 : 500,
            children: LI(t, {
                collapseExponent: !0,
                desiredDigits: 2,
                noTrailingZeros: !0
            })
        })]
    })]
})))
  , ofe = y.memo(( ({top10HoldingPcnt: e, wasRecentlyBoostedOnDexscreener: t, isDexscreenerPaid: n, dexBannerUrl: r, dexPaidAt: a, devHolding: s, devHoldingAth: o, devHoldingPcnt: l}) => {
    const {t: i} = we()
      , c = D()
      , d = n
      , u = t && n
      , p = y.useMemo(( () => v.jsxs(S, {
        gap: .25,
        children: [u && v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: i("Token boosted on dexscreener in the last 24h")
        }), d && v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "inherit",
                color: "inherit",
                children: i("Dex paid")
            }), a && v.jsx(mE, {
                ts: a,
                variant: "inherit",
                color: "inherit"
            })]
        }), v.jsx(uE, {
            bannerUrl: r
        })]
    })), [i, u, d, a, r])
      , h = y.useMemo(( () => {
        if (a && (u || d))
            return v.jsx(mE, {
                ts: a,
                variant: "paragraph3",
                color: u ? c.palette.gold[500] : d ? c.palette.success.main : c.palette.error.main
            })
    }
    ), [a, u, d, c.palette.error.main, c.palette.gold, c.palette.success.main])
      , m = y.useMemo(( () => 0 === s || !!(o && 100 * s < o)), [s, o]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        children: [v.jsx(tle, {
            color: Number(e.toFixed(0)) > lfe ? c.palette.error.main : c.palette.success.main,
            borderColor: c.palette.background.borderMain,
            Icon: Lv,
            formattedValue: jI(e, {
                omitSign: !0,
                precision: 0
            }),
            tooltipTitle: i("Top 10 holders"),
            iconSize: 14
        }), v.jsx(tle, {
            color: u ? c.palette.gold[500] : d ? c.palette.success.main : c.palette.error.main,
            borderColor: c.palette.background.borderMain,
            Icon: OS,
            formattedValue: u ? `${i("Boost")}${a ? ` ${hM} ` : ""}` : d ? `${i("Paid")}${a ? ` ${hM} ` : ""}` : i("Unpaid"),
            tooltipTitle: u || d ? p : void 0,
            suffix: h
        }), v.jsx(tle, {
            color: m ? c.palette.lavender[500] : c.palette.success.main,
            borderColor: c.palette.background.borderMain,
            Icon: Vv,
            formattedValue: m ? "DS" : jI(l, {
                omitSign: !0,
                precision: 0
            }),
            tooltipTitle: i(m ? "Dev sold" : "Dev holding")
        })]
    })
}
))
  , lfe = 15
  , ife = y.memo(( ({trenchesChain: e, ...t}) => {
    const n = pK()
      , {insufficientBalance: r, buttonDisplayValue: a, includeExitStrategies: s, selectedPreset: o, buttonValue: l} = (e => {
        const t = ZJ()
          , n = uH();
        return y.useMemo(( () => {
            switch (e) {
            case Pd.BSC:
                return {
                    ...t
                };
            case Pd.SOLANA:
                return {
                    ...n
                }
            }
        }
        ), [t, n, e])
    }
    )(e)
      , {performBuy: i, hasAnyWallet: d, selectedWalletsAddresses: u} = AD()
      , {performBuy: p, hasAnyWallet: h, selectedWalletsAddresses: m} = DJ()
      , g = y.useMemo(( () => K8(e, u, m)), [m, u, e])
      , x = y.useMemo(( () => K8(e, d, h)), [h, d, e])
      , {settings: b} = rf()
      , [f,S] = JC(!1, 200, !1)
      , [A,w] = y.useState(!1)
      , [j,T] = y.useState(!1)
      , I = j && !A
      , E = y.useCallback(( () => {
        T(!0)
    }
    ), [T])
      , M = y.useCallback(( () => {
        T(!1)
    }
    ), [T])
      , {exitStrategies: N} = KR()
      , P = y.useDeferredValue(t);
    y.useEffect(( () => {
        if (!I || !g.length)
            return;
        const n = K8(e, Gee(P), t.pancakeSwapAddress ?? t.fourMemeAddress ?? t.pumpfunAddress)
          , r = K8(e, qc, Wd);
        if (n) {
            const e = () => {
                c.forEach([...g].sort(), (e => {
                    toe({
                        chain: P.chain,
                        baseToken: P.tokenAddress,
                        poolAddress: n,
                        quoteToken: r,
                        walletAddress: e
                    })
                }
                ))
            }
            ;
            e();
            const t = setInterval(( () => {
                e()
            }
            ), 5e3);
            return () => {
                clearInterval(t)
            }
        }
    }
    ), [I, g, P, e, t.pancakeSwapAddress, t.fourMemeAddress, t.pumpfunAddress]);
    const O = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        e.stopPropagation())
    }
    ), [])
      , L = y.useMemo(( () => A ? "Buying" : `${(a ?? 0) > 1 ? LI(a ?? 0, {
        collapseExponent: (a ?? 0) > 1e6,
        symbol: "",
        padSymbol: !0,
        symbolPosition: yI.END,
        noTrailingZeros: !1,
        maxPrecision: 3
    }) : a ?? 0}`), [a, A])
      , R = y.useMemo(( () => {
        switch (e) {
        case Pd.BSC:
            {
                const n = t.pancakeSwapAddress ?? t.fourMemeAddress ?? t.pumpfunAddress;
                return fg(e, n, t.fourMemeAddress === n ? {
                    type: "fourmeme",
                    tokenAddress: t.tokenAddress
                } : null)
            }
        case Pd.SOLANA:
            return fg(Pd.SOLANA, Gee(t), null)
        }
    }
    ), [t, e]);
    k$(e === Pd.SOLANA ? R : null);
    const D = y.useCallback((async c => {
        np.info("Trending buy button clicked", {
            trenchesChain: e,
            buttonValue: l,
            tokenAddress: t.tokenAddress
        }),
        c.stopPropagation(),
        c.preventDefault();
        const d = {
            originWidget: Dp.TRENDING,
            selectedWalletsAmount: g.length,
            buttonValue: l,
            buttonDisplayValue: a,
            insufficientBalance: r,
            quoteTokenAddr: t.quoteTokenAddr,
            marketId: R
        };
        if (f || A)
            np.warn("Order hasn't been sent - loading", {
                orderInfo: d,
                isPerformingTrade: A,
                isDisabled: f
            });
        else {
            if (!g.length || !1 === x)
                return np.warn("Order hasn't been sent - no wallet selected", {
                    orderInfo: d
                }),
                void n({
                    message: uu.quickBuyNoWalletsSelected,
                    type: "warning"
                }, "no-wallets-error");
            if (!l || !a)
                return np.warn("Order hasn't been sent - missing button value", {
                    orderInfo: d
                }),
                void n({
                    message: uu.quickBuyIsZero,
                    type: "warning"
                }, "no-amount-error");
            if (r)
                return np.warn("Order hasn't been sent - insufficient balance", {
                    orderInfo: d
                }),
                void n({
                    message: uu.insufficientBalance,
                    type: "warning"
                }, "no-balance-error");
            w(!0),
            ((null == b ? void 0 : b.preventDoubleClick) ?? y$) && S(!0);
            try {
                switch (e) {
                case Pd.BSC:
                    if (zb(o))
                        throw new Error("Inferno mode on BSC not supported");
                    if (!t.quoteTokenAddr)
                        throw new Error("Missing quote currency on BSC");
                    if (!poe.has(t.quoteTokenAddr))
                        return np.warn("Order hasn't been sent - unsupported bsc quote", {
                            orderInfo: d
                        }),
                        void n({
                            message: uu.quickBuyNotAvailable,
                            type: "error"
                        }, "perform-trade-error");
                    await p({
                        value: l,
                        baseCurrency: t.tokenAddress,
                        poolQuoteCurrency: t.quoteTokenAddr,
                        baseSymbol: t.symbol,
                        quoteSymbol: "BNB",
                        marketId: R,
                        padreAvatarUrl: t.padreAvatarUrl,
                        presetName: o,
                        originWidget: Dp.TRENDING,
                        exitStrategies: s && N.length ? N : null
                    });
                    break;
                case Pd.SOLANA:
                    await i({
                        value: l,
                        baseCurrency: t.tokenAddress,
                        baseTokenType: t.tokenType,
                        poolQuoteCurrency: t.quoteTokenAddr ?? qc,
                        quoteForExecutionCurrency: qc,
                        baseSymbol: t.symbol,
                        quoteSymbol: "SOL",
                        marketId: R,
                        padreAvatarUrl: t.padreAvatarUrl,
                        presetName: o,
                        originWidget: Dp.TRENDING,
                        exitStrategies: s && N.length ? N : null
                    })
                }
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing order", {
                    e: fNe,
                    orderInfo: d
                })
            } finally {
                w(!1)
            }
        }
    }
    ), [f, A, g.length, x, l, a, r, null == b ? void 0 : b.preventDoubleClick, n, S, e, o, t.quoteTokenAddr, t.tokenAddress, t.symbol, t.padreAvatarUrl, t.tokenType, p, R, s, N, i]);
    return t.isPermissioned && !t.bondedAt ? null : v.jsx(GC, {
        title: 0 === g.length ? "No wallet selected" : r ? "Insufficient balance" : !1 === x ? "You don't have compatible wallets" : "",
        children: v.jsx(C, {
            component: "span",
            display: "flex",
            justifyContent: "flex-end",
            children: v.jsx(V, {
                tabIndex: -1,
                onKeyDown: O,
                variant: "secondary",
                size: "xsmall",
                color: "success",
                sx: dfe,
                fullWidth: !1,
                onClick: D,
                onMouseOver: E,
                onMouseOut: M,
                startIcon: A ? null : v.jsx(ay, {
                    color: "inherit",
                    size: 14
                }),
                endIcon: A ? v.jsx(J, {
                    color: "inherit",
                    size: cfe
                }) : null,
                children: v.jsx(k, {
                    noWrap: !0,
                    variant: "h2",
                    color: "inherit",
                    children: L
                })
            })
        })
    })
}
))
  , cfe = 16
  , dfe = e => {
    const t = e.palette.primary.main;
    return {
        zIndex: 10,
        color: An(t, "#fff") > 4.5 ? "#ffffff" : "#111111",
        transition: "none",
        borderRadius: 5,
        px: 2,
        minWidth: ufe,
        maxWidth: pfe,
        height: hfe,
        backgroundColor: t,
        borderColor: Me(t, .08),
        "&:hover": {
            borderColor: Me(t, .08),
            backgroundColor: Me(t, .15)
        },
        "&:focus": {
            borderColor: Me(t, .08),
            backgroundColor: Me(t, .15)
        },
        "&:disabled": {
            backgroundColor: e.palette.background.disabled,
            borderColor: e.palette.background.disabled,
            color: e.palette.text.label
        },
        "& .MuiButton-startIcon": {
            marginRight: "4px"
        }
    }
}
  , ufe = 105
  , pfe = 120
  , hfe = 32
  , mfe = y.memo(( ({isLast: e, interactiveTooltipCallback: t, trendingTimespan: n, hasScrollHandle: r, compact: a, trenchesChain: s, ...o}) => {
    const l = y.useMemo(( () => t => ({
        height: a ? 48 : 87,
        pl: Kbe,
        pr: Kbe + (r ? 0 : 1.25),
        gap: 1,
        alignItems: "center",
        borderBottom: `1px solid ${e ? "transparent" : t.palette.background.borderMain}`,
        "&:hover": {
            background: t.palette.background.buttonDefault,
            cursor: "pointer"
        }
    })), [a, r, e])
      , i = pT()
      , c = y.useMemo(( () => {
        const e = doe(o);
        return e ? vg(e) : null
    }
    ), [o])
      , d = y.useMemo(( () => QE(c, nT.TRENDING)), [c])
      , u = y.useCallback((e => {
        if (e.metaKey || e.ctrlKey)
            return void (d && window.open(d, "_blank"));
        if (e.preventDefault(),
        !c)
            return;
        const t = doe(o);
        t && mT.set(c, t),
        i({
            marketId: c,
            tradePageOrigin: nT.TRENDING
        })
    }
    ), [c, o, i, d])
      , p = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation();
        let t = e.target
          , n = null;
        for (; t && t !== e.currentTarget; ) {
            if ("A" === t.tagName && t.hasAttribute("reflink")) {
                n = t.getAttribute("reflink");
                break
            }
            if (t.hasAttribute("aria-label")) {
                const e = t.getAttribute("aria-label");
                if ((null == e ? void 0 : e.startsWith("http://")) || (null == e ? void 0 : e.startsWith("https://"))) {
                    n = e;
                    break
                }
            }
            t = t.parentElement
        }
        return n ? window.open(n, "_blank") : window.open(d, "_blank"),
        !1
    }
    ), [d])
      , h = y.useCallback((e => {
        Mn && 1 === e.button && e.preventDefault()
    }
    ), [])
      , {volume: m, buyTxns: g, sellTxns: x, totalTxns: b, deltaPct: f} = y.useMemo(( () => {
        if (!o.activityStats)
            return {
                volume: null,
                buyTxns: null,
                sellTxns: null,
                totalTxns: null,
                deltaPct: null
            };
        switch (n) {
        case Xte.M1:
            return {
                volume: o.activityStats.m1.volUsd,
                buyTxns: o.activityStats.m1.buys,
                sellTxns: o.activityStats.m1.sells,
                totalTxns: o.activityStats.m1.buys + o.activityStats.m1.sells,
                deltaPct: o.activityStats.m1.deltaPct
            };
        case Xte.M5:
            return {
                volume: o.activityStats.m5.volUsd,
                buyTxns: o.activityStats.m5.buys,
                sellTxns: o.activityStats.m5.sells,
                totalTxns: o.activityStats.m5.buys + o.activityStats.m5.sells,
                deltaPct: o.activityStats.m5.deltaPct
            };
        case Xte.M30:
            return {
                volume: o.activityStats.m30.volUsd,
                buyTxns: o.activityStats.m30.buys,
                sellTxns: o.activityStats.m30.sells,
                totalTxns: o.activityStats.m30.buys + o.activityStats.m30.sells,
                deltaPct: o.activityStats.m30.deltaPct
            };
        case Xte.H1:
            return {
                volume: o.activityStats.h1.volUsd,
                buyTxns: o.activityStats.h1.buys,
                sellTxns: o.activityStats.h1.sells,
                totalTxns: o.activityStats.h1.buys + o.activityStats.h1.sells,
                deltaPct: o.activityStats.h1.deltaPct
            }
        }
    }
    ), [o.activityStats, n])
      , S = y.useMemo(( () => Ybe(a, s)), [a, s]);
    return v.jsxs(C, {
        sx: l,
        display: "grid",
        gridTemplateColumns: S,
        component: "span",
        onClick: u,
        onAuxClick: p,
        onContextMenu: Mn ? Uw : p,
        onMouseDown: h,
        children: [v.jsx(tfe, {
            ...o,
            interactiveTooltipCallback: t,
            compact: a
        }), v.jsx(nfe, {
            fdvUsd: o.fdvInUsd,
            deltaPct: f,
            compact: a
        }), s === Pd.SOLANA && v.jsx(rfe, {
            liquidityInUsd: o.liquidityInUsd ?? null,
            compact: a
        }), v.jsx(afe, {
            volume: m,
            compact: a
        }), v.jsx(sfe, {
            totalTxns: b,
            buyTxns: g,
            sellTxns: x,
            compact: a
        }), v.jsx(ofe, {
            dexBannerUrl: o.dexBannerUrl,
            top10HoldingPcnt: o.top10HoldingPcnt,
            wasRecentlyBoostedOnDexscreener: o.wasRecentlyBoostedOnDexscreener,
            isDexscreenerPaid: o.isDexscreenerPaid,
            dexPaidAt: o.dexPaidAt,
            devHolding: o.devHolding,
            devHoldingAth: o.devHoldingAth,
            devHoldingPcnt: o.devHoldingPcnt
        }), !a && v.jsx(ife, {
            trenchesChain: s,
            ...o
        })]
    })
}
), ( (e, t) => e.volumeInUsd === t.volumeInUsd && c.isEqual(e, t)))
  , gfe = y.memo(( ({chain: e, trendingMode: t, gazeType: n, trendingTimespan: r, isPaused: a, setIsTooltipOpen: s, setIsHovering: o, compact: l=!1}) => {
    const {setTrendingSolFilters: i, trendingSolFilters: c, setTrendingBscFilters: d, trendingBscFilters: u, trendingSolNewFilters: p, setTrendingSolNewFilters: h, trendingBscNewFilters: m, setTrendingBscNewFilters: g, solDexFilters: x, setSolDexFilters: b, bscDexFilters: f, setBscDexFilters: A} = JX()
      , w = K8(e, i, d)
      , j = K8(e, c, u)
      , T = K8(e, h, g)
      , I = K8(e, p, m)
      , E = K8(e, b, A)
      , M = K8(e, x, f)
      , {hideMode: N} = xne()
      , {dexTrendingTimespan: P, newTrendingTimespan: O} = xne()
      , L = y.useMemo(( () => {
        switch (t) {
        case Yte.DEX:
            return P;
        case Yte.NEW:
            return O;
        default:
            return r
        }
    }
    ), [P, O, t, r])
      , {hiddenPairs: D, hiddenMigratedPairs: B} = SX()
      , {settings: _} = rf()
      , U = y.useMemo(( () => (null == _ ? void 0 : _.devBlacklist) ? new Set(_.devBlacklist) : new Set([])), [null == _ ? void 0 : _.devBlacklist])
      , W = y.useMemo(( () => (null == _ ? void 0 : _.handlesBlacklist) ? new Set(_.handlesBlacklist.map((e => e.toLowerCase()))) : new Set([])), [null == _ ? void 0 : _.handlesBlacklist])
      , F = mte(e === Pd.SOLANA ? n : null)
      , H = Ite(e === Pd.BSC ? n : null)
      , {i18n: z} = we()
      , $ = y.useMemo(( () => e === Pd.SOLANA && F.data ? _ee(F.data.orderedDisplayData, z.resolvedLanguage ?? null) : e === Pd.BSC && H.data ? Uee(H.data.orderedDisplayData, z.resolvedLanguage ?? null) : null), [z.resolvedLanguage, F, H, e])
      , G = y.useCallback((e => {
        if (j && M && I && w && E && T)
            switch (t) {
            case Yte.VOL_1M:
            case Yte.VOL_5M:
            case Yte.VOL_30M:
            case Yte.VOL_1H:
                w({
                    ...XX,
                    ...j,
                    TICKERS: [e]
                });
                break;
            case Yte.DEX:
                E({
                    ...XX,
                    ...M,
                    TICKERS: [e]
                });
                break;
            case Yte.NEW:
                T({
                    ...XX,
                    ...I,
                    TICKERS: [e]
                });
            case Yte.PUMP_LIVE:
            }
    }
    ), [t, w, j, E, M, T, I])
      , q = XM((e => e.registerTrenchesNewSearch));
    y.useEffect(( () => {
        const e = q(G);
        return () => {
            e()
        }
    }
    ), [G, q]);
    const K = y.useMemo(( () => ({
        onOpen: () => {
            s(!0)
        }
        ,
        onClose: () => {
            s(!1)
        }
    })), [s])
      , Y = y.useCallback(( () => {
        o(!0)
    }
    ), [o])
      , X = y.useCallback(( () => {
        o(!1)
    }
    ), [o])
      , Q = y.useCallback(( () => {
        R && o(!0)
    }
    ), [o])
      , Z = y.useCallback(( () => {
        R && o(!1)
    }
    ), [o])
      , J = y.useRef(null)
      , ee = y.useRef(null)
      , te = y.useRef([]);
    pM({
        target: J,
        onInteractionStart: Q,
        onInteractionStop: Z
    });
    const [ne,re] = y.useState(!1)
      , ae = y.useRef(0)
      , se = y.useCallback(( () => {
        if (!ee.current)
            return;
        const e = ee.current
          , t = ae.current
          , n = 0 - t
          , r = performance.now()
          , a = s => {
            const o = s - r
              , l = Math.min(o / ffe, 1)
              , i = t + n * l;
            e.scrollToPosition(i),
            l < 1 && requestAnimationFrame(a)
        }
        ;
        requestAnimationFrame(a)
    }
    ), [])
      , oe = y.useCallback(( ({scrollTop: e}) => {
        re(e > bfe),
        0 === e && R && X(),
        ae.current = e
    }
    ), [X]);
    y.useEffect(( () => {
        a && te.current.length || (te.current = $ || [])
    }
    ), [a, $]);
    const le = y.useCallback((e => {
        e.stopPropagation(),
        se()
    }
    ), [se])
      , ie = y.useCallback((e => {
        const t = e.currentTarget
          , n = e.clientX - t.getBoundingClientRect().left + t.scrollLeft;
        t.scrollWidth - n > Sfe ? Y() : X()
    }
    ), [Y, X])
      , ce = y.useCallback(( () => {
        o(!1)
    }
    ), [o])
      , de = y.useMemo(( () => {
        const t = a && te.current.length ? Wee($ ?? [], te) : $;
        return N !== sne.SHOW_ALL && (D || U.size || W.size) ? t ? t.filter((t => {
            if (U.has(t.devAddress))
                return !1;
            if (t.twitterHandle && W.has(t.twitterHandle.toLowerCase()))
                return !1;
            const n = kX(t.tokenAddress, e)
              , r = null !== t.migrationTime;
            return N !== sne.HIDE && r ? N !== sne.SHOW_MIGRATED || (!B || !B[n]) : !D || !D[n]
        }
        )) : null : $ee(t, D, U, W, e)
    }
    ), [e, a, $, D, U, B, N, W])
      , ue = y.useMemo(( () => e => ({
        background: e.palette.background.secondary,
        flex: 1,
        height: 88,
        ...l ? {
            borderTop: `1px solid ${e.palette.background.borderMain}`,
            borderBottom: `1px solid ${e.palette.background.borderMain}`
        } : {
            border: `1px solid ${e.palette.background.borderMain}`
        },
        borderRadius: l ? 0 : 2,
        overflowY: "scroll",
        overflowX: "scroll",
        maxWidth: "100%"
    })), [l])
      , pe = y.useRef(null)
      , [he,me] = y.useState(null);
    y.useEffect(( () => {
        if (!pe.current)
            return;
        const e = () => {
            var e;
            me((null == (e = pe.current) ? void 0 : e.offsetHeight) ?? null)
        }
        ;
        e();
        const t = new ResizeObserver(( () => {
            e()
        }
        ));
        return t.observe(pe.current),
        () => {
            t.disconnect()
        }
    }
    ), []);
    const ge = y.useMemo(( () => !(!he || !(null == de ? void 0 : de.length)) && de.length * (l ? 48 : 88) + (l ? 32 : 48) - 2 >= he), [l, he, null == de ? void 0 : de.length]);
    return v.jsxs(S, {
        ref: pe,
        position: "relative",
        sx: ue,
        className: "padre-no-scroll",
        children: [v.jsx(Qbe, {
            compact: l,
            chain: e
        }), v.jsx(S, {
            ref: J,
            height: `calc(100% - ${l ? 32 : 47}px)`,
            onMouseMove: ie,
            onMouseLeave: ce,
            children: de ? de.length ? v.jsx(mt, {
                children: ({height: t, width: n}) => v.jsx(gt, {
                    ref: e => {
                        ee.current = e
                    }
                    ,
                    className: "padre-decorative-scroll",
                    height: t,
                    width: Math.max(Xbe(l, e), n),
                    rowHeight: l ? 48 : 88,
                    rowCount: de.length,
                    rowRenderer: ({index: t, style: n}) => {
                        const r = de[t];
                        return v.jsx("div", {
                            style: n,
                            children: v.jsx(mfe, {
                                interactiveTooltipCallback: K,
                                isLast: t === de.length - 1,
                                trendingTimespan: L,
                                hasScrollHandle: ge,
                                compact: l,
                                trenchesChain: e,
                                ...r
                            })
                        }, Bee(r))
                    }
                    ,
                    overscanRowCount: 2,
                    onScroll: oe,
                    cellRangeRenderer: Ete
                })
            }) : v.jsx(S, {
                width: "100%",
                height: "100%",
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: "No data to show"
                })
            }) : v.jsx(Km, {})
        }), ne && v.jsx(S, {
            position: "absolute",
            bottom: 20,
            left: `calc(50% - ${xfe / 2}px)`,
            children: v.jsxs(V, {
                tabIndex: -1,
                onClick: le,
                size: "small",
                variant: "tertiary",
                sx: vfe,
                children: [v.jsx(C, {
                    display: "flex",
                    mt: "1px",
                    children: v.jsx(Rv, {
                        size: 18
                    })
                }), v.jsx(k, {
                    variant: "paragraph1",
                    children: "Back to top"
                })]
            })
        })]
    })
}
))
  , xfe = 120
  , bfe = 100
  , ffe = 500
  , vfe = e => ({
    display: "flex",
    backgroundColor: e.palette.background.primary,
    width: xfe,
    height: 32,
    opacity: .9,
    gap: 1,
    alignItems: "center",
    pr: 1,
    pl: .75,
    borderRadius: 2,
    "&focus, &:hover": {
        backgroundColor: e.palette.background.buttonDefault
    }
})
  , Sfe = 15;
var yfe = (e => (e.MC_DESC = "MC_DESC",
e.TIME_DESC = "TIME_DESC",
e))(yfe || {});
const kfe = {
    [Xte.M1]: Yte.VOL_1M,
    [Xte.M5]: Yte.VOL_5M,
    [Xte.M30]: Yte.VOL_30M,
    [Xte.H1]: Yte.VOL_1H
}
  , Cfe = yfe.TIME_DESC
  , Afe = (e, t) => {
    switch (e) {
    case Yte.VOL_1M:
        return "vol1m";
    case Yte.VOL_5M:
        return "vol5m";
    case Yte.VOL_30M:
        return "vol30m";
    case Yte.VOL_1H:
        return "vol1h";
    case Yte.DEX:
        return "dex-update";
    case Yte.NEW:
        return "trending-new";
    case Yte.PUMP_LIVE:
        if (null === t)
            return null;
        switch (t) {
        case yfe.MC_DESC:
            return "live-pf-highest-mc";
        case yfe.TIME_DESC:
            return "live-pf-latest"
        }
    }
}
  , wfe = y.memo(( ({marketId: e, ...t}) => {
    const {removeFromHistory: n} = fz()
      , r = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        e && n(e)
    }
    ), [e, n]);
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            justifyContent: "flex-end",
            ...t.sxProps || {}
        },
        children: e && v.jsx(F, {
            onClick: r,
            sx: Tfe,
            children: v.jsx(wS, {
                size: jfe
            })
        })
    })
}
))
  , jfe = 16
  , Tfe = {
    minWidth: 18,
    width: 18,
    height: 18,
    px: 0,
    mt: .25
}
  , Ife = {
    justifyContent: "flex-end",
    alignItems: "center"
}
  , Efe = e => ({
    ...sZ(e),
    headerClass: lY,
    minWidth: cY.minWidth
})
  , Mfe = ({key: e, isAssetColumnShrinked: t, toggleAssetColumnShrink: r}) => {
    switch (e) {
    case "baseName":
        return {
            ...Efe(e),
            headerName: n.t("Asset"),
            headerComponent: YQ,
            headerComponentParams: {
                onClick: r,
                isShrinked: t
            },
            cellRenderer: e => e.data ? v.jsx(EQ, {
                tokenName: e.data.baseName,
                tokenSocials: null,
                deployer: null,
                tokenSymbol: e.data.baseSymbol,
                chain: e.data.chain,
                tokenAddress: e.data.baseAddress,
                forceSmall: !0,
                shrinked: t,
                protocol: e.data.protocol,
                ...e,
                href: XE(e.data.chain, e.data.baseAddress, nT.SIDEBAR_RECENTS)
            }) : v.jsx(CQ, {}),
            flex: dY.flex,
            minWidth: t ? 45 : 115,
            maxWidth: t ? 45 : 115,
            sortable: !1,
            sort: "desc",
            headerClass: void 0,
            valueGetter: ({data: e}) => e ? `${rZ(e.seenAtTs.toString())}-${rZ(e.baseName)}-${rZ(e.baseSymbol)}-${rZ(e.baseAddress)}-${rZ(e.chain)}-${e.protocol}` : void 0
        };
    case "priceInUsd":
        return {
            ...Efe(e),
            headerName: n.t("Price"),
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    price: (null == (t = e.data) ? void 0 : t.priceInUsd) ? Number(e.data.priceInUsd) : 0,
                    symbol: "$",
                    ...e,
                    sxProps: Ife,
                    useSubscript: !0,
                    href: e.data ? XE(e.data.chain, e.data.baseAddress, nT.SIDEBAR_RECENTS) : void 0
                })
            }
            ,
            sortable: !1,
            valueGetter: ({data: e}) => e ? `${rZ(e.priceInUsd || "0")}-${e.chain}-${e.baseAddress}` : void 0
        };
    case "fdvInUsd":
        return {
            ...Efe(e),
            headerName: n.t("MCap"),
            cellRenderer: e => {
                var t;
                return v.jsx(AQ, {
                    price: (null == (t = e.data) ? void 0 : t.fdvInUsd) ? Number(e.data.fdvInUsd) : 0,
                    symbol: "$",
                    collapseExponent: !0,
                    ...e,
                    sxProps: Ife,
                    href: e.data ? XE(e.data.chain, e.data.baseAddress, nT.SIDEBAR_RECENTS) : void 0
                })
            }
            ,
            sortable: !1,
            valueGetter: ({data: e}) => e ? `${rZ(e.fdvInUsd ? e.fdvInUsd.split(".")[0] : "0")}-${e.chain}-${e.baseAddress}` : void 0
        };
    case "marketId":
        return {
            ...Efe(e),
            headerName: "",
            cellRenderer: e => {
                var t;
                return v.jsx(wfe, {
                    marketId: (null == (t = e.data) ? void 0 : t.marketId) ?? null,
                    ...e,
                    href: e.data ? XE(e.data.chain, e.data.baseAddress, nT.SIDEBAR_RECENTS) : void 0
                })
            }
            ,
            sortable: !1,
            minWidth: 44,
            valueGetter: ({data: e}) => e ? `${rZ(e.priceInUsd || "0")}-${e.chain}-${e.baseAddress}` : void 0
        };
    default:
        return {}
    }
}
  , Nfe = y.memo(( () => {
    const {history: e} = fz()
      , t = y.useMemo(( () => e.map(( ({baseAddress: e, chain: t}) => bg(t, e)))), [e])
      , n = J1(t)
      , r = y.useMemo(( () => c.uniqBy(e.map((e => {
        var t, r;
        const a = bg(e.chain, e.baseAddress);
        return {
            ...e,
            baseAddress: ng(e.baseAddress),
            priceInUsd: String((null == (t = null == n ? void 0 : n[a]) ? void 0 : t.priceInUsdUi) ?? 0),
            fdvInUsd: String((null == (r = null == n ? void 0 : n[a]) ? void 0 : r.fdvInUsdUi) ?? 0)
        }
    }
    )), (e => e.baseAddress))), [n, e])
      , a = yT()
      , s = y.useCallback((e => {
        a({
            tokenAddress: e.baseAddress,
            chain: e.chain,
            tradePageOrigin: nT.SIDEBAR_RECENTS
        })
    }
    ), [a])
      , o = y.useCallback((e => {
        xT(e.marketId)
    }
    ), [])
      , [l,i] = Mx("padreV2-sidebarRecentlyViewedAssetColumnShrinked", !1)
      , d = y.useCallback(( () => {
        i((e => !e))
    }
    ), [i])
      , u = y.useMemo(( () => ( (e, t) => [Mfe({
        key: "baseName",
        isAssetColumnShrinked: e,
        toggleAssetColumnShrink: t
    }), Mfe({
        key: "priceInUsd"
    }), Mfe({
        key: "fdvInUsd"
    }), Mfe({
        key: "marketId"
    })])(l, d)), [l, d]);
    return v.jsx(yQ, {
        rowData: r,
        onRowHover: o,
        isLoading: !1,
        columnDefs: u,
        rowHeight: mQ.COMPACT,
        getRowUniqueId: Pfe,
        onRowClick: s,
        resizableHeaders: Ofe
    })
}
))
  , Pfe = e => `${e.marketId}-${e.chain}`
  , Ofe = ["baseName"]
  , Lfe = y.memo(( ({sidebarOpenPosition: e, isShrinked: t, ...n}) => e && e.tokenSymbol ? v.jsx(kQ, {
    ...n,
    typographyOverrides: {
        sx: {
            width: "100%"
        }
    },
    children: v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1,
        width: "100%",
        children: [v.jsx(z, {
            title: t ? e.tokenSymbol : "",
            children: v.jsx(C, {
                component: "span",
                children: ru(e.tokenAddress) ? v.jsx(Sz, {
                    size: Rfe,
                    chain: e.chain
                }) : v.jsx(b_, {
                    url: IE(e.chain, e.tokenAddress),
                    padreAvatarUrl: null,
                    name: e.tokenName ?? e.tokenSymbol,
                    size: Rfe,
                    markerIcon: ru(e.tokenAddress) ? void 0 : v.jsx(Sz, {
                        chain: e.chain,
                        size: Dfe
                    }),
                    markerSize: Dfe,
                    chain: e.chain,
                    protocolInfo: null,
                    hideHoverAvatar: !0
                })
            })
        }), !t && v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            noWrap: !0,
            children: e.tokenSymbol
        })]
    })
}) : v.jsx(CQ, {})))
  , Rfe = 22
  , Dfe = 10
  , Bfe = y.memo(( ({sidebarOpenPosition: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        justifyContent: "flex-end",
        ...t.sxProps
    },
    children: v.jsx(RZ, {
        variant: "monospace2",
        value: e.pnlUsd || 0,
        formattedDisplay: null !== e.pnlUsd ? `${OI(e.pnlUsd, {
            collapseExponent: !0
        })}` : Ud
    })
}) : v.jsx(CQ, {})))
  , _fe = y.memo(( ({sidebarOpenPosition: e, price: t, symbol: n, ...r}) => e ? v.jsx(kQ, {
    ...r,
    sxProps: {
        justifyContent: "flex-end",
        ...r.sxProps
    },
    children: v.jsx(k, {
        variant: "monospace2",
        children: null === t ? Ud : LI(t, {
            symbol: n,
            padSymbol: !1,
            symbolPosition: yI.START,
            removeTrailingZerosPrecision: 2
        })
    })
}) : v.jsx(CQ, {})))
  , Ufe = {
    alignItems: "center"
}
  , Wfe = e => ({
    ...sZ(e),
    minWidth: 75,
    headerClass: lY,
    sortingOrder: ["desc", "asc"]
})
  , Ffe = ({key: e, isTokenColumnShrinked: t, toggleTokenColumnShrink: r}) => {
    switch (e) {
    case "tokenSymbol":
        return {
            ...Wfe(e),
            headerName: n.t("Token"),
            headerComponent: YQ,
            headerComponentParams: {
                onClick: r,
                isShrinked: t
            },
            cellRenderer: e => {
                var n, r;
                return v.jsx(Lfe, {
                    sidebarOpenPosition: e.data,
                    isShrinked: t || !1,
                    ...e,
                    sxProps: Ufe,
                    href: XE((null == (n = e.data) ? void 0 : n.chain) ?? null, (null == (r = e.data) ? void 0 : r.tokenAddress) ?? null, nT.SIDEBAR_POSITIONS)
                })
            }
            ,
            headerClass: void 0,
            flex: dY.flex,
            pinned: "left",
            minWidth: t ? 50 : 115,
            maxWidth: t ? 50 : 115,
            valueGetter: ({data: e}) => e ? `${e.tokenSymbol}-${e.chain}-${e.tokenAddress}-${e.tokenName}` : void 0
        };
    case "valueUsd":
        return {
            ...Wfe(e),
            headerName: n.t("Value"),
            cellRenderer: e => {
                var t, n, r;
                return v.jsx(_fe, {
                    sidebarOpenPosition: e.data,
                    price: (null == (t = e.data) ? void 0 : t.valueUsd) || null,
                    symbol: "$",
                    ...e,
                    sxProps: Ufe,
                    href: XE((null == (n = e.data) ? void 0 : n.chain) ?? null, (null == (r = e.data) ? void 0 : r.tokenAddress) ?? null, nT.SIDEBAR_POSITIONS)
                })
            }
        };
    case "pnlUsd":
        return {
            ...Wfe(e),
            headerName: n.t("PNL"),
            cellRenderer: e => {
                var t, n;
                return v.jsx(Bfe, {
                    sidebarOpenPosition: e.data,
                    ...e,
                    sxProps: Ufe,
                    href: XE((null == (t = e.data) ? void 0 : t.chain) ?? null, (null == (n = e.data) ? void 0 : n.tokenAddress) ?? null, nT.SIDEBAR_POSITIONS)
                })
            }
            ,
            headerClass: lY,
            comparator: lZ((e => e.pnlUsd ?? null))
        };
    case "cost":
        return {
            ...Wfe(e),
            headerName: n.t("Cost"),
            cellRenderer: e => {
                var t, n, r;
                return v.jsx(_fe, {
                    sidebarOpenPosition: e.data,
                    price: (null == (t = e.data) ? void 0 : t.cost) || null,
                    symbol: "$",
                    ...e,
                    sxProps: Ufe,
                    href: XE((null == (n = e.data) ? void 0 : n.chain) ?? null, (null == (r = e.data) ? void 0 : r.tokenAddress) ?? null, nT.SIDEBAR_POSITIONS)
                })
            }
        };
    default:
        return {}
    }
}
  , Vfe = [Pd.ETH_SEPOLIA, Pd.ARBITRUM_SEPOLIA]
  , Hfe = e => Vfe.includes(e)
  , zfe = (e, t, n, r) => e ? c.reduce(e, ( (e, a) => {
    const {chain: s, walletAddress: o, tokenAddress: l, tokenInfo: i, currentValueInUsdUi: c, unrealizedPnlInUsdUi: d, avgBuyPriceInUsdUi: u, markPriceInUsdUi: p, isLikelyClosed: h, isLikelyScam: m, currentCostInUsdUi: g} = a
      , x = ng(o);
    if (Hfe(s))
        return e;
    if (h)
        return e;
    if (m)
        return e;
    if (nu.includes(ng(l)))
        return e;
    if (!!t && t[kX(l, s)])
        return e;
    if ((c || 0) <= 1)
        return e;
    if (n && !r.includes(x))
        return e;
    const b = p
      , f = {
        chain: s,
        walletAddress: x,
        tokenAddress: l,
        tokenSymbol: (null == i ? void 0 : i.symbol) || null,
        tokenDecimals: i ? i.decimals : null,
        tokenName: (null == i ? void 0 : i.name) || null,
        averageBuyPriceUsd: u,
        marketPriceUsd: b,
        valueUsd: c,
        pnlUsd: d,
        cost: g
    };
    return e.push(f),
    e
}
), []) : []
  , $fe = e => `${e.tokenAddress}-${e.walletAddress}-${e.chain}`
  , Gfe = ({areOtherWalletsHidden: e}) => {
    const {portfolioData: t} = zce()
      , {lastViewedChain: n} = _H()
      , {lastSelectedWalletsPerChain: r} = OD()
      , a = y.useMemo(( () => r[n]), [r, n])
      , {hiddenPairs: s} = SX()
      , [o] = JC(!0, 300, !1)
      , [l,i] = y.useMemo(( () => t && s ? [zfe(c.flatMap(t, (e => Object.values(e.perTokenId || {}))), s, e, a ?? []), !1] : [null, !0]), [t, s, e, a])
      , d = y.useCallback((e => {
        ST({
            query: bg(e.chain, e.tokenAddress),
            withDeepCacheWarm: !1
        })
    }
    ), [])
      , u = y.useMemo(( () => oZ("sidebarOpenPositionsV4")), [])
      , [p,h] = Mx("padreV2-sidebarOpenPositionsTokenColumnShrinked", !1)
      , m = y.useCallback(( () => {
        h((e => !e))
    }
    ), [h])
      , g = y.useMemo(( () => ( (e, t) => [Ffe({
        key: "tokenSymbol",
        isTokenColumnShrinked: e,
        toggleTokenColumnShrink: t
    }), Ffe({
        key: "cost"
    }), Ffe({
        key: "valueUsd"
    }), Ffe({
        key: "pnlUsd"
    })])(p, m)), [p, m]);
    return i || o ? v.jsx(Km, {}) : o || (null == l ? void 0 : l.length) ? v.jsx(yQ, {
        rowData: l,
        onRowHover: d,
        isLoading: i || o,
        columnDefs: g,
        getRowUniqueId: $fe,
        rowHeight: 42,
        resizableHeaders: qfe,
        ...u
    }) : v.jsx(S, {
        height: "100%",
        width: "100%",
        alignItems: "center",
        justifyContent: "center",
        gap: .5,
        children: v.jsx(k, {
            variant: "paragraph1",
            color: "text.label",
            children: "No data to show"
        })
    })
}
  , qfe = ["tokenSymbol"]
  , Kfe = y.memo(( ({name: e, minWidth: t, children: n}) => v.jsxs(S, {
    direction: "row",
    justifyContent: "space-between",
    alignItems: "center",
    sx: Yfe,
    className: "padre-no-scroll",
    children: [v.jsx(k, {
        variant: "paragraph1",
        color: "text.value",
        noWrap: !0,
        minWidth: t,
        lineHeight: 1.1,
        children: e
    }), n]
})))
  , Yfe = {
    overflowY: "hidden",
    overflowX: "scroll",
    gap: .5,
    minHeight: 32
}
  , Xfe = y.memo(( ({label: e, onClick: t, isSelected: n, isBig: r=!1}) => {
    const a = y.useMemo(( () => e => ({
        whiteSpace: "nowrap",
        borderRadius: 1,
        height: {
            xs: 26,
            sm: r ? 28 : 26
        },
        minWidth: 0,
        py: 0,
        px: {
            xs: .5,
            sm: .75
        },
        border: "none",
        color: n ? r ? e.palette.text.value : e.palette.primary.main : r ? e.palette.text.label : "inherit",
        background: "none",
        transition: "none",
        fontSize: {
            xs: r ? 14 : 13,
            sm: r ? 20 : 13
        },
        "&:focus": {
            background: "none",
            color: r ? e.palette.text.value : e.palette.primary.main
        },
        "&:hover": {
            background: r ? "none" : e.palette.primary.background,
            color: r ? e.palette.text.value : e.palette.primary.main
        }
    })), [n, r]);
    return v.jsx(V, {
        variant: "tertiary",
        size: "xxsmall",
        onClick: t,
        sx: a,
        children: e
    })
}
))
  , Qfe = {
    [Xte.M1]: "1M",
    [Xte.M5]: "5M",
    [Xte.M30]: "30M",
    [Xte.H1]: "1H"
}
  , Zfe = y.memo(( ({timespan: e, setTimespan: t}) => v.jsx(S, {
    direction: "row",
    alignContent: "flex-end",
    gap: .5,
    children: Jfe.map(( (n, r) => {
        const a = e === n;
        return v.jsx(Xfe, {
            label: Qfe[n],
            onClick: () => {
                t(n)
            }
            ,
            isSelected: a
        }, r)
    }
    ))
})))
  , Jfe = [Xte.M1, Xte.M5, Xte.M30, Xte.H1]
  , eve = y.memo(( ({livePumpMode: e, setLivePumpMode: t}) => {
    const {t: n} = we()
      , r = xw()
      , {trenchesChain: a, trendingMode: s, setTrendingMode: o, trendingTimespan: l, setTrendingTimespan: i} = xne()
      , c = y.useCallback(( () => {
        o(kfe[l])
    }
    ), [o, l])
      , d = y.useCallback(( () => {
        o(Yte.DEX)
    }
    ), [o])
      , u = y.useCallback(( () => {
        o(Yte.NEW)
    }
    ), [o])
      , p = y.useCallback(( () => {
        o(Yte.PUMP_LIVE)
    }
    ), [o])
      , h = y.useCallback((e => {
        i(e),
        tve.has(s) && o(kfe[e])
    }
    ), [s, o, i])
      , m = y.useCallback(( () => {
        t(yfe.MC_DESC)
    }
    ), [t])
      , g = y.useCallback(( () => {
        t(yfe.TIME_DESC)
    }
    ), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "flex-end",
        gap: nve,
        children: [v.jsx(Xfe, {
            label: n("Trending"),
            onClick: c,
            isSelected: tve.has(s),
            isBig: !0
        }), a === Pd.SOLANA && v.jsx(Xfe, {
            label: n("Dex"),
            onClick: d,
            isSelected: s === Yte.DEX,
            isBig: !0
        }), v.jsx(Xfe, {
            label: n("New"),
            onClick: u,
            isSelected: s === Yte.NEW,
            isBig: !0
        }), a === Pd.SOLANA && v.jsx(Xfe, {
            label: n(r ? "Pump Live" : "Live"),
            onClick: p,
            isSelected: s === Yte.PUMP_LIVE,
            isBig: !0
        }), s !== Yte.PUMP_LIVE && v.jsx(Zfe, {
            timespan: l,
            setTimespan: h
        }), s === Yte.PUMP_LIVE && v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsx(Xfe, {
                label: rve[yfe.MC_DESC],
                onClick: m,
                isSelected: e === yfe.MC_DESC
            }), v.jsx(Xfe, {
                label: rve[yfe.TIME_DESC],
                onClick: g,
                isSelected: e === yfe.TIME_DESC
            })]
        })]
    })
}
))
  , tve = new Set([Yte.VOL_1M, Yte.VOL_5M, Yte.VOL_30M, Yte.VOL_1H])
  , nve = {
    xs: .75,
    md: 1
}
  , rve = {
    [yfe.MC_DESC]: "MC",
    [yfe.TIME_DESC]: "Time"
}
  , ave = y.memo(( ({timespan: e, setTimespan: t, filterMode: n}) => v.jsxs(S, {
    direction: "row",
    gap: .5,
    alignItems: "center",
    children: [v.jsx(Zfe, {
        timespan: e,
        setTimespan: t
    }), v.jsx(Cse, {
        filterMode: n,
        chain: Pd.SOLANA
    })]
})))
  , sve = Xte.M5
  , ove = y.memo(( ({visibleSections: e}) => {
    const {t: t} = we()
      , {hasChartRendered: n} = qbe()
      , {lastViewedChain: r} = _H()
      , [a,s] = Mx("padreV2-sidebarTrendingTimespan", sve)
      , o = y.useMemo(( () => kfe[a]), [a])
      , l = y.useMemo(( () => Afe(o, null)), [o])
      , [i,c] = y.useState(!1)
      , [d,u] = y.useState(!1)
      , p = y.useMemo(( () => i || d), [i, d])
      , [h,m] = Mx("padreV2-sidebarNewPairsTimespan", sve)
      , [g,x] = y.useState(!1)
      , [b,f] = y.useState(!1)
      , k = y.useMemo(( () => g || b), [g, b])
      , C = y.useMemo(( () => e.map((i => ({
        minSize: 120,
        size: e.length > 3 ? 150 : 200,
        content: ( () => {
            if (!n)
                return null;
            switch (i) {
            case NX.TRENDING:
                return v.jsxs(S, {
                    ...ive,
                    children: [v.jsx(Kfe, {
                        name: t("Trending"),
                        children: v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            gap: .5,
                            children: [p && v.jsx(H9, {
                                isLive: !1,
                                compact: !0
                            }), v.jsx(ave, {
                                timespan: a,
                                setTimespan: s,
                                filterMode: "TRENDING"
                            })]
                        })
                    }), v.jsx(S, {
                        mx: -lve,
                        height: "100%",
                        overflow: "hidden",
                        children: l && v.jsx(gfe, {
                            chain: r === Pd.BSC ? Pd.BSC : Pd.SOLANA,
                            trendingMode: o,
                            gazeType: l,
                            trendingTimespan: a,
                            isPaused: p,
                            setIsTooltipOpen: u,
                            setIsHovering: c,
                            compact: !0
                        })
                    })]
                });
            case NX.WATCHLIST:
                return v.jsx(cH, {
                    contextId: "watchlistSidebar",
                    children: v.jsxs(S, {
                        ...ive,
                        children: [v.jsx(Kfe, {
                            name: t("Watchlist"),
                            children: !1
                        }), v.jsx(S, {
                            mx: -lve,
                            height: "100%",
                            overflow: "hidden",
                            children: v.jsx(B6, {
                                selectedChain: jQ,
                                compact: !0
                            })
                        })]
                    })
                });
            case NX.RECENT:
                return v.jsxs(S, {
                    ...ive,
                    children: [v.jsx(Kfe, {
                        name: t("Recently viewed")
                    }), v.jsx(S, {
                        mx: -lve,
                        height: "100%",
                        overflow: "hidden",
                        children: v.jsx(Nfe, {})
                    })]
                });
            case NX.POSITIONS:
                return v.jsxs(S, {
                    ...ive,
                    children: [v.jsx(Kfe, {
                        name: t("Open positions"),
                        minWidth: 100
                    }), v.jsx(S, {
                        mx: -lve,
                        height: "100%",
                        overflow: "hidden",
                        children: v.jsx(Gfe, {
                            areOtherWalletsHidden: !1
                        })
                    })]
                });
            case NX.NEW_PAIRS:
                return v.jsxs(S, {
                    ...ive,
                    children: [v.jsx(Kfe, {
                        name: t("New pairs"),
                        children: v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            gap: .5,
                            children: [k && v.jsx(H9, {
                                isLive: !1,
                                compact: !0
                            }), v.jsx(ave, {
                                timespan: h,
                                setTimespan: m,
                                filterMode: "TRENDING_NEW"
                            })]
                        })
                    }), v.jsx(S, {
                        mx: -lve,
                        height: "100%",
                        overflow: "hidden",
                        children: v.jsx(gfe, {
                            chain: r === Pd.BSC ? Pd.BSC : Pd.SOLANA,
                            trendingMode: Yte.NEW,
                            gazeType: "trending-new",
                            trendingTimespan: h,
                            isPaused: k,
                            setIsTooltipOpen: f,
                            setIsHovering: x,
                            compact: !0
                        })
                    })]
                });
            default:
                return null
            }
        }
        )()
    })))), [t, r, n, k, p, h, m, s, o, a, e, l]);
    if (e.length)
        return v.jsx(S, {
            width: "100%",
            height: "calc(100% - 1px)",
            "data-testid": "trade-page-sidebar",
            children: v.jsx(Ube, {
                vertical: !0,
                storageKey: "padreV2-sidebarPaneSizes",
                panes: C,
                maxHeightLast: !0
            }, n ? "sidebar" : "sidebar-loading")
        })
}
))
  , lve = .75
  , ive = {
    height: "100%",
    p: lve,
    gap: .5
}
  , cve = y.memo(( ({hasSidebar: e=!1, children: t}) => {
    const {hideSidebar: n, isSidebarRight: r, sidebarSections: a} = _X()
      , s = y.useMemo(( () => a ? RX(a) : null), [a])
      , o = e && s && s.length && !n;
    return v.jsx(Gbe, {
        children: v.jsx(S, {
            direction: "row",
            flexGrow: 1,
            flex: "1 1 1px",
            position: "relative",
            maxHeight: "100%",
            children: v.jsx(Ube, {
                reversed: r,
                storageKey: "padreV2-tradePageHorizontalPaneSizes",
                panes: [...o ? [{
                    size: 225,
                    minSize: 225,
                    content: s ? v.jsx(ove, {
                        visibleSections: s
                    }) : v.jsx(Km, {})
                }] : [], {
                    minSize: 550,
                    content: v.jsx(S, {
                        height: "100%",
                        sx: dve,
                        flexBasis: "1px",
                        flexGrow: 1,
                        className: "padre-no-scroll",
                        children: t
                    })
                }]
            })
        })
    })
}
))
  , dve = {
    overflowY: "auto",
    overflowX: "hidden"
}
  , uve = y.memo(( () => {
    const e = bw();
    return v.jsx(v.Fragment, {
        children: v.jsx(cve, {
            hasSidebar: e,
            children: v.jsx(Kn, {})
        })
    })
}
))
  , pve = y.memo(( () => {
    const e = Xn();
    return y.useEffect(( () => {
        o(e)
    }
    ), [e]),
    v.jsx(C, {
        sx: hve,
        children: v.jsx(k, {
            variant: "h3",
            children: "Something went wrong..."
        })
    })
}
))
  , hve = {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    inset: 0
}
  , mve = N((e => ({
    topHolders: null,
    baseTokenAddress: null,
    baseTokenDecimals: null,
    set: e
})));
class gve {
    constructor({compare: e, keyFun: n, maxSize: r}) {
        t(this, "data", []),
        t(this, "keyMap", new Map),
        t(this, "compare"),
        t(this, "keyFun"),
        t(this, "maxSize"),
        t(this, "length", 0),
        this.compare = e ?? ( (e, t) => e < t ? -1 : e > t ? 1 : 0),
        this.keyFun = n ?? null,
        this.maxSize = r ?? null
    }
    insert(e) {
        const t = this.keyFun ? this.keyFun(e) : null
          , n = null !== t ? this.keyMap.get(t) : void 0;
        if (void 0 !== n)
            return this.data[n] = e,
            this._up(n),
            void this._down(n);
        if (null !== this.maxSize && this.length >= this.maxSize) {
            const t = this.peek();
            if (this.compare(e, t) <= 0)
                return;
            this.pop()
        }
        this.data.push(e);
        const r = this.length++;
        null !== t && this.keyMap.set(t, r),
        this._up(r)
    }
    getTopN(e) {
        const t = [...this.data];
        return t.sort(this.compare),
        t.slice(0, e)
    }
    delete(e) {
        const t = this.keyMap.get(e);
        if (void 0 === t)
            return !1;
        const n = this.length - 1
          , r = this.data[n];
        return this.length--,
        this.keyMap.delete(e),
        t !== n && (this.data[t] = r,
        this.keyFun && this.keyMap.set(this.keyFun(r), t),
        this._up(t),
        this._down(t)),
        this.data.pop(),
        !0
    }
    get(e) {
        const t = this.keyMap.get(e);
        if (void 0 !== t)
            return this.data[t]
    }
    pop() {
        if (0 === this.length)
            return;
        const e = this.data[0]
          , t = this.data.pop();
        return this.length--,
        this.length > 0 && (this.data[0] = t,
        this.keyFun && this.keyMap.set(this.keyFun(t), 0),
        this._down(0)),
        this.keyFun && this.keyMap.delete(this.keyFun(e)),
        e
    }
    peek() {
        return this.data[0]
    }
    values() {
        return [...this.data]
    }
    _up(e) {
        const {data: t, compare: n, keyFun: r, keyMap: a} = this
          , s = t[e]
          , o = r ? r(s) : null;
        for (; e > 0; ) {
            const o = e - 1 >> 1
              , l = t[o];
            if (n(s, l) >= 0)
                break;
            t[e] = l,
            r && a.set(r(l), e),
            e = o
        }
        t[e] = s,
        null !== o && a.set(o, e)
    }
    _down(e) {
        const {data: t, compare: n, keyFun: r, keyMap: a} = this
          , s = this.length >> 1
          , o = t[e]
          , l = r ? r(o) : null;
        for (; e < s; ) {
            let s = 1 + (e << 1);
            const l = s + 1;
            if (l < this.length && n(t[l], t[s]) < 0 && (s = l),
            n(t[s], o) >= 0)
                break;
            t[e] = t[s],
            r && a.set(r(t[s]), e),
            e = s
        }
        t[e] = o,
        null !== l && a.set(l, e)
    }
}
const xve = () => new gve({
    compare: (e, t) => Number(e.lastActivityTs) - Number(t.lastActivityTs),
    keyFun: e => e.walletAddress,
    maxSize: 1e3
})
  , bve = N((e => ({
    wrapped: null,
    setWrapped: t => e((e => ({
        ...e,
        wrapped: t((null == e ? void 0 : e.wrapped) ?? null)
    })))
})))
  , fve = (e, t, n) => {
    const r = Ax()
      , a = bve()
      , s = y.useRef(a);
    s.current = a,
    y.useEffect(( () => {
        if (ke(r) || ke(e) || ke(t) || tu(t, e) || 0 === n.length)
            return;
        let a = !1;
        return (async () => {
            try {
                const o = n.filter((e => {
                    var t;
                    return !(null == (t = s.current.wrapped) ? void 0 : t.queue.get(e))
                }
                ));
                if (0 === o.length)
                    return;
                const l = await Tm.fetchHoldingMulti(r, {
                    chain: e,
                    token: t,
                    wallets: o
                });
                a || s.current.setWrapped((e => {
                    const t = (null == e ? void 0 : e.queue) ?? xve();
                    return Object.values(l.entries).forEach((e => t.insert(B1(e)))),
                    {
                        queue: t
                    }
                }
                ))
            } catch (W$e) {}
        }
        )(),
        () => {
            a = !0
        }
    }
    ), [r, e, t, n])
}
  , vve = (e, t) => {
    const n = bve()
      , r = y.useRef(n);
    r.current = n,
    y.useEffect(( () => {
        r.current.setWrapped(( () => null))
    }
    ), [e, t]);
    const a = y.useCallback((n => ke(e) || ke(t) || tu(t, e) ? {
        unsubscribe: () => {}
    } : Tm.subscribeRecentHolders(e, t, n)), [e, t])
      , s = y.useMemo(( () => {
        return e = r.current,
        (t, n) => {
            const r = t || e;
            if ("init" === n.type) {
                const e = xve();
                return Object.values(n.snapshot.allEntries).forEach((t => e.insert(B1(t)))),
                r.setWrapped(( () => ({
                    queue: e
                }))),
                r
            }
            return r.setWrapped((e => {
                const t = (null == e ? void 0 : e.queue) ?? xve();
                return n.update.entries.forEach((e => t.insert(B1(e)))),
                {
                    queue: t
                }
            }
            )),
            r
        }
        ;
        var e
    }
    ), []);
    return Cx(a, s),
    r.current
}
  , Sve = N((e => ({
    snipers: new Set,
    set: e
})))
  , yve = (e, t) => {
    const n = ( (e, t) => {
        const n = Ax()
          , r = y.useCallback((r => n && t && e ? xm.subscribeSnipers(e, t, r) : {
            unsubscribe: () => {}
        }), [n, t, e]);
        return yx(r)
    }
    )(e, t)
      , r = Sve()
      , a = y.useRef(r);
    a.current = r,
    y.useEffect(( () => {
        a.current.set({
            snipers: new Set
        })
    }
    ), [e, t]),
    y.useEffect(( () => {
        a.current.set({
            snipers: new Set((null == n ? void 0 : n.address) ?? [])
        })
    }
    ), [n])
}
  , kve = N((e => ({
    wrapped: null,
    setWrapped: t => e(( () => ({
        wrapped: t
    })))
})))
  , Cve = () => new gve({
    compare: (e, t) => Number(e.amountString) - Number(t.amountString),
    keyFun: e => e.walletAddress,
    maxSize: 50
})
  , Ave = (e, t) => {
    if ("init" === t.type) {
        const e = Cve();
        return Object.values(t.snapshot.allEntries).forEach((t => e.insert(B1(t)))),
        {
            queue: e
        }
    }
    if (!e)
        return {
            queue: Cve()
        };
    t.update.deleted.map(jp).forEach((t => null == e ? void 0 : e.queue.delete(t)));
    return t.update.updated.map(B1).forEach((t => null == e ? void 0 : e.queue.insert(t))),
    {
        queue: e.queue
    }
}
  , wve = y.createContext({
    topHolders: null,
    baseTokenAddress: null,
    baseTokenDecimals: null
});
wve.displayName = "HoldersContext";
const jve = y.memo(( ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , n = Ade()
      , r = (null == t ? void 0 : t.baseToken.address) ?? null
      , a = ( (e, t) => {
        const n = kve()
          , r = y.useRef(n);
        y.useEffect(( () => {
            r.current.setWrapped(null)
        }
        ), [e, t]);
        const a = y.useCallback((n => ke(e) || ke(t) ? {
            unsubscribe: () => {}
        } : Tm.subscribeTopHoldersV3(e, t, n)), [e, t])
          , s = kx(a, Ave, {
            debounceDuration: 100
        });
        return y.useEffect(( () => {
            r.current.setWrapped((null == s ? void 0 : s.queue) ?? null)
        }
        ), [s]),
        s
    }
    )((null == t ? void 0 : t.chain) || null, r);
    vve((null == t ? void 0 : t.chain) || null, (null == t ? void 0 : t.baseToken.address) || null),
    yve((null == t ? void 0 : t.chain) || null, (null == t ? void 0 : t.baseToken.address) || null);
    const s = mve()
      , o = y.useRef(s);
    return y.useEffect(( () => {
        o.current.set({
            topHolders: a,
            baseTokenAddress: r,
            baseTokenDecimals: n
        })
    }
    ), [a, r, n]),
    v.jsx(wve.Provider, {
        value: s,
        children: e
    })
}
))
  , Tve = e => mve((t => e && t.baseTokenAddress === e ? t.topHolders : null))
  , Ive = () => mve((e => {
    if (null === e.topHolders || null === e.baseTokenDecimals)
        return 0;
    const t = 10n ** BigInt(e.baseTokenDecimals);
    let n = 0;
    return e.topHolders.queue.values().forEach((e => {
        const r = e.amountString;
        r && BigInt(r) > t && n++
    }
    )),
    n
}
))
  , Eve = y.createContext({
    baseTokenAddress: null,
    topTraders: null,
    requestData: c.noop
})
  , Mve = e => Number(e.totalSoldUsd) - Number(e.totalBoughtUsd)
  , Nve = () => new gve({
    compare: (e, t) => Mve(e) - Mve(t),
    keyFun: e => e.walletAddress,
    maxSize: 50
})
  , Pve = (e, t) => {
    if ("init" === t.type) {
        const e = Nve();
        return Object.values(t.snapshot.allEntries).forEach((t => e.insert(B1(t)))),
        {
            queue: e
        }
    }
    if (!e)
        return {
            queue: Nve()
        };
    t.update.deleted.map(jp).forEach((t => null == e ? void 0 : e.queue.delete(t)));
    return t.update.updated.map(B1).forEach((t => null == e ? void 0 : e.queue.insert(t))),
    {
        queue: e.queue
    }
}
  , Ove = y.memo(( ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , [n,r] = y.useState(!1)
      , a = y.useCallback(( () => {
        n || r(!0)
    }
    ), [n])
      , s = (null == t ? void 0 : t.baseToken.address) ?? null
      , o = ( (e, t, n) => {
        const r = y.useCallback((r => ke(e) || ke(t) || !n ? {
            unsubscribe: () => {}
        } : Tm.subscribeTopTraders(e, t, r)), [e, t, n]);
        return kx(r, Pve, {
            debounceDuration: 250
        })
    }
    )((null == t ? void 0 : t.chain) || null, s, n)
      , l = y.useMemo(( () => ({
        baseTokenAddress: s,
        topTraders: o,
        requestData: a
    })), [s, o, a]);
    return v.jsx(Eve.Provider, {
        value: l,
        children: e
    })
}
))
  , Lve = () => v.jsx(S, {
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    children: v.jsxs(k, {
        variant: "paragraph1",
        color: "text.label",
        sx: {
            maxWidth: 370
        },
        children: ["Unable to display market, make sure the address is correct or open support ticket on", " ", v.jsx(H, {
            href: LC,
            color: "inherit",
            target: "_blank",
            rel: "noreferer noopener",
            sx: {
                transition: "200ms ease-in-out",
                "&:hover": {
                    color: "text.primary"
                }
            },
            children: "Discord"
        }), "."]
    })
})
  , Rve = ({chain: e}) => {
    const t = pK()
      , [n,r] = y.useState(!1);
    y.useEffect(( () => {
        n || (r(!0),
        t({
            message: uu.nativeMarketClick,
            type: "default"
        }, "market-page-native-token-error"))
    }
    ), [t, n]);
    const a = eu[e]
      , s = Object.entries(a).find(( ([,e]) => e === Nd.USDC))
      , o = `${tT.TRADE}/${eg(s ? e : Pd.ETH_MAINNET)}/${s ? s[0] : "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"}`;
    return v.jsx(T$e, {
        path: o
    })
}
  , Dve = e => ({
    chain: e ?? Pd.ETH_MAINNET,
    preMigrationMarketId: null,
    marketAddress: "",
    protocol: {
        type: e === Pd.SOLANA ? Rc.RAYDIUM : Lc.UNISWAP_V2
    },
    createdAt: 0,
    realQuoteToken: null,
    baseToken: {
        chain: e ?? Pd.ETH_MAINNET,
        address: "",
        symbol: "",
        name: "",
        decimals: 9,
        deployedAt: 0,
        deployedAtBlock: null,
        deployer: null,
        tokenType: null
    },
    quoteToken: {
        chain: e ?? Pd.ETH_MAINNET,
        address: "",
        symbol: "",
        name: "",
        decimals: 9,
        deployedAt: 0,
        deployedAtBlock: null,
        deployer: null,
        tokenType: null
    },
    launchpad: null,
    launchpadAux: null
});
var Bve = (e => (e.INVESTED = "INVESTED",
e.COST = "COST",
e.REMAINING = "REMAINING",
e.SOLD = "SOLD",
e.PNL = "PNL",
e.PNL_PERCENTAGE = "PNL_PERCENTAGE",
e.TOTAL_PNL = "TOTAL PNL",
e))(Bve || {});
const _ve = [Bve.INVESTED, Bve.SOLD, Bve.REMAINING, Bve.TOTAL_PNL]
  , Uve = [Bve.REMAINING, Bve.TOTAL_PNL]
  , Wve = new Set([Bve.PNL, Bve.TOTAL_PNL, Bve.PNL_PERCENTAGE])
  , Fve = new Set([Bve.PNL_PERCENTAGE])
  , Vve = {
    [Bve.INVESTED]: n.t("Invested"),
    [Bve.COST]: n.t("Cost"),
    [Bve.REMAINING]: n.t("Remaining"),
    [Bve.SOLD]: n.t("Sold"),
    [Bve.PNL]: n.t("PNL"),
    [Bve.PNL_PERCENTAGE]: n.t("PNL"),
    [Bve.TOTAL_PNL]: n.t("Total PNL")
}
  , Hve = {
    [Rc.RAYDIUM]: !0,
    [Rc.RAYDIUM_CLMM]: !0,
    [Rc.RAYDIUM_CP]: !0,
    [Rc.WHIRLPOOL]: !0,
    [Rc.METEORA_OLD]: !0,
    [Rc.METEORA_DLMM]: !0,
    [Rc.PUMP_FUN]: !0,
    [Rc.PUMP_SWAP]: !0,
    [Rc.LAUNCH_LAB]: !0,
    [Rc.BOOP]: !0,
    [Rc.METEORA_CURVE]: !0,
    [Rc.METEORA_DAMM_V2]: !0,
    [Rc.MOONIT]: !0,
    [Rc.SUGAR]: !0,
    [Rc.SUGAR_TEST]: !0,
    [Rc.HEAVEN]: !0,
    [Rc.TOKEN_MILL]: !0,
    [Lc.UNISWAP_V2]: !1,
    [Lc.UNISWAP_V3]: !1,
    [Lc.PANCAKE_V3]: !1,
    [Lc.AERODROME_V2]: !1,
    [Lc.AERODROME_V3]: !1,
    [Lc.VISTA]: !1,
    [Lc.FOUR_MEME]: !1
}
  , zve = {
    isLoading: !0,
    [Bve.INVESTED]: {
        value: null,
        valueNative: null
    },
    [Bve.COST]: {
        value: null,
        valueNative: null
    },
    [Bve.REMAINING]: {
        value: null,
        valueNative: null
    },
    [Bve.SOLD]: {
        value: null,
        valueNative: null
    },
    [Bve.PNL]: {
        value: null,
        valueNative: null
    },
    [Bve.PNL_PERCENTAGE]: {
        value: null,
        valueNative: null
    },
    [Bve.TOTAL_PNL]: {
        value: null,
        valueNative: null
    }
}
  , $ve = {
    variant: "paragraph1",
    color: "text.value"
}
  , Gve = [Bve.INVESTED, Bve.COST, Bve.REMAINING, Bve.SOLD, Bve.PNL, Bve.PNL_PERCENTAGE, Bve.TOTAL_PNL]
  , qve = {
    ...Vve,
    [Bve.PNL_PERCENTAGE]: n.t("PNL %")
}
  , Kve = y.memo(( ({currencyMode: e, setCurrencyMode: t}) => {
    const {t: n} = we()
      , r = y.useCallback(( (e, n) => {
        t(n)
    }
    ), [t])
      , a = y.useMemo(( () => pZ(n, Yve)), [n]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            ...$ve,
            children: "Currency"
        }), v.jsx(IH, {
            size: "xxsmall",
            value: e,
            onChange: r,
            items: a,
            maxItemWidth: Xve
        })]
    })
}
))
  , Yve = [{
    value: uZ.NATIVE,
    label: "Native"
}, {
    value: uZ.USD,
    label: "USD"
}]
  , Xve = 54
  , Qve = y.memo(( () => {
    const {t: e} = we()
      , {settings: t, updateMarkPriceMode: n} = rf()
      , r = y.useCallback(( (e, t) => {
        n(t)
    }
    ), [n])
      , a = y.useMemo(( () => pZ(e, Zve)), [e]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            ...$ve,
            children: "USD marking method"
        }), v.jsx(IH, {
            size: "xxsmall",
            value: (null == t ? void 0 : t.markPriceMode) ?? Gh.TXN_TIME,
            onChange: r,
            items: a,
            maxItemWidth: Jve
        })]
    })
}
))
  , Zve = [{
    value: Gh.TXN_TIME,
    label: "Txn time"
}, {
    value: Gh.CURRENT,
    label: "Current"
}]
  , Jve = 96
  , eSe = y.memo(( ({value: e, onChange: t, allowEmpty: n=!1}) => {
    const {t: r} = we()
      , a = D()
      , s = y.useMemo(( () => [...n ? [null] : [], ...Gve]), [n]);
    return v.jsx(it, {
        value: e ?? "none",
        size: "xsmall",
        MenuProps: {
            sx: e => ({
                color: e.palette.background.borderMain
            }),
            PaperProps: {
                className: "padre-no-scroll",
                style: {
                    backgroundColor: a.palette.background.secondary
                },
                sx: e => ({
                    border: `1px solid ${e.palette.background.borderMain}`,
                    boxShadow: "none"
                })
            }
        },
        placeholder: r("never"),
        renderValue: () => v.jsx(k, {
            variant: "paragraph3",
            color: "text.value",
            children: null === e ? Ud : qve[e]
        }),
        children: s.map((n => {
            const a = n === e;
            return v.jsx(te, {
                value: n ?? "none",
                sx: tSe,
                onClick: async () => {
                    t(n)
                }
                ,
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: a ? "text.value" : "text.label",
                    children: null === n ? r("Nothing") : qve[n]
                })
            }, n ?? "none")
        }
        ))
    })
}
))
  , tSe = e => ({
    bgcolor: e.palette.background.secondary,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    }
})
  , nSe = y.memo(( ({label: e, currentOrder: t, setOrder: n}) => v.jsxs(S, {
    gap: 1,
    children: [v.jsx(k, {
        ...$ve,
        children: e
    }), v.jsx(S, {
        gap: .5,
        maxWidth: 220,
        children: t.map(( (e, r) => v.jsx(eSe, {
            value: e,
            onChange: a => {
                if (a === e || null === a)
                    return;
                const s = t.findIndex((e => e === a))
                  , o = [...t];
                -1 !== s && (o[s] = e),
                o[r] = a,
                n(o)
            }
        }, e)))
    })]
})))
  , rSe = y.memo(( () => {
    const {t: e} = we()
      , {settings: t, updateRemainingBasisMode: n} = rf()
      , r = y.useCallback(( (e, t) => {
        n(t)
    }
    ), [n])
      , a = y.useMemo(( () => pZ(e, aSe)), [e]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(k, {
                ...$ve,
                children: e("Remaining basis")
            }), !R && v.jsx(GC, {
                title: v.jsxs(S, {
                    gap: 1,
                    children: [v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: e("Market Value: value at current market price, without price impact")
                    }), v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: e("Exit Value: returns from selling the entire position, accounting for price impact")
                    })]
                }),
                children: v.jsx(C, {
                    display: "flex",
                    sx: oSe,
                    children: v.jsx(QS, {})
                })
            })]
        }), v.jsx(IH, {
            size: "xxsmall",
            value: (null == t ? void 0 : t.remainingBasis) ?? qh.MARKET_VALUE,
            onChange: r,
            items: a,
            maxItemWidth: sSe
        })]
    })
}
))
  , aSe = [{
    value: qh.MARKET_VALUE,
    label: "Mkt Value"
}, {
    value: qh.EXIT_VALUE,
    label: "Exit Value"
}]
  , sSe = 96
  , oSe = {
    "&:hover": {
        cursor: "help"
    }
}
  , lSe = y.memo(( ({sumMode: e, setSumMode: t}) => {
    const {t: n} = we()
      , r = y.useCallback(( (e, n) => {
        t(n)
    }
    ), [t])
      , a = y.useMemo(( () => pZ(n, iSe)), [n]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(k, {
            ...$ve,
            children: n("Position scope")
        }), v.jsx(IH, {
            size: "xxsmall",
            value: e,
            onChange: r,
            items: a,
            maxItemWidth: cSe
        })]
    })
}
))
  , iSe = [{
    value: qde.SELECTED,
    label: "Selected only"
}, {
    value: qde.ALL,
    label: "All wallets"
}]
  , cSe = 96
  , dSe = y.memo(( ({isOpen: e, onClose: t}) => {
    const {t: n} = we()
      , r = bw()
      , a = D()
      , {sumMode: s, setSumMode: o} = Xde()
      , {currencyMode: l, setCurrencyMode: i, positionBoxOrder: c, setPositionBoxOrder: d, positionBoxMobileLookupOrder: u, setPositionBoxMobileLookupOrder: p, showOnInstantTrade: h, setShowOnInstantTrade: m} = TSe()
      , g = y.useCallback(( () => {
        m((e => !e))
    }
    ), [m])
      , x = y.useMemo(( () => u ? u.length !== Uve.length ? Uve : u : void 0), [u]);
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        stackSx: {
            px: 3,
            pt: 1,
            pb: 2.5
        },
        desktopWidth: 260,
        minDesktopWidth: 260,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsxs(S, {
                direction: "row",
                sx: {
                    py: 1,
                    gap: 1,
                    alignItems: "center",
                    justifyContent: "space-between"
                },
                children: [v.jsx(k, {
                    variant: "h2",
                    color: "text.value",
                    children: n("Position Settings")
                }), v.jsx(F, {
                    sx: {
                        p: .75
                    },
                    onClick: t,
                    children: v.jsx(kS, {
                        color: a.palette.text.value
                    })
                })]
            }), v.jsx(Kve, {
                currencyMode: l,
                setCurrencyMode: i
            }), v.jsx(lSe, {
                sumMode: s,
                setSumMode: o
            }), v.jsx(Qve, {}), v.jsx(rSe, {}), v.jsx(nSe, {
                label: n("Main Stats"),
                currentOrder: c,
                setOrder: d
            }), !r && x && v.jsx(nSe, {
                label: n("Mobile Preview"),
                currentOrder: x,
                setOrder: p
            }), v.jsx(WR, {
                label: n("Show on Instant Trade"),
                isChecked: h,
                onClick: g,
                isFullWidth: !0,
                textVariant: "paragraph1"
            })]
        })
    })
}
))
  , uSe = ["currentCostInUsdUi", "currentCostInNativeUi", "unrealizedPnlInUsdUi", "unrealizedPnlInNativeUi", "currentValueInUsdUi", "currentValueInNativeUi", "totalInvestedInUsdUi", "totalInvestedInNativeUi", "totalSoldInUsdUi", "totalSoldInNativeUi"]
  , pSe = ["avgSellFillPriceInUsdUi", "avgFillPriceInUsdUi", "avgBuyPriceInUsdUi"]
  , hSe = e => e.totalInvestedInUsdUi ?? 0
  , mSe = (e, t) => {
    if (!t)
        return e;
    const [n,r] = [hSe(e), hSe(t)];
    return {
        ...t,
        balance: null === e.balance ? t.balance : null === t.balance ? e.balance : (BigInt(e.balance) + BigInt(t.balance)).toString(),
        ...Object.fromEntries(pSe.map((a => {
            const s = Number(e[a] ?? 0)
              , o = Number(t[a] ?? 0);
            return [a, null === e[a] && null === t[a] || n + r === 0 ? null : (s * Number(n) + o * Number(r)) / (Number(n) + Number(r))]
        }
        ))),
        ...Object.fromEntries(uSe.map((n => [n, null === e[n] ? t[n] : null === t[n] ? e[n] : (t[n] ?? 0) + (e[n] ?? 0)])))
    }
}
  , gSe = (e, t, n) => c.reduce(e, ( (e, r) => {
    var a;
    const s = null == (a = t[r]) ? void 0 : a.perTokenId;
    if (!s)
        return e;
    const o = s[n];
    return o ? e = e ? mSe(o, e) : o : e
}
), null)
  , xSe = (e, t) => !!e && Math.abs(e) >= (t === uZ.USD ? .005 : 5e-4)
  , bSe = (e, t, n, r, a=!1) => {
    const s = ( (e, t, n=!1) => {
        const r = Math.abs(e);
        if (n)
            return r >= 100 ? 0 : 1;
        switch (t) {
        case uZ.NATIVE:
            return r > 100 ? 1 : r > 10 ? 2 : 3;
        case uZ.USD:
            return r > 1e5 ? 1 : 2
        }
    }
    )(e, n, a)
      , o = `${e < 0 ? "-" : ""}${LI(Math.abs(e), {
        symbol: t,
        collapseExponent: !0,
        maxPrecision: s,
        minPrecision: s,
        symbolPosition: a ? yI.END : yI.START,
        padSymbol: !1,
        noTrailingZeros: a || n === uZ.NATIVE
    })}`;
    return r ? o : o.replace(/^[+-]/, "")
}
  , fSe = (e, t, n, r, a) => Hve[e.protocol.type] ? !r || r < 5e3 ? null : {
    basePriceInUsdUi: n,
    baseDecimals: e.baseToken.decimals,
    basePriceInNativeUi: ru(e.quoteToken.address) ? t : a && n && Ej(e.quoteToken.address) ? n / a : null
} : null
  , vSe = (e, t, n) => {
    var r;
    const a = n ?? (null == (r = e.tokenInfo) ? void 0 : r.decimals) ?? null
      , s = e.chain === Pd.SOLANA ? kU : yU;
    if (!a)
        return null;
    const o = ( (e, t, n, r) => {
        if (!e.virtualNativeLiquidity || !e.balance || "0" === e.balance || !n)
            return null;
        const a = (null == t ? void 0 : t.basePriceInNativeUi) ? t.basePriceInNativeUi : e.markPriceInNativeUi
          , s = a ? Lj({
            priceInclDecimals: a,
            baseDecimals: n,
            quoteDecimals: r
        }) : null;
        if (null === s)
            return null;
        const o = Oj({
            liquidity: e.virtualNativeLiquidity,
            unadjustedPrice: s
        });
        return gF({
            amountIn: BigInt(e.balance),
            reserveIn: o.baseReserves,
            reserveOut: o.quoteReserves,
            feePpm: 0n
        })
    }
    )(e, t, a, s);
    return null === o ? null : Number(o) / 10 ** s
}
  , SSe = (e, t, n, r, a) => {
    const s = !!t && e.balance && "0" !== e.balance
      , o = a === qh.MARKET_VALUE ? null : vSe(e, t, r);
    if (null !== o) {
        if (n)
            return o;
        const t = e.currentValueInUsdUi && e.currentValueInNativeUi ? e.currentValueInUsdUi / e.currentValueInNativeUi : null;
        if (t)
            return t * o
    }
    return s && t.basePriceInUsdUi && t.baseDecimals && !n ? Number(e.balance) * t.basePriceInUsdUi / 10 ** t.baseDecimals : s && t.basePriceInNativeUi && t.baseDecimals && n ? Number(e.balance) * t.basePriceInNativeUi / 10 ** t.baseDecimals : n ? e.currentValueInNativeUi : e.currentValueInUsdUi
}
  , ySe = (e, t, n) => {
    const r = e.balance && "0" !== e.balance ? Number(e.balance) : null
      , a = t ? n ? t.basePriceInNativeUi : t.basePriceInUsdUi : null
      , s = n ? e.currentCostInNativeUi : e.currentCostInUsdUi;
    return t && null !== r && a && null !== s ? r * a / 10 ** t.baseDecimals - s : n ? e.unrealizedPnlInNativeUi : e.unrealizedPnlInUsdUi
}
  , kSe = (e, t, n, r) => n === Gh.TXN_TIME ? {
    value: e,
    valueNative: t
} : {
    value: null !== t && null !== r ? t * r : null,
    valueNative: t
}
  , CSe = ({positionBoxEntry: e, stats: t, currencyMode: n, imageData: r}) => {
    const a = t[e]
      , s = n === uZ.NATIVE ? a.valueNative : a.value
      , o = Wve.has(e) ? s ?? 0 : void 0;
    return [e === Bve.TOTAL_PNL && r ? v.jsxs(S, {
        height: ASe,
        direction: "row",
        gap: .25,
        alignItems: "flex-start",
        children: [v.jsx(k, {
            height: ASe,
            variant: "inherit",
            color: "inherit",
            noWrap: !0,
            children: e === Bve.TOTAL_PNL ? "T. PNL" : Vve[e]
        }), v.jsx(C, {
            mt: -.25,
            children: v.jsx(i4, {
                imageData: r,
                iconSize: 13,
                padding: "1px"
            })
        })]
    }) : Vve[e], s, o]
}
  , ASe = 17
  , wSe = y.createContext({
    currencyMode: uZ.USD,
    setCurrencyMode: c.noop,
    positionBoxOrder: _ve,
    setPositionBoxOrder: c.noop,
    positionBoxMobileLookupOrder: Uve,
    setPositionBoxMobileLookupOrder: c.noop,
    openModal: c.noop,
    stats: zve,
    pnlImageData: null,
    showOnInstantTrade: !0,
    setShowOnInstantTrade: c.noop
})
  , jSe = ({children: e}) => {
    var t, n;
    const [r,a] = y.useState(!1)
      , s = y.useCallback(( () => {
        a(!0)
    }
    ), [])
      , o = y.useCallback(( () => {
        a(!1)
    }
    ), [])
      , [l,i] = Mx("padreV2-PositionBoxCurrencyModeMode", uZ.USD)
      , [c,d] = Mx("padreV2-positionBoxOrder", _ve)
      , [u,p] = Mx("padreV2-positionBoxMobileLookupOrder", Uve)
      , [h,m] = Mx("padreV2-positionBoxShowOnInstantTrade", !0)
      , {originalStaticMarketInfo: g, chainId: x} = Qce()
      , b = hde(g)
      , f = y.useMemo(( () => b ?? Dve(x)), [b, x])
      , {userStats: S} = rH()
      , {settings: k} = rf()
      , C = VV(f.chain)
      , {selectedWalletsAddresses: A, compatibleWalletsAddresses: w} = Gde()
      , {portfolioData: j, allPortfolioData: T, sumMode: I} = Xde()
      , E = ode()
      , M = gde()
      , N = bde()
      , {chainStats: P} = FV()
      , [O,L] = y.useMemo(( () => ( (e, t, n) => {
        if (!t || !e)
            return [null, !0];
        if (!n.length)
            return [null, !1];
        const r = bg(e.chain, e.baseToken.address)
          , a = gSe(n, t, r);
        return a ? [a, !1] : [null, !1]
    }
    )(f, I === qde.ALL ? T : j, I === qde.ALL ? w.map((e => ng(e.publicAddress))) : A)), [T, w, f, j, A, I])
      , R = y.useMemo(( () => {
        var e, t;
        const n = f.chain === Pd.SOLANA ? (null == (t = null == (e = null == P ? void 0 : P.perChain) ? void 0 : e.SOLANA) ? void 0 : t.stats.nativePriceInUsdUi) ?? null : null;
        return fSe(f, M, E, N, n)
    }
    ), [M, E, null == (n = null == (t = null == P ? void 0 : P.perChain) ? void 0 : t.SOLANA) ? void 0 : n.stats.nativePriceInUsdUi, N, f])
      , D = y.useMemo(( () => ( (e, t, n, r, a, s, o) => {
        if (!e.marketAddress)
            return zve;
        if (!t)
            return {
                ...zve,
                isLoading: n
            };
        const l = t.totalInvestedInUsdUi
          , i = t.totalInvestedInNativeUi
          , c = SSe(t, r, !1, e.baseToken.decimals, o)
          , d = SSe(t, r, !0, e.baseToken.decimals, o)
          , u = t.totalSoldInUsdUi
          , p = t.totalSoldInNativeUi
          , h = null !== c && null !== l ? (u ?? 0) + c - (l ?? 0) : null
          , m = null !== d && null !== i ? (p ?? 0) + d - (i ?? 0) : null
          , g = ySe(t, r, !1)
          , x = ySe(t, r, !0)
          , b = t.currentCostInUsdUi
          , f = t.currentCostInNativeUi
          , v = null !== g && b ? 100 * g / b : null
          , S = null !== x && f ? 100 * x / f : null;
        return {
            isLoading: !1,
            [Bve.INVESTED]: kSe(l, i, a, s),
            [Bve.COST]: kSe(b, f, a, s),
            [Bve.REMAINING]: kSe(c, d, a, s),
            [Bve.SOLD]: kSe(u, p, a, s),
            [Bve.PNL]: kSe(g, x, a, s),
            [Bve.PNL_PERCENTAGE]: {
                value: a === Gh.CURRENT ? S : v,
                valueNative: S
            },
            [Bve.TOTAL_PNL]: kSe(h, m, a, s)
        }
    }
    )(f, O, L, R, (null == k ? void 0 : k.markPriceMode) ?? Gh.CURRENT, C, (null == k ? void 0 : k.remainingBasis) ?? qh.MARKET_VALUE)), [f, O, L, R, null == k ? void 0 : k.markPriceMode, null == k ? void 0 : k.remainingBasis, C])
      , B = y.useMemo(( () => {
        var e;
        return D && O && !D.isLoading && D[Bve.INVESTED].value && null !== D[Bve.TOTAL_PNL].value && S.status === ox.READY ? {
            symbol: (null == (e = O.tokenInfo) ? void 0 : e.symbol) || "",
            chain: f.chain,
            investedNative: D[Bve.INVESTED].valueNative,
            profitNative: D[Bve.TOTAL_PNL].valueNative,
            profitAmount: D[Bve.TOTAL_PNL].value,
            profitPercentage: null !== D[Bve.TOTAL_PNL].value && D[Bve.INVESTED].value ? 100 * D[Bve.TOTAL_PNL].value / D[Bve.INVESTED].value : 0,
            investedAmount: D[Bve.INVESTED].value,
            remainingNative: D[Bve.REMAINING].valueNative,
            remainingAmount: D[Bve.REMAINING].value ?? 0,
            refCode: "kol" === S.data.type ? S.data.kolName : null,
            holdTime: O.holdTimeInSeconds,
            multiplier: (null !== D[Bve.TOTAL_PNL].value && D[Bve.INVESTED].value ? D[Bve.TOTAL_PNL].value / D[Bve.INVESTED].value + 1 : 1).toFixed(D[Bve.TOTAL_PNL].value / D[Bve.INVESTED].value + 1 > .1 ? 2 : 4)
        } : null
    }
    ), [f.chain, O, D, S])
      , _ = y.useMemo(( () => ({
        currencyMode: l,
        setCurrencyMode: i,
        positionBoxOrder: c,
        setPositionBoxOrder: d,
        positionBoxMobileLookupOrder: u,
        setPositionBoxMobileLookupOrder: p,
        openModal: s,
        stats: D,
        pnlImageData: B,
        showOnInstantTrade: h,
        setShowOnInstantTrade: m
    })), [l, u, c, i, p, d, s, D, B, h, m]);
    return v.jsxs(wSe.Provider, {
        value: _,
        children: [e, r && v.jsx(dSe, {
            isOpen: r,
            onClose: o
        })]
    })
}
  , TSe = () => y.useContext(wSe)
  , ISe = y.createContext({
    isTradingWidgetOpen: !1,
    toggleTradingWidget: c.noop,
    isBubblemapWidgetOpen: !1,
    toggleBubblemapWidget: c.noop,
    isInSidePanelMode: !1,
    toggleIsInSidePanelMode: c.noop,
    isSidePanelOpen: !1,
    toggleSidePanelOpen: c.noop
})
  , ESe = () => y.useContext(ISe)
  , MSe = y.memo(( ({isLoading: e, label: t, value: n, currencyMode: r, chain: a, colorTypographyValue: s, isPercentage: o=!1, toggleCurrencyMode: l, isMobileLookup: i=!1, isInstantTrade: d=!1, mobileJustifyContent: u, isGrid: p=!1, isFirst: h=!1, hasExtraWideRow: m=!1, extraWideLabel: g}) => {
    const x = bw()
      , {font: b} = Vb()
      , f = y.useMemo(( () => b === ku.GEIST ? `${RSe}px` : RSe - 1 + "px"), [b])
      , A = y.useMemo(( () => {
        if (null === n)
            return Ud;
        const e = WSe(o, r, a);
        return null === n ? Ud : bSe(n, e, r, xSe(n, r), o)
    }
    ), [a, r, n, o])
      , w = y.useMemo(( () => {
        if (null === n || o || r !== uZ.NATIVE)
            return null;
        switch (a) {
        case Pd.BSC:
            return v.jsx(S, {
                alignItems: "center",
                mt: d ? "-2px" : 0,
                children: v.jsx(ak, {
                    size: i ? 16 : 15
                })
            });
        case Pd.SOLANA:
            return v.jsx(S, {
                alignItems: "center",
                mt: i ? "-2px" : 0,
                children: v.jsx(dk, {
                    size: i ? 15 : 14
                })
            });
        default:
            return null
        }
    }
    ), [a, r, i, o, d, n])
      , j = v.jsxs(S, {
        direction: "row",
        minWidth: 0,
        alignItems: "center",
        mt: i ? "-1px" : 0,
        gap: .25,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            children: [void 0 === s ? v.jsx(k, {
                variant: d ? "paragraph3" : x ? "paragraph1" : "paragraph3",
                lineHeight: f,
                color: "text.main",
                ...Nu,
                noWrap: i || d,
                children: A
            }) : v.jsx(RZ, {
                variant: d ? "paragraph3" : x ? "paragraph1" : "paragraph3",
                lineHeight: f,
                value: xSe(n, r) ? s : 0,
                formattedDisplay: A,
                ...Nu
            }), w]
        }), g ? void 0 === s ? v.jsx(k, {
            variant: d ? "paragraph3" : x ? "paragraph1" : "paragraph3",
            fontWeight: d ? 400 : x ? void 0 : 400,
            lineHeight: f,
            color: "text.main",
            ...Nu,
            noWrap: i || d,
            children: g
        }) : v.jsx(RZ, {
            variant: d ? "paragraph3" : x ? "paragraph1" : "paragraph3",
            fontWeight: d ? 400 : x ? void 0 : 400,
            lineHeight: f,
            value: xSe(n, r) ? s : 0,
            formattedDisplay: g,
            ...Nu
        }) : null]
    })
      , T = v.jsxs(S, {
        className: "no-drag",
        flex: p ? void 0 : 1,
        direction: i || d ? "row" : "column",
        justifyContent: d ? "center" : i ? u : "center",
        alignItems: d ? "center" : void 0,
        gap: i || d ? .5 : .75,
        height: d ? NSe : i ? PSe : x ? LSe : OSe,
        children: [t && v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            sx: {
                height: 17,
                mt: i ? "1px" : 0
            },
            noWrap: i || d,
            children: t
        }), e ? v.jsx(Ie, {
            variant: "rounded",
            width: c.isNil(g) ? 40 : 75,
            height: 16,
            sx: d ? USe : void 0
        }) : v.jsx(GC, {
            title: d ? "" : `Switch currency to ${r === uZ.USD ? GD(a) : "USD"}`,
            children: v.jsx(C, {
                component: "span",
                height: RSe,
                children: !l || p && d ? j : v.jsx(V, {
                    size: "xxsmall",
                    variant: "tertiary",
                    sx: {
                        ...DSe,
                        height: RSe,
                        alignSelf: "center",
                        ...i || d ? {
                            mt: 0
                        } : {},
                        ...d ? {
                            mb: 0
                        } : {}
                    },
                    onClick: l,
                    children: j
                })
            })
        })]
    });
    return d ? v.jsx(tn, {
        item: !0,
        xs: m ? c.isNil(g) ? 2.7 : 3.9 : 3,
        sx: h ? void 0 : BSe,
        children: v.jsx(te, {
            className: "no-drag",
            sx: _Se,
            onClick: l,
            children: T
        })
    }) : p ? v.jsx(tn, {
        item: !0,
        xs: m ? c.isNil(g) ? 2.7 : 3.9 : 3,
        children: T
    }) : T
}
))
  , NSe = 28
  , PSe = 24
  , OSe = 32
  , LSe = 48
  , RSe = 16
  , DSe = {
    backgroundColor: "transparent",
    py: 0,
    pl: .5,
    pr: .75,
    mb: 1.5,
    ml: -.5,
    border: "none",
    "&:focus": {
        backgroundColor: "transparent"
    }
}
  , BSe = e => ({
    borderLeft: `1px solid ${e.palette.background.borderMain}`
})
  , _Se = {
    height: NSe,
    mt: -.25,
    ml: -.25,
    px: 0,
    pt: "7px",
    justifyContent: "center",
    "&:focus": {
        background: "transparent"
    }
}
  , USe = {
    mt: -.25
}
  , WSe = (e, t, n) => {
    if (e)
        return "%";
    if (t === uZ.USD)
        return "$";
    switch (n) {
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return mM;
    default:
        return ""
    }
}
  , FSe = y.memo(( ({marketInfo: e}) => {
    const {t: t} = we()
      , {currencyMode: n, setCurrencyMode: r, positionBoxOrder: a, openModal: s, stats: o, pnlImageData: l} = TSe()
      , i = y.useMemo(( () => a.length !== _ve.length ? _ve : a), [a])
      , c = y.useCallback(( () => {
        r((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [r])
      , d = y.useMemo(( () => a.some((e => e === Bve.TOTAL_PNL))), [a]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            sx: HSe,
            children: [v.jsx(VSe, {
                onClick: s
            }), v.jsx(tn, {
                container: !0,
                width: "100%",
                spacing: .5,
                mr: -1.5,
                children: i.map((r => {
                    const [a,s,i] = CSe({
                        positionBoxEntry: r,
                        stats: o,
                        currencyMode: n,
                        imageData: l ?? void 0
                    })
                      , u = r === Bve.TOTAL_PNL ? CSe({
                        positionBoxEntry: Bve.PNL_PERCENTAGE,
                        stats: o,
                        currencyMode: n
                    })[1] : null
                      , p = null === u ? void 0 : `(${u < 0 ? "-" : ""}${jI(u, {
                        omitSign: !0,
                        precision: 0
                    })})`;
                    return v.jsx(MSe, {
                        isLoading: o.isLoading,
                        label: "string" == typeof a ? t(a) : a,
                        value: s,
                        currencyMode: n,
                        chain: e.chain,
                        colorTypographyValue: i,
                        isPercentage: Fve.has(r),
                        toggleCurrencyMode: c,
                        isGrid: !0,
                        hasExtraWideRow: d,
                        extraWideLabel: p
                    }, r)
                }
                ))
            })]
        })
    })
}
))
  , VSe = y.memo(( ({onClick: e}) => v.jsx(F, {
    onClick: e,
    sx: zSe,
    children: v.jsx(Ny, {})
})))
  , HSe = {
    ml: -1,
    gap: 1,
    mb: 1
}
  , zSe = {
    p: .5,
    mr: .25,
    width: 24
}
  , $Se = y.memo(( ({marketInfo: e}) => {
    const {currencyMode: t, setCurrencyMode: n, positionBoxMobileLookupOrder: r, stats: a} = TSe()
      , s = y.useMemo(( () => r.length !== Uve.length ? Uve : r), [r])
      , o = y.useCallback(( () => {
        n((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [n]);
    return v.jsx(S, {
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        children: s.map(( (n, r) => {
            const [s,l,i] = CSe({
                positionBoxEntry: n,
                stats: a,
                currencyMode: t
            })
              , c = n === Bve.TOTAL_PNL ? CSe({
                positionBoxEntry: Bve.PNL_PERCENTAGE,
                stats: a,
                currencyMode: t
            })[1] : null
              , d = null === c ? void 0 : `(${c < 0 ? "-" : ""}${jI(c, {
                omitSign: !0,
                precision: 0
            })})`;
            return v.jsx(MSe, {
                isLoading: a.isLoading,
                label: s,
                value: l,
                currencyMode: t,
                chain: e.chain,
                colorTypographyValue: i,
                isPercentage: Fve.has(n),
                isMobileLookup: !0,
                mobileJustifyContent: 0 === r ? "flex-start" : "flex-end",
                toggleCurrencyMode: o,
                extraWideLabel: d
            }, n)
        }
        ))
    })
}
))
  , GSe = y.memo(( ({marketInfo: e}) => {
    const {currencyMode: t, setCurrencyMode: n, positionBoxOrder: r, stats: a} = TSe()
      , s = y.useCallback(( () => {
        n((e => e === uZ.NATIVE ? uZ.USD : uZ.NATIVE))
    }
    ), [n])
      , o = y.useMemo(( () => r.some((e => e === Bve.TOTAL_PNL))), [r]);
    return v.jsx(S, {
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        sx: qSe,
        children: v.jsx(tn, {
            container: !0,
            width: "100%",
            spacing: .25,
            children: r.map(( (n, r) => {
                const [,l,i] = CSe({
                    positionBoxEntry: n,
                    stats: a,
                    currencyMode: t
                })
                  , c = n === Bve.TOTAL_PNL ? CSe({
                    positionBoxEntry: Bve.PNL_PERCENTAGE,
                    stats: a,
                    currencyMode: t
                })[1] : null
                  , d = null === c ? void 0 : `(${c < 0 ? "-" : ""}${jI(c, {
                    omitSign: !0,
                    precision: 0
                })})`;
                return v.jsx(MSe, {
                    isLoading: a.isLoading,
                    label: "",
                    value: l ?? 0,
                    currencyMode: t,
                    chain: e.chain,
                    colorTypographyValue: i,
                    isPercentage: Fve.has(n),
                    isInstantTrade: !0,
                    mobileJustifyContent: "center",
                    toggleCurrencyMode: s,
                    isGrid: !0,
                    isFirst: 0 === r,
                    hasExtraWideRow: o,
                    extraWideLabel: n === Bve.TOTAL_PNL ? d ?? "" : void 0
                }, n)
            }
            ))
        })
    })
}
))
  , qSe = e => ({
    ml: -1,
    mr: -1.25,
    mb: -1,
    pt: .25,
    borderTop: `1px solid ${e.palette.background.borderMain}`
})
  , KSe = y.memo(( ({marketInfo: e}) => e ? v.jsx(S, {
    sx: YSe,
    children: v.jsx(FSe, {
        marketInfo: e
    })
}) : v.jsx(S, {
    sx: YSe
})))
  , YSe = e => ({
    width: 351,
    minWidth: 351,
    borderLeft: `1px solid ${e.palette.background.borderMain}`,
    px: 2,
    height: 64,
    pt: 1
})
  , XSe = y.createContext({
    selectedPreset: zh.NORMAL,
    setSelectedPreset: c.noop,
    openEditModal: c.noop,
    requiresReselect: !1
});
XSe.displayName = "SelectedPresetContext";
const QSe = () => y.useContext(XSe)
  , ZSe = {
    [Pd.BSC]: zh.NORMAL,
    [Pd.ETH_MAINNET]: zh.NORMAL,
    [Pd.ETH_SEPOLIA]: zh.NORMAL,
    [Pd.BASE]: zh.NORMAL,
    [Pd.ARBITRUM]: zh.NORMAL,
    [Pd.ARBITRUM_SEPOLIA]: zh.NORMAL,
    [Pd.SOLANA]: zh.NORMAL
}
  , JSe = ({chain: e, children: t}) => {
    const [n] = dx("padreV2-tradingFloatingWidgetOrderPreset", zh.NORMAL)
      , [r] = dx("padreV2-orderSelectedPresets", ZSe)
      , [a,s] = dx("padreV2-oldPresetsMigrated", !1)
      , [o,l] = Mx("padreV2-selectedOrderPresetsPerChain", (e => {
        const t = zb(e);
        return {
            ...ZSe,
            [Pd.SOLANA]: e,
            ...t ? {} : {
                [Pd.BSC]: e,
                [Pd.ETH_MAINNET]: e,
                [Pd.ETH_SEPOLIA]: e,
                [Pd.BASE]: e,
                [Pd.ARBITRUM]: e,
                [Pd.ARBITRUM_SEPOLIA]: e
            }
        }
    }
    )(n))
      , i = y.useMemo(( () => !a && ( (e, t, n) => {
        if (null === t)
            return !1;
        const r = t[n];
        return !r || r !== e[n]
    }
    )(o, r, e)), [a, o, r, e])
      , c = y.useCallback((t => {
        zb(t) && !$b.includes(e) || (l((n => ({
            ...n,
            [e]: t
        }))),
        a || s(!0))
    }
    ), [e, a, s, l])
      , [d,u] = y.useState(!1)
      , [p,h] = y.useState(xc.BUY)
      , m = y.useCallback(( (e=xc.BUY) => {
        h(e),
        u(!0)
    }
    ), [])
      , g = y.useCallback(( () => {
        u(!1)
    }
    ), [])
      , x = y.useMemo(( () => o[e]), [e, o])
      , b = y.useMemo(( () => ({
        selectedPreset: x,
        setSelectedPreset: c,
        openEditModal: m,
        requiresReselect: i
    })), [x, c, m, i]);
    return v.jsxs(XSe.Provider, {
        value: b,
        children: [t, e && v.jsx(tz, {
            isOpen: d,
            onClose: g,
            chain: e,
            preset: x ?? zh.NORMAL,
            setSelectedPreset: c,
            side: p
        })]
    })
}
;
var eye = (e => (e.TABLE = "TABLE",
e.SELECT = "SELECT",
e))(eye || {});
const tye = y.memo(( ({address: e, name: t, hideWalletIcon: n, pairBalances: r, isLoading: a, chain: s, padreAvatarUrl: o, showCheckbox: l=!1, isSelected: i=!1, isHeader: c=!1, isBig: d=!1}) => {
    const [u,p] = y.useMemo(( () => r ? [new sB({
        decimals: r.base.properties.decimals
    },BigInt(r.base.balance.rawAmount ?? "0")).toNumber(), new sB({
        decimals: r.quoteForExecution.properties.decimals
    },BigInt(r.quoteForExecution.balance.rawAmount ?? "0")).toNumber()] : [null, null]), [r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: oye,
        minHeight: d ? 48 : 28,
        width: "100%",
        children: [!n && v.jsx(C, {
            width: lye,
            display: "flex",
            alignItems: "center",
            children: v.jsx(iy, {
                size: lye
            })
        }), l && v.jsx(UR, {
            checked: i
        }), v.jsxs(S, {
            gap: .5,
            width: `calc(100% - ${(n ? 0 : lye) + (l ? 23 : 0)}px)`,
            direction: "row",
            children: [v.jsxs(S, {
                justifyContent: "center",
                width: "100%",
                gap: .25,
                pt: d && void 0 !== e ? .75 : 0,
                children: [v.jsx(S, {
                    direction: "row",
                    width: "100%",
                    overflow: "hidden",
                    alignItems: "center",
                    justifyContent: "space-between",
                    children: t || c ? v.jsx(k, {
                        variant: "paragraph3",
                        noWrap: !0,
                        sx: aye,
                        color: 0 === u && 0 === p && n ? "text.label" : "text.value",
                        ...Nu,
                        children: t
                    }) : v.jsx(sye, {
                        width: 90
                    })
                }), d && void 0 !== e && v.jsx(cA, {
                    address: e,
                    stopPropagation: !0,
                    preventDefault: !0,
                    customName: e.slice(0, 4),
                    labelSx: cye
                })]
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                sx: {
                    border: "none"
                },
                ...Nu,
                children: [v.jsx(rye, {
                    value: u,
                    symbol: (null == r ? void 0 : r.base.properties.symbol) || null,
                    chain: s,
                    isLoading: a || (null == r ? void 0 : r.base.balance.isLoading),
                    address: (null == r ? void 0 : r.base.properties.address) || null,
                    padreAvatarUrl: o,
                    fontWeight: c ? 600 : void 0,
                    isBase: !0
                }), v.jsx(rye, {
                    value: p,
                    symbol: (null == r ? void 0 : r.quoteForExecution.properties.symbol) || null,
                    chain: s,
                    isLoading: a || (null == r ? void 0 : r.quoteForExecution.balance.isLoading),
                    minWidth: nye,
                    fontWeight: c ? 600 : void 0
                })]
            })]
        })]
    })
}
))
  , nye = 65
  , rye = y.memo(( ({value: e, symbol: t, chain: n, isLoading: r, address: a, padreAvatarUrl: s, minWidth: o, fontWeight: l, isBase: i}) => r ? v.jsx(S, {
    alignContent: "center",
    justifyContent: "center",
    children: v.jsx(sye, {
        width: 50
    })
}) : null === e ? null : v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    gap: .5,
    children: [a && n && (!i || !!e) && v.jsx(b_, {
        url: IE(n, a),
        padreAvatarUrl: s ?? null,
        name: t ?? "?",
        chain: n,
        size: 16,
        protocolInfo: null,
        hideHoverAvatar: !0
    }), (!!e || !i) && v.jsxs(k, {
        variant: "paragraph3",
        fontWeight: l,
        color: e ? "text.value" : "text.label",
        sx: {
            whiteSpace: "nowrap",
            display: "flex",
            alignItems: "center",
            justifyContent: "flex-end",
            height: iye,
            gap: .25,
            minWidth: o
        },
        children: [LI(e, {
            collapseExponent: !0,
            symbol: a ? "" : "ETH" === t ? mM : "SOL" === t || "BNB" === t ? "" : t || "",
            padSymbol: !0,
            maxPrecision: 3
        }), "SOL" === t && v.jsx(dk, {}), "BNB" === t && v.jsx(C, {
            display: "flex",
            mt: "-1px",
            children: v.jsx(ak, {})
        })]
    })]
})))
  , aye = {
    maxWidth: 140
}
  , sye = B(Ie)(( () => ({
    height: 12,
    transform: "scale(1, 0.8)"
})))
  , oye = 1
  , lye = 16
  , iye = 16
  , cye = {
    ml: "-3px"
}
  , dye = ({userWalletAddr: e, destWallets: t, mint: n, tokenType: r, decimals: a}) => {
    const s = m.chunk(t, 9);
    return {
        txns: s.map((t => uye({
            userWalletAddr: e,
            destWallets: t,
            mint: n,
            tokenType: r,
            decimals: a
        }))),
        lamportsRequired: (n === Gc ? 0n : BigInt(t.length) * Bj) + 6000n * BigInt(s.length)
    }
}
  , uye = ({userWalletAddr: e, destWallets: t, mint: n, tokenType: r, decimals: a}) => {
    if (!t.length)
        throw new hj("Destintation wallet list must not be empty");
    if (t.length > 9)
        throw new hj("At most 9 wallets can be handled in a single txn");
    const s = Tj(e, n, r)
      , o = t.flatMap((t => {
        if (n === Gc) {
            if (t.amount < 1000000n)
                throw new hj("Amount transferred to each wallet must be at least 0.001 SOL");
            return [de.transfer({
                fromPubkey: mj(e),
                toPubkey: mj(t.addr),
                lamports: t.amount
            })]
        }
        const o = Tj(t.addr, n, r);
        return [kj(e, t.addr, {
            address: o,
            mint: n,
            tokenType: r
        }), Cj(s, o, e, n, r, t.amount, a)]
    }
    ))
      , l = wV(1000n, e);
    return fj({
        feePayer: e,
        instructions: o,
        lookupTableAccounts: []
    }, l)
}
  , pye = e => {
    const t = e * BigInt(20) / 100n;
    return e - t + BigInt(Math.floor(Math.random() * Number(2n * t + 1n)))
}
  , hye = async ({selectedWalletsAddresses: e, withBaseToken: t, withoutBaseToken: n, enqueueSnackbar: r, getSolFastData: a, getTxnSign: s, tokenInfo: o}) => {
    const l = new Set(e.map((e => ng(e))))
      , i = t.filter((e => l.has(ng(e.publicAddress))))
      , d = n.filter((e => l.has(ng(e.publicAddress))));
    if (i.length + d.length < 2)
        return void r({
            message: uu.selectAtLeastTwoWallets,
            type: "warning"
        }, "minimum-two-wallets-error");
    if (0 === i.length)
        return void r({
            message: uu.noTokenToSplit,
            type: "warning"
        }, "no-token-to-split-error");
    const u = c.reduce(i.map((e => {
        var t;
        return BigInt((null == (t = e.balances) ? void 0 : t.base.rawAmount) ?? "0")
    }
    )), ( (e, t) => e += t), 0n) / BigInt(e.length) * BigInt(Number(120. .toFixed(0))) / 100n
      , {disperseWallets: p, destinationWallets: h} = c.reduce([...i, ...d], ( (e, t) => {
        var n, r;
        const a = BigInt((null == (n = t.balances) ? void 0 : n.base.rawAmount) ?? "0")
          , s = ng(t.publicAddress);
        if (a >= u) {
            const n = BigInt((null == (r = t.balances) ? void 0 : r.native.rawAmount) ?? "0");
            e.disperseWallets.push({
                address: s,
                balance: a,
                nativeBalance: n
            })
        } else
            e.destinationWallets.push({
                address: s,
                balance: a
            });
        return e
    }
    ), {
        disperseWallets: [],
        destinationWallets: []
    });
    if (!p.length || !h.length)
        return void r({
            message: uu.alreadyDispersed,
            type: "warning"
        }, "already-dispersed-error");
    const {fromDisperse: m, toDestination: g} = ( (e, t) => {
        const n = c.reduce([...e, ...t], ( (e, t) => e + t.balance), 0n)
          , r = e.length + t.length
          , a = n / BigInt(r);
        let s = e.map((e => {
            const t = e.balance - a;
            return t > 0n ? pye(t) : 0n
        }
        ));
        const o = t.map((e => {
            const t = a - e.balance;
            return t > 0n ? pye(t) : 0n
        }
        ))
          , l = s.reduce(( (e, t) => e + t), 0n)
          , i = o.reduce(( (e, t) => e + t), 0n);
        if (l !== i) {
            const e = Number(i) / Number(l || 1n);
            s = s.map((t => BigInt(Math.floor(Number(t) * e))))
        }
        return {
            fromDisperse: s,
            toDestination: o
        }
    }
    )(p, h);
    if (m.length !== p.length || g.length !== h.length)
        return void r({
            message: uu.unknownError,
            snackName: pu.splitFailed,
            type: "error"
        }, "split-failed");
    const x = ng(o.tokenAddress)
      , {walletSplitTxns: b} = c.reduce(p, ( (e, t, n) => {
        let r = m[n];
        if (0n === r)
            return e;
        const a = [];
        c.forEach(h, ( (t, n) => {
            if (0n === r)
                return;
            const s = e.currentToDestination[n];
            if (0n === s)
                return;
            const o = r > s ? s : r;
            e.currentToDestination[n] = s - o,
            r -= o,
            a.push({
                addr: t.address,
                amount: o
            })
        }
        ));
        const s = dye({
            userWalletAddr: t.address,
            destWallets: a,
            mint: x,
            tokenType: o.tokenType,
            decimals: o.decimals
        });
        return e.walletSplitTxns.push({
            sourceAddress: t.address,
            txns: s.txns,
            hasFundsForTransfer: s.lamportsRequired <= t.nativeBalance
        }),
        e
    }
    ), {
        currentToDestination: g,
        walletSplitTxns: []
    });
    if (b.some((e => !e.hasFundsForTransfer)))
        return void r({
            message: uu.notEnoughFundsForTransfer,
            type: "error"
        }, "split-failed-no-funds");
    const f = c.reduce(b, ( (e, t) => {
        const n = ng(t.sourceAddress);
        return c.forEach(t.txns, (t => {
            e.push({
                txn: t,
                sourceAddress: n
            })
        }
        )),
        e
    }
    ), []);
    if (!f.length)
        return void r({
            message: uu.unknownError,
            snackName: pu.consolidationFailed,
            type: "error"
        }, "consolidation-failed");
    const v = c.reduce(p, ( (e, t) => {
        if (!e.isValid)
            return e;
        const n = ng(t.address)
          , r = a(n);
        return r ? (e.fastDatas[n] = r,
        e) : (e.isValid = !1,
        e)
    }
    ), {
        fastDatas: {},
        isValid: !0
    });
    if (!v.isValid)
        return void r({
            message: uu.unknownError,
            snackName: pu.splitFailed,
            type: "error"
        }, "split-failed");
    const S = f.map((e => (async () => {
        const t = v.fastDatas[ng(e.sourceAddress)];
        if (!t)
            return {
                success: !1
            };
        const n = await s(ng(e.sourceAddress), {
            ...e.txn,
            blockhash: t.blockhash.blockhash
        });
        if (!n)
            return {
                success: !1
            };
        return "success" === (await Um.submitAndAwaitResolution({
            txnHash: n.txnHash,
            signedTxnBase64: n.signedTxnBase64,
            blockhash: t.blockhash,
            builder: Fc.JITO,
            chain: Pd.SOLANA
        })).status ? {
            success: !0
        } : {
            success: !1
        }
    }
    )()));
    r({
        transferPromises: S,
        variant: lK.MULTI_TRANSFER_STATUS
    }, "transfer-multi-status"),
    await Promise.all(S)
}
  , mye = y.memo(( ({chain: e, padreAvatarUrl: t, walletSelectMode: r, compact: a=!1, isInSidePanelMode: s=!1, toggleIsInSidePanelMode: o, toggleSidePanelOpen: l, isDisplayOnly: i=!1}) => {
    const d = D()
      , u = bw()
      , {showBackdrop: p, hideBackdrop: h} = y.useContext(aX)
      , m = pK()
      , {t: g} = we()
      , x = y.useMemo(( () => ED(e)), [e])
      , {selectedWalletsAddresses: b, quoteCurrencyForExecutionProperties: f, baseCurrencyProperties: A, compatibleWallets: w, compatibleWalletsAddresses: j, toggleSelectedWalletAddress: T, setSelectedWalletsAddresses: I, isLoadingInitialState: E} = Gde()
      , {setLastSelectedWalletsPerChain: M} = OD()
      , {state: N, wallets: P} = UD((e => e))
      , O = y.useMemo(( () => !P || !!b.length && !(P || []).some((e => b.includes(ng(e.publicAddress))))), [b, P])
      , L = y.useMemo(( () => {
        return e = (w ?? []).filter((e => b.includes(ng(e.wallet.publicAddress)))),
        c.reduce(e, ( (t, n) => ({
            wallet: t.wallet,
            balances: {
                base: {
                    rawAmount: (BigInt(t.balances.base.rawAmount) + BigInt(n.balances.base.rawAmount)).toString(),
                    isLoading: 0 !== e.length && !0 === t.balances.base.isLoading && !0 === n.balances.base.isLoading
                },
                quoteForExecution: {
                    rawAmount: (BigInt(t.balances.quoteForExecution.rawAmount) + BigInt(n.balances.quoteForExecution.rawAmount)).toString(),
                    isLoading: 0 !== e.length && !0 === t.balances.quoteForExecution.isLoading && !0 === n.balances.quoteForExecution.isLoading
                },
                native: {
                    rawAmount: (BigInt(t.balances.native.rawAmount) + BigInt(n.balances.native.rawAmount)).toString(),
                    isLoading: 0 !== e.length && !0 === t.balances.native.isLoading && !0 === n.balances.native.isLoading
                }
            }
        })), {
            balances: {
                base: {
                    rawAmount: "0",
                    isLoading: 0 !== e.length
                },
                quoteForExecution: {
                    rawAmount: "0",
                    isLoading: 0 !== e.length
                },
                native: {
                    rawAmount: "0",
                    isLoading: 0 !== e.length
                }
            },
            wallet: 1 === e.length ? e[0].wallet : {
                walletType: pc.ETH,
                isImported: !1,
                isHidden: !1,
                walletId: "multi",
                subOrgId: "multi",
                walletName: n.t("{{count}} Wallets Selected", {
                    count: e.length
                }),
                publicAddress: "multi"
            }
        });
        var e
    }
    ), [w, b])
      , {evmWalletsOrder: R, solWalletsOrder: B} = rQ()
      , _ = y.useMemo(( () => {
        const t = e === Pd.SOLANA ? B : R;
        return t.length ? $J(j, Mye, t) : j
    }
    ), [e, j, R, B])
      , {withBaseToken: U, withoutBaseToken: W} = y.useMemo(( () => c.reduce(_, ( (e, t) => {
        var n;
        const r = w ? (null == (n = w.find((e => e.wallet.walletId === t.walletId))) ? void 0 : n.balances) ?? null : null
          , a = {
            ...t,
            balances: r
        };
        return (null == r ? void 0 : r.base.rawAmount) && "0" !== r.base.rawAmount ? e.withBaseToken.push(a) : e.withoutBaseToken.push(a),
        e
    }
    ), {
        withBaseToken: [],
        withoutBaseToken: []
    })), [w, _])
      , {buttonProps: H, popoverProps: z} = Fw({
        id: "comapct-wallet-select"
    })
      , {originalStaticMarketInfo: $} = Qce()
      , G = hde($)
      , {get: q} = y.useContext(zD)
      , {getTxnSign: K} = fU()
      , [Y,X] = y.useState(!1)
      , Q = y.useCallback((async () => {
        if (G && !Y)
            try {
                X(!0),
                await hye({
                    selectedWalletsAddresses: b,
                    withBaseToken: U,
                    withoutBaseToken: W,
                    enqueueSnackbar: m,
                    getSolFastData: q,
                    getTxnSign: K,
                    tokenInfo: {
                        tokenType: G.baseToken.tokenType ?? vc.SOLANA_SPL,
                        decimals: G.baseToken.decimals,
                        tokenAddress: G.baseToken.address
                    }
                })
            } catch (fNe) {
                m({
                    message: uu.unknownError,
                    snackName: pu.splitFailed,
                    type: "error"
                }, "split-failed")
            } finally {
                X(!1)
            }
    }
    ), [G, b, U, W, m, q, K, Y])
      , [Z,J] = y.useState(!1)
      , ae = y.useCallback((async () => {
        if (G && !Z)
            try {
                J(!0),
                await (async ({selectedWalletsAddresses: e, withBaseToken: t, withoutBaseToken: n, enqueueSnackbar: r, getSolFastData: a, getTxnSign: s, tokenInfo: o}) => {
                    const l = new Set(e.map((e => ng(e))))
                      , i = t.filter((e => l.has(ng(e.publicAddress))))
                      , d = n.filter((e => l.has(ng(e.publicAddress))))
                      , u = [...i, ...d];
                    if (1 !== u.length)
                        return void r({
                            message: uu.selectOneWallet,
                            type: "warning"
                        }, "not-exact-one-wallet-error");
                    const p = u[0];
                    if (t.length - i.length == 0)
                        return void r({
                            message: uu.noTokenToConsolidate,
                            type: "warning"
                        }, "no-token-to-consolidate-error");
                    const h = t.filter((e => ng(e.publicAddress) !== ng(p.publicAddress)))
                      , m = ng(p.publicAddress)
                      , g = ng(o.tokenAddress)
                      , x = c.reduce(h, ( (e, t) => {
                        var n, r;
                        const a = BigInt((null == (n = t.balances) ? void 0 : n.base.rawAmount) ?? "0")
                          , s = BigInt((null == (r = t.balances) ? void 0 : r.native.rawAmount) ?? "0")
                          , l = ng(t.publicAddress)
                          , i = dye({
                            userWalletAddr: l,
                            destWallets: [{
                                addr: m,
                                amount: a
                            }],
                            mint: g,
                            tokenType: o.tokenType,
                            decimals: o.decimals
                        });
                        return e.consolidationTxns.push({
                            sourceAddress: t.publicAddress,
                            txns: i.txns,
                            hasFundsForTransfer: i.lamportsRequired <= s
                        }),
                        e
                    }
                    ), {
                        consolidationTxns: []
                    });
                    if (!x.consolidationTxns.length)
                        return void r({
                            message: uu.unknownError,
                            snackName: pu.consolidationFailed,
                            type: "error"
                        }, "consolidation-failed");
                    x.consolidationTxns.some((e => !e.hasFundsForTransfer)) && r({
                        message: uu.notEnoughFundsForTransfer,
                        type: "error"
                    }, "consolidation-failed-no-funds");
                    const b = x.consolidationTxns.map((e => (async () => {
                        if (!e.hasFundsForTransfer)
                            return {
                                success: !1
                            };
                        const t = a(e.sourceAddress);
                        if (!t)
                            return r({
                                message: uu.unknownError,
                                snackName: pu.consolidationFailed,
                                type: "error"
                            }, "consolidation-failed"),
                            {
                                success: !1
                            };
                        const n = e.txns.map((n => (async () => {
                            const r = await s(e.sourceAddress, {
                                ...n,
                                blockhash: t.blockhash.blockhash
                            });
                            if (!r)
                                throw new Error;
                            if ("success" === (await Um.submitAndAwaitResolution({
                                txnHash: r.txnHash,
                                signedTxnBase64: r.signedTxnBase64,
                                blockhash: t.blockhash,
                                builder: Fc.JITO,
                                chain: Pd.SOLANA
                            })).status)
                                return {
                                    success: !0
                                };
                            throw new Error
                        }
                        )()));
                        try {
                            await Promise.all(n)
                        } catch {
                            return {
                                success: !1
                            }
                        }
                        return {
                            success: !0
                        }
                    }
                    )()));
                    r({
                        transferPromises: b,
                        variant: lK.MULTI_TRANSFER_STATUS
                    }, "transfer-multi-status"),
                    await Promise.all(b)
                }
                )({
                    selectedWalletsAddresses: b,
                    withBaseToken: U,
                    withoutBaseToken: W,
                    enqueueSnackbar: m,
                    getSolFastData: q,
                    getTxnSign: K,
                    tokenInfo: {
                        tokenType: G.baseToken.tokenType ?? vc.SOLANA_SPL,
                        decimals: G.baseToken.decimals,
                        tokenAddress: G.baseToken.address
                    }
                })
            } catch (fNe) {
                m({
                    message: uu.unknownError,
                    snackName: pu.consolidationFailed,
                    type: "error"
                }, "consolidation-failed")
            } finally {
                J(!1)
            }
    }
    ), [m, b, U, W, q, K, G, Z])
      , se = y.useMemo(( () => A && f && _ ? U.map(( ({publicAddress: n, walletName: a, walletId: s, balances: o}, l) => {
        const c = ng(n)
          , d = b.includes(c);
        return v.jsx(te, {
            value: c,
            sx: e => ({
                ...r !== eye.SELECT && u ? Sye : yye,
                borderBottom: !W.length && l === U.length - 1 || r !== eye.SELECT ? "none" : `1px solid ${e.palette.background.borderMain}`,
                ...i ? {
                    "&:hover, &:focus": {
                        background: `${e.palette.text.value}${Dye}`
                    }
                } : {}
            }),
            onClick: e => {
                if (!("click" !== e.type && e.nativeEvent instanceof KeyboardEvent && "Space" === e.nativeEvent.code))
                    if (e.metaKey || e.ctrlKey) {
                        if (1 === b.length && b[0] === n)
                            return;
                        T(n, !0)
                    } else
                        T(n)
            }
            ,
            disableRipple: !0,
            disableTouchRipple: !0,
            children: v.jsx(tye, {
                address: n,
                name: a,
                pairBalances: o ? {
                    base: {
                        balance: o.base,
                        properties: A
                    },
                    quoteForExecution: {
                        balance: o.quoteForExecution,
                        properties: f
                    }
                } : null,
                hideWalletIcon: !0,
                chain: e,
                padreAvatarUrl: t,
                showCheckbox: !0,
                isSelected: d,
                isBig: r === eye.SELECT || !u,
                inheritCheckboxColor: i
            })
        }, s)
    }
    )) : null), [A, e, t, f, b, _, T, r, U, W.length, i, u])
      , oe = y.useMemo(( () => A && f && _ ? W.map(( ({publicAddress: n, walletName: a, walletId: s, balances: o}, l) => {
        const c = ng(n)
          , d = b.includes(c);
        return v.jsx(te, {
            value: c,
            sx: e => ({
                ...r !== eye.SELECT && u ? Sye : yye,
                borderBottom: l !== W.length - 1 && r === eye.SELECT ? `1px solid ${e.palette.background.borderMain}` : "none",
                ...i ? {
                    "&:hover, &:focus": {
                        background: `${e.palette.text.value}${Dye}`
                    }
                } : {}
            }),
            onClick: e => {
                if (!("click" !== e.type && e.nativeEvent instanceof KeyboardEvent && "Space" === e.nativeEvent.code))
                    if (e.metaKey || e.ctrlKey) {
                        if (1 === b.length && b[0] === n)
                            return;
                        T(n, !0)
                    } else
                        T(n)
            }
            ,
            disableRipple: !0,
            disableTouchRipple: !0,
            children: v.jsx(tye, {
                address: n,
                name: a,
                pairBalances: o ? {
                    base: {
                        balance: o.base,
                        properties: A
                    },
                    quoteForExecution: {
                        balance: o.quoteForExecution,
                        properties: f
                    }
                } : null,
                hideWalletIcon: !0,
                chain: e,
                padreAvatarUrl: t,
                showCheckbox: !0,
                isSelected: d,
                isBig: r === eye.SELECT || !u,
                inheritCheckboxColor: i
            })
        }, s)
    }
    )) : null), [A, e, t, f, b, _, T, r, W, i, u])
      , le = y.useCallback(( () => {
        const t = gc(x);
        if (j.length === b.length || t <= b.length)
            return I([]),
            void M((t => ({
                ...t,
                [e]: []
            })));
        {
            const n = j.map((e => e.publicAddress)).slice(0, t);
            I(n),
            M((t => ({
                ...t,
                [e]: n
            }))),
            j.length > t && m({
                message: gu(x),
                type: "warning"
            }, "max-wallets-error")
        }
    }
    ), [e, j, m, b.length, M, I, x])
      , ie = y.useCallback(( () => {
        const t = U.map((e => ng(e.publicAddress)))
          , n = new Set(b)
          , r = new Set(t)
          , a = gc(x)
          , s = j.length === b.length || a <= b.length
          , o = t.filter((e => n.has(e)))
          , l = t.every((e => n.has(e)));
        if (o.length && (l || s)) {
            const t = b.filter((e => !r.has(e)));
            return I(t),
            void M((n => ({
                ...n,
                [e]: t
            })))
        }
        const i = c.uniq([...b, ...t]);
        i.length > a && m({
            message: gu(x),
            type: "warning"
        }, "max-wallets-error");
        const d = i.slice(0, a);
        d.length !== n.size && (I(d),
        M((t => ({
            ...t,
            [e]: d
        }))))
    }
    ), [U, b, x, j.length, I, M, e, m])
      , ce = y.useCallback(( () => {
        const t = W.map((e => ng(e.publicAddress)))
          , n = new Set(b)
          , r = new Set(t)
          , a = gc(x)
          , s = j.length === b.length || a <= b.length
          , o = t.filter((e => n.has(e)))
          , l = t.every((e => n.has(e)));
        if (o.length && (l || s)) {
            const t = b.filter((e => !r.has(e)));
            return I(t),
            void M((n => ({
                ...n,
                [e]: t
            })))
        }
        const i = c.uniq([...b, ...t]);
        i.length > a && m({
            message: gu(x),
            type: "warning"
        }, "max-wallets-error");
        const d = i.slice(0, a);
        d.length !== n.size && (I(d),
        M((t => ({
            ...t,
            [e]: d
        }))))
    }
    ), [W, b, x, j.length, I, M, e, m])
      , de = y.useCallback(( () => {
        o && (h(),
        z.onClose(),
        o())
    }
    ), [z, o, h])
      , ue = y.useMemo(( () => {
        const t = U.map((e => e.publicAddress))
          , n = new Set(b)
          , o = gc(x)
          , l = t.filter((e => n.has(e))).length && (t.every((e => n.has(e))) || j.length === b.length || o <= b.length);
        return v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            sx: Nye,
            mt: a || r !== eye.SELECT ? 0 : -1,
            children: [v.jsx(GC, {
                title: g(l ? "Unselect all wallets containing token" : "Select all wallets containing token"),
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        sx: Pye,
                        onClick: ie,
                        children: l ? "Unselect All" : "Select All"
                    })
                })
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [!!U.length && e === Pd.SOLANA && G && !tu(G.baseToken.address, e) && v.jsxs(v.Fragment, {
                    children: [v.jsx(GC, {
                        title: g("Move all token to selected one wallet"),
                        children: v.jsx(C, {
                            component: "span",
                            display: "flex",
                            children: v.jsxs(V, {
                                variant: "tertiary",
                                size: "xxsmall",
                                sx: Oye,
                                onClick: ae,
                                children: [v.jsx(Dv, {
                                    size: 12
                                }), "Consolidate"]
                            })
                        })
                    }), v.jsx(GC, {
                        title: g("Split token evenly between selected wallets with 20% variance"),
                        children: v.jsx(C, {
                            component: "span",
                            display: "flex",
                            children: v.jsxs(V, {
                                variant: "tertiary",
                                size: "xxsmall",
                                sx: Oye,
                                onClick: Q,
                                children: [v.jsx(Dv, {
                                    size: 12
                                }), "Split Token"]
                            })
                        })
                    })]
                }), (a || i) && v.jsx(F, {
                    sx: Lye,
                    onClick: de,
                    children: v.jsx(Nf, {
                        color: s ? d.palette.text.value : d.palette.text.label
                    })
                })]
            })]
        })
    }
    ), [U, b, x, j.length, a, r, g, ie, e, G, ae, Q, i, de, s, d.palette.text.value, d.palette.text.label])
      , pe = y.useMemo(( () => {
        const e = W.map((e => e.publicAddress))
          , t = new Set(b)
          , n = gc(x)
          , o = e.filter((e => t.has(e))).length && (e.every((e => t.has(e))) || j.length === b.length || n <= b.length);
        return v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            sx: Nye,
            mt: a || r !== eye.SELECT || U.length ? 0 : -1,
            children: [v.jsx(GC, {
                title: g(o ? "Unselect all wallets without token" : "Select all wallets without token"),
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        sx: Pye,
                        onClick: ce,
                        children: o ? "Unselect All" : "Select All"
                    })
                })
            }), (a || i) && !U.length && v.jsx(F, {
                sx: Lye,
                onClick: de,
                children: v.jsx(Nf, {
                    color: s ? d.palette.text.value : d.palette.text.label
                })
            })]
        })
    }
    ), [W, b, x, j, a, r, U.length, g, ce, i, de, s, d.palette.text.value, d.palette.text.label])
      , he = y.useMemo(( () => {
        if (!A || !f || !j || !w || w.length < 2)
            return null;
        const n = w ? w.reduce(( (e, t) => {
            const n = t.balances.base;
            return e + (n ? BigInt(n.rawAmount ?? "0") : 0n)
        }
        ), 0n) : null
          , r = w ? w.reduce(( (e, t) => {
            const n = t.balances.quoteForExecution;
            return e + (n ? BigInt(n.rawAmount ?? "0") : 0n)
        }
        ), 0n) : null
          , a = null !== n && null !== r ? {
            base: {
                balance: {
                    rawAmount: String(n)
                },
                properties: A
            },
            quoteForExecution: {
                balance: {
                    rawAmount: String(r)
                },
                properties: f
            }
        } : null
          , s = j.length === b.length;
        return v.jsx(te, {
            value: "All Wallets",
            sx: Sye,
            onClick: le,
            children: v.jsx(tye, {
                name: `${b.length}/${w.length} selected`,
                pairBalances: a,
                hideWalletIcon: !0,
                chain: e,
                padreAvatarUrl: t,
                showCheckbox: !0,
                isSelected: s,
                isHeader: !0
            })
        }, "all-wallets")
    }
    ), [A, f, j, w, b.length, le, e, t])
      , me = y.useCallback(( () => {
        h(),
        z.onClose()
    }
    ), [h, z])
      , ge = y.useCallback(( () => {
        if (s && l)
            return l(),
            void h();
        z.open ? me() : (H.onClick(),
        p(me))
    }
    ), [s, l, z.open, h, me, H, p]);
    return i ? v.jsxs(S, {
        className: "padre-decorative-scroll no-drag",
        sx: Rye,
        children: [!!U.length && v.jsxs(S, {
            children: [ue, se]
        }), !!W.length && v.jsxs(S, {
            children: [pe, oe]
        })]
    }) : a ? v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            className: "no-drag",
            ...H,
            onClick: ge,
            variant: "tertiary",
            size: "xxsmall",
            tabIndex: -1,
            onMouseDown: Uw,
            sx: Aye,
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "flex-start",
                gap: .5,
                children: [v.jsx(ly, {
                    size: Cye
                }), (N === BD.READY || P && P.length) && !E && A && f && (null == j ? void 0 : j.length) ? v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    sx: wye,
                    children: b.length
                }) : v.jsx(Ie, {
                    variant: "rounded",
                    width: 14,
                    height: 16
                })]
            })
        }), v.jsx(ne, {
            ...z,
            onClick: Ww,
            sx: jye,
            children: v.jsx(re, {
                onClickAway: c.noop,
                children: v.jsxs(ee, {
                    elevation: 1,
                    sx: Tye,
                    className: "padre-decorative-scroll no-drag",
                    children: [!!U.length && v.jsxs(S, {
                        children: [ue, se]
                    }), !!W.length && v.jsxs(S, {
                        children: [pe, oe]
                    })]
                })
            })
        })]
    }) : v.jsx(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        justifyContent: "center",
        children: (N === BD.READY || P && P.length) && !E && A && f && (null == j ? void 0 : j.length) ? w && !w.length ? v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "No compatible wallets found."
        }) : L ? r === eye.SELECT ? v.jsxs(it, {
            multiple: !0,
            size: "xsmall",
            sx: {
                width: "100%"
            },
            MenuProps: {
                sx: {
                    maxHeight: gye
                },
                PaperProps: {
                    style: {
                        width: u ? bye : "100%"
                    },
                    className: "padre-no-scroll"
                }
            },
            displayEmpty: !0,
            value: b,
            renderValue: () => v.jsx(tye, {
                address: L.wallet.publicAddress,
                name: L.wallet.walletName,
                pairBalances: {
                    base: {
                        balance: L.balances.base,
                        properties: A
                    },
                    quoteForExecution: {
                        balance: L.balances.quoteForExecution,
                        properties: f
                    }
                },
                isLoading: O,
                chain: e,
                padreAvatarUrl: t
            }),
            children: [!!U.length && v.jsxs(S, {
                children: [ue, se]
            }), !!W.length && v.jsxs(S, {
                children: [pe, oe]
            })]
        }) : v.jsxs(S, {
            direction: "column",
            className: "padre-no-scroll",
            width: "100%",
            gap: 1,
            children: [v.jsx(S, {
                width: "100%",
                sx: u ? Iye : Eye,
                children: he
            }), v.jsxs(S, {
                className: "padre-no-scroll",
                width: "100%",
                sx: e => ({
                    maxHeight: u ? fye : vye,
                    overflow: "scroll",
                    borderRadius: 1,
                    border: `1px solid ${e.palette.background.borderMain}`
                }),
                divider: v.jsx(Ee, {
                    flexItem: !0,
                    style: {
                        marginBottom: 0,
                        marginTop: 0
                    }
                }),
                children: [se, oe]
            })]
        }) : v.jsx(xye, {
            chain: e,
            padreAvatarUrl: t
        }) : v.jsx(xye, {
            chain: e,
            padreAvatarUrl: t
        })
    })
}
))
  , gye = 465
  , xye = y.memo(( ({chain: e, padreAvatarUrl: t}) => v.jsxs(S, {
    direction: "row",
    width: "100%",
    height: 36,
    borderRadius: 1,
    sx: kye,
    children: [v.jsx(tye, {
        address: "",
        name: "",
        pairBalances: null,
        isLoading: !0,
        chain: e,
        padreAvatarUrl: t
    }), v.jsx(Sy, {
        size: 18
    })]
})))
  , bye = 318
  , fye = 148
  , vye = 216
  , Sye = {
    height: 36,
    maxHeight: 36,
    px: 1.25,
    py: .25
}
  , yye = {
    height: 56,
    maxHeight: 56,
    px: 1.25,
    py: .25
}
  , kye = e => ({
    border: `1px solid ${e.palette.background.borderMain}`,
    pl: "13px",
    alignItems: "center",
    gap: 1,
    pr: "5px"
})
  , Cye = 14
  , Aye = {
    width: 46,
    height: 24,
    pr: 0,
    pl: .75,
    py: 0,
    borderRadius: "12px",
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-start"
}
  , wye = {
    pt: .25
}
  , jye = {
    zIndex: 1396
}
  , Tye = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    maxHeight: 400,
    minWidth: 350,
    maxWidth: 350,
    pb: 0,
    position: "relative",
    gap: 1
})
  , Iye = e => ({
    overflow: "hidden",
    borderRadius: 1,
    border: `1px solid ${e.palette.background.borderMain}`,
    background: e.palette.background.secondary,
    height: 32
})
  , Eye = e => ({
    overflow: "hidden",
    borderRadius: 1,
    border: `1px solid ${e.palette.background.borderMain}`,
    background: e.palette.background.secondary,
    height: 48
})
  , Mye = e => e.walletId
  , Nye = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    gap: .5,
    py: 1.5,
    px: 1.5
})
  , Pye = e => ({
    borderRadius: 4,
    px: .5,
    minWidth: 90,
    border: `1px solid ${e.palette.background.borderActive}`,
    fontSize: 12,
    height: 24
})
  , Oye = e => ({
    display: "flex",
    gap: .5,
    borderRadius: "12px",
    px: .5,
    minWidth: 95,
    border: "none",
    fontSize: 12,
    height: 24,
    background: e.palette.background.tertiary,
    "&:hover, &:focus": {
        border: "none"
    }
})
  , Lye = {
    px: .25,
    width: 24,
    height: 24
}
  , Rye = {
    overflowX: "hidden",
    overflowY: "scroll",
    cursor: "default",
    height: "100%",
    pt: 1
}
  , Dye = "0C"
  , Bye = y.memo(( () => {
    const {showOnInstantTrade: e} = TSe()
      , {originalStaticMarketInfo: t} = Qce()
      , n = hde(t);
    return n && e ? v.jsx(GSe, {
        marketInfo: n
    }) : null
}
))
  , _ye = y.memo(( ({onClick: e, preset: t}) => {
    const n = y.useMemo(( () => e => ({
        height: Uye,
        width: Uye,
        minWidth: Uye,
        maxWidth: Uye,
        p: 0,
        display: "flex",
        justifyContent: "center",
        borderRadius: "50%",
        borderColor: "Inferno" === t ? e.palette.originalPrimary.main : e.palette.purple.main
    })), [t]);
    return v.jsx(V, {
        variant: "secondary",
        color: "Inferno" === t ? "primary" : "success",
        onClick: e,
        sx: n,
        children: yH(t, 16, 6)
    })
}
))
  , Uye = 28
  , Wye = y.createContext({
    openSplitModal: c.noop
})
  , Fye = y.memo(( ({balance: e, address: t, name: n, symbol: r, decimals: a}) => {
    const [s,o] = JC(!1, Gye)
      , l = y.useCallback((e => {
        e.stopPropagation(),
        QC && (ZC(t),
        o(!0))
    }
    ), [t, o]);
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        justifyContent: "space-between",
        alignItems: "center",
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1.25,
            alignItems: "center",
            children: [ru(t) ? v.jsx(dk, {
                size: zye
            }) : v.jsx(b_, {
                url: IE(Pd.SOLANA, t),
                name: n,
                chain: Pd.SOLANA,
                padreAvatarUrl: null,
                protocolInfo: null,
                size: zye,
                hideHoverAvatar: !0
            }), v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "flex-end",
                children: [v.jsx(GC, {
                    title: n,
                    children: v.jsx(k, {
                        variant: "h1",
                        fontWeight: 600,
                        sx: Hye,
                        ...Nu,
                        children: iu(r, Vye)
                    })
                }), !ru(t) && v.jsx(GC, {
                    title: s ? v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        ...Nu,
                        children: ["Copied", v.jsx(G, {
                            sx: $ye,
                            color: "success"
                        })]
                    }) : `Copy ${oA(t)}`,
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        ...Nu,
                        fontWeight: 400,
                        onClick: l,
                        children: oA(t)
                    })
                })]
            })]
        }), v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: !e || isNaN(Number(e)) || m.isNil(a) ? Ud : LI(Number(e) / 10 ** a, {
                collapseExponent: !0,
                desiredDigits: 3
            })
        })]
    })
}
))
  , Vye = 20
  , Hye = {
    "&:hover": {
        cursor: "pointer"
    }
}
  , zye = 20
  , $ye = {
    fontSize: "1.5em"
}
  , Gye = 6e3
  , qye = y.memo(( ({onClick: e, ...t}) => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    height: 44,
    onClick: e,
    sx: Kye,
    maxWidth: "100%",
    children: v.jsx(Fye, {
        ...t
    })
})))
  , Kye = e => ({
    pl: .25,
    pr: .75,
    "&:hover": {
        background: e.palette.background.buttonDefault,
        cursor: "pointer"
    }
})
  , Yye = y.memo(( ({splitWalletData: e, onClose: t, selectToken: n}) => {
    const [r,a] = y.useState("")
      , s = y.useMemo(( () => {
        const t = Object.values(e.holdings);
        if (!r.trim())
            return t;
        const n = r.toLowerCase();
        return t.filter((e => !isNaN(Number(e.balance)) && Number(e.balance) > 0 && (lj(e.name, n) || lj(e.symbol, n) || lj(e.address, n))))
    }
    ), [r, e.holdings])
      , o = y.useCallback((e => {
        n(e),
        t()
    }
    ), [t, n]);
    return v.jsxs(S, {
        gap: 1.5,
        children: [v.jsx(oQ, {
            search: r,
            setSearch: a,
            placeholder: "Search token (by ticker, CA or name)"
        }), v.jsx(Ee, {
            flexItem: !0
        }), v.jsx(S, {
            sx: Xye,
            overflow: "scroll",
            className: "padre-no-scroll",
            children: v.jsx(mt, {
                children: ({height: e, width: t}) => v.jsx(gt, {
                    className: "padre-no-scroll",
                    height: e,
                    width: t,
                    rowHeight: 44,
                    rowCount: s.length,
                    itemData: s,
                    rowRenderer: ({index: e, style: t}) => {
                        const n = s[e];
                        return v.jsx("div", {
                            style: t,
                            children: v.jsx(qye, {
                                ...n,
                                onClick: () => {
                                    o(n.address)
                                }
                            })
                        }, n.address)
                    }
                    ,
                    overscanRowCount: 2
                })
            })
        })]
    })
}
))
  , Xye = {
    overflowX: "hidden",
    overflowY: "scroll",
    height: {
        xs: "calc(100vh - 130px)",
        md: 245
    },
    mb: {
        xs: 0,
        md: -2
    }
}
  , Qye = y.memo(( ({isOpen: e, onClose: t, splitWalletData: n, selectToken: r}) => {
    if (e)
        return v.jsx(Sw, {
            open: e,
            onClose: t,
            stackSx: Zye,
            children: v.jsxs(S, {
                gap: 2,
                children: [v.jsxs(S, {
                    py: .5,
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    children: [v.jsx(k, {
                        variant: "h2",
                        color: "text.value",
                        children: "Select Token"
                    }), v.jsx(F, {
                        sx: Jye,
                        onClick: t,
                        children: v.jsx(gy, {
                            size: 24
                        })
                    })]
                }), v.jsx(Yye, {
                    splitWalletData: n,
                    onClose: t,
                    selectToken: r
                })]
            })
        })
}
))
  , Zye = {
    zIndex: 1311,
    p: 2
}
  , Jye = {
    p: .25
}
  , eke = y.memo(( ({maxAmount: e, amount: t, setAmount: n}) => {
    const r = y.useMemo(( () => Number((e ? t / e * 100 : 0).toFixed(0))), [t, e])
      , a = y.useCallback(( (t, r) => {
        if (!e)
            return;
        const a = "number" == typeof r ? r : r[0];
        n(Number((a / 100 * e).toFixed(2)))
    }
    ), [n, e])
      , s = y.useCallback((async ({target: {value: t}}) => {
        if (!e)
            return;
        const r = QR(AI(t))
          , a = Number(XR(cke(r), 0, 100));
        isNaN(a) || n(100 === a ? e : a / 100 * e)
    }
    ), [e, n])
      , o = y.useCallback((t => {
        e && n(Number((t / 100 * e).toFixed(2)))
    }
    ), [n, e])
      , l = y.useMemo(( () => v.jsx(We, {
        position: "end",
        children: v.jsx(k, {
            sx: {
                font: "inherit"
            },
            color: "text.label",
            children: "%"
        })
    })), []);
    return v.jsx(S, {
        spacing: 2,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 3,
            children: [v.jsxs(S, {
                flexGrow: 1,
                children: [v.jsx(Z, {
                    value: r,
                    onChange: a,
                    min: 0,
                    max: 100,
                    step: 1,
                    marks: tke,
                    disabled: !e,
                    sx: rke
                }), v.jsx(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    position: "relative",
                    height: 14,
                    children: nke.map((e => v.jsxs(k, {
                        variant: "paragraph3",
                        sx: lke,
                        onClick: () => o(e.value),
                        left: `${e.left}%`,
                        children: [e.value, "%"]
                    }, e.value)))
                })]
            }), v.jsx(je, {
                onChange: s,
                value: r,
                "data-pseudotype": "numberLike",
                inputMode: "decimal",
                size: "medium",
                sx: dke,
                inputProps: ike,
                endAdornment: l
            })]
        })
    })
}
))
  , tke = [{
    value: 25
}, {
    value: 50
}, {
    value: 75
}]
  , nke = [{
    value: 0,
    left: 0
}, {
    value: 25,
    left: 22
}, {
    value: 50,
    left: 47
}, {
    value: 75,
    left: 72
}, {
    value: 100,
    left: 94
}]
  , rke = e => ({
    "& .MuiSlider-thumb": {
        ...oke,
        transition: "none",
        color: e.palette.primary.main,
        border: `2px solid ${e.palette.background.primary}`
    },
    "& .MuiSlider-rail": {
        transition: "none",
        color: e.palette.text.disabled,
        height: "2px",
        opacity: 1
    },
    "& .MuiSlider-track": {
        transition: "none",
        opacity: 1,
        height: "0px",
        color: `${e.palette.text.label} !important`
    },
    "& .MuiSlider-mark": {
        color: e.palette.text.label,
        width: ske,
        height: ake
    },
    "& .MuiSlider-markActive": {
        backgroundColor: e.palette.text.label,
        opacity: 1
    }
})
  , ake = 5
  , ske = 2
  , oke = {
    height: 18,
    width: 18,
    borderRadius: "50%",
    boxShadow: "none",
    "&, &:hover, &.Mui-selected, &.Mui-active, &.Mui-focusVisible, &::after": {
        boxShadow: "none"
    }
}
  , lke = {
    position: "absolute",
    bottom: 0,
    cursor: "pointer",
    userSelect: "none"
}
  , ike = {
    [vu]: "true",
    style: {
        textAlign: "right",
        paddingLeft: 0
    },
    inputMode: "decimal"
}
  , cke = e => e.replace(/\.$/, "")
  , dke = e => ({
    maxWidth: 70,
    backgroundColor: "transparent",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , uke = y.memo(( ({label: e, value: t, tokenSymbol: n, notExact: r=!1}) => v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    height: pke,
    justifyContent: "space-between",
    children: [null !== t && v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        children: e
    }), null !== t && v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        children: `${r ? "~" : ""}${LI(t, {
            collapseExponent: !0,
            symbol: n.slice(0, hke),
            desiredDigits: 3
        })}`
    })]
})))
  , pke = 16
  , hke = 16
  , mke = y.memo(( ({isSelected: e, isMultiple: t=!1, isSelectRenderValue: n=!1, ...r}) => v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    gap: 1,
    minHeight: 28,
    width: "100%",
    children: [t && v.jsx(UR, {
        checked: e
    }), v.jsxs(S, {
        gap: .5,
        width: `calc(100% - ${t ? 23 : 0}px)`,
        direction: "row",
        children: [v.jsx(S, {
            direction: "row",
            width: "100%",
            overflow: "hidden",
            alignItems: "center",
            justifyContent: "space-between",
            children: r.name ? v.jsx(k, {
                variant: "paragraph3",
                noWrap: !0,
                sx: gke,
                color: r.solBalance || r.tokenBalance || e ? "text.value" : "text.label",
                ...Nu,
                children: r.name
            }) : v.jsx(Ie, {
                width: 85
            })
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            ...Nu,
            children: [null !== r.tokenBalance && v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [r.tokenAddress && v.jsx(b_, {
                    url: IE(Pd.SOLANA, r.tokenAddress),
                    padreAvatarUrl: null,
                    name: r.tokenSymbol ?? "",
                    chain: Pd.SOLANA,
                    size: 14,
                    protocolInfo: null,
                    hideHoverAvatar: !0
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: r.tokenBalance ? "text.value" : "text.label",
                    sx: xke,
                    children: LI(r.tokenBalance, {
                        collapseExponent: !0,
                        symbol: r.tokenSymbol ?? "",
                        padSymbol: !0,
                        maxPrecision: 3
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .25,
                children: [v.jsx(k, {
                    variant: "paragraph3",
                    color: r.solBalance ? "text.value" : "text.label",
                    sx: bke,
                    children: LI(r.solBalance, {
                        collapseExponent: !0,
                        symbol: "",
                        maxPrecision: 3
                    })
                }), v.jsx(dk, {
                    size: 14
                })]
            }), !n && !t && v.jsx(C, {
                width: 13,
                children: e && v.jsx(xy, {})
            })]
        })]
    })]
})))
  , gke = {
    maxWidth: 140
}
  , xke = {
    whiteSpace: "nowrap",
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    gap: .25
}
  , bke = {
    ...xke,
    minWidth: 45
}
  , fke = y.memo(( ({mainWallet: e, setMainWallet: t, walletItems: n}) => {
    const r = bw()
      , a = y.useMemo(( () => n.find((t => t.address === e)) ?? null), [e, n])
      , s = y.useMemo(( () => ({
        sx: {
            maxHeight: 450
        },
        PaperProps: {
            style: {
                width: r ? yke : "100%"
            },
            className: "padre-no-scroll"
        }
    })), [r]);
    return v.jsx(it, {
        size: "xsmall",
        sx: Ske,
        MenuProps: s,
        displayEmpty: !0,
        value: e,
        renderValue: () => a ? v.jsx(mke, {
            isSelected: !0,
            isSelectRenderValue: !0,
            ...a
        }) : v.jsx(Ie, {
            variant: "rounded",
            height: 26,
            width: "100%"
        }),
        children: n.map((n => {
            const r = n.address === e;
            return v.jsx(te, {
                value: n.address,
                sx: vke,
                onClick: () => {
                    t(n.address)
                }
                ,
                children: v.jsx(mke, {
                    isSelected: r,
                    ...n
                })
            }, n.address)
        }
        ))
    })
}
))
  , vke = {
    height: 32,
    maxHeight: 32,
    px: 1.5,
    py: 0
}
  , Ske = {
    width: "100%"
}
  , yke = 444
  , kke = y.memo(( ({selectedWallets: e, toggleWallet: t, walletItems: n, mainWallet: r, requireToken: a=!1}) => {
    const {t: s} = we()
      , o = bw()
      , l = y.useMemo(( () => n.filter((e => e.address !== r && (!a || !!e.tokenBalance || ru(e.tokenAddress ?? "") && e.solBalance)))), [r, a, n])
      , i = y.useMemo(( () => {
        const t = l.filter((t => e.includes(t.address)));
        return t.length ? c.reduce(t, ( (e, t) => (e.solBalance += t.solBalance,
        e)), {
            ...t[0],
            solBalance: 0,
            name: `${t.length} Wallet${t.length > 1 ? "s" : ""} selected`,
            tokenBalance: null,
            tokenSymbol: null,
            tokenAddress: null
        }) : null
    }
    ), [e, l])
      , d = y.useMemo(( () => ({
        sx: {
            maxHeight: 450
        },
        PaperProps: {
            style: {
                width: o ? wke : "100%"
            },
            className: "padre-no-scroll"
        }
    })), [o]);
    return v.jsx(it, {
        size: "xsmall",
        sx: Ake,
        MenuProps: d,
        displayEmpty: !0,
        multiple: !0,
        value: e,
        disabled: !l.length,
        renderValue: () => l.length ? i ? v.jsx(mke, {
            isSelected: !0,
            isSelectRenderValue: !0,
            ...i
        }) : v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: s("No wallets selected")
        }) : v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: "No valid wallets"
        }),
        children: l.map((n => {
            const r = e.includes(n.address);
            return v.jsx(te, {
                value: n.address,
                sx: Cke,
                onClick: r => {
                    if (r.metaKey || r.ctrlKey) {
                        if (1 === e.length && e[0] === n.address)
                            return;
                        t(n.address, !0)
                    } else
                        t(n.address)
                }
                ,
                children: v.jsx(mke, {
                    isSelected: r,
                    isMultiple: !0,
                    ...n
                })
            }, n.address)
        }
        ))
    })
}
))
  , Cke = {
    height: 32,
    maxHeight: 32,
    px: 1.5,
    py: 0
}
  , Ake = {
    width: "100%"
}
  , wke = 444;
var jke = (e => (e.SPLIT = "SPLIT",
e.CONSOLIDATE = "CONSOLIDATE",
e))(jke || {});
const Tke = e => {
    const t = Object.values(e);
    return t.length ? c.reduce(t, ( (e, t) => (Object.values(t.holdings).forEach((t => {
        e.holdings[t.address] ? e.holdings[t.address] = {
            ...e.holdings[t.address],
            balance: e.holdings[t.address].balance && t.balance ? (BigInt(e.holdings[t.address].balance) + BigInt(t.balance)).toString() : e.holdings[t.address].balance ? e.holdings[t.address].balance : t.balance
        } : e.holdings[t.address] = t
    }
    )),
    e)), {
        walletAddress: "consolidated",
        walletName: "consolidated",
        walletSubOrgId: "",
        walletSolBalance: 0,
        holdings: {}
    }) : null
}
  , Ike = y.memo(( ({initialTokenAddress: e, intialWalletAddress: t, onClose: n}) => {
    const [r,a] = y.useState(jke.SPLIT)
      , [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        o(!0)
    }
    ), [])
      , i = y.useCallback(( () => {
        o(!1)
    }
    ), [])
      , [d,u] = y.useState(ng(e))
      , {state: p, wallets: h} = UD((e => e))
      , {portfolioData: m} = zce()
      , g = y.useMemo(( () => m && h && p === BD.READY ? ( (e, t) => c.reduce(e, ( (e, n) => {
        var r;
        const a = t ? Object.values((null == (r = t[ng(n.publicAddress)]) ? void 0 : r.perTokenId) || {}) : null;
        if (n.walletType !== pc.SOL)
            return e;
        if (!a)
            return e;
        const s = ng(n.publicAddress)
          , o = c.reduce(a, ( (e, t) => {
            const n = ng(t.tokenAddress);
            return t.tokenInfo ? (ru(n) && (e.walletSolBalance += t.balance && !isNaN(Number(t.balance)) ? Number(t.balance) / 10 ** t.tokenInfo.decimals : 0),
            e.holdings[n] = {
                balance: t.balance ?? "0",
                address: n,
                name: t.tokenInfo.name,
                symbol: t.tokenInfo.symbol,
                decimals: t.tokenInfo.decimals,
                tokenType: t.tokenInfo.tokenType ?? vc.SOLANA_SPL
            },
            t.tokenInfo.tokenType,
            e) : e
        }
        ), {
            walletAddress: s,
            walletName: n.walletName,
            walletSubOrgId: n.subOrgId,
            walletSolBalance: 0,
            holdings: {}
        });
        return e[s] = o,
        e
    }
    ), {}))(h, m) : null), [m, p, h])
      , [x,b] = y.useState([])
      , f = y.useCallback(( (e, t=!1) => {
        b(t ? [e] : t => t.includes(e) ? [...t.filter((t => t !== e))] : [...t, e])
    }
    ), [])
      , [A,w] = y.useState([])
      , j = y.useCallback(( (e, t=!1) => {
        w(t ? [e] : t => t.includes(e) ? [...t.filter((t => t !== e))] : [...t, e])
    }
    ), [])
      , [T,I] = y.useState(ng(t))
      , E = y.useCallback((e => {
        A.includes(e) && w((t => [...t.filter((t => t !== e))])),
        x.includes(e) && b((t => [...t.filter((t => t !== e))])),
        _(0),
        I(e)
    }
    ), [A, x])
      , M = y.useMemo(( () => g && Object.keys(g).length ? Object.values(g).map((e => {
        const t = d ? e.holdings[d] : null
          , n = t && !ru(t.address) && t.decimals && t.balance && !isNaN(Number(t.balance)) ? Number(t.balance) / 10 ** t.decimals : null
          , r = t ? t.symbol : null;
        return {
            address: e.walletAddress,
            name: e.walletName,
            solBalance: e.walletSolBalance,
            tokenBalance: n,
            tokenAddress: d,
            tokenSymbol: r
        }
    }
    )) : null), [g, d]);
    y.useEffect(( () => {
        if (!g)
            return;
        const e = Object.keys(g);
        e.length && (e.includes(T) || E(e[0]))
    }
    ), [T, E, g]);
    const N = y.useMemo(( () => g ? Tke(g) : null), [g])
      , P = y.useMemo(( () => g && A.length ? Tke(c.reduce(A, ( (e, t) => (e[t] = g[t],
    e)), {})) : null), [A, g])
      , O = y.useMemo(( () => P && d ? (null == P ? void 0 : P.holdings[d]) ?? null : null), [P, d])
      , L = y.useMemo(( () => {
        var e;
        return g && d ? r === jke.CONSOLIDATE ? (null == N ? void 0 : N.holdings[d]) ?? null : (null == (e = g[T]) ? void 0 : e.holdings[d]) ?? null : null
    }
    ), [null == N ? void 0 : N.holdings, T, r, g, d])
      , R = y.useMemo(( () => g ? g[T] ?? null : null), [T, g])
      , D = y.useMemo(( () => {
        if (!d || !R)
            return null;
        const e = R.holdings[d];
        return !e || isNaN(Number(e.balance)) ? null : Number(e.balance)
    }
    ), [R, d])
      , [B,_] = y.useState(D ?? 0)
      , U = y.useCallback((e => {
        u(e);
        const t = R ? R.holdings[ng(e)] : null
          , n = t && t.balance && !isNaN(Number(t.balance)) ? Number(t.balance) : 0;
        _(n),
        w([])
    }
    ), [R])
      , W = pK()
      , {get: F} = y.useContext(zD)
      , {getTxnSign: H} = fU()
      , [z,$] = y.useState(!1)
      , {splitTxns: G, splitRequiredLamports: q} = y.useMemo(( () => {
        var e, t, n, r;
        if (!(g && d && B && x.length))
            return {
                splitTxns: null,
                splitRequiredLamports: null
            };
        const a = (null == (t = null == (e = g[T]) ? void 0 : e.holdings[d]) ? void 0 : t.tokenType) ?? vc.SOLANA_SPL
          , s = (null == (r = null == (n = g[T]) ? void 0 : n.holdings[d]) ? void 0 : r.decimals) ?? 9
          , o = ( (e, t) => {
            if (t <= 0)
                return null;
            const n = e / BigInt(t)
              , r = e % BigInt(t);
            return Array.from({
                length: t
            }, ( (e, t) => t < Number(r) ? n + 1n : n))
        }
        )(BigInt(B.toFixed(0)), x.length);
        if (!o)
            return {
                splitTxns: null,
                splitRequiredLamports: null
            };
        try {
            const e = x.map(( (e, t) => ({
                addr: e,
                amount: o.length >= t ? o[t] : 0n
            })))
              , t = dye({
                userWalletAddr: T,
                destWallets: e,
                mint: d,
                tokenType: a,
                decimals: s
            });
            return {
                splitTxns: t.txns,
                splitRequiredLamports: t.lamportsRequired
            }
        } catch (fNe) {
            return {
                splitTxns: null,
                splitRequiredLamports: null
            }
        }
    }
    ), [B, x, T, d, g])
      , K = y.useCallback((async () => {
        if (!(g && d && B && x.length))
            return;
        if (!(null == G ? void 0 : G.length))
            return void W({
                message: uu.unknownError,
                snackName: pu.splitFailed,
                type: "error"
            }, "split-failed");
        const e = g[T].walletSolBalance;
        if (!e || BigInt((e * 10 ** kU).toFixed(0)) < q)
            W({
                message: uu.insufficientBalance,
                snackName: pu.splitFailed,
                type: "error"
            }, "split-failed");
        else
            try {
                $(!0);
                const e = F(T);
                if (!e)
                    return void W({
                        message: uu.unknownError,
                        snackName: pu.splitFailed,
                        type: "error"
                    }, "split-failed");
                const t = G.map((t => (async () => {
                    const r = await H(T, {
                        ...t,
                        blockhash: e.blockhash.blockhash
                    });
                    if (!r)
                        return void W({
                            message: uu.unknownError,
                            snackName: pu.splitFailed,
                            type: "error"
                        }, "split-failed");
                    const a = await Um.submitAndAwaitResolution({
                        txnHash: r.txnHash,
                        signedTxnBase64: r.signedTxnBase64,
                        blockhash: e.blockhash,
                        builder: Fc.JITO,
                        chain: Pd.SOLANA
                    });
                    "success" === a.status ? (W({
                        message: uu.transferSuccess,
                        type: "success"
                    }, "split-success"),
                    n()) : W({
                        message: "Transaction " + ("reverted" === a.status ? "reverted" : "timed out"),
                        snackName: pu.splitFailed,
                        type: "error"
                    }, "split-error")
                }
                )()));
                await Promise.all(t)
            } catch (fNe) {} finally {
                $(!1)
            }
    }
    ), [B, x.length, W, F, H, T, n, G, d, g, q])
      , Y = y.useMemo(( () => ( (e, t, n, r, a, s) => {
        if (!e)
            return {
                tooltip: "",
                label: "No token selected"
            };
        if (!t.length)
            return {
                tooltip: "",
                label: "No destination wallets selected"
            };
        if (0 === n)
            return {
                tooltip: "",
                label: "No amount selected"
            };
        if (!a)
            return {
                tooltip: "",
                label: "No wallets data available"
            };
        if (!Object.keys(a).includes(r))
            return {
                tooltip: "Select other source wallet",
                label: "Wallet mismatch"
            };
        const o = n / t.length;
        if (ru(e) && o < 1e6)
            return {
                tooltip: "Amount transferred to each wallet must be at least 0.001 SOL",
                label: "Too small amount"
            };
        if (null === s)
            return null;
        const l = Number(s) / 10 ** kU;
        return a[r].walletSolBalance < l + (ru(e) ? n / 10 ** kU : 0) ? {
            tooltip: `You need at least${ru(e) ? " amount plus" : ""} ${UI(l.toFixed(5))} SOL to make split.`,
            label: "Insufficient funds"
        } : null
    }
    )(d, x, B, T, g, q)), [B, x, T, d, g, q])
      , [X,Q] = y.useState(!1)
      , {consolidationTxns: Z, consolidationRequiredLamports: ee} = y.useMemo(( () => {
        var e, t, n, r;
        if (!g || !d || !A.length)
            return {
                consolidationTxns: null,
                consolidationRequiredLamports: null
            };
        const a = (null == (t = null == (e = g[A[0]]) ? void 0 : e.holdings[d]) ? void 0 : t.tokenType) ?? vc.SOLANA_SPL
          , s = (null == (r = null == (n = g[A[0]]) ? void 0 : n.holdings[d]) ? void 0 : r.decimals) ?? 9;
        try {
            const e = T
              , t = d
              , n = A.map((e => {
                var t;
                const n = g[e];
                if (!n)
                    throw new Error("Missing data for wallet");
                const r = null == (t = n.holdings[d]) ? void 0 : t.balance;
                return {
                    address: e,
                    balance: BigInt(r)
                }
            }
            ));
            return c.reduce(n, ( (n, r) => {
                const o = [{
                    addr: e,
                    amount: r.balance
                }]
                  , l = dye({
                    userWalletAddr: r.address,
                    destWallets: o,
                    mint: t,
                    tokenType: a,
                    decimals: s
                });
                n.consolidationRequiredLamports < l.lamportsRequired && (n.consolidationRequiredLamports = l.lamportsRequired);
                const i = [{
                    addr: e,
                    amount: r.balance - l.lamportsRequired
                }]
                  , c = dye({
                    userWalletAddr: r.address,
                    destWallets: i,
                    mint: t,
                    tokenType: a,
                    decimals: s
                });
                return n.consolidationTxns.push({
                    sourceAddress: r.address,
                    txns: c.txns
                }),
                n
            }
            ), {
                consolidationTxns: [],
                consolidationRequiredLamports: 0n
            })
        } catch (fNe) {
            return {
                consolidationTxns: null,
                consolidationRequiredLamports: null
            }
        }
    }
    ), [A, T, d, g])
      , te = y.useCallback((async () => {
        var e, t;
        if (!g || !d || !A.length)
            return;
        if (null == (t = null == (e = g[A[0]]) ? void 0 : e.holdings[d]) ? void 0 : t.tokenType)
            if (null == Z ? void 0 : Z.length)
                try {
                    Q(!0);
                    const e = Z.map((e => (async () => {
                        const t = F(e.sourceAddress);
                        if (!t)
                            return void W({
                                message: uu.unknownError,
                                snackName: pu.consolidationFailed,
                                type: "error"
                            }, "consolidation-failed");
                        const r = e.txns.map((r => (async () => {
                            const a = await H(e.sourceAddress, {
                                ...r,
                                blockhash: t.blockhash.blockhash
                            });
                            if (!a)
                                return void W({
                                    message: uu.unknownError,
                                    snackName: pu.consolidationFailed,
                                    type: "error"
                                }, "consolidation-failed");
                            const s = await Um.submitAndAwaitResolution({
                                txnHash: a.txnHash,
                                signedTxnBase64: a.signedTxnBase64,
                                blockhash: t.blockhash,
                                builder: Fc.JITO,
                                chain: Pd.SOLANA
                            });
                            "success" === s.status ? (W({
                                message: uu.transferSuccess,
                                type: "success"
                            }, "consolidation-success"),
                            n()) : W({
                                message: "Transaction " + ("reverted" === s.status ? "reverted" : "timed out"),
                                snackName: pu.consolidationFailed,
                                type: "error"
                            }, "consolidation-error")
                        }
                        )()));
                        return await Promise.all(r)
                    }
                    )()));
                    await Promise.all(e)
                } catch (fNe) {} finally {
                    Q(!1)
                }
            else
                W({
                    message: uu.unknownError,
                    snackName: pu.consolidationFailed,
                    type: "error"
                }, "consolidation-failed");
        else
            W({
                message: uu.unknownError,
                snackName: pu.consolidationFailed,
                type: "error"
            }, "consolidation-failed")
    }
    ), [Z, A, W, F, H, n, d, g])
      , ne = y.useMemo(( () => ( (e, t, n, r, a) => {
        if (!e)
            return {
                tooltip: "",
                label: "No token selected"
            };
        if (!t.length)
            return {
                tooltip: "",
                label: "No consolidation wallets selected"
            };
        if (!r)
            return {
                tooltip: "",
                label: "No wallets data available"
            };
        if (!Object.keys(r).includes(n))
            return {
                tooltip: "Select other destination wallet",
                label: "Wallet mismatch"
            };
        if (null === a)
            return null;
        const s = Number(a) / 10 ** kU;
        return Object.values(r).filter((e => t.includes(e.walletAddress))).some((e => e.walletSolBalance < s)) ? {
            tooltip: `You need at least ${UI(s.toFixed(5))} SOL on each source wallet.`,
            label: "Insufficient funds"
        } : null
    }
    )(d, A, T, g, ee)), [A, T, d, g, ee])
      , re = y.useCallback(( (e, t) => {
        X || z || a(t)
    }
    ), [X, z]);
    return g ? v.jsxs(S, {
        gap: 3,
        minHeight: "100%",
        justifyContent: "space-between",
        children: [v.jsxs(S, {
            gap: 3,
            children: [v.jsxs(ot, {
                value: r,
                onChange: re,
                children: [v.jsx(lt, {
                    label: v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        children: [v.jsx(C, {
                            display: "flex",
                            children: v.jsx(Dv, {
                                color: "inherit",
                                size: Eke
                            })
                        }), v.jsx(k, {
                            color: "inherit",
                            variant: "inherit",
                            children: "Split Tokens"
                        })]
                    }),
                    value: jke.SPLIT
                }), v.jsx(lt, {
                    label: v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        children: [v.jsx(C, {
                            display: "flex",
                            sx: Mke,
                            children: v.jsx(Dv, {
                                color: "inherit",
                                size: Eke
                            })
                        }), v.jsx(k, {
                            color: "inherit",
                            variant: "inherit",
                            children: "Consolidate Tokens"
                        })]
                    }),
                    value: jke.CONSOLIDATE
                })]
            }), r === jke.CONSOLIDATE && v.jsxs(S, {
                gap: 1.25,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: "Select token"
                }), L || N ? v.jsx(V, {
                    variant: "tertiary",
                    size: "xsmall",
                    onClick: l,
                    children: L ? v.jsx(Fye, {
                        ...L
                    }) : v.jsx(k, {
                        textAlign: "left",
                        width: "100%",
                        variant: "inherit",
                        color: "inherit",
                        children: "No token selected"
                    })
                }) : v.jsx(Ie, {
                    variant: "rounded",
                    height: 32,
                    width: "100%"
                }), ru(d ?? "") && v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.label",
                    textAlign: "center",
                    px: 3,
                    children: "Consolidation might leave small amount of SOL in each wallet to ensure fees are covered."
                })]
            }), v.jsxs(S, {
                gap: 1.25,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: "Select source wallet" + (r === jke.SPLIT ? "" : "s")
                }), M ? r === jke.SPLIT ? v.jsx(fke, {
                    mainWallet: T,
                    setMainWallet: E,
                    walletItems: M
                }) : v.jsx(kke, {
                    selectedWallets: A,
                    toggleWallet: j,
                    walletItems: M,
                    mainWallet: T,
                    requireToken: !0
                }) : v.jsx(Ie, {
                    variant: "rounded",
                    height: 32,
                    width: "100%"
                })]
            }), r === jke.SPLIT && v.jsxs(S, {
                gap: 1.25,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: "Select token"
                }), L || g ? v.jsx(V, {
                    variant: "tertiary",
                    size: "xsmall",
                    onClick: l,
                    children: L ? v.jsx(Fye, {
                        ...L
                    }) : v.jsx(k, {
                        textAlign: "left",
                        width: "100%",
                        variant: "inherit",
                        color: "inherit",
                        children: "No token selected"
                    })
                }) : v.jsx(Ie, {
                    variant: "rounded",
                    height: 32,
                    width: "100%"
                })]
            }), r === jke.SPLIT && v.jsx(eke, {
                maxAmount: D,
                amount: B,
                setAmount: _
            }), v.jsx(uke, {
                label: r === jke.SPLIT ? "Amount to disperse" : "Consolidation amount",
                value: r === jke.SPLIT ? L ? B / 10 ** L.decimals : null : O ? Math.max(0, Number(Number(O.balance) / 10 ** O.decimals) - (ru(d ?? "") && ee ? Number(ee) / 10 ** kU * A.length : 0)) : null,
                tokenSymbol: (null == L ? void 0 : L.symbol) ?? "",
                notExact: r === jke.CONSOLIDATE && ru(d ?? "")
            }), v.jsx(Ee, {
                flexItem: !0
            }), v.jsxs(S, {
                gap: 1.25,
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: "Select destination wallet" + (r === jke.SPLIT ? "s" : "")
                }), M ? r === jke.SPLIT ? v.jsx(kke, {
                    selectedWallets: x,
                    toggleWallet: f,
                    walletItems: M,
                    mainWallet: T
                }) : v.jsx(fke, {
                    mainWallet: T,
                    setMainWallet: E,
                    walletItems: M
                }) : v.jsx(Ie, {
                    variant: "rounded",
                    height: 32,
                    width: "100%"
                })]
            })]
        }), r === jke.SPLIT && v.jsx(GC, {
            title: Y ? Y.tooltip : "",
            children: v.jsx(C, {
                display: "flex",
                children: v.jsxs(V, {
                    fullWidth: !0,
                    disabled: !L || !!Y || z || !G,
                    variant: "primary",
                    onClick: K,
                    sx: Pke,
                    children: [z ? "Splitting" : !L && d ? v.jsx(Ie, {
                        width: "100%",
                        variant: "rounded",
                        height: 24
                    }) : Y ? Y.label : `${x.length > 1 ? "Split" : "Send"} ${null == L ? void 0 : L.symbol.slice(0, Nke)} to ${x.length} wallet${x.length > 1 ? "s" : ""}`, z && v.jsx(J, {
                        size: 14,
                        color: "inherit"
                    })]
                })
            })
        }), r === jke.CONSOLIDATE && v.jsx(GC, {
            title: ne ? ne.tooltip : "",
            children: v.jsx(C, {
                display: "flex",
                children: v.jsxs(V, {
                    fullWidth: !0,
                    disabled: !L || !!ne || X,
                    variant: "primary",
                    onClick: te,
                    sx: Pke,
                    children: [X ? "Consolidating" : !L && d ? v.jsx(Ie, {
                        width: "100%",
                        variant: "rounded",
                        height: 24
                    }) : ne ? ne.label : `${A.length > 1 ? "Consolidate" : "Send"} ${null == L ? void 0 : L.symbol.slice(0, Nke)} from ${A.length} wallet${A.length > 1 ? "s" : ""}`, X && v.jsx(J, {
                        size: 14,
                        color: "inherit"
                    })]
                })
            })
        }), r === jke.SPLIT && R && v.jsx(Qye, {
            isOpen: s,
            onClose: i,
            splitWalletData: R,
            selectToken: U
        }), r === jke.CONSOLIDATE && N && v.jsx(Qye, {
            isOpen: s,
            onClose: i,
            splitWalletData: N,
            selectToken: U
        })]
    }) : v.jsx(Km, {})
}
))
  , Eke = 14
  , Mke = {
    transform: "scaleY(-1)"
}
  , Nke = 16
  , Pke = {
    gap: .75,
    display: "flex"
}
  , Oke = y.memo(( ({isOpen: e, onClose: t, initialTokenAddress: n, intialWalletAddress: r}) => v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: Lke,
    children: v.jsxs(S, {
        gap: 1.5,
        children: [v.jsxs(S, {
            py: .5,
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "h2",
                color: "text.value",
                children: "Token manager"
            }), v.jsx(F, {
                sx: Rke,
                onClick: t,
                children: v.jsx(gy, {
                    size: 24
                })
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: Dke
        }), v.jsx(Ike, {
            initialTokenAddress: n,
            intialWalletAddress: r,
            onClose: t
        })]
    })
})))
  , Lke = {
    zIndex: 1310,
    p: 2
}
  , Rke = {
    p: .25
}
  , Dke = {
    mx: {
        xs: -2,
        md: 0
    }
}
  , Bke = ({children: e}) => {
    const [t,n] = y.useState(null)
      , r = y.useCallback((e => {
        n(e)
    }
    ), [])
      , a = y.useCallback(( () => {
        n(null)
    }
    ), [])
      , s = y.useMemo(( () => ({
        openSplitModal: r
    })), [r]);
    return v.jsxs(Wye.Provider, {
        value: s,
        children: [e, t && v.jsx(Oke, {
            onClose: a,
            isOpen: !0,
            initialTokenAddress: t.initialTokenAddress,
            intialWalletAddress: t.intialWalletAddress
        })]
    })
}
  , _ke = () => y.useContext(Wye)
  , Uke = () => {
    const [e,t] = y.useState({
        status: ox.INITIAL
    })
      , [n,r] = y.useState(null)
      , a = y.useRef(!1)
      , s = y.useCallback(( () => {
        t({
            status: ox.INITIAL
        }),
        r(null)
    }
    ), [])
      , o = y.useCallback(( ({payload: e, force: t, rapidPolling: n}) => {
        e ? (a.current = n ?? !1,
        t && r(e)) : s()
    }
    ), [r, s]);
    return y.useEffect(( () => {
        if (!n)
            return void t({
                status: ox.INITIAL
            });
        let e = !1
          , r = null;
        const s = +i()
          , o = async () => {
            if (!(+i() - s > Vke || e))
                try {
                    const r = await cm.getQuoteV2(n);
                    if (e)
                        return;
                    t({
                        status: ox.READY,
                        data: r
                    })
                } catch (W$e) {
                    if (e)
                        return;
                    t((e => e.status === ox.READY ? e : {
                        status: ox.ERROR
                    }))
                }
        }
        ;
        t((e => e.status === ox.READY ? e : {
            status: ox.LOADING
        })),
        o();
        const l = a.current ? Fke : Wke;
        return r = setInterval(( () => {
            o()
        }
        ), l),
        () => {
            e = !0,
            r && clearInterval(r)
        }
    }
    ), [n]),
    {
        setQuotePayload: o,
        invalidate: s,
        quoterData: e
    }
}
  , Wke = 3e3
  , Fke = 1e3
  , Vke = 6e5
  , Hke = (e, t, n, r, a, s) => {
    const o = PA({
        refreshRate: zke,
        immediateRunAfterPageBecomesVisible: !0
    });
    y.useEffect(( () => {
        e && null !== n && r && a && s && t.length && c.forEach(t.sort(), (e => {
            toe({
                chain: n,
                baseToken: r,
                poolAddress: mg(s).marketAddress,
                quoteToken: a,
                walletAddress: e
            })
        }
        ))
    }
    ), [e, o, n, r, s, a, t])
}
  , zke = 5e3
  , $ke = y.createContext({
    get: () => null
});
$ke.displayName = "SolOrderDataContext";
const Gke = y.memo(( ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , {get: n} = y.useContext(zD)
      , r = dde(t)
      , a = UD((e => e.wallets))
      , s = y.useMemo(( () => a ? a.filter((e => e.walletType === pc.SOL)).map((e => e.publicAddress)) : null), [a])
      , l = y.useMemo(( () => s ? s.join("-") : null), [s])
      , i = !!t
      , c = y.useMemo(( () => loe(t)), [t])
      , d = y.useMemo(( () => !!(c && ru(c.address) && (null == t ? void 0 : t.quoteToken.address) && Ej(t.quoteToken.address))), [c, t])
      , u = ( (e, t, n, r, a) => {
        const s = Ax()
          , o = y.useCallback(( (o, l) => s && r && t && e && a && a === Pd.SOLANA ? om.subscribeAtaOrderContext(t, r, n ? "1" : null, l) : {
            unsubscribe: () => {}
        }), [s, e, n, t, r, a])
          , l = y.useMemo(( () => ({
            transition: (e, t) => e ? {
                info: {
                    ...e.info,
                    [t.walletAddr]: t.ctx
                }
            } : {
                info: {
                    [t.walletAddr]: t.ctx
                }
            },
            extractPageCursor: () => ""
        })), []);
        return fx(o, l)
    }
    )(i, r, d, l, (null == t ? void 0 : t.chain) ?? null)
      , p = (e => {
        const t = Ax()
          , n = y.useCallback(( (n, r) => t && e ? mg(e).chain !== Pd.SOLANA ? {
            unsubscribe: () => {}
        } : om.subscribeAuxOrderContextV2(e, r) : {
            unsubscribe: () => {}
        }), [t, e])
          , r = y.useMemo(( () => ({
            transition: (e, t) => "init" === t.type ? t.snapshot : e ? {
                ...e,
                ...t.update
            } : (o(new Error("AuxOrderContext is null, but received non-init event")),
            null),
            extractPageCursor: () => ""
        })), []);
        return fx(n, r)
    }
    )(r)
      , h = (e => {
        const t = Ax()
          , n = y.useCallback(( (n, r) => t && e ? mg(e).chain !== Pd.SOLANA ? {
            unsubscribe: () => {}
        } : om.subscribeMarketOrderContextV2(e, r) : {
            unsubscribe: () => {}
        }), [t, e])
          , r = y.useMemo(( () => ({
            transition: (e, t) => "init" === t.type ? t.snapshot : e ? {
                ...e,
                ...t.update
            } : (o(new Error("PoolContext is null, but received non-init event")),
            null),
            extractPageCursor: () => ""
        })), []);
        return fx(n, r)
    }
    )(r)
      , m = y.useMemo(( () => ({
        get: (e, t) => {
            var a, s;
            if (e !== r)
                return null;
            const o = n(t)
              , l = mg(e)
              , i = h()
              , c = p()
              , d = (null == (s = null == (a = u()) ? void 0 : a.info) ? void 0 : s[t]) ?? null;
            if (!(o && i && c && d))
                return null;
            return {
                blockhash: o.blockhash,
                poolAddr: l.marketAddress,
                poolCtx: i,
                auxCtx: c,
                ataCtx: d,
                walletCtx: o.walletCtx,
                userCtx: o.userCtx
            }
        }
    })), [r, p, u, h, n]);
    return v.jsx($ke.Provider, {
        value: m,
        children: e
    })
}
))
  , qke = () => y.useContext($ke)
  , Kke = ["q", "w", "e", "r", "a", "s", "d", "f"]
  , Yke = (e, t, n, r, a, s, o, l, c, d, u, p, h) => {
    const m = zb(h);
    if (m && !$b.includes(n.chain))
        throw new Error("Unsupported inferno mode chain");
    if (!o && !m)
        throw new Error("Missing preset");
    const g = vU()
      , x = c ? OB(d, YR.has(n.chain)) : [];
    return {
        type: rc.MARKET,
        tradeParams: {
            pair: {
                baseCurrency: n.baseToken.address,
                quoteCurrency: r
            },
            side: t,
            quantity: e,
            slippage: {
                type: "MANUAL",
                valueBps: 100 * Number((null == o ? void 0 : o.slippage) ?? "0")
            },
            routingFilters: {
                marketIds: [fg(n.chain, n.marketAddress, n.protocol.type === Lc.FOUR_MEME ? {
                    type: "fourmeme",
                    tokenAddress: n.baseToken.address
                } : null)]
            }
        },
        executionOptions: {
            gasSettings: m && $b.includes(n.chain) ? {
                type: "SOLBEAST"
            } : n.chain === Pd.SOLANA ? {
                type: "SOLANA",
                tipInSolUi: l && (null == o ? void 0 : o.customRpcUrl) ? "0" : TB((null == o ? void 0 : o.tip) ?? "0"),
                prioInSolUi: TB((null == o ? void 0 : o.prio) ?? "0")
            } : {
                type: "EVM",
                prioInGweiUi: (null == o ? void 0 : o.prio) ?? "0"
            },
            useMevProtection: Dd.includes(n.chain) ? (!l || !(null == o ? void 0 : o.customRpcUrl)) && ((null == o ? void 0 : o.mevProtection) ?? void 0) : void 0,
            ...m && $b.includes(n.chain) || !l || !(null == o ? void 0 : o.customRpcUrl) ? {} : {
                customRpc: {
                    type: "solana",
                    url: o.customRpcUrl
                }
            }
        },
        ...x.length ? {
            postSuccessHook: {
                orderTriggers: x
            }
        } : {},
        context: {
            displayedBasePriceInUsd: UI(a.toFixed(36)),
            displayedBasePriceInQuote: UI(s.toFixed(36)),
            displayedQuoteToken: r,
            multiWalletCount: p,
            multiWalletId: u,
            rev: Du.SENTRY_RELEASE_HASH,
            selectedPresetName: h
        },
        attribution: {
            firstUserClickMs: +i()
        },
        idemp: g
    }
}
  , Xke = [rg.DARK, rg.INDIGO]
  , Qke = [Xh.DARK, Xh.INDIGO]
  , Zke = y.memo(( ({className: e, onClick: t, supportsMevProtection: n, supportsTip: r, slippageValuePercent: a, gasSettings: s, useMevProtection: o, isInInfernoMode: l, hasCustomRpc: i, customRpc: c, mobileMode: d}) => {
    const {t: u} = we();
    return l ? v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        height: 16,
        children: [!d && v.jsx(Cf, {}), v.jsx(k, {
            variant: "paragraph1",
            color: "originalPrimary.main",
            children: u("Inferno mode active")
        })]
    }) : v.jsxs(S, {
        className: e,
        direction: "row",
        justifyContent: "flex-start",
        gap: 1,
        divider: v.jsx(Ee, {
            orientation: "vertical",
            flexItem: !0,
            sx: {
                my: .25
            }
        }),
        children: [v.jsxs(S, {
            ...aCe,
            onClick: t,
            children: [v.jsx(wy, {
                size: tCe
            }), v.jsx(k, {
                ...nCe,
                sx: rCe,
                children: Jke(null == s ? void 0 : s.prio)
            })]
        }), r && v.jsxs(S, {
            ...aCe,
            onClick: t,
            children: [v.jsx(_k, {
                size: tCe
            }), v.jsx(k, {
                ...nCe,
                sx: rCe,
                children: Jke(null == s ? void 0 : s.tip)
            })]
        }), v.jsxs(S, {
            ...aCe,
            onClick: t,
            children: [v.jsx(Uk, {
                size: tCe
            }), v.jsx(k, {
                ...nCe,
                sx: rCe,
                children: eCe(a)
            })]
        }), n && v.jsxs(S, {
            ...aCe,
            onClick: t,
            children: [o ? v.jsx(Py, {
                size: tCe
            }) : v.jsx(Oy, {
                size: tCe
            }), v.jsx(k, {
                ...nCe,
                sx: rCe,
                children: u(o ? "On" : "Off")
            })]
        }), !l && i && v.jsx(S, {
            ...aCe,
            onClick: t,
            children: v.jsx(z, {
                title: c ? iu(c, 20) : "",
                children: v.jsx(k, {
                    variant: "paragraph3",
                    color: "text.value",
                    sx: rCe,
                    noWrap: !0,
                    children: "RPC"
                })
            })
        })]
    })
}
))
  , Jke = e => {
    const t = Number(e);
    return !t || isNaN(t) ? Ud : UI(t > 1 ? wI(t, {
        precision: 2,
        symbol: ""
    }) : EI(t, {
        precision: 3
    }))
}
  , eCe = e => {
    const t = Number(e);
    return t && !isNaN(t) ? UI(t >= 1 ? wI(t, {
        precision: 0,
        symbol: "%",
        symbolPosition: yI.END
    }) : `${EI(t, {
        precision: 1
    })}%`) : Ud
}
  , tCe = 14
  , nCe = {
    variant: "paragraph3",
    color: "text.value"
}
  , rCe = {
    opacity: .9
}
  , aCe = {
    direction: "row",
    alignItems: "flex-end",
    height: tCe,
    gap: .5,
    sx: {
        "&:hover": {
            cursor: "pointer"
        }
    }
}
  , sCe = ({side: e, baseDecimals: t, quoteDecimals: n, cpQuoteInputs: r, quantityValue: a}) => {
    try {
        return oCe({
            side: e,
            baseDecimals: t,
            quoteDecimals: n,
            cpQuoteInputs: r,
            quantityValue: a
        })
    } catch (W$e) {
        o(W$e)
    }
    return null
}
  , oCe = ({side: e, baseDecimals: t, quoteDecimals: n, cpQuoteInputs: r, quantityValue: a}) => {
    if (!a || isNaN(Number(a)) || !Number(a) || !r || !r.baseReserve || !r.quoteReserve)
        return null;
    const [s,o,l,i] = e === xc.BUY ? [n, 10 ** -t, BigInt(r.quoteReserve), BigInt(r.baseReserve)] : [t, 10 ** -n, BigInt(r.baseReserve), BigInt(r.quoteReserve)]
      , c = Number(a) * 10 ** s
      , d = (u = c,
    !Number.isFinite(u) || isNaN(u) ? null : BigInt(ce(u).toFixed(0)));
    var u;
    if (null === d)
        return null;
    const p = (e => {
        const {amountIn: t, reserveIn: n, reserveOut: r, fee: a} = e;
        if (t <= 0n)
            return null;
        if (0n === n || 0n === r)
            return null;
        const s = t * (1000000n - a);
        return s * r / (1000000n * n + s)
    }
    )({
        amountIn: d,
        reserveIn: l,
        reserveOut: i,
        fee: 0n
    });
    return null === p ? null : Number(p) * o
}
  , lCe = e => {
    if (!e)
        return null;
    switch (e) {
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return Yv;
    case Pd.SOLANA:
        return dk;
    case Pd.BSC:
        return ak
    }
}
  , iCe = y.memo(( ({currentPositions: e, mobileMode: t, quoteValue: n, quotePercentage: r, quoterData: a, sellNativeValue: s, totalBaseValue: o, tradeSide: l, showSellInitQuoterValue: i}) => {
    var d, u;
    const {originalStaticMarketInfo: p} = Qce()
      , h = hde(p)
      , m = Nde()
      , g = ode()
      , x = gde()
      , b = bde()
      , {chainStats: f} = FV()
      , C = (null == h ? void 0 : h.chain) === Pd.SOLANA ? (null == (u = null == (d = null == f ? void 0 : f.perChain) ? void 0 : d.SOLANA) ? void 0 : u.stats.nativePriceInUsdUi) ?? null : null
      , A = y.useMemo(( () => h ? fSe(h, x, g, b, C) : null), [C, x, g, b, h])
      , w = y.useMemo(( () => {
        var t, n;
        if (!h || !(null == e ? void 0 : e.length))
            return null;
        if (!ru(h.quoteToken.address))
            return null;
        const a = h.chain === Pd.SOLANA ? kU : yU
          , s = h.baseToken.decimals;
        if (!s)
            return null;
        const o = c.reduce(e.map((e => e.balance)), ( (e, t) => {
            if (!t || "" === t)
                return e;
            const n = BigInt(t);
            return null === e ? e = n : e += n,
            e
        }
        ), null);
        if (null === o)
            return null;
        const l = (null == (t = e.find((e => null !== e.virtualNativeLiquidity))) ? void 0 : t.virtualNativeLiquidity) ?? null;
        if (null === l)
            return null;
        const i = (null == (n = e.find((e => null !== e.markPriceInNativeUi))) ? void 0 : n.markPriceInNativeUi) ?? null;
        if (null === i)
            return null;
        const d = ( ({baseDecimals: e, quoteDecimals: t, balance: n, virtualNativeLiquidity: r, markPriceInNativeUi: a, fastPrices: s}) => {
            if (!r || !n || "0" === n || !e)
                return null;
            const o = (null == s ? void 0 : s.basePriceInNativeUi) ? s.basePriceInNativeUi : a
              , l = o ? Lj({
                priceInclDecimals: o,
                baseDecimals: e,
                quoteDecimals: t
            }) : null;
            if (null === l)
                return null;
            const i = Oj({
                liquidity: r,
                unadjustedPrice: l
            })
              , c = gF({
                amountIn: BigInt(n),
                reserveIn: i.baseReserves,
                reserveOut: i.quoteReserves,
                feePpm: 0n
            });
            return null === c ? null : Number(c) / 10 ** t
        }
        )({
            baseDecimals: s,
            quoteDecimals: a,
            balance: o.toString(),
            virtualNativeLiquidity: l,
            markPriceInNativeUi: i,
            fastPrices: A
        });
        return null === d ? null : r ? d * (r / 100) : d
    }
    ), [e, h, r, A])
      , j = y.useMemo(( () => {
        if (t)
            return null;
        const e = n ?? (l === xc.SELL && m && o && h ? o.toString() : null);
        return h && e ? sCe({
            side: l,
            baseDecimals: h.baseToken.decimals,
            quoteDecimals: h.quoteToken.decimals,
            cpQuoteInputs: m,
            quantityValue: e
        }) : null
    }
    ), [n, l, m, o, h, t])
      , T = y.useMemo(( () => a.status === ox.READY && h && "string" == typeof a.data.quantity.value ? Number(a.data.quantity.value) / 10 ** (l === xc.SELL ? h.quoteToken.decimals : h.baseToken.decimals) : null), [a, h, l])
      , I = y.useMemo(( () => {
        if (t)
            return null;
        const e = l === xc.SELL ? w ?? j ?? T : j ?? T;
        if (!h)
            return null;
        if (null === e)
            return null;
        if (!e || isNaN(e))
            return LI(0, {
                collapseExponent: !0,
                symbolPosition: yI.END,
                padSymbol: !0,
                symbol: l === xc.SELL ? ru(h.quoteToken.address) ? "" : iu(h.quoteToken.symbol) : iu(h.baseToken.symbol)
            });
        return LI(e, {
            collapseExponent: !0,
            symbolPosition: yI.END,
            padSymbol: !0,
            symbol: l === xc.SELL ? ru(h.quoteToken.address) ? "" : iu(h.quoteToken.symbol) : iu(h.baseToken.symbol)
        })
    }
    ), [j, T, w, h, l, t])
      , E = y.useMemo(( () => t ? null : s ? UI(LI(s, {
        collapseExponent: !0,
        symbol: ""
    })) : i ? (null == e ? void 0 : e.length) ? LI(c.sum(e.map((e => e.amount))), {
        collapseExponent: !0,
        symbol: ""
    }) : null : I || (l === xc.BUY ? null : "0")), [t, s, i, I, l, e])
      , M = y.useMemo(( () => lCe((null == h ? void 0 : h.chain) ?? null)), [null == h ? void 0 : h.chain]);
    return h ? E ? v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .25,
        height: 14,
        children: [v.jsx(k, {
            variant: "paragraph1",
            color: l === xc.SELL ? "text.value" : "text.label",
            children: E
        }), l === xc.SELL && ru(h.quoteToken.address) && M ? v.jsx(M, {
            size: cCe
        }) : null]
    }) : null : v.jsx(Ie, {
        variant: "rounded",
        width: 60,
        height: 14
    })
}
))
  , cCe = 15
  , dCe = y.memo(( ({shortcutKey: e}) => v.jsx(S, {
    direction: "row",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    mt: -1.25,
    sx: uCe,
    children: e.toUpperCase()
})))
  , uCe = e => ({
    width: 28,
    height: 24,
    border: `1px solid ${e.palette.background.borderActive}`,
    backgroundColor: e.palette.background.buttonActive,
    borderRadius: 1
})
  , pCe = y.memo(( ({onClick: e, onPointerEnter: t, onPointerLeave: n, tradeSide: r, label: a, value: s, chain: o, IconComponent: l, isSellNative: i, mobileMode: c, index: d}) => {
    const u = y.useMemo(( () => e => ({
        minWidth: "calc(25% - 10px)",
        transition: "none",
        borderRadius: c ? 7 : 3.5,
        gap: .25,
        flex: 1,
        flexGrow: 1,
        height: "100%",
        px: 0,
        py: .5,
        fontSize: c ? 14 : 12,
        borderColor: `${r === xc.BUY ? e.palette.success.main : e.palette.error.main}${hCe}`,
        color: r === xc.BUY ? e.palette.success.main : e.palette.error.main,
        background: "transparent",
        "&:disabled": {
            border: `1px solid ${e.palette.background.borderMain}${hCe}`
        },
        "&:hover, &:focus": {
            background: `${r === xc.BUY ? e.palette.success.main : e.palette.error.main}14`,
            color: Me(r === xc.BUY ? e.palette.success.main : e.palette.error.main, .2),
            borderColor: `${r === xc.BUY ? e.palette.success.main : e.palette.error.main}${hCe}`
        }
    })), [c, r])
      , p = y.useCallback((async () => {
        if (np.info("Instant trade button clicked", {
            onClickPreset: !!e,
            value: s,
            isSellNative: i,
            tradeSide: r,
            label: a,
            index: d
        }),
        e && !(s <= 0))
            try {
                await e(s, i)
            } catch (fNe) {}
    }
    ), [e, s, i, r, a, d])
      , h = y.useCallback(( () => {
        t && t(s, i)
    }
    ), [s, t, i])
      , m = y.useCallback(( () => {
        n && n()
    }
    ), [n]);
    return v.jsxs(V, {
        onClick: p,
        onPointerEnter: h,
        onPointerLeave: m,
        className: "no-drag",
        size: c ? "small" : "xxsmall",
        variant: "tertiary",
        sx: u,
        tabIndex: -1,
        onMouseDown: Uw,
        children: [null === a ? v.jsx(Ie, {
            variant: "rounded",
            width: c ? 60 : 45,
            height: c ? 24 : 18
        }) : v.jsx(k, {
            variant: "monospace2",
            fontWeight: 400,
            children: a
        }), l && v.jsx(C, {
            display: "flex",
            ml: o === Pd.SOLANA ? "-2px" : 0,
            children: v.jsx(l, {
                size: c ? 16 : 13,
                color: "inherit"
            })
        })]
    })
}
))
  , hCe = "80"
  , mCe = y.memo(( ({value: e, configIndex: t, isExtra: n, mobileMode: r, inputButtonMode: a, chain: s}) => {
    const {updateAmountInputPreset: o, updateExtraAmountInputPreset: l} = rf()
      , [i,d] = y.useState(e.toString())
      , u = y.useMemo(( () => c.debounce((e => {
        null === e || e < 0 || !s || !a || (n ? l(e, a, s, t) : o(e, a, s, t))
    }
    ), xCe, {
        maxWait: bCe
    })), [s, t, a, n, o, l])
      , p = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e)
          , n = XR(t, 3, a === Ox.PERCENTAGE ? 100 : null);
        d(n);
        const r = Number(n);
        !isNaN(r) && r >= 0 ? u(r) : u(null)
    }
    ), [u, a])
      , h = y.useMemo(( () => e => ({
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        minWidth: "calc(25% - 10px)",
        transition: "none",
        borderRadius: r ? 7 : 3.5,
        gap: .25,
        flex: 1,
        flexGrow: 1,
        height: "100%",
        px: 0,
        py: 0,
        fontSize: r ? 13 : 12,
        maxHeight: r ? "23px " : void 0,
        border: `1px solid ${e.palette.primary.main}80`,
        color: e.palette.text.value,
        background: e.palette.primary.background,
        "&:hover": {
            background: e.palette.primary.background
        },
        "&:focus": {
            background: e.palette.primary.background
        }
    })), [r]);
    return v.jsx(C, {
        className: "no-drag",
        sx: h,
        children: v.jsx(Qn, {
            name: "myField",
            value: i,
            onChange: p,
            autoComplete: "off",
            placeholder: "",
            sx: gCe
        })
    })
}
))
  , gCe = {
    border: "none",
    outline: "none",
    p: 0,
    background: "transparent",
    "& input": {
        p: 0,
        textAlign: "center",
        fontSize: "13px",
        height: "auto"
    }
}
  , xCe = 250
  , bCe = 1e3
  , fCe = y.memo(( ({chain: e, buttonsConfig: t, extraButtonsConfig: n, mobileMode: r, spacebarHeld: a, shortcutsEnabled: s, tradeSide: o, onClick: l, onPointerEnter: i, onPointerLeave: c, isInButtonValuesEditMode: d}) => v.jsx(S, {
    direction: "row",
    gap: 1,
    mb: .5,
    flexWrap: "wrap",
    flexGrow: 1,
    children: t ? [...t, ...n ?? []].map(( (n, u) => {
        const p = a && s && !d ? ( (e, t) => {
            if (t === xc.BUY)
                switch (e) {
                case 0:
                    return "q";
                case 1:
                    return "w";
                case 2:
                    return "e";
                case 3:
                    return "r";
                default:
                    return null
                }
            else
                switch (e) {
                case 0:
                    return "a";
                case 1:
                    return "s";
                case 2:
                    return "d";
                case 3:
                    return "f";
                default:
                    return null
                }
        }
        )(u, o) : null
          , h = u >= t.length;
        return v.jsx(GC, {
            open: null !== p,
            noTooltipBackground: !0,
            placement: "bottom",
            title: p ? v.jsx(dCe, {
                shortcutKey: p
            }) : "",
            children: v.jsx(C, {
                component: "span",
                display: "flex",
                minWidth: "calc(25% - 10px)",
                flex: 1,
                children: d ? v.jsx(mCe, {
                    value: n.value,
                    configIndex: h ? u - t.length : u,
                    isExtra: h,
                    mobileMode: r,
                    inputButtonMode: n.inputButtonMode ?? null,
                    chain: e
                }) : v.jsx(pCe, {
                    onClick: l,
                    onPointerEnter: i,
                    onPointerLeave: c,
                    tradeSide: o,
                    label: n.label,
                    value: n.value,
                    chain: e,
                    IconComponent: o === xc.SELL && n.Icon ? n.Icon ?? null : null,
                    index: u,
                    isSellNative: n.isSellNative || !1,
                    mobileMode: r
                })
            })
        }, u)
    }
    )) : Array(n ? 8 : 4).fill("").map(( (t, n) => v.jsx(pCe, {
        tradeSide: o,
        value: 0,
        label: null,
        chain: e,
        IconComponent: null,
        index: n,
        isSellNative: !1,
        mobileMode: r
    }, n)))
})));
var vCe = (e => (e.PERCENTAGE = "PERCENTAGE",
e.QUANTITY = "QUANTITY",
e))(vCe || {});
const SCe = Array(4).fill(null)
  , yCe = (e, t, n, r, a) => {
    if (e === vCe.PERCENTAGE) {
        const e = ((null == r ? void 0 : r.percentage) || Dx.percentage)[n] || Dx.percentage[n]
          , s = (null == r ? void 0 : r.instantSellNativeValues) || Dx.instantSellNativeValues
          , o = a && ru(t) && n === Pd.SOLANA && s[n] || SCe;
        return e.slice(0, 4).map(( (e, n) => {
            const r = o[n];
            return {
                value: r ?? e,
                label: c.isNil(r) ? `${UI(e.toFixed(1))}%` : `${UI(r.toFixed(r < 1 ? 3 : r < 10 ? 2 : 0))}`,
                ...c.isNil(r) ? {
                    inputButtonMode: Ox.PERCENTAGE
                } : {
                    Icon: kCe(t),
                    isSellNative: !0,
                    inputButtonMode: Ox.INSTANT_SELL_NATIVE
                }
            }
        }
        ))
    }
    const s = CCe(t, n)
      , o = kCe(t);
    if ((t === Gc || t === qc) && n === Pd.SOLANA || [Wd, "0x4200000000000000000000000000000000000006", Fd].includes(t) && n !== Pd.SOLANA) {
        return (((null == r ? void 0 : r.native) || Dx.native)[n] || Dx.native[n]).slice(0, 4).map((e => ({
            value: e,
            label: `${UI(e.toFixed(e < 1 ? 3 : e < 10 ? 2 : 0))} ${s}`,
            Icon: o,
            inputButtonMode: Ox.NATIVE
        })))
    }
    return (((null == r ? void 0 : r.stable) || Dx.stable)[n] || Dx.stable[n]).slice(0, 4).map((e => ({
        value: e,
        label: `${s ? "$" : ""}${UI(LI(e, {
            maxPrecision: e < 10 || e >= 1e4 ? 2 : 0,
            minPrecision: e < 10 || e >= 1e4 ? 2 : 0,
            collapseExponent: e >= 1e4
        }))}`,
        inputButtonMode: Ox.STABLE
    })))
}
  , kCe = e => {
    const t = ng(e);
    return t === Wd ? Yv : t === Gc || t === qc ? dk : void 0
}
  , CCe = (e, t) => {
    const n = ng(e);
    return n === Wd || n === Gc || n === qc ? "" : eu[t][n] || ""
}
  , ACe = y.memo(( ({tradeSide: e, selectedPreset: t, shortcutsEnabled: n, sellNativeMode: r, toggleSellNativeMode: a, mobileMode: s=!1, openPresetSelectDrawer: o, forceExtraButtons: l=!1, isInButtonValuesEditMode: d}) => {
    const {t: u} = we()
      , p = Ax()
      , m = D()
      , g = pK()
      , {originalStaticMarketInfo: x, tradePageOriginRef: b} = Qce()
      , f = hde(x)
      , A = y.useMemo(( () => loe(f)), [f])
      , {settings: w} = rf()
      , {showModal: j} = gU()
      , {getTxnSign: T} = fU()
      , {get: I} = qke()
      , {getPadreLutData: E} = y.useContext(zD)
      , {trackCreatedOrder: M} = hf()
      , N = kde()
      , P = mde()
      , O = xde()
      , L = y.useCallback(( (e, t, n) => f && A ? AU({
        orderType: e.type,
        quantity: e.tradeParams.quantity,
        basePriceInUsdUi: t,
        basePriceInQuoteUi: n,
        baseDecimals: f.baseToken.decimals,
        quoteDecimals: A.decimals
    }) : null), [f, A])
      , {selectedWalletsAddresses: R, compatibleWallets: B, refreshBalances: _} = Gde()
      , {openSplitModal: U} = _ke()
      , W = y.useCallback(( () => {
        R.length && f && f.chain === Pd.SOLANA && U({
            initialTokenAddress: ng(f.baseToken.address),
            intialWalletAddress: R[0]
        })
    }
    ), [f, U, R])
      , {openEditModal: H} = QSe()
      , z = y.useCallback(( () => {
        H(e)
    }
    ), [H, e])
      , $ = y.useMemo(( () => {
        if (!x)
            return null;
        const n = (null == w ? void 0 : w.orderPresets) || Bx
          , r = x.chain
          , a = (n[r] || Bx[r])[e] || Bx[r][e];
        return zb(t) ? null : a[t] ?? Bx[r][e][t]
    }
    ), [x, null == w ? void 0 : w.orderPresets, e, t])
      , G = y.useMemo(( () => A && f ? f.chain === Pd.SOLANA && e === xc.SELL && ru(A.address) : null), [A, e, f])
      , q = y.useMemo(( () => B && R ? c.reduce(B, ( (e, t) => R.includes(ng(t.wallet.publicAddress)) ? (e || (e = []),
    e.push(t),
    e) : e), null) : null), [B, R])
      , [K,Y,X] = y.useMemo(( () => {
        if (!x || !A)
            return [null, null, null];
        const {totalBaseBalance: e, isAnyBaseLoaded: t, totalQuoteForExecutionBalance: n, isAnyQuoteForExecutionLoaded: r, baseBalancePerWallet: a} = c.reduce(q ?? [], ( (e, t) => {
            const n = t.balances.base.rawAmount ?? "0"
              , r = t.balances.quoteForExecution.rawAmount ?? "0";
            return e = {
                baseBalancePerWallet: {
                    ...e.baseBalancePerWallet,
                    [ng(t.wallet.publicAddress)]: n
                },
                totalBaseBalance: (BigInt(e.totalBaseBalance) + BigInt(n)).toString(),
                isAnyBaseLoaded: 0 === R.length || e.isAnyBaseLoaded || !t.balances.base.isLoading,
                totalQuoteForExecutionBalance: (BigInt(e.totalQuoteForExecutionBalance) + BigInt(r)).toString(),
                isAnyQuoteForExecutionLoaded: 0 === R.length || e.isAnyQuoteForExecutionLoaded || !t.balances.quoteForExecution.isLoading
            }
        }
        ), {
            totalBaseBalance: "0",
            isAnyBaseLoaded: 0 === R.length,
            totalQuoteForExecutionBalance: "0",
            isAnyQuoteForExecutionLoaded: 0 === R.length,
            baseBalancePerWallet: {}
        })
          , s = t ? new sB({
            decimals: x.baseToken.decimals
        },BigInt(e)).toNumber() : null
          , o = c.mapValues(a, (e => new sB({
            decimals: x.baseToken.decimals
        },BigInt(e))));
        return [s, r ? new sB({
            decimals: A.decimals
        },BigInt(n)).toNumber() : null, o]
    }
    ), [A, q, R.length, x])
      , {buttonsConfig: Q, extraButtonsConfig: Z} = ( (e, t, n, r, a, s) => {
        const {settings: o, extraInputPresets: l} = rf();
        return y.useMemo(( () => t && n ? {
            buttonsConfig: e === xc.BUY ? yCe(vCe.QUANTITY, n, t.chain, (null == o ? void 0 : o.amountInputPresets) || null, !1) : yCe(vCe.PERCENTAGE, n, t.chain, (null == o ? void 0 : o.amountInputPresets) || null, r),
            extraButtonsConfig: !l && !s || a ? null : e === xc.BUY ? yCe(vCe.QUANTITY, n, t.chain, (null == o ? void 0 : o.extraAmountInputPresets) || null, !1) : yCe(vCe.PERCENTAGE, n, t.chain, (null == o ? void 0 : o.extraAmountInputPresets) || null, r)
        } : {
            buttonsConfig: null,
            extraButtonsConfig: null
        }), [t, n, e, null == o ? void 0 : o.amountInputPresets, null == o ? void 0 : o.extraAmountInputPresets, l, r, a, s])
    }
    )(e, x, (null == A ? void 0 : A.address) ?? null, !!G && r, s, l)
      , J = f ? vg(f) : x ? vg(x) : null
      , ee = (null == f ? void 0 : f.chain) ?? null
      , te = y.useMemo(( () => !!ee && Bd.includes(ee)), [ee])
      , ne = y.useMemo(( () => !!ee && (Od.includes(ee) || !(!Ld.includes(ee) || !(null == $ ? void 0 : $.mevProtection)))), [ee, null == $ ? void 0 : $.mevProtection])
      , re = y.useMemo(( () => !!ee && Dd.includes(ee)), [ee])
      , ae = y.useMemo(( () => $ && $.prio ? {
        prio: $.prio,
        tip: $.tip
    } : void 0), [$])
      , se = zV()
      , oe = qV()
      , {exitStrategies: le, includeExitStrategies: ie} = KR()
      , [ce,de] = y.useState(!1)
      , ue = y.useRef(0)
      , pe = y.useCallback((async (n, r=!1, a=!1) => {
        const s = {
            selectedWalletsAmount: (null == R ? void 0 : R.length) ?? null,
            tradeSide: e,
            selectedPreset: t,
            value: n,
            isHotkey: r,
            isSellNative: a,
            ...f ? {
                baseAddress: f.baseToken.address,
                baseSymbol: f.baseToken.address,
                quoteAddress: f.quoteToken.address,
                quoteSymbol: f.quoteToken.address,
                marketAddress: f.marketAddress
            } : {
                marketInfo: null
            }
        };
        if (ue.current + 50 > i().valueOf())
            return void np.warn("Order hasn't been sent - double click prevention", {
                orderInfo: s
            });
        if (ue.current = i().valueOf(),
        0 === R.length)
            return np.warn("Order hasn't been sent - no wallet selected", {
                orderInfo: s
            }),
            void g({
                message: pu.noWalletSelected,
                type: "warning"
            }, "no-wallet-selected");
        const o = (null == P ? void 0 : P.current) ?? null
          , l = (null == O ? void 0 : O.current) ?? null;
        if (R && f && A && p && null !== o && null !== l && ($ || zb(t)) && w)
            try {
                de(!0);
                const i = r ? Dp.INSTA_HOTKEY : Dp.INSTA_MOUSE
                  , d = h();
                let u = null;
                const m = R.length
                  , x = R.map(( (r, h) => (async () => {
                    w.multiWalletsTradeDelay && h && e === xc.BUY && await Hu(1e3 * w.multiWalletsTradeDelay * h);
                    const x = X ? X[r] : null;
                    if (e === xc.SELL && c.isNil(x))
                        throw new Error(`No base holdings for wallet ${r}`);
                    const b = e === xc.BUY ? _V(n, R.length, h, w.multiWalletsTradeSpread ?? 2, f.chain).toString() : "0"
                      , v = e === xc.BUY ? sB.fromFractionalAmount({
                        decimals: A.decimals
                    }, b).getRawAmount().toString() : a ? sB.fromFractionalAmount({
                        decimals: A.decimals
                    }, n.toString()).getRawAmount().toString() : {
                        type: "pct",
                        pctValue: String(Math.floor(n))
                    }
                      , S = {
                        unit: e === xc.BUY || a ? bc.QUOTE : bc.BASE,
                        value: v
                    }
                      , y = Yke(S, e, f, A.address, o, l, $, te, e === xc.BUY && ie, le, d, m, t);
                    if (e === xc.SELL && (!y.tradeParams.quantity.value || "0" === y.tradeParams.quantity.value))
                        return 1 === R.length && (np.warn("Order hasn't been sent - no token on selected wallet", {
                            orderInfo: s
                        }),
                        g({
                            message: pu.youDontHaveToken,
                            type: "warning"
                        }, "padre-order-form-missing-value-warning")),
                        {
                            orderId: ""
                        };
                    try {
                        try {
                            if (J && ac(y)) {
                                const e = await BV(r, y, I(J, r), T, E());
                                e && (y.signV2 = e)
                            }
                        } catch (k) {
                            np.error("Error during FE sign, falling back", {
                                err: k,
                                orderInfo: s
                            })
                        }
                        const t = DV({
                            uid: p,
                            chainId: f.chain,
                            walletAddress: r,
                            request: y,
                            origin: i,
                            marketQuoteToken: f.quoteToken.address
                        })
                          , c = $ && !isNaN(Number($.tip)) ? Number($.tip) : 0
                          , d = $ && !isNaN(Number($.prio)) ? Number($.prio) : 0;
                        if (1 === R.length) {
                            const r = !(!ru(ng(f.quoteToken.address)) || null === Y) && jU({
                                balanceNative: Y,
                                amountInNative: isNaN(Number(b)) ? 0 : Number(b),
                                tipInNative: c,
                                prioInNative: d
                            });
                            g({
                                onOrderResolve: se,
                                onFill: () => {
                                    _()
                                }
                                ,
                                onOpenSummary: j,
                                orderIdPromise: t,
                                variant: lK.SLIM_ORDER_STATUS,
                                orderSnackDetails: {
                                    customAutoTimeoutDuration: oe,
                                    orderType: rc.MARKET,
                                    tradeSide: e,
                                    baseSymbol: f.baseToken.symbol,
                                    baseValue: a ? `up to ${LI(n, {
                                        collapseExponent: !0,
                                        symbol: "SOL",
                                        symbolPosition: yI.END
                                    })}` : e === xc.SELL ? `${UI(LI(n, {
                                        collapseExponent: !0,
                                        symbol: ""
                                    }))}%` : "",
                                    quoteSymbol: A.symbol,
                                    quoteValue: e === xc.BUY ? UI(LI(b, {
                                        collapseExponent: !0,
                                        symbol: ""
                                    })) : "",
                                    tokenAddress: f.baseToken.address,
                                    padreAvatarUrl: (null == N ? void 0 : N.padreAvatarUrl) ?? null,
                                    chain: f.chain,
                                    showLowBalanceWarning: r
                                }
                            }, "order-slim-status")
                        }
                        const h = L(y, o, l);
                        return u = null === h ? u : (u ?? 0) + h,
                        await t
                    } catch (W$e) {
                        return np.error("Order hasn't been sent - exception thrown during processing order", {
                            error: W$e,
                            orderInfo: s
                        }),
                        {
                            orderId: ""
                        }
                    }
                }
                )()));
                R.length > 1 && g({
                    onOrderResolve: se,
                    onFill: () => {
                        _()
                    }
                    ,
                    orderIdPromises: x,
                    variant: lK.MULTI_ORDER_STATUS,
                    orderSnackDetails: {
                        customAutoTimeoutDuration: oe,
                        orderType: rc.MARKET,
                        tradeSide: e,
                        baseSymbol: f.baseToken.symbol,
                        baseValue: e === xc.SELL ? `${UI(LI(n, {
                            collapseExponent: !0,
                            symbol: ""
                        }))}%` : "",
                        quoteSymbol: A.symbol,
                        quoteValue: e === xc.BUY ? UI(LI(n, {
                            collapseExponent: !0,
                            symbol: ""
                        })) : "",
                        tokenAddress: f.baseToken.address,
                        padreAvatarUrl: (null == N ? void 0 : N.padreAvatarUrl) ?? null,
                        chain: f.chain
                    }
                }, "order-multi-status"),
                await Promise.allSettled(x),
                M({
                    chain: f.chain,
                    specificType: e === xc.SELL ? ic.MARKET_SELL : ic.MARKET_BUY,
                    originWidget: i,
                    isMultiWallet: R.length > 1,
                    estimatedUsd: u,
                    tradePageOrigin: b.current ?? nT.OTHER
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing multi orders", {
                    e: fNe,
                    orderInfo: s
                }),
                g({
                    message: uu.unknownError,
                    snackName: pu.createFailed,
                    type: "error"
                }, "floating-trading-widget-create-order-failed")
            } finally {
                de(!1)
            }
        else
            np.warn("Order hasn't been sent - loading data", {
                orderInfo: s
            })
    }
    ), [R, P, O, f, A, p, $, t, w, g, e, X, te, ie, le, M, J, I, T, E, Y, se, j, oe, null == N ? void 0 : N.padreAvatarUrl, _, L, b])
      , he = y.useCallback((async (e, n=!1) => {
        !f || !p || ce && ((null == w ? void 0 : w.preventDoubleClick) ?? y$) || !$ && !zb(t) ? np.warn("Order hasn't been sent - disabled button state", {
            value: e,
            isSellNative: n,
            marketInfoPresent: !!f,
            uid: p,
            isPerformingTrade: ce,
            preventDoubleClickSettings: !!(null == w ? void 0 : w.preventDoubleClick),
            tradePreset: $,
            selectedPreset: t
        }) : await pe(e, !1, n)
    }
    ), [ce, pe, t, f, $, p, null == w ? void 0 : w.preventDoubleClick])
      , {portfolioData: me} = Xde()
      , ge = y.useMemo(( () => {
        if (!(f && A && p && X && R.length && me))
            return null;
        if (f.chain !== Pd.SOLANA)
            return null;
        if (f.protocol.type === Rc.METEORA_CURVE)
            return null;
        if (!ru(A.address))
            return null;
        const e = bg(f.chain, f.baseToken.address);
        return c.reduce(R, ( (t, n) => {
            var r, a;
            const s = null == (r = me[n]) ? void 0 : r.perTokenId;
            if (!s)
                return t;
            const o = s[e];
            if (!o || o.wasExternallyTraded || o.wasAirdropped)
                return t;
            if (null === o.totalInvestedInNativeUi)
                return t;
            const l = o.totalInvestedInNativeUi - (o.totalSoldInNativeUi ?? 0);
            if (l < 1e-4)
                return t;
            const i = B ? (null == (a = B.find((e => ng(e.wallet.publicAddress) === ng(n)))) ? void 0 : a.wallet.walletName) ?? null : null
              , {virtualNativeLiquidity: c, balance: d, markPriceInNativeUi: u} = o;
            return t.push({
                walletAddress: n,
                walletName: i,
                sellInitAmount: UI(l.toFixed(36)),
                amount: l,
                virtualNativeLiquidity: c,
                balance: d,
                markPriceInNativeUi: u
            }),
            t
        }
        ), [])
    }
    ), [A, X, B, me, R, f, p])
      , xe = y.useMemo(( () => e => ({
        border: "none",
        backgroundColor: "transparent",
        px: .25,
        height: 16,
        color: e.palette.error[500],
        "&:hover, &:focus": {
            border: "none",
            backgroundColor: "transparent"
        },
        "&.Mui-disabled": {
            border: "none",
            backgroundColor: "transparent"
        }
    })), [])
      , be = y.useCallback((async () => {
        const n = {
            selectedWalletsAmount: (null == R ? void 0 : R.length) ?? null,
            tradeSide: e,
            selectedPreset: t,
            isSellInit: !0,
            ...f ? {
                baseAddress: f.baseToken.address,
                baseSymbol: f.baseToken.address,
                quoteAddress: f.quoteToken.address,
                quoteSymbol: f.quoteToken.address,
                marketAddress: f.marketAddress
            } : {
                marketInfo: null
            }
        };
        if (e !== xc.SELL)
            return void np.warn("Order hasn't been sent - sell init trade side mismatch", {
                orderInfo: n
            });
        if (!w)
            return void np.warn("Order hasn't been sent - loading settings", {
                orderInfo: n
            });
        if (!(null == ge ? void 0 : ge.length))
            return np.warn("Order hasn't been sent - no token to sell init", {
                orderInfo: n
            }),
            void g({
                message: v.jsxs(S, {
                    gap: .5,
                    className: "padre-no-scroll",
                    children: [v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: uu.noTokenToSellInit
                    }), v.jsx($C, {
                        label: "Learn more",
                        href: UC,
                        nofollow: !1,
                        variant: "paragraph3"
                    })]
                }),
                snackName: pu.sellInitialFailed,
                type: "warning"
            }, "floating-trading-widget-create-sell-init-order-no-token");
        if (!(f && A && p && X && Q))
            return void np.warn("Order hasn't been sent - loading sell init info", {
                orderInfo: n
            });
        const r = (null == P ? void 0 : P.current) ?? null
          , a = (null == O ? void 0 : O.current) ?? null;
        if (null !== r && null !== a)
            try {
                de(!0);
                const e = h();
                let s = null;
                const o = ge.length
                  , l = ge.map(( ({walletAddress: l, sellInitAmount: i, amount: d, walletName: u}) => (async () => {
                    try {
                        const n = X[l];
                        if (c.isNil(n))
                            throw new Error(`No base holdings for wallet ${l}`);
                        const m = Yke({
                            unit: bc.QUOTE,
                            value: sB.fromFractionalAmount({
                                decimals: A.decimals
                            }, i).getRawAmount().toString()
                        }, xc.SELL, f, A.address, r, a, $, te, !1, [], e, o, t);
                        try {
                            if (J && ac(m)) {
                                const e = await BV(l, m, I(J, l), T, E());
                                e && (m.signV2 = e)
                            }
                        } catch (h) {
                            np.error("Error during FE sign, falling back", {
                                err: h
                            })
                        }
                        const x = DV({
                            uid: p,
                            chainId: f.chain,
                            walletAddress: l,
                            request: m,
                            origin: Dp.INSTA_MOUSE,
                            marketQuoteToken: f.quoteToken.address
                        });
                        1 === R.length && g({
                            onOrderResolve: se,
                            onFill: () => {
                                _()
                            }
                            ,
                            onOpenSummary: j,
                            orderIdPromise: x,
                            variant: lK.SLIM_ORDER_STATUS,
                            orderSnackDetails: {
                                customAutoTimeoutDuration: oe,
                                orderType: rc.MARKET,
                                tradeSide: xc.SELL,
                                baseSymbol: f.baseToken.symbol,
                                baseValue: `up to ${LI(d, {
                                    collapseExponent: !0,
                                    symbol: "SOL",
                                    symbolPosition: yI.END
                                })}`,
                                quoteSymbol: A.symbol,
                                quoteValue: "",
                                tokenAddress: f.baseToken.address,
                                padreAvatarUrl: (null == N ? void 0 : N.padreAvatarUrl) ?? null,
                                chain: f.chain,
                                walletName: u ?? void 0,
                                showLowBalanceWarning: !1
                            },
                            isSellInit: !0
                        }, "order-slim-status-sell-init");
                        const b = L(m, r, a);
                        return s = null === b ? s : (s ?? 0) + b,
                        await x
                    } catch (W$e) {
                        return np.error("Order hasn't been sent - exception thrown during processing sell init", {
                            error: W$e,
                            orderInfo: n
                        }),
                        {
                            orderId: ""
                        }
                    }
                }
                )()));
                ge.length > 1 && g({
                    onOrderResolve: se,
                    onFill: () => {
                        _()
                    }
                    ,
                    orderIdPromises: l,
                    variant: lK.MULTI_ORDER_STATUS,
                    orderSnackDetails: {
                        customAutoTimeoutDuration: oe,
                        orderType: rc.MARKET,
                        tradeSide: xc.SELL,
                        baseSymbol: f.baseToken.symbol,
                        baseValue: `up to ${LI(c.sum(ge.map((e => e.amount))), {
                            collapseExponent: !0,
                            symbol: "SOL",
                            symbolPosition: yI.END
                        })}`,
                        quoteSymbol: A.symbol,
                        quoteValue: "",
                        tokenAddress: f.baseToken.address,
                        padreAvatarUrl: null,
                        chain: f.chain
                    },
                    isSellInit: !0
                }, "order-multi-status-sell-init"),
                await Promise.allSettled(l),
                M({
                    chain: f.chain,
                    specificType: "SELL_INIT",
                    originWidget: Dp.INSTA_MOUSE,
                    isMultiWallet: R.length > 1,
                    estimatedUsd: s,
                    tradePageOrigin: b.current ?? nT.OTHER
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing sell inits", {
                    e: fNe
                }),
                g({
                    message: uu.unknownError,
                    snackName: pu.createFailed,
                    type: "error"
                }, "floating-trading-widget-create-sell-init-order-failed")
            } finally {
                de(!1)
            }
        else
            np.warn("Order hasn't been sent - missing prices", {
                orderInfo: n
            })
    }
    ), [e, w, ge, f, A, p, X, Q, P, O, g, $, te, t, R.length, j, J, T, E, I, M, se, oe, null == N ? void 0 : N.padreAvatarUrl, _, L, b])
      , [fe,ve] = y.useState(!1)
      , Se = y.useCallback(( () => {
        s || ve(!0)
    }
    ), [s])
      , ye = y.useCallback(( () => {
        ve(!1)
    }
    ), [])
      , [ke,Ce] = y.useState({
        value: null,
        percentage: null
    })
      , {setQuotePayload: Ae, invalidate: je, quoterData: Te} = Uke()
      , [Ee,Me] = y.useState(null)
      , Ne = y.useCallback(( (n, r) => {
        if (s || !J || !A || !R || !p || !f || !$ && !zb(t))
            return;
        if (r)
            return void Me(n);
        const a = e === xc.SELL ? sB.fromFractionalAmount({
            decimals: f.baseToken.decimals
        }, ((K ?? 0) * (n / 100)).toString()).getRawAmount().toString() : sB.fromFractionalAmount({
            decimals: A.decimals
        }, n.toString()).getRawAmount().toString();
        Ce(e === xc.SELL ? {
            value: ((K ?? 0) * (n / 100)).toFixed(36),
            percentage: n
        } : {
            value: n.toString(),
            percentage: null
        }),
        R.length ? Ae({
            rapidPolling: !0,
            payload: {
                chain: f.chain,
                pair: {
                    baseCurrency: f.baseToken.address,
                    quoteCurrency: A.address
                },
                side: e,
                quantity: e === xc.SELL ? {
                    unit: bc.BASE,
                    value: a
                } : {
                    unit: bc.QUOTE,
                    value: a
                },
                gasSettings: zb(t) && f.chain === Pd.SOLANA ? {
                    type: "SOLBEAST"
                } : f.chain === Pd.SOLANA ? {
                    type: "SOLANA",
                    tipInSolUi: te && (null == $ ? void 0 : $.customRpcUrl) ? "0" : TB((null == $ ? void 0 : $.tip) ?? "0"),
                    prioInSolUi: TB((null == $ ? void 0 : $.prio) ?? "0")
                } : {
                    type: "EVM",
                    prioInGweiUi: (null == $ ? void 0 : $.prio) ?? "0"
                },
                marketIds: [J],
                uid: p,
                walletsAddresses: R
            },
            force: !0
        }) : je()
    }
    ), [A, je, te, J, t, R, Ae, f, K, $, e, p, s])
      , Pe = y.useCallback(( () => {
        Ce({
            value: null,
            percentage: null
        }),
        je(),
        Me(null)
    }
    ), [je])
      , Oe = y.useMemo(( () => f && A ? e === xc.BUY ? null === Y ? null : LI(Y, {
        collapseExponent: !0,
        symbolPosition: yI.END,
        padSymbol: !0,
        symbol: ru(A.address) ? "" : iu(A.symbol, 16)
    }) : null === K ? null : LI(K, {
        collapseExponent: !0,
        symbolPosition: yI.END,
        padSymbol: !0,
        symbol: iu(f.baseToken.symbol, 16)
    }) : null), [f, K, Y, A, e])
      , [Le,Re] = y.useState(!1)
      , De = y.useCallback((t => {
        if (Le && !d && Kke.includes(t)) {
            if (!Q)
                return void np.warn("Order hasn't been sent - buttons config missing", {
                    key: t
                });
            if (Q.length < 4)
                return void np.warn("Order hasn't been sent - buttons config mismatch", {
                    key: t,
                    buttonsConfig: Q
                });
            const {side: n, value: r, isSellNative: a} = ( (e, t, n) => {
                switch (e) {
                case "q":
                    return {
                        index: 0,
                        side: xc.BUY,
                        value: t.length > 0 ? t[0].value : 0,
                        isSellNative: !1
                    };
                case "w":
                    return {
                        index: 1,
                        side: xc.BUY,
                        value: t.length > 1 ? t[1].value : 0,
                        isSellNative: !1
                    };
                case "e":
                    return {
                        index: 2,
                        side: xc.BUY,
                        value: t.length > 2 ? t[2].value : 0,
                        isSellNative: !1
                    };
                case "r":
                    return {
                        index: 3,
                        side: xc.BUY,
                        value: t.length > 3 ? t[3].value : 0,
                        isSellNative: !1
                    };
                case "a":
                    return {
                        index: 0,
                        side: xc.SELL,
                        value: n.length > 0 ? n[0].value : 0,
                        isSellNative: n.length > 0 && n[0].isSellNative || !1
                    };
                case "s":
                    return {
                        index: 1,
                        side: xc.SELL,
                        value: n.length > 1 ? n[1].value : 0,
                        isSellNative: n.length > 1 && n[1].isSellNative || !1
                    };
                case "d":
                    return {
                        index: 2,
                        side: xc.SELL,
                        value: n.length > 2 ? n[2].value : 0,
                        isSellNative: n.length > 2 && n[2].isSellNative || !1
                    };
                case "f":
                    return {
                        index: 3,
                        side: xc.SELL,
                        value: n.length > 3 ? n[3].value : 0,
                        isSellNative: n.length > 3 && n[3].isSellNative || !1
                    }
                }
            }
            )(t, e === xc.BUY ? Q : [], e === xc.BUY ? [] : Q);
            if (n !== e || r <= 0)
                return void np.warn("Order hasn't been sent - shortcuts disabled", {
                    key: t,
                    side: n,
                    value: r,
                    isSellNative: a
                });
            (async () => {
                try {
                    await pe(r, !0, a)
                } catch (fNe) {
                    np.error("Order hasn't been sent - exception thrown during processing shortcut click", {
                        e: fNe,
                        key: t,
                        side: n,
                        value: r,
                        isSellNative: a
                    })
                }
            }
            )()
        }
    }
    ), [Q, pe, e, Le, d]);
    y.useEffect(( () => {
        const e = e => {
            if (!n)
                return;
            const t = document.activeElement;
            if (!(t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement || t instanceof HTMLSelectElement || t instanceof HTMLElement && t.isContentEditable)) {
                "Space" === e.code && (e.preventDefault(),
                e.repeat || Le || Re(!0));
                try {
                    e.repeat || De(e.key.toLowerCase())
                } catch (r) {}
            }
        }
          , t = e => {
            "Space" === e.code && Re(!1)
        }
          , r = e => {
            try {
                if (!e.isTrusted || e.origin !== document.location.origin)
                    return;
                if (e.data.repeat)
                    return;
                "keyEvent" === e.data.type && "keydown" === e.data.eventType && 32 === e.data.keyCode && Re(!0),
                "keyEvent" === e.data.type && "keyup" === e.data.eventType && 32 === e.data.keyCode && Re(!1),
                Le && "keyEvent" === e.data.type && "keydown" === e.data.eventType && 32 !== e.data.keyCode && De(e.data.key.toLowerCase())
            } catch (W$e) {}
        }
        ;
        return window.addEventListener("message", r),
        window.addEventListener("keydown", e),
        window.addEventListener("keyup", t),
        () => {
            window.removeEventListener("message", r),
            window.removeEventListener("keydown", e),
            window.removeEventListener("keyup", t)
        }
    }
    ), [Q, pe, Le, n, De, e]);
    const [Be,_e] = y.useState(!1)
      , Ue = y.useCallback(( () => {
        _e(!0)
    }
    ), [])
      , We = y.useCallback(( () => {
        _e(!1)
    }
    ), []);
    Hke((Le || Be) && !!f, R, (null == f ? void 0 : f.chain) ?? null, (null == f ? void 0 : f.baseToken.address) ?? null, (null == f ? void 0 : f.quoteToken.address) ?? null, J);
    const Fe = y.useMemo(( () => lCe((null == f ? void 0 : f.chain) ?? null)), [null == f ? void 0 : f.chain]);
    return v.jsxs(S, {
        gap: s ? jCe : wCe,
        onMouseEnter: Ue,
        onMouseLeave: We,
        flexGrow: 1,
        children: [!s && v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [G ? v.jsxs(V, {
                className: "no-drag",
                variant: "tertiary",
                onClick: a,
                sx: ICe,
                children: [v.jsx(k, {
                    variant: "paragraph2",
                    color: "text.value",
                    children: "Sell " + (r ? "SOL" : "%")
                }), v.jsx(oy, {
                    size: 12,
                    color: m.palette.text.value
                })]
            }) : v.jsx(k, {
                variant: "paragraph2",
                color: "text.value",
                children: e === xc.BUY ? "Buy" : "Sell"
            }), v.jsxs(S, {
                direction: "row",
                gap: .75,
                alignItems: "center",
                children: [v.jsx(iCe, {
                    quoteValue: ke.value,
                    quotePercentage: ke.percentage,
                    mobileMode: s,
                    tradeSide: e,
                    sellNativeValue: Ee,
                    quoterData: Te,
                    totalBaseValue: K,
                    showSellInitQuoterValue: fe,
                    currentPositions: ge
                }), v.jsxs(S, {
                    direction: "row",
                    gap: .25,
                    alignItems: "center",
                    height: 14,
                    children: [Oe ? v.jsx(k, {
                        variant: "paragraph1",
                        color: e === xc.SELL ? "text.label" : "text.value",
                        children: Oe
                    }) : v.jsx(Ie, {
                        variant: "rounded",
                        width: 50,
                        height: 15
                    }), e === xc.BUY && Fe && A && ru(A.address) ? v.jsx(Fe, {
                        size: ECe
                    }) : null, e === xc.BUY && !!R.length && f && f.chain === Pd.SOLANA && !!K && v.jsx(F, {
                        className: "no-drag",
                        onClick: W,
                        sx: MCe,
                        children: v.jsx(Dv, {
                            size: 12
                        })
                    })]
                })]
            })]
        }), v.jsx(fCe, {
            mobileMode: s,
            chain: (null == f ? void 0 : f.chain) ?? null,
            tradeSide: e,
            spacebarHeld: Le,
            buttonsConfig: null === G ? null : Q,
            extraButtonsConfig: null === G ? null : Z,
            shortcutsEnabled: n,
            onPointerEnter: Ne,
            onPointerLeave: Pe,
            onClick: he,
            isInButtonValuesEditMode: d
        }), v.jsxs(S, {
            direction: "row",
            gap: .25,
            justifyContent: "space-between",
            alignItems: "center",
            height: s && o ? 24 : 16,
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [s && o && v.jsx(_ye, {
                    onClick: o,
                    preset: t
                }), v.jsx(Zke, {
                    className: "no-drag",
                    onClick: z,
                    supportsMevProtection: re,
                    supportsTip: ne,
                    slippageValuePercent: (null == $ ? void 0 : $.slippage) ?? null,
                    gasSettings: ae,
                    useMevProtection: (!te || !(null == $ ? void 0 : $.customRpcUrl)) && ((null == $ ? void 0 : $.mevProtection) ?? void 0),
                    isInInfernoMode: zb(t),
                    hasCustomRpc: te && !!(null == $ ? void 0 : $.customRpcUrl),
                    customRpc: (null == $ ? void 0 : $.customRpcUrl) ?? "",
                    mobileMode: s
                })]
            }), e === xc.SELL && f && A && G && v.jsx(GC, {
                maxWidth: 325,
                title: ru(ng(A.address)) ? (null == ge ? void 0 : ge.length) && ge.length > 1 ? v.jsx(S, {
                    children: ge.map(( (e, t) => v.jsxs(S, {
                        gap: 1.5,
                        direction: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                        children: [v.jsx(k, {
                            variant: "inherit",
                            color: "text.value",
                            children: `~${LI(e.amount, {
                                collapseExponent: !0,
                                symbol: "SOL",
                                symbolPosition: yI.END
                            })}`
                        }), v.jsx(k, {
                            variant: "inherit",
                            color: "text.label",
                            children: oA(e.walletAddress)
                        })]
                    }, t)))
                }) : "" : "Initial sell is only supported on SOL markets",
                children: v.jsx(C, {
                    component: "span",
                    sx: TCe,
                    children: v.jsx(V, {
                        disabled: !!A && !ru(ng(A.address)),
                        className: "no-drag",
                        size: "xxsmall",
                        variant: "tertiary",
                        sx: xe,
                        onClick: be,
                        onPointerEnter: Se,
                        onPointerLeave: ye,
                        children: v.jsx(k, {
                            noWrap: !0,
                            variant: "inherit",
                            color: "inherit",
                            children: u("Sell Init.")
                        })
                    })
                })
            })]
        })]
    })
}
))
  , wCe = .75
  , jCe = 2
  , TCe = {
    cursor: "help"
}
  , ICe = {
    py: 0,
    px: .25,
    ml: -.25,
    mt: .25,
    height: 16,
    alignItems: "center",
    display: "flex",
    gap: .25,
    background: "transparent",
    border: "none !important"
}
  , ECe = 15
  , MCe = {
    p: .25
}
  , NCe = "padreV2-tradingFloatinghWidgetSellNativeMode";
Rc.METEORA_CURVE,
Rc.HEAVEN,
Rc.TOKEN_MILL;
const PCe = y.memo(( ({selectedPreset: e, shortcutsEnabled: t, stackRef: n, forceExtraButtons: r, isInButtonValuesEditMode: a}) => {
    const [s,o] = Mx(NCe, !1)
      , l = y.useCallback(( () => {
        o((e => !e))
    }
    ), [o]);
    return v.jsxs(S, {
        ref: n,
        className: "padre-no-scroll",
        height: "100%",
        width: "100%",
        gap: 1.5,
        children: [v.jsx(ACe, {
            tradeSide: xc.BUY,
            selectedPreset: e,
            shortcutsEnabled: t,
            sellNativeMode: s,
            toggleSellNativeMode: l,
            forceExtraButtons: r,
            isInButtonValuesEditMode: a
        }), v.jsx(ACe, {
            tradeSide: xc.SELL,
            selectedPreset: e,
            shortcutsEnabled: t,
            sellNativeMode: s,
            toggleSellNativeMode: l,
            forceExtraButtons: r,
            isInButtonValuesEditMode: a
        }), v.jsx(Bye, {})]
    })
}
))
  , OCe = y.memo(( ({chain: e, width: t, lightHover: n=!1}) => {
    const {selectedPreset: r, setSelectedPreset: a, openEditModal: s} = QSe();
    return v.jsx(v.Fragment, {
        children: v.jsx(S, {
            direction: "row",
            alignItems: "center",
            gap: .25,
            className: "no-drag",
            children: (e && $b.includes(e) ? RCe : LCe).map(( (e, o) => {
                const l = r === e;
                return v.jsx(fH, {
                    label: yH(e, 14, 0, l),
                    onClick: () => {
                        l && "Inferno" !== r ? s() : a(e)
                    }
                    ,
                    useFlex: !1,
                    typographyColor: l ? "primary.main" : "text.label",
                    width: t,
                    lightHover: n
                }, o)
            }
            ))
        })
    })
}
))
  , LCe = [zh.NORMAL, zh.FAST, zh.ULTRA]
  , RCe = [...LCe, "Inferno"]
  , DCe = y.memo(( ({chain: e}) => {
    const t = kde()
      , {isInSidePanelMode: n, toggleIsInSidePanelMode: r, toggleSidePanelOpen: a} = ESe();
    return e ? v.jsx(mye, {
        chain: e,
        padreAvatarUrl: (null == t ? void 0 : t.padreAvatarUrl) ?? null,
        walletSelectMode: eye.SELECT,
        compact: !0,
        isInSidePanelMode: n,
        toggleIsInSidePanelMode: r,
        toggleSidePanelOpen: a
    }) : v.jsx(Ie, {
        variant: "rounded",
        width: 46,
        height: 28
    })
}
))
  , BCe = y.memo(( ({shortcutsEnabled: e, toggleShortcutsEnabled: t, chain: n, isInButtonValuesEditMode: r, toggleButtonValuesEditMode: a, onClose: s, isLightBackground: o}) => {
    const {t: l} = we()
      , i = D()
      , {includeExitStrategies: c, toggleIncludeExitStrategies: d} = KR();
    return v.jsxs(S, {
        width: "100%",
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        gap: .25,
        pl: .5,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(DCe, {
                chain: n
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .25,
                children: [v.jsx(VCe, {
                    shortcutsEnabled: e,
                    toggleShortcutsEnabled: t,
                    isLightBackground: o
                }), v.jsx(GC, {
                    title: l(c ? "Disable exit strategies" : "Enable exit strategies"),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsx(V, {
                            className: "no-drag",
                            variant: "tertiary",
                            size: "xxsmall",
                            onClick: d,
                            sx: o ? zCe : HCe,
                            children: v.jsx(C, {
                                display: "flex",
                                children: v.jsx(yS, {
                                    size: 18,
                                    color: c ? i.palette.primary.main : i.palette.text.label
                                })
                            })
                        })
                    })
                })]
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "flex-end",
            gap: .5,
            className: "no-drag",
            sx: FCe,
            children: [v.jsx(z, {
                title: l("Edit button values"),
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        onClick: a,
                        sx: o ? zCe : HCe,
                        children: r ? v.jsx(xy, {}) : v.jsx(Ky, {})
                    })
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "flex-end",
                children: [v.jsx(OCe, {
                    chain: n,
                    width: _Ce,
                    lightHover: o
                }), v.jsx(F, {
                    sx: o ? WCe : UCe,
                    onClick: s,
                    children: v.jsx(gy, {})
                })]
            })]
        })]
    })
}
))
  , _Ce = 28
  , UCe = {
    p: .75,
    width: _Ce,
    height: _Ce
}
  , WCe = e => ({
    ...UCe,
    "&:hover": {
        background: e.palette.background.hover
    }
})
  , FCe = {
    cursor: "auto"
}
  , VCe = y.memo(( ({shortcutsEnabled: e, toggleShortcutsEnabled: t, isLightBackground: n}) => {
    const {t: r} = we()
      , a = D()
      , s = ( () => {
        const [e,t] = y.useState(!1);
        return y.useEffect(( () => {
            const e = () => {
                const e = document.activeElement
                  , n = e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e instanceof HTMLSelectElement || e instanceof HTMLElement && e.isContentEditable;
                t(n)
            }
              , n = () => {
                setTimeout(( () => {
                    const e = document.activeElement
                      , n = e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e instanceof HTMLSelectElement || e instanceof HTMLElement && e.isContentEditable;
                    t(n)
                }
                ), 0)
            }
            ;
            return window.addEventListener("focusin", e),
            window.addEventListener("focusout", n),
            () => {
                window.removeEventListener("focusin", e),
                window.removeEventListener("focusout", n)
            }
        }
        ), []),
        e
    }
    )()
      , [o,l] = y.useState(!1)
      , i = y.useCallback(( () => {
        l(!0)
    }
    ), [])
      , c = y.useCallback(( () => {
        l(!1)
    }
    ), [])
      , d = y.useMemo(( () => v.jsx(C, {
        className: "no-drag",
        component: "span",
        children: v.jsx(V, {
            onClick: t,
            variant: "tertiary",
            color: "primary",
            size: "xxsmall",
            sx: n ? zCe : HCe,
            children: v.jsx(vS, {
                color: e ? a.palette.primary.main : a.palette.text.label
            })
        })
    })), [e, a.palette.primary.main, a.palette.text.label, t, n]);
    return v.jsx(GC, {
        open: o || s && e,
        onOpen: i,
        onClose: c,
        title: r(e ? s ? "Shortcuts paused while youre typing" : "Hold spacebar to use hotkeys" : "Enable hotkeys"),
        children: d
    }, "controlled-tooltip")
}
))
  , HCe = e => ({
    p: 0,
    transition: "none",
    minWidth: _Ce,
    border: "none",
    background: "transparent",
    "&:focus": {
        border: "none",
        background: "transparent"
    },
    "&:hover": {
        border: "none",
        background: e.palette.background.buttonDefault
    }
})
  , zCe = e => ({
    ...HCe(e),
    "&:hover": {
        border: "none",
        background: e.palette.background.hover
    }
})
  , $Ce = y.memo(( ({closeTradingWidget: e, internalIndex: t, initialXAbsolute: n, initialYAbsolute: r, isSidePanelOpen: a}) => {
    const [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        o((e => !e))
    }
    ), [])
      , {colorSkin: i, defaultThemeSkin: c} = Vb()
      , d = y.useMemo(( () => ( (e, t) => Xke.includes(e) || !(!t || !Qke.includes(t)))(i, c)), [i, c])
      , {originalStaticMarketInfo: u} = Qce()
      , p = hde(u)
      , {extraInputPresets: h} = rf()
      , {selectedPreset: m} = QSe()
      , [g,x] = Mx("padreV2-tradingFloatingWidgetShortcutsEnabled", !1)
      , b = y.useCallback(( () => {
        x((e => !e))
    }
    ), [x])
      , f = y.useMemo(( () => v.jsx(BCe, {
        shortcutsEnabled: g,
        toggleShortcutsEnabled: b,
        chain: (null == p ? void 0 : p.chain) ?? null,
        isInButtonValuesEditMode: s,
        toggleButtonValuesEditMode: l,
        onClose: e,
        isLightBackground: d
    })), [g, null == p ? void 0 : p.chain, b, l, s, e, d])
      , {showOnInstantTrade: k} = TSe()
      , C = y.useMemo(( () => 226 + (h ? 68 : 0) + (k ? 28 : 0)), [h, k])
      , A = y.useMemo(( () => ({
        minWidth: 343,
        minHeight: C
    })), [C])
      , w = y.useRef(null)
      , [j,T] = y.useState(!1);
    y.useEffect(( () => {
        const e = w.current;
        if (!e)
            return;
        const t = () => {
            const t = e.offsetHeight;
            T(t > 294 + (k ? 28 : 0) - qCe)
        }
          , n = new ResizeObserver(( () => {
            t()
        }
        ));
        return n.observe(e),
        t(),
        () => {
            n.disconnect()
        }
    }
    ), [k]);
    const {toggleIsInSidePanelMode: I} = ESe()
      , E = kde()
      , M = y.useMemo(( () => a && p ? v.jsx(S, {
        height: "100%",
        width: "100%",
        className: N8,
        sx: e => ({
            backdropFilter: "blur(12px)",
            WebkitBackdropFilter: "blur(12px)",
            backgroundColor: $t(d ? e.palette.background.hover : e.palette.background.default, .18),
            boxShadow: "inset 1px 0 0 rgba(255,255,255,0.06)"
        }),
        children: v.jsx(mye, {
            chain: p.chain,
            padreAvatarUrl: (null == E ? void 0 : E.padreAvatarUrl) ?? null,
            walletSelectMode: eye.SELECT,
            isInSidePanelMode: !0,
            toggleIsInSidePanelMode: I,
            isDisplayOnly: !0
        })
    }) : void 0), [null == E ? void 0 : E.padreAvatarUrl, a, p, I, d]);
    return v.jsx(v.Fragment, {
        children: v.jsx(P8, {
            id: Y6.TRADING_WIDGET,
            width: 343,
            height: C,
            initialX: n - 343 - 12,
            initialY: r - 113 + 86,
            header: f,
            headerSx: GCe,
            internalIndex: t,
            disableScroll: !0,
            resizeParams: A,
            hasModals: !0,
            sidePanel: M,
            sidePanelWidth: KCe,
            lightBackground: d,
            children: v.jsx(PCe, {
                selectedPreset: m,
                shortcutsEnabled: g,
                stackRef: w,
                forceExtraButtons: j,
                isInButtonValuesEditMode: s
            })
        })
    })
}
))
  , GCe = {
    pb: .25
}
  , qCe = 52
  , KCe = 350
  , YCe = [Pd.SOLANA, Pd.BSC, Pd.ETH_MAINNET, Pd.BASE]
  , XCe = (e, t) => {
    if (!t || !e)
        return null;
    const n = (e => {
        switch (e) {
        case Pd.ETH_MAINNET:
            return "1";
        case Pd.SOLANA:
            return "solana";
        case Pd.BASE:
            return "8453";
        case Pd.BSC:
            return "56";
        case Pd.ARBITRUM:
            return "42161"
        }
        return null
    }
    )(e);
    return n ? `https://app.insightx.network/bubblemaps/${n}/${t}?link=0&tooltip=true&hide=token&v=2` : null
}
  , QCe = y.memo(( ({chain: e, contractAddress: t}) => {
    const n = y.useMemo(( () => XCe(e, t)), [e, t])
      , r = y.useMemo(( () => e ? (e => YCe.includes(e))(e) : null), [e]);
    return n && null !== r ? v.jsx(S, {
        width: "100%",
        height: "100%",
        className: "no-drag",
        children: r ? v.jsx("iframe", {
            style: ZCe,
            src: n,
            title: "Bubblemap",
            allow: "clipboard-write"
        }) : v.jsx(S, {
            alignItems: "center",
            width: "100%",
            height: "100%",
            justifyContent: "center",
            children: v.jsx(k, {
                textAlign: "center",
                variant: "paragraph3",
                color: "text.label",
                children: "Bubble chart not available"
            })
        })
    }) : v.jsx(S, {
        height: "100%",
        children: v.jsx(Km, {})
    })
}
))
  , ZCe = {
    width: "100%",
    height: "100%",
    border: "none",
    transform: "none"
}
  , JCe = y.memo(( ({closeBubblemapWidget: e, internalIndex: t, initialXAbsolute: n, initialYAbsolute: r}) => {
    const {originalStaticMarketInfo: a} = Qce();
    return v.jsx(P8, {
        id: Y6.BUBBLEMAP,
        width: eAe,
        height: tAe,
        initialX: n - eAe - 12,
        initialY: r - tAe / 2 + 86,
        onClose: e,
        header: "Bubble chart",
        internalIndex: t,
        resizeParams: nAe,
        noContentPadding: !0,
        children: v.jsx(S, {
            className: "padre-no-scroll",
            height: "100%",
            width: "100%",
            children: v.jsx(QCe, {
                chain: (null == a ? void 0 : a.chain) ?? null,
                contractAddress: (null == a ? void 0 : a.baseToken.address) ?? null
            })
        })
    })
}
))
  , eAe = 300
  , tAe = 320
  , nAe = {
    minWidth: 250,
    minHeight: 250,
    maxHeight: 800,
    maxWidth: 600
}
  , rAe = [Pd.SOLANA, Pd.BASE, Pd.BSC]
  , aAe = ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , n = (null == t ? void 0 : t.chain) ?? null
      , r = bw()
      , {widgetsOrder: a, toggleMostRecentWidget: s} = Lce()
      , [o,l] = y.useState({
        x: 0,
        y: 0
    })
      , [i,c] = dx("padreV2-tradingFloatingWidgetOpen", !1)
      , d = y.useCallback(( () => {
        c(!1)
    }
    ), [c])
      , u = y.useCallback((e => {
        l(e),
        i || s(Y6.TRADING_WIDGET),
        c((e => !e))
    }
    ), [i, c, s])
      , [p,h] = dx("padreV2-tradingFloatingWidgetPanelOpen", !1)
      , m = y.useCallback(( () => {
        h((e => !e))
    }
    ), [h])
      , [g,x] = Mx("padreV2-tradingFloatingWidgetSide", !1)
      , b = y.useCallback(( () => {
        h(!g),
        x(!g)
    }
    ), [g, x, h])
      , [f,S] = y.useState({
        x: 0,
        y: 0
    })
      , [k,C] = dx("padreV2-bubblemapFloatingWidgetOpen", !1)
      , A = y.useCallback(( () => {
        C(!1)
    }
    ), [C])
      , w = y.useCallback((e => {
        S(e),
        i || s(Y6.BUBBLEMAP),
        C((e => !e))
    }
    ), [i, C, s])
      , j = y.useMemo(( () => ({
        isTradingWidgetOpen: i,
        toggleTradingWidget: u,
        isBubblemapWidgetOpen: k,
        toggleBubblemapWidget: w,
        isInSidePanelMode: g,
        toggleIsInSidePanelMode: b,
        isSidePanelOpen: p,
        toggleSidePanelOpen: m
    })), [k, i, w, u, g, b, p, m]);
    return v.jsxs(ISe.Provider, {
        value: j,
        children: [e, i && n && rAe.includes(n) && v.jsx($Ce, {
            closeTradingWidget: d,
            internalIndex: a[Y6.TRADING_WIDGET] ?? 0,
            initialXAbsolute: o.x,
            initialYAbsolute: o.y,
            isSidePanelOpen: g && p
        }), r && k && v.jsx(JCe, {
            closeBubblemapWidget: A,
            internalIndex: a[Y6.BUBBLEMAP] ?? 0,
            initialXAbsolute: f.x,
            initialYAbsolute: f.y
        })]
    })
}
;
var sAe = (e => (e.OPEN = "Open",
e.HISTORY = "History",
e.TRADES = "Trades",
e.POSITIONS = "Positions",
e.LIQUIDITY = "Liquidity",
e.HOLDERS = "Holders",
e.SNIPES = "Snipes",
e.TOP_TRADERS = "TopTraders",
e.DEV_TOKENS = "DevTokens",
e))(sAe || {})
  , oAe = (e => (e.ORDERS = "Orders",
e.TRADES = "Trades",
e.EVENTS = "Events",
e.POSITIONS = "Positions",
e.LIQUIDITY_PROVIDERS = "Liquidity Providers",
e.HOLDERS = "Holders",
e.TOP_TRADERS = "Top Traders",
e.DEV_TOKENS = "Dev Tokens",
e))(oAe || {})
  , lAe = (e => (e.USD = "usd",
e.QUOTE = "quote",
e))(lAe || {})
  , iAe = (e => (e.OPEN = "OPEN",
e.HISTORY = "HISTORY",
e))(iAe || {});
const cAe = y.memo(( ({orderData: e, ...t}) => {
    const n = bw();
    return e && e.specificType ? v.jsx(kQ, {
        ...t,
        typographyOverrides: {
            color: "text.value",
            variant: "paragraph2"
        },
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...t.sxProps || {}
        },
        children: v.jsxs(S, {
            gap: .25,
            direction: "row",
            justifyContent: "flex-end",
            children: [v.jsx(k, {
                color: "inherit",
                variant: "inherit",
                children: Ic(e.specificType, !0)
            }), e.isCopyTrade && !n && v.jsx(k, {
                color: "inherit",
                variant: "inherit",
                children: "Copy"
            })]
        })
    }) : v.jsx(CQ, {})
}
))
  , dAe = y.memo(( ({orderData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        justifyContent: "flex-end",
        ...t.sxProps
    },
    children: v.jsx(GB, {
        type: e.type,
        orderStatus: e.status,
        iconSize: uAe,
        labelTypographyOverrides: {
            variant: "paragraph2"
        },
        isShort: !0
    })
}) : v.jsx(CQ, {})))
  , uAe = 14
  , pAe = e => {
    switch (e) {
    case xc.BUY:
        return "success.main";
    case xc.SELL:
        return "error.main"
    }
}
  , hAe = y.memo(( ({orderData: e, omitSymbol: t=!1, useSideColor: n=!1, ...r}) => e ? v.jsx(kQ, {
    typographyOverrides: {
        textAlign: "right",
        color: n ? pAe(e.side) : "text.value"
    },
    ...r,
    sxProps: {
        alignItems: "center",
        justifyContent: "flex-end",
        ...r.sxProps || {}
    },
    children: (null == e ? void 0 : e.baseAmountDecimalized) ? `${e.side === xc.BUY && e.status !== sc.FILLED ? "~" : " "}${OI((null == e ? void 0 : e.baseAmountDecimalized) ?? 0, {
        precision: 3,
        collapseExponent: !0,
        symbol: t ? "" : e.baseSymbol ? `${iu(e.baseSymbol, 6)} ` : ""
    })}` : Ud
}) : v.jsx(CQ, {})))
  , mAe = e => !!e && !(!e.automationId || !e.automationId.includes("post-success-hook"))
  , gAe = [sc.WAITING, sc.EXECUTING]
  , xAe = [sc.EXECUTION_FAILED, sc.FILLED, sc.CANCELED]
  , bAe = (e, t, n) => {
    if (null === n)
        return null;
    const r = ( (e, t) => e.currentStateData.status === sc.FILLED ? t === bc.BASE ? e.currentStateData.fillDetails.baseAmount : e.currentStateData.fillDetails.quoteAmount : e.def.type !== rc.STOP && e.def.type !== rc.TRAILING_STOP || e.def.tradeParams.quantity.unit !== t || !fc(e.def.tradeParams.quantity.value) ? null : e.def.tradeParams.quantity.value)(e, t);
    return r ? new sB({
        decimals: n
    },BigInt(r)) : null
}
  , fAe = (e, t, n, r, a) => {
    const s = ( (e, t) => e.filter((e => {
        const {status: n} = e.currentStateData;
        return !(t !== iAe.OPEN || !gAe.includes(n)) || !(t !== iAe.HISTORY || !xAe.includes(n))
    }
    )))(e, n);
    return s.map((e => {
        const {chain: n, type: s, orderId: o, tradeParams: l, creationTime: i, orderListId: c} = e.def
          , d = e.currentStateData.lastUpdateTs
          , {side: u, quantity: p, pair: h} = l
          , m = h.baseCurrency
          , g = h.quoteCurrency
          , x = t.find((e => e.tokenAddress === m && e.chain === n))
          , b = t.find((e => e.tokenAddress === g && e.chain === n))
          , f = e.def.type === rc.STOP && "usd" === e.def.priceCondition.price.type ? Number(e.def.priceCondition.price.value) : null
          , v = bAe(e, bc.BASE, (null == x ? void 0 : x.decimals) ?? null)
          , S = v ? v.toNumber() : null
          , y = bAe(e, bc.QUOTE, (null == b ? void 0 : b.decimals) ?? null)
          , k = y ? y.toNumber() : null
          , C = e.currentStateData.status === sc.FILLED ? Number(e.currentStateData.fillDetails.executionPriceInUsd) : null
          , A = e.def.type === rc.TRAILING_STOP ? Number(e.def.trailingDelta.pctValue) : null
          , w = C && S ? S * Number(C) : null
          , j = Cc(s, u, e.def.type === rc.STOP ? e.def.priceCondition.direction : null);
        return {
            chain: n,
            protocolType: r,
            createDate: i,
            type: s,
            side: u,
            walletAddress: e.def.walletAddress,
            status: e.currentStateData.status,
            baseSymbol: (null == x ? void 0 : x.symbol) || null,
            baseAddress: m,
            baseDecimals: (null == x ? void 0 : x.decimals) ?? null,
            baseName: (null == x ? void 0 : x.name) || null,
            quoteSymbol: (null == b ? void 0 : b.symbol) || null,
            quoteAddress: g,
            quoteDecimals: (null == b ? void 0 : b.decimals) ?? null,
            quantity: p,
            orderId: o,
            orderListId: c,
            percentagePriceChange: null,
            baseAmountDecimalized: S,
            quoteAmountDecimalized: k,
            quoteInUsd: w,
            triggerPriceInUsd: f,
            executionPriceInUsd: C,
            displayedPriceInUsd: null,
            specificType: j,
            trailingDeltaPct: A,
            isCopyTrade: (T = e.def.attribution,
            !!T && !(!T.automationId || !T.automationId.includes("copy-trading"))),
            isPostSuccesHookOrder: mAe(e.def.attribution),
            isBulkSelected: a.has(o),
            lastUpdateTs: d
        };
        var T
    }
    ))
}
  , vAe = (e, t) => e && null !== t ? e.maxPriceInUsd * (1 - t / 100) : null
  , SAe = y.memo(( ({orderData: e, useSideColor: t=!1, ...n}) => {
    const r = Lde((t => {
        var n;
        return null == (n = t.wrapped) ? void 0 : n.lookup.get((null == e ? void 0 : e.orderId) ?? "")
    }
    ), ze)
      , a = (null == e ? void 0 : e.status) === sc.FILLED ? e.executionPriceInUsd : (null == e ? void 0 : e.type) === rc.TRAILING_STOP ? vAe(r, e.trailingDeltaPct) : (null == e ? void 0 : e.type) === rc.STOP ? null == e ? void 0 : e.triggerPriceInUsd : (null == e ? void 0 : e.type) === rc.MARKET ? e.displayedPriceInUsd : null;
    return e ? v.jsx(kQ, {
        typographyOverrides: {
            textAlign: "right",
            color: t ? pAe(e.side) : "text.value"
        },
        ...n,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...n.sxProps || {}
        },
        children: a ? `${LI(a ?? 0, {
            symbol: "$",
            padSymbol: !1,
            symbolPosition: yI.START
        })}` : (null == e ? void 0 : e.type) === rc.MARKET ? yAe : Ud
    }) : v.jsx(CQ, {})
}
))
  , yAe = "market"
  , kAe = y.memo(( ({orderData: e, skipSymbol: t, showNative: n=!1, useSideColor: r=!1, ...a}) => {
    const s = y.useMemo(( () => {
        if (!e)
            return Ud;
        if ((null == e ? void 0 : e.status) === sc.FILLED || e.type === rc.MARKET)
            return (null == e ? void 0 : e.quoteInUsd) ? `${n ? OI(e.quoteAmountDecimalized ?? 0, {
                precision: 3,
                symbol: t ? "" : e.quoteSymbol || "",
                padSymbol: !0
            }) : OI(e.quoteInUsd ?? 0, {
                precision: 2,
                symbol: t ? "" : "$"
            })}` : Ud;
        if (e.type === rc.STOP || e.type === rc.TRAILING_STOP)
            return null === e.quoteAmountDecimalized ? null === e.quantity || fc(e.quantity.value) ? Ud : jI(isNaN(Number(e.quantity.value.pctValue)) ? 0 : Number(e.quantity.value.pctValue), {
                omitSign: !0
            }) : `${e.side === xc.SELL ? "~" : ""}${OI(e.quoteAmountDecimalized ?? 0, {
                precision: 3,
                symbol: e.quoteSymbol || "",
                padSymbol: !0
            })}`;
        if (e.type === rc.DEV_SOLD) {
            if (!e.quantity)
                return Ud;
            if (e.side === xc.BUY) {
                if (!e.quoteDecimals)
                    return Ud;
                const t = Number(e.quantity.value);
                return isNaN(t) ? Ud : LI(t / 10 ** e.quoteDecimals, {
                    collapseExponent: !0,
                    symbol: e.quoteSymbol ?? "",
                    desiredDigits: 3,
                    noTrailingZeros: !0,
                    symbolPosition: yI.START
                })
            }
            {
                if (!e.baseDecimals)
                    return Ud;
                const t = Number(e.quantity.value);
                return isNaN(t) ? Ud : LI(t / 10 ** e.baseDecimals, {
                    collapseExponent: !0,
                    symbol: iu(e.baseSymbol ?? ""),
                    desiredDigits: 3,
                    noTrailingZeros: !0,
                    symbolPosition: yI.END
                })
            }
        }
        return Ud
    }
    ), [e, n, t]);
    return e ? v.jsx(kQ, {
        typographyOverrides: {
            textAlign: "right",
            color: r ? pAe(e.side) : "text.value"
        },
        ...a,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...a.sxProps || {}
        },
        children: s
    }) : v.jsx(CQ, {})
}
))
  , CAe = ({orderData: e, ...t}) => e && null !== e.baseSymbol && null !== e.quoteSymbol ? v.jsx(kQ, {
    ...t,
    sxProps: {
        ...t.sxProps,
        alignItems: "center"
    },
    children: v.jsxs(S, {
        direction: "row",
        gap: .5,
        alignItems: "center",
        overflow: "hidden",
        children: [v.jsx(S, {
            height: AAe + 2,
            width: AAe + 2,
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(b_, {
                url: IE(e.chain, e.baseAddress),
                name: e.baseSymbol ?? "",
                padreAvatarUrl: null,
                size: AAe,
                chain: e.chain,
                hideHoverAvatar: !0,
                protocolInfo: null
            })
        }), v.jsx(k, {
            variant: "paragraph2",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            color: "text.value",
            ...Nu,
            children: `${iu(e.baseSymbol, 6)}/${iu(e.quoteSymbol, 6)}`
        })]
    })
}) : v.jsx(CQ, {})
  , AAe = 16
  , wAe = y.createContext({
    isInBulkSelectMode: !1,
    isAllSelected: !1,
    hasAnySelected: !1,
    hasAnyOrder: !1,
    onBulkSelectCheckboxClick: c.noop,
    cancelSelected: async () => {}
})
  , jAe = () => y.useContext(wAe)
  , TAe = y.memo(( ({orderData: e, ...t}) => {
    const {t: n} = we()
      , r = pK()
      , {isInBulkSelectMode: a} = jAe()
      , [s,o] = y.useState(!1)
      , [l,i] = y.useState(!1)
      , c = l_()
      , d = y.useCallback((async t => {
        if (t.preventDefault(),
        (null == e ? void 0 : e.orderId) && (!e.orderListId || !c.cancellingOrderListIds.includes(e.orderListId))) {
            try {
                o(!0),
                e.orderListId && c.registerCancel(e.orderListId);
                if ((await sm.cancelOrder(e.orderId)).success)
                    return r({
                        message: pu.orderCancel,
                        type: "success"
                    }, "order-cancel-success"),
                    void i(!0)
            } catch (fNe) {}
            r({
                message: uu.orderFailedToCancel,
                snackName: pu.cancelFailed,
                type: "error"
            }, "order-cancel-error"),
            o(!1)
        }
    }
    ), [e, c, r]);
    return e ? v.jsx(kQ, {
        ...t,
        sxProps: {
            justifyContent: "flex-end",
            ...t.sxProps || {}
        },
        children: (null == e ? void 0 : e.status) !== sc.WAITING || l ? null : s || e.orderListId && c.cancellingOrderListIds.includes(e.orderListId) ? v.jsx(J, {
            size: 16
        }) : a ? v.jsx(GC, {
            title: e.isBulkSelected ? "Order is selected" : "Order is not selected",
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(UR, {
                    checked: e.isBulkSelected
                })
            })
        }) : v.jsx(GC, {
            title: n("Cancel order"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    variant: "tertiary",
                    onClick: d,
                    disabled: s,
                    sx: {
                        width: IAe,
                        minWidth: IAe,
                        height: IAe,
                        p: 0
                    },
                    children: v.jsx(gy, {})
                })
            })
        })
    }) : v.jsx(CQ, {})
}
))
  , IAe = 20
  , EAe = y.memo(( ({orderData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        ...t.sxProps,
        justifyContent: "flex-end"
    },
    children: v.jsx(H_, {
        tradeSide: e.side
    })
}) : v.jsx(CQ, {})))
  , MAe = () => {
    const {t: e} = we()
      , {isInBulkSelectMode: t, isAllSelected: n, hasAnySelected: r, hasAnyOrder: a, onBulkSelectCheckboxClick: s, cancelSelected: o} = jAe()
      , [l,i] = y.useState(!1)
      , c = y.useCallback((async () => {
        try {
            i(!0),
            await o()
        } catch (fNe) {} finally {
            i(!1)
        }
    }
    ), [o]);
    return v.jsxs(C, {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-end",
        width: "100%",
        sx: {
            gap: .5,
            pr: .5
        },
        children: [a && t && r && v.jsx(GC, {
            title: e("Cancel selected"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    disabled: l,
                    onClick: c,
                    size: "xxsmall",
                    sx: {
                        px: 0,
                        height: NAe,
                        minWidth: NAe,
                        width: NAe
                    },
                    variant: "secondary",
                    color: "error",
                    children: v.jsx(wS, {
                        color: "inherit",
                        size: PAe
                    })
                })
            })
        }), a && v.jsx(UR, {
            disabled: l,
            sx: e => ({
                width: NAe,
                height: NAe,
                "& .MuiSvgIcon-root": {
                    fontSize: 24,
                    fill: t ? n ? void 0 : e.palette.primary.main : e.palette.background.borderActive
                }
            }),
            checked: n && t,
            onChange: s
        })]
    })
}
  , NAe = 20
  , PAe = 14
  , OAe = {
    alignItems: "center"
}
  , LAe = (e, t) => ({
    ...sZ(e),
    minWidth: 90,
    sortingOrder: t ? ["desc", "asc"] : void 0,
    sortable: t,
    headerClass: lY
})
  , RAe = ({key: e, isOpen: t, isPortfolio: r, isShort: a, totalMode: s, toggleTotalMode: o, quoteSymbol: l}) => {
    switch (e) {
    case "createDate":
        return {
            ...LAe(e, t),
            headerName: n.t("Date"),
            cellRenderer: e => {
                var t;
                return v.jsx(wQ, {
                    date: (null == (t = e.data) ? void 0 : t.createDate) || null,
                    ...e,
                    sxProps: OAe
                })
            }
            ,
            lockPosition: "left",
            flex: a ? 1 : 5,
            minWidth: 48,
            maxWidth: a ? 58 : 70,
            headerClass: void 0,
            sort: t ? "desc" : void 0
        };
    case "specificType":
        return {
            ...LAe(e, t),
            headerName: n.t("Type"),
            cellRenderer: e => v.jsx(cAe, {
                orderData: e.data,
                ...e,
                sxProps: OAe
            }),
            minWidth: a && r ? 86 : 100,
            maxWidth: r ? void 0 : 100,
            valueGetter: ({data: e}) => e ? `${e.specificType}-${e.isCopyTrade}` : void 0
        };
    case "side":
        return {
            ...LAe(e, t),
            headerName: n.t("Side"),
            cellRenderer: e => v.jsx(EAe, {
                orderData: e.data,
                ...e,
                sxProps: OAe
            }),
            minWidth: r ? void 0 : 40,
            maxWidth: r ? 100 : 40
        };
    case "baseAddress":
        return {
            ...LAe(e, t),
            headerName: n.t("Pair"),
            cellRenderer: e => v.jsx(CAe, {
                orderData: e.data,
                ...e,
                sxProps: OAe
            }),
            headerClass: void 0,
            minWidth: r && a ? 130 : 100,
            maxWidth: r && a ? 130 : 150,
            pinned: a && r ? "left" : void 0,
            valueGetter: ({data: e}) => e ? `${e.baseAddress}-${e.quoteSymbol}-${e.baseSymbol}-${e.baseName}` : void 0
        };
    case "quoteAmountDecimalized":
        return {
            ...LAe(e, t),
            headerName: r || s === lAe.QUOTE ? `${n.t("Total")} ${l ? ` ${l}` : ""}` : `${n.t("Total")} $`,
            headerComponent: !r && s ? $Q : void 0,
            headerComponentParams: !r && s ? {
                onClick: o,
                nextLabel: s === lAe.QUOTE ? n.t("size in USD") : n.t("size in quote"),
                alignRight: !0,
                grayOut: s !== lAe.USD
            } : void 0,
            cellRenderer: e => v.jsx(kAe, {
                orderData: e.data,
                ...e,
                skipSymbol: !r && s === lAe.QUOTE,
                showNative: r || s === lAe.QUOTE,
                useSideColor: r
            }),
            minWidth: a ? 102 : 90,
            maxWidth: r ? 185 : 102,
            valueGetter: ({data: e}) => {
                var t;
                return e ? `${e.quoteInUsd}-${e.quoteAmountDecimalized}-${e.quoteSymbol}-${null == (t = e.quantity) ? void 0 : t.value.toString()}` : void 0
            }
            ,
            comparator: lZ((e => e.quoteInUsd))
        };
    case "quoteInUsd":
        return {
            ...LAe(e, t),
            headerName: n.t("Total USD"),
            cellRenderer: e => v.jsx(kAe, {
                orderData: e.data,
                ...e,
                showNative: !1,
                useSideColor: r
            }),
            minWidth: 70,
            maxWidth: r ? 185 : 90,
            valueGetter: ({data: e}) => e ? `${e.quoteInUsd}-${e.quoteAmountDecimalized}-${e.quoteSymbol}` : void 0,
            comparator: lZ((e => e.quoteInUsd))
        };
    case "executionPriceInUsd":
        return {
            ...LAe(e, t),
            headerName: n.t("Price"),
            cellRenderer: e => v.jsx(SAe, {
                orderData: e.data,
                ...e,
                useSideColor: r
            }),
            minWidth: 75
        };
    case "baseAmountDecimalized":
        return {
            ...LAe(e, t),
            headerName: n.t("Amount"),
            cellRenderer: e => v.jsx(hAe, {
                orderData: e.data,
                ...e,
                omitSymbol: !0,
                useSideColor: r
            }),
            minWidth: 75,
            sortable: !1,
            valueGetter: ({data: e}) => e ? `${e.baseAmountDecimalized}-${e.baseSymbol}-${e.side}-${e.status}` : void 0
        };
    case "walletAddress":
        return {
            ...LAe(e, t),
            headerName: n.t("Wallet"),
            cellRenderer: e => {
                var t, n;
                return v.jsx(NQ, {
                    chain: (null == (t = e.data) ? void 0 : t.chain) || null,
                    walletAddress: (null == (n = e.data) ? void 0 : n.walletAddress) || null,
                    ...e,
                    sxProps: OAe
                })
            }
            ,
            minWidth: 125,
            flex: 1,
            maxWidth: r ? 220 : void 0,
            headerClass: void 0,
            valueGetter: ({data: e}) => e ? `${e.walletAddress}-${e.chain}` : void 0
        };
    case "lastUpdateTs":
        return {
            ...LAe(e, t),
            headerName: n.t("Updated"),
            headerComponent: qQ,
            headerComponentParams: {
                tooltipTitle: n.t("Last update")
            },
            cellRenderer: e => {
                var t;
                return v.jsx(wQ, {
                    date: (null == (t = e.data) ? void 0 : t.createDate) || null,
                    ...e,
                    sxProps: {
                        ...OAe,
                        justifyContent: "flex-end"
                    }
                })
            }
            ,
            flex: a ? 1 : 5,
            minWidth: 70,
            maxWidth: 70,
            sortingOrder: t ? ["desc", "asc"] : ["desc"],
            sort: t ? void 0 : "desc"
        };
    case "status":
        return {
            ...LAe(e, t),
            headerName: n.t("Status"),
            cellRenderer: e => v.jsx(dAe, {
                orderData: e.data,
                ...e,
                sxProps: OAe
            }),
            minWidth: 82,
            maxWidth: 82
        };
    case "orderId":
        return {
            ...LAe(e, t),
            headerName: "",
            sortable: !1,
            headerComponent: r ? MAe : void 0,
            cellRenderer: e => v.jsx(TAe, {
                orderData: e.data,
                ...e,
                sxProps: OAe
            }),
            minWidth: r ? 70 : 40,
            flex: -1,
            maxWidth: r ? 80 : 50,
            valueGetter: ({data: e}) => e ? `${e.orderId}-${e.orderListId}-${e.isBulkSelected}` : void 0
        };
    default:
        return {}
    }
}
  , DAe = [RAe({
    key: "createDate",
    isShort: !0,
    isOpen: !0
}), RAe({
    key: "baseAddress",
    isOpen: !0
}), RAe({
    key: "side",
    isOpen: !0
}), RAe({
    key: "specificType",
    isOpen: !0
}), RAe({
    key: "baseAmountDecimalized",
    isShort: !0,
    isOpen: !0
}), RAe({
    key: "quoteInUsd",
    isOpen: !0
}), RAe({
    key: "executionPriceInUsd",
    isOpen: !0
}), RAe({
    key: "lastUpdateTs",
    isOpen: !0
}), RAe({
    key: "status",
    isOpen: !0
})]
  , BAe = [RAe({
    key: "createDate",
    isShort: !0,
    isOpen: !1
}), RAe({
    key: "baseAddress",
    isOpen: !1
}), RAe({
    key: "side",
    isOpen: !1
}), RAe({
    key: "specificType",
    isOpen: !1
}), RAe({
    key: "baseAmountDecimalized",
    isShort: !0,
    isOpen: !1
}), RAe({
    key: "quoteInUsd",
    isOpen: !1
}), RAe({
    key: "executionPriceInUsd",
    isOpen: !1
}), RAe({
    key: "lastUpdateTs",
    isOpen: !1
}), RAe({
    key: "status",
    isOpen: !1
})]
  , _Ae = (e, t, n, r) => [RAe({
    key: "createDate",
    isOpen: n
}), RAe({
    key: "walletAddress",
    isOpen: n
}), RAe({
    key: "baseAddress",
    isOpen: n
}), RAe({
    key: "specificType",
    isOpen: n
}), RAe({
    key: "side",
    isOpen: n
}), RAe({
    key: "executionPriceInUsd",
    isOpen: n
}), RAe({
    key: "baseAmountDecimalized",
    isOpen: n
}), RAe({
    key: "quoteAmountDecimalized",
    totalMode: e,
    toggleTotalMode: t,
    quoteSymbol: r,
    isOpen: n
}), RAe({
    key: "lastUpdateTs",
    isOpen: n
}), RAe({
    key: "status",
    isOpen: n
}), RAe({
    key: "orderId",
    isOpen: n
})]
  , UAe = (e, t) => [...t ? [] : [RAe({
    key: "createDate",
    isOpen: e
}), RAe({
    key: "walletAddress",
    isPortfolio: !0,
    isOpen: e
})], RAe({
    key: "baseAddress",
    isPortfolio: !0,
    isShort: t,
    isOpen: e
}), RAe({
    key: "side",
    isPortfolio: !0,
    isShort: t,
    isOpen: e
}), ...e ? [RAe({
    key: "specificType",
    isPortfolio: !0,
    isShort: t,
    isOpen: e
})] : [], RAe({
    key: "executionPriceInUsd",
    isPortfolio: !0,
    isOpen: e
}), ...e ? [] : [RAe({
    key: "baseAmountDecimalized",
    isPortfolio: !0,
    isShort: t,
    isOpen: e
})], RAe({
    key: "quoteAmountDecimalized",
    isPortfolio: !0,
    isShort: t,
    isOpen: e
}), ...e ? [] : [RAe({
    key: "quoteInUsd",
    isPortfolio: !0,
    isOpen: e
})], ...t ? [RAe({
    key: "createDate",
    isOpen: e
})] : [], ...e ? [RAe({
    key: "lastUpdateTs",
    isOpen: e
})] : [], ...e ? [RAe({
    key: "orderId",
    isPortfolio: !0,
    isOpen: e
})] : []]
  , WAe = (e, t=4) => {
    var n, r;
    const a = "number" == typeof e ? e.toFixed(20) : Number(e).toFixed(20)
      , [s,o] = a.split(".")
      , l = (null == (r = null == (n = (o ?? "").match(/^0*/)) ? void 0 : n[0]) ? void 0 : r.length) || 0
      , i = "0" === s;
    return /^0*$/.test(s) && /^0*$/.test(o) ? 1 : i ? l + t : t - Math.min(i ? 0 : s.length, t)
}
  , FAe = y.createContext({
    setNewOrderData: O,
    subscribeLineChange: O,
    unsubscribeLineChange: O,
    setChartData: O,
    stopOrderLines: {}
})
  , VAe = y.memo(( ({children: e}) => {
    const t = D()
      , n = t.palette.success.main
      , r = t.palette.error.main
      , a = t.palette.background.buttonDefault
      , s = t.palette.text.value
      , l = y.useMemo(( () => Me(t.palette.blue[500], .25)), [t.palette.blue])
      , i = t.palette.text.label
      , c = y.useRef(null)
      , d = pK()
      , u = bw()
      , [p,h] = y.useState({
        isChartReady: !1,
        chartApi: null
    })
      , m = y.useRef(null)
      , g = y.useRef(!1)
      , x = y.useRef({})
      , {originalStaticMarketInfo: b} = Qce()
      , {selectedWalletsAddresses: f, compatibleWallets: S} = Gde()
      , {openOrders: k} = _de()
      , C = y.useRef({})
      , A = l_();
    y.useEffect(( () => {
        p.isChartReady || (x.current = {})
    }
    ), [p]);
    const w = Lde((e => {
        var t;
        return null == (t = e.wrapped) ? void 0 : t.lookup
    }
    ), ze);
    (e => {
        const t = Lde((e => e.addCallback), ze)
          , n = Lde((e => e.removeCallback), ze);
        y.useEffect(( () => (t(e),
        () => {
            n(e)
        }
        )), [t, n, e])
    }
    )(y.useCallback((e => {
        var t;
        const n = x.current[e.orderId]
          , r = null == (t = null == k ? void 0 : k.wrapper) ? void 0 : t.lookup.get(e.orderId);
        if (n && r && r.def.type === rc.TRAILING_STOP) {
            const t = vAe(e, Number(r.def.trailingDelta.pctValue));
            t && n.setPrice(t)
        }
    }
    ), [x, k]));
    const j = y.useCallback(( (e, t) => {
        C.current[e] || t && A.cancellingOrderListIds.includes(t) || (C.current = {
            ...C.current,
            [e]: !0
        },
        t && A.registerCancel(t),
        sm.cancelOrder(e).then((t => {
            const n = {
                message: pu.orderCancel,
                type: "success"
            };
            if (t.success) {
                const t = x.current[e];
                t && (t.remove(),
                delete x.current[e])
            } else
                n.message = uu.orderFailedToCancel,
                n.snackName = pu.cancelFailed,
                n.type = "error";
            d(n, "padre-candles-order-cancel")
        }
        )).catch((e => {
            d({
                message: uu.unknownError,
                snackName: pu.unknownError,
                type: "error"
            }, "padre-candles-order-cancel")
        }
        )).finally(( () => {
            delete C.current[e]
        }
        )))
    }
    ), [d, A])
      , T = y.useCallback((e => {
        m.current = e
    }
    ), [])
      , I = y.useCallback(( () => {
        m.current = null
    }
    ), [])
      , E = y.useCallback((e => {
        h((t => ({
            ...t,
            ...e
        })))
    }
    ), [h])
      , M = y.useCallback(( (e, t, n, r) => null === t ? e.setTooltip("") : n === xc.SELL && t > 100 ? e.setTooltip("Order amount exceeds wallet balance - will fail if triggered") : r ? e.setTooltip(`Order fill has been attempted ${r} time${1 === r ? "" : "s"}.`) : e.setTooltip("")), [])
      , N = y.useCallback(( (e, t, n) => {
        var r;
        const {specificType: a, quantity: s, unit: o, walletAddress: l} = e
          , i = jc(a) === xc.BUY
          , {baseToken: c, quoteToken: d} = t
          , u = o === bc.BASE ? c : d
          , {decimals: p} = u;
        if (n && 1 !== f.length)
            return null;
        const h = l ?? (f.length ? f[0] : null)
          , m = (null == (r = null == S ? void 0 : S.find((e => ng(e.wallet.publicAddress) === ng(h || "")))) ? void 0 : r.balances[(e => {
            switch (e) {
            case bc.BASE:
                return "base";
            case bc.QUOTE:
                return "quoteForExecution"
            }
        }
        )(o)].rawAmount) ?? null;
        if (!(h && null !== m || i))
            return;
        const g = new sB({
            decimals: p
        },BigInt(m ?? 0)).toNumber()
          , x = $Ae(s, p, n);
        if (0 === g)
            return 1e3;
        const b = Number(x) / g * 100;
        return Math.abs(b - 100) < .01 ? 100 : b
    }
    ), [S, f])
      , P = y.useCallback(( (e, t, c, d) => {
        const {orderId: u, specificType: p, value: h, quantity: x, unit: b, orderListId: f} = c
          , v = c.specificType === ic.TRAILING_STOP_LOSS ? vAe(null == w ? void 0 : w.get(u), c.trailingDeltaPct) : null
          , S = jc(p)
          , {baseToken: y, quoteToken: k} = t
          , C = u === HAe
          , A = S === xc.BUY
          , T = C ? `${i}${sg}` : A ? `${n}${sg}` : `${r}${sg}`
          , I = b === bc.BASE ? y : k
          , {decimals: E, symbol: P} = I
          , O = $Ae(x, E, C)
          , L = N(c, t, u === HAe);
        if (void 0 === L)
            return null;
        let R = null;
        const D = p === ic.TRAILING_STOP_LOSS ? v ?? 0 : Number(h);
        try {
            return R = (d ?? e.createOrderLine()).setText("").setQuantity("").setText(qAe(p, P, O, L, C ? null : c.failedAttemptsCount, !fc(x))).setLineColor(T).setLineStyle(1).setPrice(isNaN(D) ? 0 : D).setEditable(!0).setBodyTextColor("#000000").setBodyBackgroundColor(C ? i : l).setBodyBorderColor(C ? i : l).setCancelButtonBorderColor(l),
            C || R.setCancellable(!0).setCancelButtonBackgroundColor(a).setCancelButtonIconColor(s).onCancel(( () => {
                j(u, f)
            }
            )),
            C && R.setText(` ${R.getText()}`).onMove(( () => {
                var e;
                try {
                    if (R) {
                        const t = R.getPrice()
                          , n = Math.max(2, WAe(t))
                          , r = Number(t.toFixed(n));
                        null == (e = m.current) || e.call(m, r),
                        R.setPrice(r)
                    }
                } catch (fNe) {}
                g.current = !1
            }
            )).onMoving(( () => {
                var e;
                try {
                    if (R) {
                        const t = R.getPrice()
                          , n = Math.max(2, WAe(t))
                          , r = Number(t.toFixed(n));
                        null == (e = m.current) || e.call(m, r),
                        R.setPrice(r)
                    }
                } catch (fNe) {}
                g.current = !0
            }
            )),
            M(R, L, S, C ? null : c.failedAttemptsCount)
        } catch (fNe) {
            o(fNe);
            try {
                d || null == R || R.remove()
            } catch (W$e) {
                o(W$e)
            }
            return null
        }
    }
    ), [w, M, N, j, n, a, s, i, l, r])
      , O = y.useCallback((e => {
        var t;
        if (!b)
            return;
        const n = [];
        null == (t = null == k ? void 0 : k.wrapper) || t.lookup.forEach((e => {
            zAe(e) && n.push(e)
        }
        )),
        c.current && n.push(c.current);
        const r = n.map(GAe).filter(YAe)
          , a = new Set(r.map((e => e.orderId)))
          , s = {
            ...x.current
        };
        Object.keys(s).forEach((e => {
            const t = s[e];
            if (!a.has(e))
                try {
                    t.remove()
                } catch (fNe) {
                    o(fNe)
                } finally {
                    delete s[e]
                }
        }
        )),
        r.forEach((t => {
            const {orderId: n} = t;
            if (n === HAe && !u)
                return;
            const r = P(e, b, t, s[n]);
            r && (s[n] = r)
        }
        )),
        x.current = s
    }
    ), [P, u, b, k])
      , L = y.useCallback((e => {
        Ac(e.specificType) !== rc.STOP ? c.current = null : c.current = e,
        p.isChartReady && p.chartApi ? O(p.chartApi) : x.current = x.current ?? {}
    }
    ), [p.chartApi, p.isChartReady, O]);
    y.useEffect(( () => {
        p.isChartReady && p.chartApi ? O(p.chartApi) : x.current = x.current ?? {}
    }
    ), [p.chartApi, p.isChartReady, O]);
    const R = y.useMemo(( () => ({
        setNewOrderData: L,
        stopOrderLines: x.current,
        subscribeLineChange: T,
        unsubscribeLineChange: I,
        setChartData: E
    })), [L, T, I, E]);
    return v.jsx(FAe.Provider, {
        value: R,
        children: e
    })
}
))
  , HAe = "NEW_ORDER"
  , zAe = e => [rc.STOP, rc.TRAILING_STOP].includes(e.def.type) && ("WAITING" === e.currentStateData.status || "EXECUTING" === e.currentStateData.status)
  , $Ae = (e, t, n) => n ? fc(e) ? e ?? "0" : e.pctValue ?? "0" : fc(e) ? new sB({
    decimals: t
},BigInt(e ?? "0")).toNumber() : e.pctValue ?? "0"
  , GAe = e => {
    var t;
    if ("def"in e) {
        if (e.def.type === rc.TRAILING_STOP)
            return {
                orderId: e.def.orderId,
                specificType: ic.TRAILING_STOP_LOSS,
                unit: e.def.tradeParams.quantity.unit,
                quantity: "" === e.def.tradeParams.quantity.value ? "0" : e.def.tradeParams.quantity.value,
                value: "0",
                walletAddress: e.def.walletAddress,
                orderListId: e.def.orderListId || null,
                trailingDeltaPct: (null == (t = e.def.trailingDelta) ? void 0 : t.pctValue) ? Number(e.def.trailingDelta.pctValue) : null,
                failedAttemptsCount: e.currentStateData.failedExecutionAttempts.length
            };
        {
            const t = Cc(e.def.type, e.def.tradeParams.side, e.def.priceCondition.direction);
            return t ? {
                orderId: e.def.orderId,
                specificType: t,
                unit: e.def.tradeParams.quantity.unit,
                quantity: "" === e.def.tradeParams.quantity.value ? "0" : e.def.tradeParams.quantity.value,
                value: e.def.priceCondition.price.value,
                walletAddress: e.def.walletAddress,
                orderListId: e.def.orderListId || null,
                trailingDeltaPct: null,
                failedAttemptsCount: Ac(t) === rc.STOP ? e.currentStateData.failedExecutionAttempts.length : null
            } : null
        }
    }
    return {
        orderId: HAe,
        specificType: e.specificType,
        unit: Tc(e.specificType),
        quantity: e.quantityInputMode === nB.PERCENTAGE ? {
            type: "pct",
            pctValue: "" === e.quantityPercentageValue ? "0" : e.quantityPercentageValue
        } : "" === e.quantityValue ? "0" : e.quantityValue,
        value: e.triggerPrice ?? "0",
        walletAddress: null,
        orderListId: null,
        trailingDeltaPct: null,
        failedAttemptsCount: Ac(e.specificType) === rc.STOP ? 0 : null
    }
}
  , qAe = (e, t, n, r, a, s) => {
    var o;
    const l = KAe(e)
      , i = jc(e) === xc.BUY
      , c = l ? `${l} | ` : ""
      , d = a ? `${a} | ` : ""
      , u = Number(n)
      , p = u < .01 ? void 0 : Math.min((null == (o = u.toString().split(".")[1]) ? void 0 : o.length) ?? 2, 4)
      , h = i ? n : r;
    if (null === h)
        return "Multi";
    if (!i && null !== r && r > 100 && !s)
        return `${c}>100% (!)`;
    return `${d}${c}${`${s && !i ? jI(u, {
        omitSign: !0,
        precision: 0
    }) : `${LI(n, {
        symbol: i ? t : "",
        collapseExponent: !0,
        maxPrecision: p
    })}${i ? "" : `  (${LI(h, {
        collapseExponent: !0,
        symbol: "%",
        padSymbol: !1,
        minPrecision: 0,
        maxPrecision: 0
    })})`}`}`}`
}
  , KAe = e => {
    switch (e) {
    case ic.BUY_DIP:
        return "BD";
    case ic.TAKE_PROFIT:
        return "TP";
    case ic.STOP_LOSS:
        return "SL";
    case ic.TRAILING_STOP_LOSS:
        return "TSL";
    default:
        return null
    }
}
  , YAe = e => null !== e;
var XAe = (e => (e.MARKET_ACTIVITY = "MARKET_ACTIVITY",
e.PANEL = "PANEL",
e))(XAe || {});
const QAe = () => {
    const e = Sde()
      , t = Ive()
      , n = y.useMemo(( () => Math.max(e ?? 0, t)), [e, t])
      , [r,a] = y.useState(( () => n >= ZAe));
    return y.useEffect(( () => {
        r ? n < ZAe - JAe && a(!1) : n >= ZAe && a(!0)
    }
    ), [n, r]),
    r
}
  , ZAe = 50
  , JAe = 5
  , ewe = ["7rtiKSUDLBm59b1SBmD9oajcP8xE64vAGSMbAN5CXy1q"]
  , twe = e => ewe.includes(e);
var nwe = (e => (e.MARKET = "Market",
e.MY = "My",
e.GROUP = "Group",
e))(nwe || {})
  , rwe = (e => (e.MARKET_CAP = "MARKET_CAP",
e.USD = "USD",
e.QUOTE = "QUOTE",
e))(rwe || {});
const awe = {
    tipInNativeUi: "Tip & Prio",
    side: "Side",
    priceInUsd: "Price/MCap",
    amountBase: "Amount",
    amountInUsd: "Total USD",
    amountInNative: "Total Native"
}
  , swe = ["tipInNativeUi", "side", "priceInUsd", "amountBase", "amountInUsd", "amountInNative"]
  , owe = []
  , lwe = ["timestamp", "tipInNativeUi", "side", "priceInUsd", "amountBase", "amountInUsd", "amountInNative", "maker", "txnHash"]
  , iwe = ["amountInUsd", "priceInUsd", "maker", "timestamp"]
  , cwe = ["timestamp", "priceInUsd", "amountBase", "amountInUsd", "maker"]
  , dwe = rwe.USD
  , uwe = new Set([rwe.USD, rwe.QUOTE])
  , pwe = "trades-content-class"
  , hwe = "makerTradingApp"
  , mwe = "makerCount"
  , gwe = "makerExplorer"
  , xwe = {
    [hwe]: !0,
    [mwe]: !1,
    [gwe]: !1
}
  , bwe = {
    maker: [{
        flagKey: gwe,
        label: n.t("Show explorer icon")
    }, {
        flagKey: mwe,
        label: n.t("Show maker count")
    }, {
        flagKey: hwe,
        label: n.t("Show trading app")
    }]
}
  , fwe = ["maker"]
  , vwe = (e, t, n, r, a, s, o, l, i, d, u, p, h, m) => {
    const g = c.reduce(o, ( (e, t) => (e[ng(t.publicAddress)] = t.walletName,
    e)), {})
      , x = qj(p)
      , b = e.map((e => {
        const t = ng(e.maker)
          , n = Kj(x, t);
        return {
            ...e,
            chain: r,
            quoteSymbol: a,
            isUserTxn: void 0 !== g[t],
            walletName: g[t] || (null == l ? void 0 : l.get(t)) || null,
            isCopyTrade: !1,
            isPostSuccesHookOrder: !1,
            isDeployer: !!i && (t === i && !twe(i)),
            isPool: u.has(t),
            isToken: t === d,
            isMayhem: _1.has(t),
            amountBase: kwe(e.amountInQuote, e.priceInQuote),
            groups: n,
            customWalletName: h[t] ?? null,
            customWalletEmoji: m[t] ?? null,
            baseSymbol: s
        }
    }
    ));
    return c.uniqBy(b.filter((e => t ? t.includes(ng(e.maker)) : !n || !!e.groups.length)), (e => Swe(e)))
}
  , Swe = e => `${e.txnHash}-${e.tradeIndex}-${e.priceInUsd}-${e.maker}`
  , ywe = e => {
    const t = [];
    for (let n = e.amountInQuote.length - 1; n >= 0; n--) {
        const r = {
            priceInUsd: e.priceInUsd[n],
            amountInUsd: e.amountInUsd[n],
            priceInQuote: e.priceInQuote[n],
            amountInQuote: e.amountInQuote[n],
            tipInNativeUi: e.tipInNativeUi[n],
            prioInNativeUi: e.prioInNativeUi[n],
            prioSurchargeInNativeUi: e.prioSurchargeInNativeUi[n],
            tradeIndex: e.tradeIndex[n],
            timestamp: e.timestamp[n],
            maker: e.maker[n],
            side: e.side[n],
            txnHash: e.txnHash[n],
            blockNumber: e.blockNumber[n],
            tradingApp: e.tradingApp[n],
            np: null,
            processedAtMs: null,
            priceInNative: e.priceInNative[n],
            amountInNative: e.amountInNative[n],
            hardProtocolFeeInNativeUi: 0,
            softProtocolFeeInNativeUi: 0
        }
          , a = e.markers[n];
        null !== a && (r.markers = a),
        t.push(r)
    }
    return t
}
  , kwe = (e, t) => e && t && "0" !== t ? Number(ce(e).div(ce(t)).toString()) : null
  , Cwe = (e, t, n) => t ? iwe : (e ? cwe : lwe).filter(n)
  , Awe = y.createContext({
    isLive: !0,
    isLoading: !0,
    trades: [],
    setHover: c.noop,
    minimumUsdValue: null,
    setMinimumUsdValue: c.noop,
    timeFilter: null,
    setTimeFilter: c.noop,
    tradesProxy: {
        originalMarketId: null,
        newCallbacks: new Set,
        smartFeedCallbacks: new Set,
        trades: null
    },
    showOldest: !1,
    toggleShowOldest: c.noop,
    pauseOnHover: !0,
    setPauseOnHover: c.noop,
    tooltipOpen: !1,
    onTooltipOpen: c.noop,
    onTooltipClose: c.noop
});
Awe.displayName = "TradesContext";
const wwe = y.createContext({
    focusedTraders: null,
    areTrackedGroupsFocused: !1,
    focusedWalletGroupAddresses: null,
    focusedWalletGroupAddressesLoading: !0,
    focusTraders: c.noop,
    focusTrackedGroups: c.noop,
    panelFocusedTraders: null,
    panelAreTrackedGroupsFocused: !1,
    panelFocusedWalletGroupAddresses: null,
    panelFocusedWalletGroupAddressesLoading: !0,
    panelFocusTraders: c.noop,
    panelFocusTrackedGroups: c.noop,
    setTradesLocation: c.noop,
    tradesLocation: XAe.MARKET_ACTIVITY,
    allTrackedGroupIds: null
});
wwe.displayName = "FocusedTradersContext";
const jwe = () => y.useContext(wwe)
  , Twe = 60
  , Iwe = e => {
    const t = e.timestamp.map(( (e, t) => t)).sort(( (t, n) => {
        return r = e.timestamp[t],
        a = e.timestamp[n],
        s = e.tradeIndex[t],
        o = e.tradeIndex[n],
        r !== a || "number" != typeof s || "number" != typeof o ? r - a : s - o;
        var r, a, s, o
    }
    ))
      , n = {
        txnHash: [],
        blockNumber: [],
        tradeIndex: [],
        maker: [],
        timestamp: [],
        priceInUsd: [],
        amountInUsd: [],
        priceInQuote: [],
        amountInQuote: [],
        tipInNativeUi: [],
        prioInNativeUi: [],
        prioSurchargeInNativeUi: [],
        side: [],
        markers: [],
        tradingApp: [],
        priceInNative: [],
        amountInNative: []
    };
    return Object.keys(e).forEach((r => {
        var a;
        n[r] = (a = t.map((t => e[r][t]))).length > 120 ? a.slice(-60) : a
    }
    )),
    n
}
  , Ewe = e => e.reduce(( (e, t) => (e.txnHash.push(t[qp]),
e.blockNumber.push(t[Kp]),
e.tradeIndex.push(t[Yp]),
e.maker.push(t[Xp]),
e.timestamp.push(t[Qp]),
e.priceInUsd.push(String(t[Zp])),
e.amountInUsd.push(String(t[Jp])),
e.priceInNative.push(t[ih]),
e.amountInNative.push(t[ch]),
e.priceInQuote.push(String(t[eh])),
e.amountInQuote.push(String(t[th])),
e.tipInNativeUi.push(t[nh] ?? 0),
e.prioInNativeUi.push(t[rh] ?? 0),
e.prioSurchargeInNativeUi.push(t[ah] ?? 0),
e.side.push(0 === t[sh] ? xc.BUY : xc.SELL),
e.markers.push(t[oh] ?? null),
e.tradingApp.push(t[lh] ?? null),
e)), {
    txnHash: [],
    blockNumber: [],
    tradeIndex: [],
    maker: [],
    timestamp: [],
    priceInUsd: [],
    amountInUsd: [],
    priceInQuote: [],
    amountInQuote: [],
    tipInNativeUi: [],
    prioInNativeUi: [],
    prioSurchargeInNativeUi: [],
    side: [],
    markers: [],
    tradingApp: [],
    priceInNative: [],
    amountInNative: []
})
  , Mwe = (e, t) => (e.push(...t),
e)
  , Nwe = (e, t) => {
    return "init" === t.type ? {
        trades: Iwe(Ewe(t.snapshot))
    } : {
        ...e ?? {},
        trades: Iwe((n = (null == e ? void 0 : e.trades) ?? {
            txnHash: [],
            blockNumber: [],
            tradeIndex: [],
            maker: [],
            timestamp: [],
            priceInUsd: [],
            amountInUsd: [],
            priceInQuote: [],
            amountInQuote: [],
            tipInNativeUi: [],
            prioInNativeUi: [],
            prioSurchargeInNativeUi: [],
            side: [],
            markers: [],
            tradingApp: [],
            priceInNative: [],
            amountInNative: []
        },
        r = Ewe(t.update),
        {
            txnHash: Mwe(n.txnHash, r.txnHash),
            blockNumber: Mwe(n.blockNumber, r.blockNumber),
            tradeIndex: Mwe(n.tradeIndex, r.tradeIndex),
            maker: Mwe(n.maker, r.maker),
            timestamp: Mwe(n.timestamp, r.timestamp),
            priceInUsd: Mwe(n.priceInUsd, r.priceInUsd),
            amountInUsd: Mwe(n.amountInUsd, r.amountInUsd),
            priceInQuote: Mwe(n.priceInQuote, r.priceInQuote),
            amountInQuote: Mwe(n.amountInQuote, r.amountInQuote),
            priceInNative: Mwe(n.priceInNative, r.priceInNative),
            amountInNative: Mwe(n.amountInNative, r.amountInNative),
            tipInNativeUi: Mwe(n.tipInNativeUi, r.tipInNativeUi),
            prioInNativeUi: Mwe(n.prioInNativeUi, r.prioInNativeUi),
            prioSurchargeInNativeUi: Mwe(n.prioSurchargeInNativeUi, r.prioSurchargeInNativeUi),
            side: Mwe(n.side, r.side),
            markers: Mwe(n.markers, r.markers),
            tradingApp: Mwe(n.tradingApp, r.tradingApp)
        }))
    };
    var n, r
}
  , Pwe = (e, t) => {
    const n = Ax()
      , r = y.useCallback((r => {
        if (!n || !e)
            return {
                unsubscribe: () => {}
            };
        const a = (e => mg(e).chain === Pd.SOLANA ? new Ag("trades-feed",{
            marketId: e
        }) : new Eg)(e)
          , s = xm.subscribeSmartFeed(e, null, {
            ...r,
            onMessage: e => {
                var n, s;
                if ("init" === e.type)
                    a.recordInit();
                else {
                    const t = null == (s = null == (n = e.update) ? void 0 : n[0]) ? void 0 : s[16];
                    t && a.recordUpdate({
                        serverSideMs: t
                    })
                }
                t.current.smartFeedCallbacks.forEach((t => {
                    t(e)
                }
                )),
                r.onMessage(e)
            }
        });
        return {
            unsubscribe: () => {
                s.unsubscribe(),
                a.close()
            }
        }
    }
    ), [e, t, n]);
    return kx(r, Nwe, {
        debounceDuration: 75
    })
}
  , Owe = N((e => ({
    isLive: !0,
    isLoading: !0,
    trades: [],
    setHover: c.noop,
    minimumUsdValue: null,
    setMinimumUsdValue: c.noop,
    showOldest: !1,
    toggleShowOldest: c.noop,
    timeFilter: null,
    setTimeFilter: c.noop,
    tradesProxy: {
        originalMarketId: null,
        newCallbacks: new Set,
        smartFeedCallbacks: new Set,
        trades: null
    },
    set: e,
    pauseOnHover: !0,
    setPauseOnHover: c.noop,
    tooltipOpen: !1,
    onTooltipOpen: c.noop,
    onTooltipClose: c.noop
})))
  , Lwe = e => [e.timestamp, e.side, e.txnHash].map((e => rZ(e.toString()))).join("-")
  , Rwe = e => `${e.txnHash}-${e.maker}-${e.side}-${e.priceInQuote}`
  , Dwe = ({originalMarketId: e, originalMarketInfo: t, children: n}) => {
    const r = bw()
      , {settings: a} = rf()
      , [s,o] = Mx("padreV2-tradesMinimumUsdValue", null)
      , {focusedTraders: l, areTrackedGroupsFocused: d, focusedWalletGroupAddresses: u, tradesLocation: p, panelFocusedTraders: h, panelAreTrackedGroupsFocused: m, panelFocusedWalletGroupAddresses: g, allTrackedGroupIds: x} = jwe()
      , b = y.useMemo(( () => p === XAe.PANEL && r ? h : l), [l, h, p, r])
      , f = y.useMemo(( () => p === XAe.PANEL && r ? m : d), [p, r, m, d])
      , S = y.useMemo(( () => p === XAe.PANEL && r ? g : u), [u, g, p, r])
      , [k,C] = y.useState(!1)
      , [A,w] = y.useState(null)
      , j = y.useCallback(( () => {
        C((e => !e))
    }
    ), [C])
      , T = ((null == b ? void 0 : b.length) ?? 0) > 0 || f || null !== s
      , I = dde(t)
      , E = (null == t ? void 0 : t.baseToken.address) ?? null
      , M = y.useRef(new hg(E ? 1e3 : 1))
      , [N,P] = y.useState(null)
      , O = y.useRef(null);
    y.useEffect(( () => {
        O.current = null,
        E && (M.current = new hg(1e3)),
        P(null)
    }
    ), [E]);
    const [L,R] = Mx("padreV2-tradesPauseOnHover", !0)
      , [D,B] = y.useState(!1)
      , _ = y.useCallback((e => {
        L && B(e)
    }
    ), [L])
      , [U,W] = y.useState(!1)
      , F = y.useCallback(( () => {
        W(!0)
    }
    ), [])
      , V = y.useCallback(( () => {
        W(!1)
    }
    ), []);
    y.useEffect(( () => {
        U || L && D ? N || P(O.current ?? []) : P(null)
    }
    ), [N, D, U, L]);
    const [H,z] = y.useState(null)
      , $ = QAe();
    y.useEffect(( () => {
        let e = !1;
        return (async () => {
            try {
                if (e || !I || !T)
                    return;
                const t = $ && f && (null == x ? void 0 : x.length) ? dh(x) : null
                  , n = await bm.getHistoryV5(I, (null == b ? void 0 : b.length) ? YA(b) : null, i().unix(), null, t, s, null);
                if (e)
                    return;
                z(n.trades)
            } catch (fNe) {
                if (e)
                    return
            }
        }
        )(),
        () => {
            e = !0
        }
    }
    ), [b, T, I, s, f, x, $]);
    const G = y.useMemo(( () => (null == H ? void 0 : H.map((e => e.maker))) ?? []), [H]);
    fve((null == t ? void 0 : t.chain) ?? null, E, G);
    const q = y.useRef({
        originalMarketId: e,
        newCallbacks: new Set,
        smartFeedCallbacks: new Set,
        trades: null
    });
    q.current.originalMarketId !== e && (q.current = {
        originalMarketId: e,
        newCallbacks: new Set,
        smartFeedCallbacks: new Set,
        trades: null
    });
    const K = Pwe(I, q)
      , Y = y.useMemo(( () => (null == K ? void 0 : K.trades) ? ywe(K.trades) : null), [null == K ? void 0 : K.trades])
      , X = y.useRef(new Set);
    y.useEffect(( () => {
        X.current = new Set
    }
    ), [e, null == a ? void 0 : a.devSoldSound]),
    y.useEffect(( () => {
        const n = q.current;
        if ((null == a ? void 0 : a.devSoldSound) && e && n.originalMarketId === e) {
            const e = e => {
                const n = ( (e, t, n) => {
                    if (!t)
                        return [];
                    const r = ng(t);
                    return c.filter(e, (e => ng(e.maker) === r && e.side === xc.SELL && !n.current.has(Rwe(e))))
                }
                )(e, (null == t ? void 0 : t.baseToken.deployer) ?? null, X);
                n.length && (( (e, t) => {
                    e.forEach((e => {
                        t.current.add(Rwe(e))
                    }
                    ))
                }
                )(n, X),
                nw.playDevSold())
            }
            ;
            return n.newCallbacks.add(e),
            () => {
                n.newCallbacks.delete(e)
            }
        }
    }
    ), [null == t ? void 0 : t.baseToken.deployer, null == a ? void 0 : a.devSoldSound, e]),
    y.useEffect(( () => {
        if (!Y)
            return;
        if (q.current.originalMarketId !== e)
            return;
        q.current.trades = Y;
        const t = 0 === M.current.size()
          , n = (r = M.current,
        Y.filter((e => {
            const t = Rwe(e);
            return !r.has(t) && (r.set(t, !0),
            !0)
        }
        )));
        var r;
        n.length > 0 && !t && q.current.newCallbacks.forEach((e => e(n)))
    }
    ), [e, Y]);
    const Q = y.useMemo(( () => {
        if (!Y)
            return null;
        if (!T)
            return Y;
        const e = [null !== s ? e => e.filter((e => Number(e.amountInUsd) >= s)) : e => e, e => b ? e.filter((e => b.includes(e.maker))) : e, e => S && !(null == b ? void 0 : b.length) ? e.filter((e => S.has(e.maker))) : e];
        return c.flow(e)(Y)
    }
    ), [Y, T, S, s, b])
      , Z = null === Q || null === H && T
      , J = y.useMemo(( () => {
        if (!T || !Q || !H)
            return Q ? Q.slice(0, Twe) : [];
        const e = Q.slice(0, Twe);
        if (e.length >= Twe)
            return e;
        const t = new Set;
        e.forEach((e => t.add(Lwe(e))));
        for (const n of H) {
            if (e.length >= Twe)
                break;
            t.has(Lwe(n)) || e.push(n)
        }
        return e
    }
    ), [Q, T, H]);
    O.current = J;
    const ee = y.useMemo(( () => null !== N ? N : J), [J, N])
      , te = Owe()
      , ne = y.useRef(te)
      , re = y.useMemo(( () => ({
        isLoading: Z,
        isLive: null === N && !k && !A,
        setHover: _,
        trades: ee,
        minimumUsdValue: s,
        setMinimumUsdValue: o,
        tradesProxy: q.current,
        showOldest: k,
        toggleShowOldest: j,
        pauseOnHover: L,
        setPauseOnHover: R,
        tooltipOpen: U,
        onTooltipOpen: F,
        onTooltipClose: V,
        timeFilter: A,
        setTimeFilter: w
    })), [Z, N, k, _, ee, s, o, j, L, R, U, F, V, A, w]);
    return y.useEffect(( () => {
        ne.current.set(re)
    }
    ), [re]),
    v.jsx(Awe.Provider, {
        value: re,
        children: n
    })
}
  , Bwe = ({children: e}) => {
    const t = Hb()
      , [n,r] = y.useMemo(( () => t ? [new Set(c.uniq(t.flatMap((e => e.addresses)))), !1] : [null, !0]), [t])
      , a = y.useMemo(( () => t ? t.map((e => e.groupId)) : null), [t])
      , [s,o] = y.useState(null)
      , [l,i] = dx("padreV2-tradesFilterOnlyTracked", !1)
      , [d,u] = y.useMemo(( () => l ? [l ? n : null, r] : [null, r]), [l, n, r])
      , p = y.useCallback((e => {
        if (e) {
            l && i(!1);
            const t = e.map((e => ng(e)));
            o(t)
        } else
            o(null)
    }
    ), [l, o, i])
      , h = y.useCallback((e => {
        i(e)
    }
    ), [i])
      , [m,g] = Mx("padreV2-marketPageTradesLocation", XAe.MARKET_ACTIVITY)
      , [x,b] = y.useState(null)
      , [f,S] = dx("padreV2-tradesPanelFilterOnlyTracked", !1)
      , [k,C] = y.useMemo(( () => f ? [f ? n : null, r] : [null, r]), [f, n, r])
      , A = y.useCallback((e => {
        if (e) {
            f && S(!1);
            const t = e.map((e => ng(e)));
            b(t)
        } else
            b(null)
    }
    ), [f, S])
      , w = y.useCallback((e => {
        S(e)
    }
    ), [S])
      , j = y.useMemo(( () => ({
        focusedTraders: s,
        areTrackedGroupsFocused: l,
        focusedWalletGroupAddresses: d,
        focusedWalletGroupAddressesLoading: u,
        focusTraders: p,
        focusTrackedGroups: h,
        panelFocusedTraders: x,
        panelAreTrackedGroupsFocused: f,
        panelFocusedWalletGroupAddresses: k,
        panelFocusedWalletGroupAddressesLoading: C,
        panelFocusTraders: A,
        panelFocusTrackedGroups: w,
        tradesLocation: m,
        setTradesLocation: g,
        allTrackedGroupIds: a
    })), [s, l, d, u, p, h, x, f, k, C, A, w, m, g, a]);
    return v.jsx(wwe.Provider, {
        value: j,
        children: e
    })
}
  , _we = () => Owe((e => !e.tooltipOpen && (!e.pauseOnHover || e.isLive)))
  , Uwe = () => Owe((e => e.setHover))
  , Wwe = () => Owe((e => e.minimumUsdValue))
  , Fwe = () => Owe((e => e.timeFilter))
  , Vwe = () => Owe((e => e.setTimeFilter))
  , Hwe = (e, t, n) => {
    const r = y.useMemo(( () => ({
        currentId: e,
        currentData: t
    })), [e, t])
      , a = y.useDeferredValue(r)
      , s = null !== e && a.currentId === e ? a.currentData : n;
    return y.useMemo(( () => ({
        data: s,
        isSync: !0
    })), [s])
}
  , zwe = (e, t, n) => {
    const r = bve((e => {
        var t;
        return n && (null == (t = e.wrapped) ? void 0 : t.queue) ? ( (e, t) => {
            const n = new Map;
            for (const r of t) {
                const t = e.get(r);
                void 0 !== t && n.set(r, t)
            }
            return n
        }
        )(e.wrapped.queue, n) : null
    }
    ), ze)
      , a = Ax()
      , [s,o] = y.useState(null)
      , l = y.useMemo(( () => e && t && n ? {
        chain: e,
        token: ng(t),
        wallets: Array.from(n).map((e => ng(e)))
    } : null), [e, t, n])
      , i = y.useRef(null);
    return i.current = l,
    y.useEffect(( () => {
        if (!a || !l)
            return;
        let e = !1;
        return (async () => {
            const t = await Tm.fetchHoldingMulti(a, l);
            e || o(t.entries.map((e => B1(e))))
        }
        )(),
        () => {
            e = !0
        }
    }
    ), [a, l]),
    y.useEffect(( () => {
        r && o((e => {
            const t = []
              , n = new Set;
            if (e)
                for (const a of e)
                    r.has(a.walletAddress) ? (t.push(r.get(a.walletAddress)),
                    n.add(a.walletAddress)) : t.push(a);
            return r && r.forEach((e => {
                n.has(e.walletAddress) || t.push(e)
            }
            )),
            t
        }
        ))
    }
    ), [r]),
    l && i.current === l ? s : null
}
  , $we = e => e ? c.reduce(e, ( (e, t) => ("string" == typeof t && e.add(ng(t)),
e)), new Set) : new Set
  , Gwe = y.memo(( ({label: e, typographyOverrides: t, backgroundColor: n, minWidth: r}) => {
    const a = y.useMemo(( () => e => ({
        backgroundColor: n ?? e.palette.background.buttonHover,
        borderRadius: "4px",
        display: "flex",
        py: .25,
        px: .5,
        minWidth: r,
        alignItems: "center",
        justifyContent: "center"
    })), [n, r]);
    return v.jsx(C, {
        sx: a,
        children: v.jsx(k, {
            variant: "paragraph3",
            fontWeight: wu.REGULAR,
            color: "text.value",
            ...t,
            children: e
        })
    })
}
))
  , qwe = y.memo(( ({maker: e, filterIconSize: t=Kwe, onFilterCallback: n, isInTrades: r=!1}) => {
    const a = bw()
      , {focusTraders: s, focusedTraders: o, areTrackedGroupsFocused: l, focusTrackedGroups: i, panelFocusedTraders: c, panelAreTrackedGroupsFocused: d, panelFocusTrackedGroups: u, tradesLocation: p, panelFocusTraders: h} = jwe()
      , m = y.useCallback((e => {
        p === XAe.PANEL && a && r ? h(e) : s(e)
    }
    ), [s, h, p, a, r])
      , g = y.useMemo(( () => p === XAe.PANEL && a && r ? c : o), [o, c, p, a, r])
      , x = y.useMemo(( () => p === XAe.PANEL && a && r ? d : l), [p, a, r, d, l])
      , b = y.useCallback((e => {
        p === XAe.PANEL && a && r ? u(e) : i(e)
    }
    ), [p, a, r, u, i])
      , f = y.useMemo(( () => g && (null == g ? void 0 : g.includes(e))), [g, e])
      , S = y.useCallback(( () => {
        const t = ( (e, t) => {
            if (!(null == t ? void 0 : t.length))
                return [e];
            if (!t || !(null == t ? void 0 : t.includes(e)))
                return [...t, e].sort();
            const n = [...t].filter((t => t !== e));
            return n.length ? n : null
        }
        )(e, g);
        m(t),
        x ? b(!1) : n && !f && n()
    }
    ), [e, g, m, x, b, n, f])
      , k = y.useMemo(( () => e => ({
        cursor: "pointer",
        width: t + 8,
        height: t + 8,
        p: .5,
        svg: {
            fill: e.palette.text.label,
            color: e.palette.text.label,
            ":hover": {
                fill: e.palette.text.value,
                color: e.palette.text.value
            },
            transition: e.transitions.create(["fill", "color"], {
                duration: e.transitions.duration.short,
                easing: e.transitions.easing.easeOut
            })
        }
    })), [t]);
    return v.jsx(F, {
        onClick: S,
        sx: k,
        children: f || x ? v.jsx(gy, {
            color: "inherit",
            size: t
        }) : v.jsx(bk, {
            size: t
        })
    })
}
))
  , Kwe = 16
  , Ywe = y.memo(( ({tradingApp: e, size: t=Xwe}) => {
    const n = D()
      , {settings: r} = rf()
      , [a,s] = y.useMemo(( () => {
        const t = Qwe[e];
        return (null == r ? void 0 : r.hidePlatformTradeIcon) || !t ? [qS, "Pro Trader"] : t
    }
    ), [null == r ? void 0 : r.hidePlatformTradeIcon, e]);
    return v.jsx(GC, {
        title: s,
        children: v.jsx(C, {
            component: "span",
            display: "flex",
            width: t,
            height: t,
            children: v.jsx(a, {
                size: t,
                color: n.palette.primary.main
            })
        })
    })
}
))
  , Xwe = 14
  , Qwe = {
    [Sc.PHOTON]: [e => v.jsx(bf, {
        icon: "/assets/photon-DB_Vn6YE.png",
        ...e
    }), "Photon app"],
    [Sc.BULLX]: [e => v.jsx(bf, {
        icon: "/assets/bullx-C1YsWQba.png",
        ...e
    }), "Bullx app"],
    [Sc.GMGN]: [e => v.jsx(bf, {
        icon: "/assets/gmgn-D3zaVI63.png",
        ...e
    }), "GMGN bot"],
    [Sc.BANANA]: [e => v.jsx(bf, {
        icon: "/assets/banana-RGLdoz-1.png",
        ...e
    }), "Banana bot"],
    [Sc.MAESTRO]: [e => v.jsx(bf, {
        icon: "/assets/maestro-CAxnJYrU.png",
        ...e
    }), "Maestro bot"],
    [Sc.BONK]: [e => v.jsx(bf, {
        icon: "/assets/bonkbot-BTJp7Q-F.png",
        ...e
    }), "Bonk bot"],
    [Sc.SOL_TRADING_BOT]: [e => v.jsx(bf, {
        icon: "/assets/soltradingbot-DjanOfVJ.png",
        ...e
    }), "Sol trading bot"],
    [Sc.PEPEBOOST]: [e => v.jsx(bf, {
        icon: "/assets/pepeboostsol-DQ6Vczb_.png",
        ...e
    }), "PepeBoost Sol bot"],
    [Sc.PADRE]: [e => v.jsx(bf, {
        icon: "/assets/terminal-CFbgu0Ol.png",
        ...e
    }), "Terminal app"],
    [Sc.TROJAN]: [e => v.jsx(bf, {
        icon: "/assets/trojan-CpTIgByC.png",
        ...e
    }), "Trojan bot"],
    [Sc.AXIOM]: [e => v.jsx(bf, {
        icon: "/assets/axiom-CiHqZG2d.png",
        ...e
    }), "Axiom app"],
    [Sc.NOVA]: [qS, "Memecoin app"],
    [Sc.VECTOR_FUN]: [qS, "Memecoin app"],
    [Sc.FASOL]: [qS, "Memecoin app"],
    [Sc.PHANTOM]: [qS, "Memecoin app"],
    [Sc.CIPHER]: [qS, "Memecoin app"],
    [Sc.DEXCELERATE]: [qS, "Memecoin app"],
    [Sc.MEVX]: [qS, "Memecoin app"],
    [Sc.TRADE_WIZ]: [qS, "Memecoin app"],
    [Sc.BLOOM]: [qS, "Memecoin app"],
    [Sc.AQUABOT]: [qS, "Memecoin app"],
    [Sc.MONKEY_KING]: [qS, "Memecoin app"],
    [Sc.FOMO]: [qS, "Memecoin app"]
}
  , Zwe = (e, t) => UX((n => {
    if (!e || !t)
        return null;
    const r = n.entries.get(e);
    return r ? r.status !== ox.READY ? null : r.data.get(ng(t)) ?? null : null
}
))
  , Jwe = e => `https://content.padre.gg/kols/kol_${ng(e)}.jpg`
  , eje = {
    width: 18,
    height: 18
}
  , tje = y.memo(( ({activationTimestamp: e}) => {
    const [t,n] = y.useState(null);
    y.useEffect(( () => {
        if (!e)
            return void n(null);
        if (e + 86400 < i().unix())
            return void n(null);
        n(WA(i().unix() - e, !0));
        const t = setInterval(( () => {
            e + 86400 < i().unix() ? n(null) : n(WA(i().unix() - e, !0))
        }
        ), 6e4);
        return () => {
            clearInterval(t)
        }
    }
    ), [e]);
    const {originalStaticMarketInfo: r} = Qce()
      , a = (null == r ? void 0 : r.chain) ?? null
      , s = D();
    return null !== t && a ? v.jsx(GC, {
        title: `Address had 0 ${GD(a)} until ${t} ago`,
        children: v.jsx(C, {
            component: "span",
            display: "inline-flex",
            children: v.jsx(Mf, {
                size: rje,
                color: s.palette.originalGreen.main
            })
        })
    }) : null
}
))
  , nje = y.memo(( ({holdersData: e, tableAddressMode: t, onFilterCallback: n, showWhaleIndicator: r, showTradesCount: a, showTradingApp: s, showPnlBasedColor: o, ...l}) => {
    const {t: i} = we()
      , c = D()
      , {openModal: d} = r6()
      , u = y.useCallback(( () => {
        e && d(e.address)
    }
    ), [d, e])
      , p = Zwe((null == e ? void 0 : e.chain) ?? null, (null == e ? void 0 : e.address) ?? null)
      , h = y.useMemo(( () => ({
        justifyContent: "flex-end",
        alignItems: "center",
        ...l.sxProps
    })), [l.sxProps])
      , m = Sve((t => t.snipers.has((null == e ? void 0 : e.address) ?? "")));
    if (!e)
        return v.jsx(CQ, {});
    const g = 0 === e.groups.length && !!p
      , x = oje(e, m, g);
    return v.jsx(kQ, {
        ...l,
        sxProps: h,
        typographyOverrides: lje,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            width: "100%",
            gap: .75,
            children: [v.jsxs(S, {
                direction: "row",
                maxWidth: `max(calc(100% - ${x}px), ${sje}px)`,
                alignItems: "center",
                gap: .25,
                children: [v.jsx(qwe, {
                    maker: e.address,
                    filterIconSize: rje,
                    onFilterCallback: n
                }), v.jsxs(S, {
                    width: "calc(100% - 18px)",
                    direction: "row",
                    alignItems: "center",
                    onClick: u,
                    sx: ije,
                    children: [r && !e.isPool && v.jsx(C, {
                        display: "flex",
                        width: rje,
                        height: rje,
                        children: v.jsx(F1, {
                            size: rje,
                            volume: (e.totalBoughtUsd ?? 0) + (e.totalSoldUsd ?? 0),
                            useColors: null !== e.totalBoughtUsd && null !== e.totalSoldUsd
                        })
                    }), v.jsx(k, {
                        noWrap: !0,
                        sx: {
                            ...$_(200, !1),
                            cursor: "pointer",
                            direction: e.customWalletName || e.name ? "ltr" : "rtl",
                            textAlign: "right"
                        },
                        fontWeight: e.groups.length || e.isMayhem || e.isUser || e.isPool || p ? wu.EXTRA_LARGE : wu.MEDIUM,
                        variant: "paragraph2",
                        color: e.isMayhem ? c.palette.success.main : e.isPool ? c.palette.lavender[500] : e.groups.length || e.isUser ? c.palette.gold[500] : p ? "text.value" : null !== e.pnlInUsd && o ? e.pnlInUsd > 0 ? "success.main" : "error.main" : "text.label",
                        children: e.isMayhem ? "MAYHEM" : e.isPool ? "LIQ POOL" : e.customWalletName ? e.customWalletName : e.isUser ? "YOU" : p ? p.name : t2(e.address, t)
                    })]
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: `${aje}px`,
                children: [a && (null !== e.buyTxns || null !== e.sellTxns) && v.jsx(Gwe, {
                    minWidth: 22,
                    label: null !== e.buyTxns || null !== e.sellTxns ? LI((e.buyTxns ?? 0) + (e.sellTxns ?? 0), {
                        collapseExponent: !0,
                        maxPrecision: 0,
                        minPrecision: 0,
                        symbol: ""
                    }) : Ud
                }), e.isDeployer && v.jsx(GC, {
                    title: i("Dev"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(Vv, {
                            size: rje,
                            color: c.palette.primary.main
                        })
                    })
                }), s && !ke(e.tradingApp) && v.jsx(Ywe, {
                    tradingApp: e.tradingApp
                }), e.groups.map((t => v.jsx(GC, {
                    title: t.name,
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(ZT, {
                            emoji: e.customWalletEmoji ?? t.emoji
                        })
                    })
                }, t.groupId))), g && v.jsx(Te, {
                    src: Jwe(p.walletAddress),
                    sx: eje
                }), m && !e.isDeployer && !e.isPool && v.jsx(GC, {
                    title: i("Sniper"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(ES, {
                            size: rje,
                            color: c.palette.error.main
                        })
                    })
                }), e.isMayhem && v.jsx(C, {
                    component: "span",
                    display: "inline-flex",
                    mt: "1px",
                    children: v.jsx(TC, {
                        size: rje
                    })
                }), e.isPool && v.jsx(GC, {
                    title: i("Liquidity pool"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(GS, {
                            size: rje,
                            color: c.palette.lavender[500]
                        })
                    })
                }), v.jsx(tje, {
                    activationTimestamp: (null == e ? void 0 : e.activationTimestamp) ?? null
                }), e.isToken && v.jsx(GC, {
                    title: i("Token contract"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(TS, {
                            size: rje
                        })
                    })
                }), e.isUser && v.jsx(GC, {
                    title: i("You"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(jS, {
                            size: rje,
                            color: c.palette.primary.main
                        })
                    })
                }), e.isBundler && v.jsx(GC, {
                    title: i("Bundler"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(Uv, {
                            size: rje,
                            color: c.palette.error.main
                        })
                    })
                }), e.address === Vd && v.jsx(GC, {
                    title: i("Burn"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(NS, {
                            size: rje
                        })
                    })
                }), e.address === zd && v.jsx(GC, {
                    title: i("Vesting"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(dS, {
                            size: rje
                        })
                    })
                }), e.address === ud && v.jsx(GC, {
                    title: i("Raydium Authority V4"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(oS, {
                            size: rje
                        })
                    })
                }), e.address === Qd && v.jsx(GC, {
                    title: i("UCNX Vesting Contract"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(zS, {
                            size: rje
                        })
                    })
                }), e.address === Gd && v.jsx(GC, {
                    title: i("Boop Vault"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(Xk, {
                            size: rje
                        })
                    })
                }), e.address === $d && v.jsx(GC, {
                    title: i("Raydium CPMM Vault"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(oS, {
                            size: rje
                        })
                    })
                }), e.address === Kd && v.jsx(GC, {
                    title: i("Launch Lab Vault"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(Hk, {
                            size: rje
                        })
                    })
                }), (e.address === Yd || e.address === Xd) && v.jsx(GC, {
                    title: i("Heaven Vault"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(sC, {
                            size: rje
                        })
                    })
                }), e.address === qd && v.jsx(GC, {
                    title: i("BAGS Vault"),
                    children: v.jsx(C, {
                        component: "span",
                        display: "inline-flex",
                        children: v.jsx(tS, {
                            size: rje
                        })
                    })
                })]
            })]
        })
    })
}
), c.isEqual)
  , rje = 14
  , aje = 2
  , sje = 80
  , oje = (e, t, n) => c.sum([24, e.isDeployer ? 31 : 0, t ? rje + aje : 0, e.isPool ? rje + aje : 0, e.isToken ? rje + aje : 0, e.isUser ? rje + aje : 0, e.tradingApp ? rje + aje : 0, 18 * e.groups.length, n ? 18 + aje : 0, [ud, zd, Vd, Qd, $d, Gd, qd, Kd, Yd, Xd].includes(e.address) ? rje + aje : 0])
  , lje = {
    sx: {
        width: "100%"
    }
}
  , ije = {
    gap: .5,
    "&:hover": {
        cursor: "pointer"
    }
}
  , cje = ({holdersData: e, ...t}) => e ? v.jsx(kQ, {
    ...t,
    sxProps: {
        alignItems: "center",
        ...t.sxProps
    },
    children: v.jsx(k, {
        variant: "paragraph2",
        color: "text.value",
        children: Math.abs(e.rank)
    })
}) : v.jsx(CQ, {})
  , dje = ({tradeSide: e, currencyMode: t, holdersData: n, ...r}) => {
    const a = y.useDeferredValue(Ade())
      , s = y.useDeferredValue(vde())
      , o = y.useMemo(( () => {
        if (t === uZ.USD || !n)
            return null;
        switch (n.chain) {
        case Pd.SOLANA:
            return v.jsx(dk, {
                size: 15
            });
        case Pd.BSC:
            return v.jsx(rk, {
                size: 15
            });
        case Pd.ETH_MAINNET:
        case Pd.BASE:
            return v.jsx(Df, {
                size: 12
            });
        default:
            return null
        }
    }
    ), [t, n]);
    if (!n)
        return v.jsx(CQ, {});
    const l = e === xc.BUY ? n.buyTxns : n.sellTxns
      , i = e === xc.BUY ? n.totalBoughtUsd : n.totalSoldUsd
      , c = n.chain !== Pd.SOLANA
      , d = e === xc.BUY ? n.amountBought : n.amountSold
      , u = null === d ? null : c ? a ? d * 10 ** a : null : d
      , p = null === u || null === a ? "" : OI(u / 10 ** a, {
        collapseExponent: !0,
        precision: 1,
        symbol: ""
    })
      , h = z1({
        totalUsd: i,
        totalAmount: u,
        totalSupply: s,
        decimals: a
    })
      , m = t === uZ.USD ? i : null !== i && n.firstNativePriceUsd ? i / n.firstNativePriceUsd : null;
    return v.jsx(kQ, {
        ...r,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...r.sxProps
        },
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "flex-end",
            children: [v.jsxs(S, {
                alignContent: "flex-end",
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    height: 15,
                    children: [null === m ? null : o, v.jsx(k, {
                        textAlign: "end",
                        variant: "monospace1",
                        color: e === xc.BUY ? "success.main" : "error.main",
                        children: null === m ? Ud : LI(m, {
                            collapseExponent: !0,
                            padSymbol: !1,
                            symbol: t === uZ.USD ? "$" : "",
                            symbolPosition: yI.START,
                            maxPrecision: t === uZ.USD ? 2 : 3,
                            minPrecision: t === uZ.USD ? 2 : 3
                        })
                    })]
                    }), v.jsx(S, {
                    alignItems: "flex-end",
                    children: v.jsxs(k, {
                        variant: "monospace3",
                        color: "text.label",
                        textAlign: "end",
                        children: [null === l ? Ud : LI(l, {
                            collapseExponent: !0,
                            padSymbol: !0,
                            maxPrecision: 0,
                            minPrecision: 0
                        }), null !== l && (p ? " | " : l > 1 ? " txns" : " txn"), p]
                    })
                })]
            }), null !== h && v.jsx(k, {
                sx: uje,
                textAlign: "end",
                variant: "monospace3",
                minWidth: 46,
                color: e === xc.BUY ? "success.main" : "error.main",
                children: LI(h, {
                    collapseExponent: !0,
                    padSymbol: !1,
                    symbol: "$",
                    symbolPosition: yI.START,
                    ...h >= 1e3 ? {
                        desiredDigits: 3
                    } : {
                        maxPrecision: 1,
                        minPrecision: 1
                    }
                })
            })]
        })
    })
}
  , uje = {
    pl: 1
}
  , pje = y.memo(( ({holdersData: e, currencyMode: t, ...n}) => {
    const r = y.useMemo(( () => {
        if (t === uZ.USD || !e)
            return null;
        switch (e.chain) {
        case Pd.SOLANA:
            return v.jsx(dk, {});
        case Pd.BSC:
            return v.jsx(rk, {});
        case Pd.ETH_MAINNET:
        case Pd.BASE:
            return v.jsx(Df, {
                size: 14
            });
        default:
            return null
        }
    }
    ), [t, e]);
    if (!e)
        return v.jsx(CQ, {});
    const {pnlInUsd: a, firstNativePriceUsd: s} = e
      , o = t === uZ.USD ? a : s && null !== a ? a / s : null;
    return v.jsx(kQ, {
        ...n,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...n.sxProps
        },
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .25,
            children: [null === o ? null : r, v.jsx(k, {
                variant: "monospace1",
                color: o ? o > 0 ? "success.main" : "error.main" : "text.value",
                children: null === o ? Ud : `${OI(o, {
                    collapseExponent: !0,
                    symbol: t === uZ.NATIVE ? "" : "$"
                })}`
            })]
        })
    })
}
))
  , hje = ({holdersData: e, ...t}) => {
    if (!e)
        return v.jsx(CQ, {});
    const {nativeBalance: n, chain: r} = e;
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...t.sxProps
        },
        children: v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [null !== n && v.jsx(Sz, {
                chain: r
            }), v.jsx(k, {
                variant: "paragraph2",
                color: n ? "text.value" : "text.label",
                children: null === n ? Ud : LI(n, {
                    collapseExponent: !0,
                    symbol: "",
                    minPrecision: 3,
                    maxPrecision: 3
                })
            })]
        })
    })
}
  , mje = ({holdersData: e, ...t}) => {
    if (!e)
        return v.jsx(CQ, {});
    const {fundedBy: n, fundedGroupCount: r} = e;
    return v.jsx(kQ, {
        ...t,
        sxProps: {
            alignItems: "center",
            justifyContent: "flex-end",
            ...t.sxProps
        },
        children: n ? v.jsx(S5, {
            chain: e.chain,
            ...n,
            fundedGroupCount: r
        }) : Ud
    })
}
  , gje = {
    justifyContent: "flex-end",
    alignItems: "center"
}
  , xje = ({...e}) => {
    var t, n, r, a;
    const s = y.useRef(null);
    y.useEffect(( () => {
        const t = (n = t => {
            var n;
            const r = (null == (n = e.data) ? void 0 : n.amount) ? (t ?? 0) * Number(e.data.amount ?? "0") : null
              , a = e.currencyMode === uZ.USD ? r : null !== r && e.data && e.data.firstNativePriceUsd ? r / e.data.firstNativePriceUsd : null
              , o = (l = a,
            i = e.currencyMode === uZ.USD,
            null === l ? Ud : LI(l, {
                collapseExponent: !0,
                symbol: i ? "$" : "",
                symbolPosition: yI.START,
                ...l >= 1e3 ? {
                    desiredDigits: 3
                } : {
                    maxPrecision: 2,
                    minPrecision: 2
                }
            }));
            var l, i;
            s.current && s.current.textContent !== o && (s.current.textContent = o)
        }
        ,
        Zce.subscribe((e => {
            var t;
            return (null == (t = e.marketStats) ? void 0 : t.basePriceInUsdUi) ?? null
        }
        ), ( (e, t) => {
            e !== t && n(e)
        }
        )));
        var n;
        return () => {
            t()
        }
    }
    ), [e.currencyMode, e.data, e.data.amount]);
    const o = vde()
      , l = Ade()
      , i = o && !m.isNil(l) ? 100 * ((null == (t = e.data) ? void 0 : t.amount) ?? 0) / Number(o) * 10 ** l : null
      , c = o && !m.isNil(l) ? (null == (n = e.data) ? void 0 : n.amount) ?? 0 : null
      , d = ( () => {
        var e;
        return (null == (e = Zce.getState().marketStats) ? void 0 : e.basePriceInUsdUi) ?? null
    }
    )()
      , u = (null == (r = e.data) ? void 0 : r.amount) ? (d ?? 0) * Number(e.data.amount ?? "0") : null
      , p = e.currencyMode === uZ.USD ? u : null !== u && e.data && e.data.firstNativePriceUsd ? u / e.data.firstNativePriceUsd : null;
    return v.jsx(HQ, {
        ...e,
        remaining: p,
        remainingAmount: c,
        remainingPercentage: i,
        isLoading: !e.data,
        sxProps: gje,
        ref: s,
        isUsd: e.currencyMode === uZ.USD,
        chainIcon: e.currencyMode === uZ.NATIVE ? null == (a = e.data) ? void 0 : a.chain : void 0
    })
}
;
var bje = (e => (e.HOLDERS = "HOLDERS",
e.TOP_TRADERS = "TOP_TRADERS",
e))(bje || {});
const fje = {
    rank: "Rank",
    address: "Address",
    nativeBalance: "Balance",
    totalBoughtUsd: "Bought (Avg MC)",
    totalSoldUsd: "Sold (Avg MC)",
    pnlInUsd: "PNL",
    remainingPlaceholder: "Remaining",
    lastActivityTs: "Edit",
    holdingSince: "Hold For",
    fundedBy: "Funded By"
}
  , vje = (e, t) => ({
    ...sZ(e),
    headerClass: lY,
    minWidth: 70,
    sortable: !1,
    headerName: t(fje[e])
})
  , Sje = ({key: e, chain: t, openSettings: n, tableAddressMode: r, onFilterCallback: a, showRemainingValue: s, showRemainingAmount: o, showRemainingProgress: l, currencyMode: i, showWhaleIndicator: c, showTradesCount: d, showTradingApp: u, showPnlBasedColor: p, t: h}) => {
    switch (e) {
    case "rank":
        return {
            ...vje(e, h),
            headerClass: void 0,
            minWidth: 70,
            maxWidth: 70,
            cellRenderer: e => v.jsx(cje, {
                ...e,
                holdersData: e.data
            })
        };
    case "address":
        return {
            ...vje(e, h),
            sort: "desc",
            sortingOrder: ["desc"],
            cellRenderer: e => v.jsx(nje, {
                tableAddressMode: r ?? iZ.END,
                onFilterCallback: a,
                holdersData: e.data,
                ...e,
                showWhaleIndicator: !!c,
                showTradesCount: !!d,
                showTradingApp: !!u,
                showPnlBasedColor: !!p,
                sxProps: {
                    ...gje,
                    justifyContent: "flex-start"
                }
            }),
            headerClass: void 0,
            flex: 2,
            minWidth: 196 - (d ? 0 : 24) - (u ? 0 : 16) - (c ? 0 : 16),
            valueGetter: ({data: e}) => e ? `${e.name}-${e.address}-${e.isDeployer}-${e.isPool}-${e.isUser}-${e.isToken}-${e.groups.map((e => e.groupId)).join("-")}-${e.customWalletName}-${e.buyTxns}-${e.sellTxns}-${e.pnlInUsd}-${d}-${u}-${p}-${c}-${e.rank}` : void 0,
            comparator: lZ((e => e.rank ?? null))
        };
    case "nativeBalance":
        return {
            ...vje(e, h),
            headerName: `${t ? GD(t) : ""} ${h("Balance")}`,
            minWidth: 84,
            maxWidth: 84,
            cellRenderer: e => v.jsx(hje, {
                holdersData: e.data,
                ...e,
                sxProps: gje
            }),
            valueGetter: ({data: e}) => e ? `${e.nativeBalance}-${e.chain}` : void 0
        };
    case "totalBoughtUsd":
        return {
            ...vje(e, h),
            minWidth: 125,
            cellRenderer: e => v.jsx(dje, {
                tradeSide: xc.BUY,
                currencyMode: i ?? uZ.USD,
                ...e,
                holdersData: e.data
            }),
            valueGetter: ({data: e}) => e ? `${e.totalBoughtUsd}-${e.buyTxns}-${e.firstNativePriceUsd}` : void 0
        };
    case "totalSoldUsd":
        return {
            ...vje(e, h),
            minWidth: 125,
            cellRenderer: e => v.jsx(dje, {
                tradeSide: xc.SELL,
                currencyMode: i ?? uZ.USD,
                ...e,
                holdersData: e.data
            }),
            valueGetter: ({data: e}) => e ? `${e.totalSoldUsd}-${e.sellTxns}-${e.firstNativePriceUsd}` : void 0
        };
    case "pnlInUsd":
        return {
            ...vje(e, h),
            minWidth: 80,
            cellRenderer: e => v.jsx(pje, {
                ...e,
                holdersData: e.data,
                currencyMode: i ?? uZ.USD
            }),
            valueGetter: ({data: e}) => e ? `${e.pnlInUsd}-${e.firstNativePriceUsd}` : void 0
        };
    case "holdingSince":
        return {
            ...vje(e, h),
            minWidth: 70,
            cellRenderer: e => {
                var t, n;
                return v.jsx(zQ, {
                    ...e,
                    date: (null == (t = e.data) ? void 0 : t.amount) ? (null == (n = e.data) ? void 0 : n.holdingSince) ?? null : null
                })
            }
            ,
            valueGetter: ({data: e}) => e ? `${e.holdingSince}-${e.amount}` : void 0
        };
    case "fundedBy":
        return {
            ...vje(e, h),
            minWidth: 130,
            cellRenderer: e => v.jsx(mje, {
                ...e,
                holdersData: e.data
            })
        };
    case "remainingPlaceholder":
        return {
            ...vje(e, h),
            minWidth: (l ?? 1) || (s ?? 1) ? 128 : 95,
            cellRenderer: e => v.jsx(xje, {
                showValue: s ?? !0,
                showAmount: o ?? !0,
                showProgressBar: l ?? !0,
                currencyMode: i ?? uZ.USD,
                ...e
            }),
            valueGetter: ({data: e}) => e ? `${e.amount}-${e.firstNativePriceUsd}` : void 0
        };
    case "lastActivityTs":
        return {
            ...vje(e, h),
            ...n ? {
                headerComponent: eZ,
                headerComponentParams: {
                    onClick: n
                }
            } : {},
            minWidth: 66,
            maxWidth: 120,
            cellRenderer: e => {
                var t;
                return v.jsx(zQ, {
                    ...e,
                    date: (null == (t = e.data) ? void 0 : t.lastActivityTs) ?? null
                })
            }
        };
    default:
        return {}
    }
}
  , yje = ["rank", "nativeBalance", "totalBoughtUsd", "totalSoldUsd", "pnlInUsd", "holdingSince", "remainingPlaceholder", "fundedBy"]
  , kje = "remainingValue"
  , Cje = "remainingAmount"
  , Aje = "remainingProgress"
  , wje = "addressWhale"
  , jje = "addressCount"
  , Tje = "addressTradingApp"
  , Ije = "addressPnlColors"
  , Eje = {
    [kje]: !0,
    [Cje]: !1,
    [Aje]: !0,
    [wje]: !0,
    [jje]: !0,
    [Tje]: !0,
    [Ije]: !0
}
  , Mje = {
    remainingPlaceholder: [{
        flagKey: kje,
        label: n.t("Remaining value")
    }, {
        flagKey: Cje,
        label: n.t("Remaining amount")
    }, {
        flagKey: Aje,
        label: n.t("Remaining % line")
    }],
    address: [{
        flagKey: wje,
        label: n.t("Whale indicator")
    }, {
        flagKey: jje,
        label: n.t("Show trades count")
    }, {
        flagKey: Tje,
        label: n.t("Show trading app")
    }, {
        flagKey: Ije,
        label: n.t("Show PNL based colors")
    }]
}
  , Nje = ["address"]
  , Pje = {
    [bje.HOLDERS]: {
        customizeLabel: n.t("holders"),
        dataGridColumnsConfigStorageKey: oZ("HoldersTable").columnsConfigStorageKey ?? "",
        columnsConfigStorageKey: IZ("Holders"),
        customFlagsStorageKey: "padreV2-holdersCustomFlagsV2",
        customFlagsStorageKeyOld: "padreV2-holdersCustomFlags",
        addressModeStorageKey: "padreV2-holderAddressMode",
        currencyModeStorageKey: "padreV2-holdersStatsCurrencyMode"
    },
    [bje.TOP_TRADERS]: {
        customizeLabel: n.t("top traders"),
        dataGridColumnsConfigStorageKey: oZ("TopTradersTable").columnsConfigStorageKey ?? "",
        columnsConfigStorageKey: IZ("TopTraders"),
        customFlagsStorageKey: "padreV2-topTradersCustomFlagsV2",
        customFlagsStorageKeyOld: "padreV2-topTradersCustomFlags",
        addressModeStorageKey: "padreV2-topTradersAddressMode",
        currencyModeStorageKey: "padreV2-topTradersStatsCurrencyMode"
    }
}
  , Oje = (e, t, n, r, a, s, o, l, i, d, u, p, h, m, g, x) => {
    const b = qj(d)
      , f = new Map;
    t.forEach((e => {
        if (e.fundFrom) {
            const t = f.get(e.fundFrom);
            f.set(e.fundFrom, 1 + (t ?? 0))
        }
    }
    ));
    const v = [...t].filter((e => null !== e.fundTs)).sort(( (e, t) => (t.fundTs ?? 0) - (e.fundTs ?? 0)))
      , S = c.reduce(v, ( (e, t) => {
        if (!t.fundTs || !t.fundFrom)
            return e;
        if (!e[t.fundFrom] || !e[t.fundFrom].length)
            return e[t.fundFrom] = [{
                startTs: t.fundTs,
                count: 1
            }],
            e;
        const n = e[t.fundFrom];
        if (!n.length)
            return e;
        const r = n[n.length - 1];
        return t.fundTs >= r.startTs - Lje && t.fundTs <= r.startTs + Rje ? e[t.fundFrom] = [...n.slice(0, n.length - 1), {
            ...r,
            count: r.count + 1
        }] : e[t.fundFrom] = [...n, {
            startTs: t.fundTs,
            count: 1
        }],
        e
    }
    ), {});
    v.forEach((e => {
        e.fundFrom
    }
    ));
    const y = t.filter((e => !h || h.has(e.walletAddress))).map((t => {
        const {walletAddress: d, amountString: h, buyTxns: m, totalBoughtUsd: g, amountBought: f, sellTxns: v, totalSoldUsd: y, amountSold: k, lastActivityTs: C, activationTimestamp: A, tradingApp: w, nativeBalanceUi: j, isBundler: T, holdingSince: I, fundHash: E, fundFrom: M, fundAmountNativeUi: N, fundTs: P, fundExchange: O} = t
          , L = void 0 === j ? null : j
          , R = ng(d)
          , D = (null == n ? void 0 : n.get(d)) || null
          , B = Number(new sB({
            decimals: e.baseToken.decimals
        },BigInt(h ?? "0")).toNumber().toFixed(0))
          , _ = R === r && !twe(r)
          , U = R === a || i.has(R)
          , W = R === o
          , F = s.has(R)
          , V = _1.has(R)
          , H = Kj(b, R)
          , z = u[R] ?? null
          , $ = p[R] ?? null
          , G = null === y && null === g ? null : (y ?? 0) - (g ?? 0)
          , q = M ? S[M] : []
          , K = P ? q.find((e => P >= e.startTs - Lje && P <= e.startTs + Rje)) : null;
        return {
            address: R,
            chain: l,
            name: D,
            amount: B,
            isDeployer: _,
            isPool: U,
            isToken: W,
            isUser: F,
            isMayhem: V,
            groups: H,
            customWalletName: z,
            customWalletEmoji: $,
            buyTxns: m,
            totalBoughtUsd: g,
            amountBought: f,
            sellTxns: v,
            totalSoldUsd: y,
            amountSold: k,
            pnlInUsd: G,
            lastActivityTs: C,
            activationTimestamp: A,
            tradingApp: w,
            remainingPlaceholder: null,
            nativeBalance: L,
            isBundler: T,
            holdingSince: I,
            firstNativePriceUsd: x,
            fundedBy: E && M && P && !c.isNil(N) ? {
                fundHash: E,
                fundFrom: M,
                fundAmountNativeUi: N,
                fundTs: P,
                fundExchange: O
            } : null,
            fundedGroupCount: (null == K ? void 0 : K.count) ?? null
        }
    }
    )).sort(( (e, t) => m ? (t.pnlInUsd ?? 0) - (e.pnlInUsd ?? 0) : t.amount - e.amount));
    return y.filter((e => !g || y.length <= 1 || e.amount > 0)).map(( (e, t) => ({
        rank: -(t + 1),
        ...e
    })))
}
  , Lje = 300
  , Rje = 900
  , Dje = ({holdersState: e, focusedTraders: t, focusedWalletGroupAddresses: n, focusedWalletGroupAddressesLoading: r, pnlSort: a, skipEmpty: s, onFilterCallback: o, mode: l}) => {
    const {customizeLabel: i, dataGridColumnsConfigStorageKey: d, columnsConfigStorageKey: u, customFlagsStorageKey: p, addressModeStorageKey: h, currencyModeStorageKey: m} = y.useMemo(( () => Pje[l]), [l])
      , {walletGroups: g, customWalletNames: x, customWalletEmojis: b} = rf()
      , {originalStaticMarketInfo: f, chainId: k} = Qce()
      , C = hde(f)
      , A = VV(k || null)
      , [w,j] = y.useState(null);
    y.useEffect(( () => {
        !k || !A || w && w[k] || j({
            [k]: A
        })
    }
    ), [k, w, A]);
    const T = y.useMemo(( () => w && k ? w[k] ?? null : null), [k, w])
      , I = fde()
      , [E,M] = Mx(h, iZ.END)
      , [N,P] = Mx(m, uZ.USD)
      , {wallets: O} = UD((e => e))
      , L = y.useMemo(( () => O ? c.reduce(O, ( (e, t) => (e.add(ng(t.publicAddress)),
    e)), new Set) : new Set), [O])
      , [R,D] = y.useMemo(( () => t ? [new Set([...t]), !1] : n ? [n, !1] : [null, r]), [t, n, r])
      , B = zwe((null == C ? void 0 : C.chain) || null, (null == C ? void 0 : C.baseToken.address) || null, R)
      , _ = y.useMemo(( () => []), [])
      , U = y.useMemo(( () => (D ? null : R ? B : null == e ? void 0 : e.queue.getTopN(50)) ?? _), [_, R, B, e, D])
      , [W,F] = y.useMemo(( () => (null == C ? void 0 : C.chain) ? [Oje(C, U, null, C.baseToken.deployer ? ng(C.baseToken.deployer) : null, C.marketAddress ? ng(C.marketAddress) : null, L, C.baseToken.address ? ng(C.baseToken.address) : null, C.chain, $we(I || null), g, x, b, R, a, s, T), !1] : [null, !0]), [U, C, L, I, g, x, b, R, a, s, T])
      , {hiddenColumnsKeys: V, isModalOpen: H, openModal: z, closeModal: $, setHiddenColumnsKeys: G} = EZ(u)
      , {t: q} = we()
      , [K,Y] = Mx(p, Eje)
      , [X,Q,Z,J,ee,te,ne] = y.useMemo(( () => [!!K[kje], !!K[Cje], !!K[Aje], !!K[wje], !!K[jje], !!K[Tje], !!K[Ije]]), [K])
      , re = y.useMemo(( () => ( (e, t) => e.filter((e => !t.includes(e.field ?? ""))))(( (e, t, n, r, a, s, o, l, i, c, d, u, p) => [Sje({
        key: "rank",
        t: e
    }), Sje({
        key: "address",
        tableAddressMode: r,
        onFilterCallback: a,
        showWhaleIndicator: c,
        showTradesCount: d,
        showTradingApp: u,
        showPnlBasedColor: p,
        t: e
    }), Sje({
        key: "nativeBalance",
        chain: t,
        t: e
    }), Sje({
        key: "totalBoughtUsd",
        currencyMode: i,
        t: e
    }), Sje({
        key: "totalSoldUsd",
        currencyMode: i,
        t: e
    }), Sje({
        key: "pnlInUsd",
        currencyMode: i,
        t: e
    }), Sje({
        key: "holdingSince",
        t: e
    }), Sje({
        key: "remainingPlaceholder",
        showRemainingValue: s,
        showRemainingAmount: o,
        showRemainingProgress: l,
        currencyMode: i,
        t: e
    }), Sje({
        key: "fundedBy",
        t: e
    }), Sje({
        key: "lastActivityTs",
        openSettings: n,
        t: e
    })])(q, (null == C ? void 0 : C.chain) ?? null, z, E, o, X, Q, Z, N, J, ee, te, ne), V)), [q, null == C ? void 0 : C.chain, z, E, o, X, Q, Z, V, N, J, ee, te, ne]);
    return v.jsxs(S, {
        height: "100%",
        children: [v.jsx(yQ, {
            rowData: W,
            isLoading: F,
            columnDefs: re,
            getRowUniqueId: Bje,
            rowHeight: _je,
            columnsConfigStorageKey: d
        }), v.jsx(jZ, {
            customizableColumnsKeys: yje,
            hiddenColumnsKeys: V,
            isModalOpen: H,
            closeModal: $,
            setHiddenColumnsKeys: G,
            keysLabelsLookup: fje,
            label: q("Customize {{customizeLabel}}", {
                customizeLabel: i
            }),
            tableAddressMode: E,
            setTableAddressMode: M,
            customFlagsConfig: Mje,
            customFlags: K,
            setCustomFlags: Y,
            currencyMode: N,
            setCurrencyMode: P,
            extraFlagColumns: Nje
        })]
    })
}
  , Bje = e => e.address
  , _je = 44
  , Uje = y.memo(( ({focusedWalletGroupAddresses: e, focusedWalletGroupAddressesLoading: t, onFilterCallback: n}) => {
    const {originalMarketId: r, originalStaticMarketInfo: a} = Qce()
      , {focusedTraders: s} = jwe()
      , o = (null == a ? void 0 : a.baseToken.address) ?? null
      , l = Tve(o)
      , {data: i} = Hwe(r, l, null);
    return v.jsx(Dje, {
        focusedTraders: s,
        focusedWalletGroupAddresses: e,
        focusedWalletGroupAddressesLoading: t,
        holdersState: i,
        pnlSort: !1,
        skipEmpty: !0,
        onFilterCallback: n,
        mode: bje.HOLDERS
    })
}
))
  , Wje = y.memo(( ({focusedWalletGroupAddresses: e, focusedWalletGroupAddressesLoading: t, isQuote: n, onFilterCallback: r}) => {
    const {originalMarketId: a, originalStaticMarketInfo: s} = Qce()
      , {focusedTraders: o} = jwe()
      , {baseTokenAddress: l, topTraders: i, requestData: c} = y.useContext(Eve)
      , d = l && l === (null == s ? void 0 : s.baseToken.address) ? i : null
      , {data: u} = Hwe(a, d, null);
    return y.useEffect(( () => {
        n || c()
    }
    ), [c, n]),
    n ? v.jsx(S, {
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            textAlign: "center",
            children: "Top traders not available for stable and native currencies"
        })
    }) : v.jsx(Dje, {
        focusedTraders: o,
        focusedWalletGroupAddresses: e,
        focusedWalletGroupAddressesLoading: t,
        holdersState: u,
        pnlSort: !0,
        skipEmpty: !1,
        onFilterCallback: r,
        mode: bje.TOP_TRADERS
    })
}
))
  , Fje = y.memo(( ({focusedWalletGroupAddresses: e, focusedWalletGroupAddressesLoading: t, onFilterCallback: n}) => {
    const {originalStaticMarketInfo: r} = Qce()
      , [a,s] = Mx("padreV2-holdersSplitBubblemapVisible", !1)
      , o = y.useCallback((e => {
        e.stopPropagation(),
        s((e => !e))
    }
    ), [s])
      , l = y.useMemo(( () => v.jsx(Uje, {
        focusedWalletGroupAddresses: e,
        focusedWalletGroupAddressesLoading: t,
        onFilterCallback: n
    })), [e, n, t]);
    return v.jsxs(S, {
        height: "100%",
        width: "100%",
        position: "relative",
        sx: Gje,
        children: [a ? v.jsxs($n, {
            direction: "horizontal",
            autoSaveId: "padreV2-holdersBubblemapPanes",
            children: [v.jsx(Gn, {
                id: "holders",
                order: 1,
                defaultSize: 80,
                minSize: 15,
                children: l
            }), v.jsxs(C, {
                position: "relative",
                display: "flex",
                alignItems: "center",
                children: [v.jsx(C, {
                    zIndex: 1241,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    children: v.jsx(C, {
                        position: "absolute",
                        onClick: o,
                        top: Vje,
                        sx: zje,
                        children: v.jsx(Cy, {})
                    })
                }), v.jsx(qn, {
                    className: $je
                })]
            }), v.jsx(Gn, {
                id: "bubblemap",
                order: 2,
                defaultSize: 20,
                minSize: 15,
                children: v.jsx(QCe, {
                    chain: (null == r ? void 0 : r.chain) ?? null,
                    contractAddress: (null == r ? void 0 : r.baseToken.address) ?? null
                })
            })]
        }) : l, !a && v.jsx(C, {
            position: "absolute",
            zIndex: 1,
            onClick: o,
            top: Vje,
            right: 0,
            sx: Hje,
            children: v.jsx(RS, {})
        })]
    })
}
))
  , Vje = 60
  , Hje = e => ({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: e.palette.background.buttonDefault,
    borderTopLeftRadius: 6,
    borderBottomLeftRadius: 6,
    width: 20,
    height: 38,
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonHover
    }
})
  , zje = e => ({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: e.palette.background.buttonDefault,
    borderRadius: 1,
    width: 20,
    height: 38,
    pointerEvents: "auto",
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        cursor: "pointer",
        background: e.palette.background.buttonHover
    }
})
  , $je = "resize-handle-holders-class"
  , Gje = e => ({
    [`.${$je}`]: {
        background: e.palette.divider,
        position: "relative",
        width: "4px",
        height: "100%",
        transition: "background 100ms ease",
        zIndex: zw,
        "&::before": {
            content: '""',
            position: "absolute",
            top: "50%",
            left: "2px",
            transform: "translate(-50%, -50%)",
            width: "2px",
            height: "2px",
            borderRadius: "50%",
            background: e.palette.text.label,
            zIndex: 1239,
            boxShadow: `\n    0 -4px 0 0 ${e.palette.text.label},\n    0 4px 0 0 ${e.palette.text.label}\n  `
        },
        "&:hover": {
            background: e.palette.text.primary
        }
    }
})
  , qje = y.memo(( () => {
    const {history: e} = fz()
      , t = pK()
      , {userStats: n} = rH()
      , r = y.useMemo(( () => {
        const t = Yje(n)
          , r = Xje(e);
        return `${RC}${r ?? "/"}${t ? `?${Sbe}=${t}` : ""}`
    }
    ), [e, n])
      , a = y.useCallback(( () => {
        ZC(r),
        t({
            message: mu("Link"),
            type: "success"
        }, "clipboard-save-success")
    }
    ), [r, t]);
    return QC ? v.jsx(S, {
        direction: "row",
        alignItems: "center",
        gap: .5,
        sx: Kje,
        onClick: a,
        children: v.jsx(AS, {
            color: "inherit",
            size: Qje
        })
    }) : null
}
))
  , Kje = e => ({
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.primary.main,
        cursor: "pointer"
    }
})
  , Yje = e => e.status !== ox.READY ? null : "kol" === e.data.type ? e.data.kolName : null
  , Xje = e => {
    if (!e.length)
        return null;
    const t = e.sort(( (e, t) => t.seenAtTs - e.seenAtTs))[0];
    return `${tT.TRADE}/${eg(t.chain)}/${mg(t.marketId).marketAddress}`
}
  , Qje = 16
  , Zje = y.memo(( ({tooltipTitle: e}) => v.jsx(GC, {
    title: e,
    children: v.jsx(C, {
        sx: Jje,
        children: v.jsx(k, {
            variant: "paragraph3",
            fontSize: 10,
            color: "inherit",
            children: "beta"
        })
    })
})))
  , Jje = e => ({
    display: "flex",
    alignItems: "center",
    borderRadius: 6,
    border: `1px solid ${e.palette.lavender[500]}`,
    color: e.palette.lavender[500],
    background: `${e.palette.lavender[500]}20`,
    px: .75,
    height: 18,
    "&:hover": {
        cursor: "help"
    }
})
  , eTe = y.memo(( () => {
    const {pnlImageData: e} = TSe();
    return e ? v.jsx(i4, {
        imageData: e,
        iconSize: tTe,
        onlyIcon: !0,
        padding: .5
    }) : null
}
))
  , tTe = 16
  , nTe = [Rc.BOOP, Rc.PUMP_FUN, Rc.METEORA_CURVE, Rc.LAUNCH_LAB, Lc.FOUR_MEME]
  , rTe = y.memo(( ({marketInfo: e}) => {
    const t = D()
      , n = xw()
      , {t: r, i18n: a} = we()
      , s = y.useMemo(( () => (null == e ? void 0 : e.baseToken) || null), [e])
      , o = yde()
      , l = kde()
      , i = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.translations) ?? null
    }
    ), c.isEqual)
      , {hiddenMigratedPairs: d, hiddenPairs: u} = SX()
      , p = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.isPermissioned) ?? null
    }
    ), c.isEqual)
      , h = y.useMemo(( () => {
        if (!e)
            return !1;
        const t = kX(e.baseToken.address, e.chain);
        return !!d && !!d[t] || !!u && !!u[t]
    }
    ), [d, u, e])
      , m = Ide()
      , {originalMarketId: g} = Qce()
      , {data: x} = Hwe(g, Tde(), null)
      , b = y.useMemo(( () => {
        var e;
        return (null == (e = null == x ? void 0 : x.pfArticles) ? void 0 : e.length) ? x.pfArticles.sort(( (e, t) => t.createdAt - e.createdAt))[0].articleId : null
    }
    ), [null == x ? void 0 : x.pfArticles])
      , {settings: f} = rf()
      , A = y.useMemo(( () => (null == f ? void 0 : f.devBlacklist) ? new Set(f.devBlacklist) : new Set([])), [null == f ? void 0 : f.devBlacklist])
      , w = y.useMemo(( () => !(!e || !e.baseToken.deployer) && A.has(ng(e.baseToken.deployer))), [A, e])
      , j = y.useMemo(( () => (null == l ? void 0 : l.twitterUrl) ? Dee(null == l ? void 0 : l.twitterUrl) : null), [null == l ? void 0 : l.twitterUrl])
      , T = y.useMemo(( () => (null == f ? void 0 : f.handlesBlacklist) ? new Set(f.handlesBlacklist.map((e => e.toLowerCase()))) : new Set([])), [null == f ? void 0 : f.handlesBlacklist])
      , I = y.useMemo(( () => !!j && T.has(j.toLowerCase())), [T, j])
      , {openAddAlertModal: E} = Iue()
      , M = y.useCallback(( () => {
        e && E({
            chain: e.chain,
            address: ng(e.baseToken.address),
            symbol: e.baseToken.symbol,
            name: e.baseToken.name,
            marketId: fg(e.chain, e.marketAddress, null)
        })
    }
    ), [e, E])
      , N = n ? 42 : 38
      , P = y.useMemo(( () => (null == e ? void 0 : e.chain) ? l || {
        chain: e.chain,
        tokenAddress: e.baseToken.address,
        discordUrl: null,
        telegramUrl: null,
        projectWebsiteUrl: null,
        twitterUrl: null,
        farcasterUrl: null,
        twitterLaunchMetadata: null
    } : null), [l, null == e ? void 0 : e.chain, null == e ? void 0 : e.baseToken.address])
      , O = Boolean(null == P ? void 0 : P.dexscreenerUpdatedAt)
      , L = PA({
        refreshRate: 6e4,
        immediateRunAfterPageBecomesVisible: !0
    })
      , R = y.useMemo(( () => !!((null == o ? void 0 : o.approxLastBoostTs) && o.approxLastBoostTs + 86400 > L.unix())), [null == o ? void 0 : o.approxLastBoostTs, L])
      , B = y.useMemo(( () => ({
        width: N,
        height: N
    })), [N])
      , _ = y.useMemo(( () => ({
        minWidth: 40,
        maxWidth: {
            xs: 80,
            md: 150
        },
        ...(null == e ? void 0 : e.baseToken.deployedAt) ? {
            ":hover": {
                cursor: "help"
            }
        } : {}
    })), [null == e ? void 0 : e.baseToken.deployedAt])
      , U = e ? wA(e.baseToken.address, e.chain) : null
      , {translatedName: W, translatedSymbol: V} = y.useMemo(( () => i ? jee(a.resolvedLanguage ?? null, i) : {
        translatedSymbol: null,
        translatedName: null
    }), [i, a.resolvedLanguage]);
    return v.jsxs(S, {
        overflow: "hidden",
        "data-testid": "token-info",
        direction: "row",
        gap: 1.25,
        minWidth: n ? aTe : void 0,
        minHeight: 56,
        sx: sTe,
        flexGrow: 1,
        ml: n ? -.25 : -.5,
        children: [v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            ml: .5,
            children: s && e ? v.jsx(Ote, {
                name: s.symbol ?? "?",
                tokenAddress: s.address,
                avatarSize: N,
                progressBarGap: 3,
                padreAvatarUrl: (null == P ? void 0 : P.padreAvatarUrl) ?? null,
                isAvatarReused: !1,
                curveProgress: 0,
                hasBonded: !!m,
                chain: e.chain,
                shape: Pte.SQUARE,
                protocol: e.protocol,
                launchpad: e.launchpad,
                launchpadAux: e.launchpadAux,
                devAddress: e.baseToken.deployer ?? "",
                isHidden: h,
                isBlacklisted: w,
                isHandleBlacklisted: I,
                twitterHandle: j,
                subtleBorder: !0,
                migrationHide: !!m,
                protocolMarkerSize: 13,
                protocolMarkerOffset: 5,
                protocolMarkerInnerIconSize: 9,
                cornerButtons: !0,
                actionButtonSize: c_.SMALL
            }) : v.jsx(Ie, {
                variant: "rectangular",
                sx: B
            })
        }), e && v.jsxs(S, {
            direction: "column",
            justifyContent: "center",
            pt: .25,
            gap: .25,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                width: "100%",
                children: [v.jsx(GC, {
                    title: (null == e ? void 0 : e.baseToken) ? v.jsxs(S, {
                        gap: .5,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            ...Nu,
                            children: e.baseToken.name
                        }), W && W !== e.baseToken.name && v.jsx(k, {
                            variant: "paragraph3",
                            color: t.palette.yellow[500],
                            ...Nu,
                            children: W
                        })]
                    }) : "",
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "flex-end",
                        gap: .5,
                        position: "relative",
                        children: [v.jsxs(k, {
                            variant: "h2",
                            color: "text.main",
                            sx: _,
                            ...Nu,
                            noWrap: !0,
                            children: [(null == s ? void 0 : s.symbol) ?? Ud, "/", (null == e ? void 0 : e.quoteToken.symbol) ?? Ud]
                        }), V && V !== (null == e ? void 0 : e.baseToken.symbol) && v.jsx(k, {
                            variant: "paragraph3",
                            color: t.palette.yellow[500],
                            sx: lTe,
                            noWrap: !0,
                            ...Nu,
                            children: V
                        })]
                    })
                }), v.jsx(wR, {
                    isPermissioned: p,
                    omitAggregator: !0,
                    isDexPaid: O,
                    isDexBoosted: R,
                    tokenAddress: (null == e ? void 0 : e.baseToken.address) || null,
                    showBoopLink: "boop" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Rc.BOOP,
                    showPumpfunLink: "pumpfun" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Rc.PUMP_FUN,
                    showFourmemeLink: "fourmeme" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Lc.FOUR_MEME,
                    showBagsLink: ("meteora-curve" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Rc.METEORA_CURVE) && "bags" === (null == e ? void 0 : e.launchpadAux),
                    showBelieveLink: ("meteora-curve" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Rc.METEORA_CURVE) && "believe" === (null == e ? void 0 : e.launchpadAux),
                    showLaunchlabLink: "launchlab" === (null == e ? void 0 : e.launchpad) || (null == e ? void 0 : e.protocol.type) === Rc.LAUNCH_LAB,
                    showBonkLink: "bonk" === (null == e ? void 0 : e.launchpadAux),
                    showDaosLink: "daos" === (null == e ? void 0 : e.launchpadAux),
                    tokenSocials: P,
                    marketAddress: null == e ? void 0 : e.marketAddress,
                    deployerAddress: (null == e ? void 0 : e.baseToken.deployer) ?? null,
                    pumpFunNewsArticleId: b,
                    iconSize: iTe,
                    mayhemUntilTs: (null == x ? void 0 : x.mayhemActiveUntilTs) ?? void 0,
                    isConfirmedBot: null == x ? void 0 : x.isConfirmedBot
                }), v.jsx(S, {
                    alignItems: "center",
                    justifyContent: "center",
                    gap: .25,
                    mt: n ? .25 : 0,
                    pl: .5,
                    children: v.jsx(x$, {
                        chain: e.chain,
                        tokenAddress: e.baseToken.address
                    })
                }), v.jsx(GC, {
                    title: r("Add price alert"),
                    children: v.jsx(F, {
                        onClick: M,
                        sx: oTe,
                        children: v.jsx(My, {
                            color: "inherit"
                        })
                    })
                }), e.chain === Pd.BSC && v.jsx(Zje, {
                    tooltipTitle: r("BSC support currently available in beta - some features may be limited.")
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                ml: !(null == e ? void 0 : e.baseToken.deployedAt) && e ? -.5 : 0,
                children: [!!(null == e ? void 0 : e.baseToken.deployedAt) && v.jsx(s$, {
                    createdAt: e.baseToken.deployedAt,
                    aggregatorUrl: U ?? void 0
                }), e && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(wG, {
                        address: e.baseToken.address,
                        customName: e.baseToken.name,
                        maxWidth: 200
                    }), W && W !== e.baseToken.name && v.jsx(k, {
                        variant: "paragraph3",
                        color: t.palette.yellow[500],
                        sx: lTe,
                        noWrap: !0,
                        ...Nu,
                        children: W
                    })]
                }), v.jsx(qje, {}), v.jsx(C, {
                    display: "flex",
                    mt: "-1px",
                    children: v.jsx(eTe, {})
                })]
            })]
        })]
    })
}
))
  , aTe = 360
  , sTe = {
    height: "100%"
}
  , oTe = e => ({
    color: e.palette.text.label,
    p: "1px",
    "&:hover": {
        color: e.palette.primary.main,
        background: "transparent"
    }
})
  , lTe = {
    maxWidth: {
        xs: 60,
        md: 150
    }
}
  , iTe = 16
  , cTe = (e, t=!1) => !e || isNaN(e) ? t ? "text.value" : "text.label" : e < dTe ? t ? "success.main" : "text.value" : e < uTe ? "warning.main" : "error.main"
  , dTe = 5
  , uTe = 25
  , pTe = y.memo(( ({label: e, tooltipTitle: t}) => {
    const n = y.useMemo(( () => t ? {
        "&:hover": {
            color: "text.value",
            cursor: "help"
        }
    } : {}), [t]);
    return v.jsx(z, {
        title: t || "",
        children: v.jsx(k, {
            color: "text.label",
            variant: "paragraph3",
            sx: n,
            fontWeight: 400,
            height: 16,
            children: e
        })
    })
}
))
  , hTe = y.memo(( ({label: e, value: t, tooltipTitle: n, minWidth: r}) => {
    const a = bw();
    return v.jsxs(S, {
        alignItems: "left",
        justifyContent: null === e ? "center" : "space-between",
        px: null === e ? .25 : .5,
        pt: null === e ? .5 : 0,
        gap: a ? .5 : .25,
        width: "100%",
        minWidth: r ?? (a ? gTe : xTe),
        children: [null !== e && v.jsx(pTe, {
            label: e,
            tooltipTitle: n
        }), v.jsx(k, {
            sx: bTe,
            variant: a ? "h2" : "paragraph3",
            lineHeight: null === e ? "20px" : "16px",
            fontSize: null === e ? 20 : 14,
            color: "text.main",
            ...Nu,
            children: t
        })]
    })
}
))
  , mTe = y.memo(y.forwardRef((function({label: e, value: t, tooltipTitle: n, minWidth: r}, a) {
    const s = bw();
    return v.jsxs(S, {
        alignItems: "left",
        justifyContent: null === e ? "center" : "space-between",
        px: null === e ? .25 : .5,
        pt: null === e ? .5 : 0,
        gap: s ? .5 : .25,
        width: "100%",
        minWidth: r ?? (s ? gTe : xTe),
        children: [null !== e && v.jsx(pTe, {
            label: e,
            tooltipTitle: n
        }), v.jsx(k, {
            sx: bTe,
            variant: s ? "h2" : "paragraph3",
            lineHeight: null === e ? "16px" : "14px",
            fontSize: null === e ? 16 : 14,
            color: "text.main",
            ...Nu,
            ref: a,
            children: t
        })]
    })
}
)))
  , gTe = 85
  , xTe = 75
  , bTe = {
    display: "flex",
    alignItems: "center"
}
  , fTe = y.memo(( ({label: e, prcValue: t, url: n}) => {
    const r = v.jsx(k, {
        variant: "labelLarge",
        color: "text.primary",
        children: e
    });
    return v.jsxs(S, {
        gap: .25,
        width: "100%",
        children: [n ? v.jsx(zC, {
            href: n,
            nofollow: !0,
            sx: {
                color: "inherit",
                textDecorationColor: "inherit"
            },
            children: r
        }) : r, v.jsxs(S, {
            direction: "row",
            width: "100%",
            gap: .5,
            children: [v.jsx(k, {
                variant: "bodyMediumLarge",
                sx: {
                    width: vTe
                },
                children: null !== t ? jI(t, {
                    omitSign: !0
                }) : Ud
            }), v.jsx(Z, {
                disabled: null === t,
                value: t || 0,
                max: 100,
                sx: e => ({
                    mt: .25,
                    "&.MuiSlider-root": {
                        paddingY: .5
                    },
                    "& .MuiSlider-thumb": {
                        display: "none"
                    },
                    "& .MuiSlider-rail": {
                        height: STe,
                        color: e.palette.text.meta
                    },
                    "& .MuiSlider-track": {
                        color: e.palette.positive.main,
                        height: STe,
                        border: "none",
                        transitionProperty: "left, bottom, width, height, color"
                    },
                    "&:hover": {
                        cursor: "auto"
                    },
                    "&.Mui-disabled": {
                        "& .MuiSlider-track": {
                            color: e.palette.text.meta,
                            transitionProperty: "left, bottom, width, height, color",
                            transitionDuration: "300ms"
                        }
                    }
                })
            })]
        })]
    })
}
))
  , vTe = 70
  , STe = 6
  , yTe = Ec("0xe2fe530c047f2d85298b07d9333c05737f1435fb")
  , kTe = Ec("0x71b5759d73262fbb223956913ecf4ecc51057641")
  , CTe = (e, t, n) => {
    if (t)
        switch (e) {
        case fp.UNCX:
            {
                const e = ATe(n);
                if (null === e)
                    return;
                return `https://beta.uncx.network/lockers/univ2/chain/${e}/address/${t}`
            }
        case fp.TEAM_FINANCE:
            if (n !== Pd.ETH_MAINNET)
                return;
            return `https://etherscan.io/token/${t}?a=${yTe}`;
        case fp.PINK_LOCK:
            if (n !== Pd.ETH_MAINNET)
                return;
            return `https://etherscan.io/token/${t}?a=${kTe}`;
        default:
            return
        }
}
  , ATe = e => e && e === Pd.ETH_MAINNET ? 1 : null
  , wTe = e => {
    switch (e) {
    case fp.UNCX:
        return "UNCX";
    case fp.TEAM_FINANCE:
        return "TeamFinance";
    case fp.PINK_LOCK:
        return "PinkLock";
    default:
        return e
    }
}
  , jTe = y.memo(( ({lockedPcnt: e, protocol: t, burnedLiquidityPcnt: n, marketAddress: r, chain: a}) => {
    const {t: s} = we()
      , o = D()
      , {buttonProps: l, popoverProps: i} = Fw({
        id: "liquidity-lock-popover"
    })
      , c = y.useMemo(( () => Math.min(100, (e || 0) + (n || 0))), [n, e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(V, {
            ...l,
            variant: "tertiary",
            sx: {
                border: "none",
                p: 0,
                mt: "-2px",
                height: TTe,
                width: TTe,
                minWidth: TTe,
                backgroundColor: "transparent",
                "&:hover": {
                    backgroundColor: "transparent"
                },
                "&:focus": {
                    backgroundColor: "transparent"
                }
            },
            children: v.jsxs(C, {
                sx: {
                    position: "relative",
                    display: "inline-block",
                    "&:hover": {
                        cursor: "pointer"
                    }
                },
                height: TTe,
                children: [v.jsx(J, {
                    "data-testid": "background-circular-progress",
                    variant: "determinate",
                    sx: e => ({
                        color: `${e.palette.green[900]}99`
                    }),
                    size: TTe,
                    thickness: ETe,
                    value: 100
                }), v.jsx(J, {
                    "data-testid": "controlled-circular-progress",
                    size: TTe,
                    variant: "determinate",
                    value: c,
                    thickness: ETe,
                    sx: e => ({
                        color: e.palette.positive.main,
                        position: "absolute",
                        left: 0
                    })
                }), v.jsx(C, {
                    display: "flex",
                    "data-testid": "lock-icon",
                    sx: {
                        position: "absolute",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%, -50%)",
                        fontSize: ITe
                    },
                    children: v.jsx(vk, {
                        size: ITe,
                        color: o.palette.positive.main
                    })
                })]
            })
        }), v.jsx(ae, {
            ...i,
            disablePortal: !0,
            onClick: e => {
                e.stopPropagation()
            }
            ,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            sx: {
                transform: `translateY(${NTe}px)`
            },
            children: v.jsx(ee, {
                elevation: 1,
                sx: e => ({
                    background: e.palette.background.tertiary,
                    overflow: "auto",
                    p: 1.75,
                    borderRadius: 1
                }),
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    gap: 1.75,
                    width: MTe,
                    children: [v.jsx(fTe, {
                        label: s("Total locked liquidity"),
                        prcValue: c
                    }), v.jsx(fTe, {
                        label: s("Burned"),
                        prcValue: n
                    }), t && v.jsx(fTe, {
                        label: wTe(t),
                        prcValue: e,
                        url: CTe(t, r, a)
                    })]
                })
            })
        })]
    })
}
))
  , TTe = 18
  , ITe = 10
  , ETe = 4
  , MTe = 200
  , NTe = 6
  , PTe = y.memo(( ({liquidityUsd: e, liquidityLock: t, burnedLiquidityPcnt: n, marketAddress: r, chain: a}) => {
    const s = bw();
    return v.jsxs(S, {
        direction: "row",
        gap: .75,
        alignItems: s ? "flex-start" : "flex-end",
        children: [v.jsx(k, {
            component: "span",
            variant: "inherit",
            color: e < OTe ? "error.main" : e < LTe ? "warning.main" : "text.main",
            children: LI(e, {
                collapseExponent: !0,
                desiredDigits: 3,
                symbol: "$",
                padSymbol: !1,
                symbolPosition: yI.START
            })
        }), (t || !!n) && v.jsx(jTe, {
            lockedPcnt: (null == t ? void 0 : t.lockedPcnt) || null,
            protocol: (null == t ? void 0 : t.protocol) || null,
            unlocksAt: (null == t ? void 0 : t.unlocksAt) || null,
            burnedLiquidityPcnt: n,
            marketAddress: r,
            chain: a
        })]
    })
}
))
  , OTe = 1
  , LTe = 100
  , RTe = ({IconComponent: e, launchpadColors: t, launchpadCurveProgress: n}) => v.jsxs(C, {
    sx: {
        position: "relative",
        display: "inline-block",
        mt: "-2px",
        height: DTe
    },
    children: [v.jsx(J, {
        "data-testid": "background-circular-progress",
        variant: "determinate",
        sx: () => ({
            color: t[1]
        }),
        size: DTe,
        thickness: _Te,
        value: 100
    }), v.jsx(J, {
        "data-testid": "controlled-circular-progress",
        size: DTe,
        variant: "determinate",
        value: Math.max(0, Math.min(100, n)),
        thickness: _Te,
        sx: {
            color: t[0],
            position: "absolute",
            left: 0
        }
    }), v.jsx(C, {
        "data-testid": "lock-icon",
        sx: {
            display: "flex",
            alignItems: "center",
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: BTe,
            height: BTe
        },
        children: e ? v.jsx(e, {
            size: BTe
        }) : v.jsx(Dk, {
            size: BTe
        })
    })]
})
  , DTe = 18
  , BTe = 10
  , _Te = 4
  , UTe = y.memo(( () => {
    const e = y.useRef(null);
    y.useEffect(( () => {
        const t = (n = t => {
            e.current && (e.current.textContent = t)
        }
        ,
        Zce.subscribe((e => {
            var t;
            const n = (null == (t = e.marketStats) ? void 0 : t.basePriceInUsdUi) ?? null;
            return null === n ? null : "$" + LI(n)
        }
        ), ( (e, t) => {
            e !== t && n(e)
        }
        )));
        var n;
        return () => {
            t()
        }
    }
    ), []);
    const {t: t} = we();
    return v.jsx(mTe, {
        ref: e,
        label: t("Price"),
        value: ide() ?? "-"
    })
}
))
  , WTe = y.memo(( ({baseSymbol: e, quoteSymbol: t, marketAddress: n, chain: r}) => {
    const a = bde()
      , s = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.liquidityLock) ?? null
    }
    ), c.isEqual)
      , o = Mde()
      , {t: l} = we();
    return v.jsx(hTe, {
        label: l("Liquidity"),
        tooltipTitle: l("Value of {{base}} and {{quote}} available for trading on this market", {
            base: e,
            quote: t
        }),
        value: null === a ? v.jsx(KTe, {}) : v.jsx(PTe, {
            liquidityUsd: a,
            liquidityLock: s,
            burnedLiquidityPcnt: o,
            marketAddress: n,
            chain: r
        })
    })
}
))
  , FTe = new Intl.NumberFormat("en",{
    notation: "compact",
    maximumSignificantDigits: 3
})
  , VTe = y.memo(( () => {
    const e = bw()
      , t = vde()
      , n = Ade()
      , r = null !== t && null !== n ? Number(t) / 10 ** n : 0
      , {t: a} = we();
    return v.jsx(hTe, {
        minWidth: e ? 65 : 40,
        label: a("Supply"),
        value: FTe.format(r)
    })
}
))
  , HTe = y.memo(( () => {
    const e = y.useRef(null)
      , {t: t} = we();
    return y.useEffect(( () => {
        const t = (n = t => {
            e.current && (e.current.textContent = t)
        }
        ,
        Zce.subscribe((e => {
            const t = !e.marketStats || c.isNil(e.baseTokenDecimals) || c.isNil(e.marketStats.basePriceInUsdUi) || c.isNil(e.marketStats.baseTokenTotalSupply) ? null : new sB({
                decimals: e.baseTokenDecimals
            },BigInt(e.marketStats.baseTokenTotalSupply)).multiply(e.marketStats.basePriceInUsdUi).toNumber();
            return null === t ? null : LI(t, {
                collapseExponent: !0,
                symbol: "$",
                padSymbol: !1,
                symbolPosition: yI.START,
                desiredDigits: 3
            })
        }
        ), ( (e, t) => {
            e !== t && n(e)
        }
        )));
        var n;
        return () => {
            t()
        }
    }
    ), []),
    v.jsx(mTe, {
        ref: e,
        minWidth: 95,
        label: null,
        value: lde() ?? Ud,
        tooltipTitle: t("Fully diluted valuation is the total value of a token if the entire supply were in circulation")
    })
}
))
  , zTe = y.memo(( () => {
    const e = D()
      , {t: t} = we()
      , {originalStaticMarketInfo: n} = Qce()
      , r = hde(n)
      , a = wde()
      , s = jde()
      , o = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.isLikelyUntaxed) ?? null
    }
    ))
      , l = r && !!r.preMigrationMarketId
      , i = (e => !!(e && ([Rc.PUMP_FUN, Rc.METEORA_CURVE, Rc.METEORA_DAMM_V2, Rc.METEORA_DLMM].includes(e.protocol.type) || e.launchpadAux && ["bags", "bonk"].includes(e.launchpadAux) || "pumpfun" === e.launchpad)))(r)
      , d = r && (!Op(r) || "meteora-curve" === r.launchpad) && (!c.isNil(a) || !c.isNil(s)) && !(l && i) && "moonit" !== r.launchpad
      , u = Number(a ?? 0) > uTe || Number(s ?? 0) > uTe
      , p = "meteora-curve" === (null == r ? void 0 : r.launchpad) || 0 === Number(a ?? "0") && 0 === Number(s ?? "0");
    return d ? v.jsx(hTe, {
        label: v.jsxs(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "inherit",
                color: u ? "error.main" : "text.label",
                sx: {
                    transition: "200ms ease-in-out",
                    "&:hover": {
                        color: u ? "error.300" : "text.primary",
                        cursor: "help"
                    }
                },
                children: t(p ? "Tax" : "Taxes")
            }), u && v.jsx(S, {
                mt: "-2px",
                children: v.jsx(Ck, {
                    size: 14,
                    color: e.palette.error.main
                })
            })]
        }),
        value: a ? v.jsxs(S, {
            gap: 1,
            direction: "row",
            children: [v.jsx(k, {
                component: "span",
                variant: "inherit",
                color: cTe(c.isNil(a) || isNaN(Number(a)) ? null : Number(Number(a).toFixed(QTe))),
                children: c.isNil(a) ? o ? Ud : v.jsx(KTe, {
                    width: XTe
                }) : a ? jI(Number(a), {
                    omitSign: !0,
                    precision: QTe
                }) : Ud
            }), !p && v.jsx(Ee, {
                orientation: "vertical",
                flexItem: !0,
                sx: {
                    my: .25
                }
            }), !p && v.jsx(k, {
                component: "span",
                variant: "inherit",
                color: cTe(c.isNil(s) || isNaN(Number(s)) ? null : Number(Number(s).toFixed(QTe))),
                children: c.isNil(s) ? o ? Ud : v.jsx(KTe, {
                    width: XTe
                }) : s ? jI(Number(s), {
                    omitSign: !0,
                    precision: QTe
                }) : Ud
            })]
        }) : v.jsx(k, {
            variant: "inherit",
            children: Ud
        }),
        tooltipTitle: t(o ? "Unable to simulate taxes, token is likely deployed on markets that don't support buy and sell taxes" : "Portion of trade's size collected by the token owner at each swap")
    }) : null
}
))
  , $Te = y.memo(( () => {
    const {originalMarketId: e} = Qce()
      , {t: t} = we()
      , {data: n} = Hwe(e, Tde(), null);
    return n ? v.jsx(hTe, {
        label: v.jsx(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: v.jsx(k, {
                variant: "inherit",
                color: "text.label",
                children: t("Total Fees Paid")
            })
        }),
        minWidth: 100,
        value: v.jsxs(S, {
            gap: .25,
            direction: "row",
            alignItems: "center",
            children: [v.jsx(dk, {}), v.jsx(k, {
                component: "span",
                variant: "inherit",
                color: 0 === n.totalSolFees ? "text.label" : "text.value",
                children: 0 === n.totalSolFees ? "0" : LI(n.totalSolFees, {
                    collapseExponent: !0,
                    symbol: "",
                    maxPrecision: 3
                })
            })]
        })
    }) : null
}
))
  , GTe = y.memo(( () => {
    const e = bw()
      , t = D()
      , {t: n} = we()
      , r = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.launchpadCurveProgress) ?? null
    }
    ))
      , {originalStaticMarketInfo: a} = Qce()
      , s = hde(a)
      , o = !!s && Op(s)
      , l = !!s && !Op(s)
      , i = s ? v$(s.protocol.type, s.launchpad, s.launchpadAux, s.chain, l) : null
      , c = y.useMemo(( () => s ? RM(l, s.launchpadAux ?? s.launchpad, s.protocol.type ?? null, t) : null), [l, s, t]);
    return o && c ? v.jsx(hTe, {
        label: v.jsx(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            children: v.jsx(k, {
                variant: "inherit",
                color: "text.label",
                children: n("B. Curve")
            })
        }),
        value: null === r ? v.jsx(k, {
            variant: "inherit",
            children: Ud
        }) : v.jsxs(S, {
            gap: .75,
            direction: "row",
            alignItems: e ? "flex-start" : "flex-end",
            children: [v.jsx(k, {
                component: "span",
                variant: "inherit",
                color: c[0],
                children: jI(r, {
                    omitSign: !0,
                    precision: 0
                })
            }), v.jsx(RTe, {
                IconComponent: (null == i ? void 0 : i.Icon) ?? null,
                launchpadColors: c,
                launchpadCurveProgress: r
            })]
        })
    }) : null
}
))
  , qTe = y.memo((e => {
    const {originalStaticMarketInfo: t} = Qce()
      , n = hde(t);
    if (!n)
        return v.jsx(S, {
            height: ZTe
        });
    const r = n.baseToken.symbol
      , a = n.quoteToken.symbol;
    return v.jsxs(S, {
        flex: 1,
        "data-testid": "token-stats",
        direction: "row",
        height: ZTe,
        gap: JTe,
        ml: eIe,
        mr: tIe,
        pr: nIe,
        ...e,
        children: [v.jsx(HTe, {}), v.jsx(UTe, {}), v.jsx(WTe, {
            baseSymbol: r,
            chain: (null == n ? void 0 : n.chain) ?? null,
            marketAddress: (null == n ? void 0 : n.marketAddress) ?? null,
            quoteSymbol: a
        }), v.jsx(VTe, {}), v.jsx($Te, {}), v.jsx(zTe, {}), v.jsx(GTe, {})]
    })
}
))
  , KTe = ({width: e=YTe}) => v.jsx(k, {
    variant: "inherit",
    children: v.jsx(Ie, {
        width: e,
        variant: "rounded"
    })
})
  , YTe = 65
  , XTe = 16
  , QTe = 1
  , ZTe = 33
  , JTe = {
    xs: .25,
    xl: .75
}
  , eIe = {
    xs: -1,
    md: 0
}
  , tIe = {
    xs: -2,
    md: 0
}
  , nIe = {
    xs: 0,
    md: 1.5
}
  , rIe = y.memo(( ({selectedPreset: e, onClose: t, chain: n}) => {
    const {setSelectedPreset: r} = QSe()
      , {settings: a} = rf()
      , {openEditModal: s} = QSe()
      , o = y.useCallback((e => {
        r(e),
        t()
    }
    ), [t, r])
      , l = y.useCallback(( () => {
        o("Inferno")
    }
    ), [o])
      , [i,c] = y.useMemo(( () => {
        const e = ((null == a ? void 0 : a.orderPresets) || Bx)[n] || Bx[n];
        return [e[xc.BUY] || Bx[n][xc.BUY], e[xc.SELL] || Bx[n][xc.SELL]]
    }
    ), [n, null == a ? void 0 : a.orderPresets])
      , d = y.useMemo(( () => $b.includes(n)), [n])
      , u = y.useCallback(( () => {
        s(),
        t()
    }
    ), [s, t]);
    return v.jsxs(S, {
        minHeight: aIe,
        gap: 2,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "h1",
                color: "text.value",
                children: "Select preset"
            }), v.jsx(F, {
                onClick: u,
                sx: sIe,
                children: v.jsx(Ny, {
                    size: 18
                })
            })]
        }), v.jsxs(S, {
            divider: v.jsx(Ee, {
                flexItem: !0
            }),
            children: [lIe.map((t => {
                const r = e === t
                  , a = i && i[t] || Bx[n][xc.BUY][t]
                  , s = c && c[t] || Bx[n][xc.SELL][t];
                return v.jsxs(te, {
                    sx: oIe,
                    onClick: () => {
                        o(t)
                    }
                    ,
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: 1,
                        children: [v.jsx(kH, {
                            preset: t
                        }), v.jsxs(S, {
                            gap: .5,
                            children: [v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                children: [v.jsx(k, {
                                    variant: "paragraph1",
                                    color: "success.main",
                                    children: "Buy"
                                }), v.jsx(gM, {
                                    presetValues: a,
                                    isTooltip: !1,
                                    chain: n
                                })]
                            }), v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1,
                                children: [v.jsx(k, {
                                    variant: "paragraph1",
                                    color: "error.main",
                                    children: "Sell"
                                }), v.jsx(gM, {
                                    presetValues: s,
                                    isTooltip: !1,
                                    chain: n
                                })]
                            })]
                        })]
                    }), v.jsx(UR, {
                        checked: r
                    })]
                }, t)
            }
            )), d && v.jsxs(te, {
                sx: oIe,
                onClick: l,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    children: [v.jsx(kH, {
                        preset: "Inferno"
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "originalPrimary.main",
                        children: "Inferno mode"
                    })]
                }), v.jsx(UR, {
                    checked: "Inferno" === e
                })]
            })]
        })]
    })
}
))
  , aIe = 200
  , sIe = {
    p: .5,
    width: 26,
    height: 26
}
  , oIe = {
    height: 32,
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 1,
    py: .25,
    mx: -1.5,
    pl: 1
}
  , lIe = [zh.NORMAL, zh.FAST, zh.ULTRA]
  , iIe = y.memo(( ({onClick: e, tradeSide: t, baseAddress: n, baseDecimals: r, quoteAddress: a, quoteDecimals: s, chain: o, protocol: l}) => {
    const {selectedWalletsAddresses: i, compatibleWallets: d} = Gde()
      , u = kde()
      , p = y.useMemo(( () => d && null !== r && null !== s ? i.length ? c.reduce(d, ( (e, n) => {
        if (!i.includes(ng(n.wallet.publicAddress)))
            return e;
        const o = t === xc.BUY ? n.balances.quoteForExecution : n.balances.base
          , c = t === xc.BUY ? l && ooe.includes(l.type) && a && Ej(a) ? kU : s : r;
        return e += new sB({
            decimals: c
        },BigInt(o.rawAmount ?? "0")).toNumber()
    }
    ), 0) : 0 : null), [r, d, l, a, s, i, t])
      , h = y.useMemo(( () => {
        const e = t === xc.BUY ? a : n;
        if (!e || !o)
            return null;
        if (ru(e) || l && ooe.includes(l.type) && Ej(e)) {
            const e = vz(o, !1);
            return e ? v.jsx(C, {
                display: "flex",
                children: v.jsx(e, {
                    size: hIe
                })
            }) : null
        }
        return v.jsx(C, {
            mt: "1px",
            display: "flex",
            children: v.jsx(b_, {
                size: hIe,
                url: IE(o, e),
                name: e,
                chain: o,
                padreAvatarUrl: (null == u ? void 0 : u.padreAvatarUrl) ?? null,
                protocolInfo: null,
                alwaysShowBorder: !0,
                hideHoverAvatar: !0,
                hideBorder: !0
            })
        })
    }
    ), [n, null == u ? void 0 : u.padreAvatarUrl, o, l, a, t]);
    return v.jsx(V, {
        sx: uIe,
        size: "xxsmall",
        variant: "tertiary",
        onClick: e,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            height: dIe,
            gap: .5,
            children: [v.jsx(iy, {
                size: pIe
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "inherit",
                noWrap: !0,
                textAlign: "start",
                sx: cIe,
                children: i.length
            }), h, v.jsx(k, {
                variant: "paragraph3",
                color: "inherit",
                noWrap: !0,
                children: null === p ? Ud : LI(p, {
                    collapseExponent: !0
                })
            })]
        })
    })
}
))
  , cIe = {
    minWidth: 12
}
  , dIe = 16
  , uIe = {
    height: 30,
    borderRadius: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-start",
    px: .5,
    maxWidth: 120
}
  , pIe = 14
  , hIe = 16
  , mIe = y.memo(( ({chain: e, onClose: t}) => {
    const n = kde();
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "h1",
                color: "text.value",
                children: "Wallets"
            }), v.jsx(F, {
                onClick: t,
                sx: gIe,
                children: v.jsx(kS, {
                    size: 18
                })
            })]
        }), v.jsx(mye, {
            chain: e,
            padreAvatarUrl: (null == n ? void 0 : n.padreAvatarUrl) ?? null,
            walletSelectMode: eye.TABLE
        })]
    })
}
))
  , gIe = {
    p: .5,
    width: 26,
    height: 26
}
  , xIe = zh.NORMAL
  , bIe = y.memo(( ({toggleInstantMode: e}) => {
    const {setLastViewedSide: t} = _H()
      , {originalStaticMarketInfo: n} = Qce()
      , r = hde(n)
      , [a,s] = y.useState(!1)
      , o = y.useCallback(( () => {
        s((e => !e))
    }
    ), [])
      , [l,i] = y.useState(xc.BUY)
      , c = y.useCallback(( (e, n) => {
        const r = n;
        i(r),
        t(r)
    }
    ), [i, t])
      , {selectedPreset: d} = QSe()
      , u = y.useMemo(( () => d ?? xIe), [d])
      , [p,h] = y.useState(!1)
      , m = y.useCallback(( () => {
        h(!1)
    }
    ), [])
      , g = y.useCallback(( () => {
        h(!0)
    }
    ), [])
      , [x,b] = y.useState(!1)
      , f = y.useCallback(( () => {
        b(!1)
    }
    ), [])
      , A = y.useCallback(( () => {
        b(!0)
    }
    ), [])
      , [w,j] = dx(NCe, !1)
      , T = y.useCallback(( () => {
        j((e => !e))
    }
    ), [j])
      , I = y.useMemo(( () => !!n && (ru(n.quoteToken.address) && n.chain === Pd.SOLANA && l === xc.SELL && (null == r ? void 0 : r.protocol.type) !== Rc.METEORA_CURVE)), [n, l, null == r ? void 0 : r.protocol.type]);
    return v.jsxs(S, {
        gap: 2.25,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            gap: .5,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                children: [v.jsx(iIe, {
                    tradeSide: l,
                    onClick: A,
                    baseAddress: (null == n ? void 0 : n.baseToken.address) ?? null,
                    baseDecimals: (null == n ? void 0 : n.baseToken.decimals) ?? null,
                    quoteAddress: (null == n ? void 0 : n.quoteToken.address) ?? null,
                    quoteDecimals: (null == n ? void 0 : n.quoteToken.decimals) ?? null,
                    chain: (null == n ? void 0 : n.chain) ?? null,
                    protocol: (null == n ? void 0 : n.protocol) ?? null
                }), v.jsx(C, {
                    component: "span",
                    display: "flex",
                    children: v.jsx(V, {
                        variant: "tertiary",
                        size: "xxsmall",
                        onClick: o,
                        sx: CIe,
                        children: a ? v.jsx(xy, {}) : v.jsx(Ky, {})
                    })
                }), I && v.jsx(F, {
                    onClick: T,
                    sx: SIe,
                    children: w ? v.jsx(dk, {}) : v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        children: "%"
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                gap: 1.5,
                children: [v.jsx(V, {
                    onClick: e,
                    sx: yIe,
                    size: "xsmall",
                    children: v.jsx(k, {
                        color: "text.label",
                        variant: "inherit",
                        sx: kIe,
                        children: "Limit orders"
                    })
                }), v.jsx(S, {
                    minWidth: 2 + 2 * fIe,
                    children: v.jsx(IH, {
                        size: "xsmall",
                        value: l,
                        onChange: c,
                        items: vIe,
                        minItemWidth: fIe
                    })
                })]
            })]
        }), v.jsx(ACe, {
            tradeSide: l,
            selectedPreset: u,
            shortcutsEnabled: !1,
            mobileMode: !0,
            openPresetSelectDrawer: g,
            sellNativeMode: w,
            toggleSellNativeMode: T,
            isInButtonValuesEditMode: a
        }), n && v.jsx(_R, {
            anchor: "bottom",
            open: p,
            onOpen: g,
            onClose: m,
            disableSwipeToOpen: !0,
            keepMounted: !1,
            children: v.jsx(jR, {
                isOpen: p,
                children: v.jsx(rIe, {
                    selectedPreset: u,
                    onClose: m,
                    chain: n.chain
                })
            })
        }), n && v.jsx(_R, {
            anchor: "bottom",
            open: x,
            onOpen: A,
            onClose: f,
            disableSwipeToOpen: !0,
            keepMounted: !1,
            children: v.jsx(jR, {
                isOpen: x,
                children: v.jsx(mIe, {
                    chain: n.chain,
                    onClose: f
                })
            })
        })]
    })
}
))
  , fIe = 40
  , vIe = [{
    value: xc.BUY,
    color: "positive",
    label: "Buy"
}, {
    value: xc.SELL,
    color: "negative",
    label: "Sell"
}]
  , SIe = {
    p: .5,
    width: 24,
    height: 24
}
  , yIe = {
    border: "none",
    p: 0,
    px: .25,
    backgroundColor: "transparent",
    "&:hover": {
        color: "text.main",
        backgroundColor: "transparent"
    },
    "&:focus": {
        backgroundColor: "transparent"
    }
}
  , kIe = {
    textDecoration: "underline",
    textDecorationStyle: "dotted"
}
  , CIe = e => ({
    p: 0,
    transition: "none",
    minWidth: 24,
    border: "none",
    background: "transparent",
    "&:focus": {
        border: "none",
        background: "transparent"
    },
    "&:hover": {
        border: "none",
        background: e.palette.background.buttonDefault
    }
})
  , AIe = y.memo(( ({toggleInstantMode: e}) => {
    const {originalStaticMarketInfo: t} = Qce();
    if (t)
        return v.jsx(bIe, {
            toggleInstantMode: e
        })
}
))
  , wIe = 2.5
  , jIe = (e, t, n) => {
    const [r,a] = y.useState({});
    return y.useEffect(( () => {
        let e = !1
          , r = null;
        const s = async () => {
            try {
                const r = (await rm.getMarketsWithPrices({
                    tokens: [{
                        chain: n,
                        tokenAddress: t
                    }]
                })).markets[n];
                e || a({
                    [TIe(n, t)]: r ? r[t] : null
                })
            } catch (fNe) {
                e || (r = setTimeout(( () => {
                    s()
                }
                ), IIe))
            }
        }
        ;
        return s(),
        () => {
            e = !0,
            r && clearTimeout(r)
        }
    }
    ), [n, t]),
    y.useMemo(( () => {
        if (!e)
            return null;
        const a = r[TIe(n, t)];
        return a ? ( (e, t, n) => {
            if (!e)
                return null;
            const r = e.filter((e => null !== e.buySlippagePcnt && null !== e.priceInUsd && null !== e.sellSlippagePcnt));
            if (!r.length)
                return null;
            const a = r.sort(( (e, t) => e.tradeSlippageSpread - t.tradeSlippageSpread))[0];
            if (a.marketId === t)
                return null;
            const s = r.find((e => e.marketId === t));
            return !s && n === Pd.SOLANA || s && !(a.tradeSlippageSpread < s.tradeSlippageSpread - wIe) ? null : a.marketId
        }
        )(a, e, n) : null
    }
    ), [n, e, r, t])
}
  , TIe = (e, t) => `${e}-${ng(t)}`
  , IIe = 5e3
  , EIe = y.memo(( ({protocol: e, chain: t, blur: n, isFreezeable: r, isFreezableAcknowledged: a, acknowledgeFreezeable: s, children: o}) => {
    const {t: l} = we()
      , i = D()
      , c = y.useMemo(( () => r && !a ? "FREEZEABLE" : "MIGRATION"), [a, r])
      , [d,u] = y.useState(!1)
      , p = y.useCallback(( () => {
        u((e => !e))
    }
    ), [u])
      , h = y.useCallback(( () => {
        s(d)
    }
    ), [s, d])
      , m = y.useMemo(( () => ({
        position: "relative",
        overflow: "hidden",
        m: `-${MIe}px`,
        "::before": n ? {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            zIndex: 1,
            pointerEvents: "none",
            borderRadius: "4px"
        } : void 0
    })), [n])
      , g = y.useMemo(( () => ({
        filter: n ? "blur(6px)" : "blur(0px)",
        pointerEvents: n ? "none" : "auto",
        p: `${MIe}px`
    })), [n])
      , x = y.useMemo(( () => ({
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        pointerEvents: n ? "auto" : "none"
    })), [n])
      , [b,f,A,w] = y.useMemo(( () => {
        switch (e.type) {
        case Rc.PUMP_FUN:
            return [Dk, Bk, "Pump.fun", "PumpSwap"];
        case Lc.FOUR_MEME:
            return [ry, ik, "Four.Meme", "PancakeSwap"];
        case Rc.LAUNCH_LAB:
            return [Hk, pk, "LaunchLab", "Raydium"];
        case Rc.BOOP:
            return [Xk, pk, "Boop", "Raydium"];
        case Rc.METEORA_CURVE:
            return [xC, mk, "Virtual Curve", "Meteora"];
        default:
            return t === Pd.SOLANA ? [Dk, Bk, "Pump.fun", "PumpSwap"] : [ry, ik, "Four.Meme", "PancakeSwap"]
        }
    }
    ), [t, e]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(C, {
            sx: m,
            children: [v.jsx(C, {
                sx: g,
                children: o
            }), n && v.jsx(S, {
                gap: 2.5,
                sx: x,
                children: "MIGRATION" === c ? v.jsxs(v.Fragment, {
                    children: [v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: 1.5,
                        children: [v.jsx(b, {
                            size: NIe
                        }), v.jsx(ZS, {}), v.jsx(f, {
                            size: NIe
                        })]
                    }), v.jsxs(k, {
                        variant: "h1",
                        color: "text.value",
                        children: [A, " is migrating", v.jsx(D5, {})]
                    }), v.jsxs(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        textAlign: "center",
                        mx: 5,
                        mt: -1,
                        children: ["The LP has hit the 100% bonding curve and is now migrating to ", w]
                    }), v.jsx(S, {
                        gap: 1.5,
                        alignItems: "center",
                        justifyContent: "center",
                        children: v.jsx(V, {
                            size: "xxsmall",
                            variant: "primary",
                            disabled: !0,
                            children: "Migrating..."
                        })
                    })]
                }) : v.jsxs(v.Fragment, {
                    children: [v.jsxs(S, {
                        gap: 1,
                        alignItems: "center",
                        children: [v.jsx(Ck, {
                            size: NIe,
                            color: i.palette.error.main
                        }), v.jsxs(k, {
                            textAlign: "center",
                            variant: "paragraph1",
                            color: "text.value",
                            children: [l("Token is freezable."), " ", v.jsx("br", {}), l("Before trading, make sure"), v.jsx("br", {}), l("to check our"), " ", v.jsx($C, {
                                label: l("docs"),
                                href: "https://docs.padre.gg/padre-v2/support/faq#freezable-accounts",
                                nofollow: !1,
                                variant: "paragraph1",
                                color: i.palette.primary.main
                            })]
                        })]
                    }), v.jsx(V, {
                        variant: "primary",
                        size: "xxsmall",
                        onClick: h,
                        children: l("I understand")
                    }), v.jsx(WR, {
                        label: l("Never show again"),
                        isChecked: d,
                        onClick: p
                    })]
                })
            })]
        })
    })
}
))
  , MIe = 8
  , NIe = 28
  , PIe = e => {
    const {user: t} = VK()
      , n = pK()
      , {state: r, hasLimitRawSigningPolicy: a, createLimitRawSigningPolicy: s} = UD((e => e))
      , [o,l] = y.useState(!1)
      , i = (null == t ? void 0 : t.uid) ?? null
      , c = y.useCallback((async e => {
        if (e.stopPropagation(),
        e.preventDefault(),
        !a && i && !o)
            if (r === BD.READY) {
                l(!0);
                try {
                    await s(i)
                } finally {
                    l(!1)
                }
            } else
                n({
                    message: uu.unknownError,
                    snackName: pu.unknownError,
                    type: "error"
                }, "limit-raw-signing-wallets-not-ready")
    }
    ), [i, r, a, s, n, o, l]);
    return !i || a ? null : v.jsxs(S, {
        width: "100%",
        children: [v.jsx(k, {
            align: "center",
            variant: "bodyRegular",
            p: 1,
            children: e.message
        }), v.jsx(V, {
            disabled: o || r !== BD.READY,
            fullWidth: !0,
            onClick: c,
            variant: "primary",
            startIcon: o ? v.jsx(J, {
                size: e.iconSize,
                color: "inherit"
            }) : void 0,
            children: e.label
        })]
    })
}
  , OIe = () => y.useContext(FAe)
  , LIe = y.memo(( ({side: e, transactionFeeInUsd: t, supportsMevProtection: n, supportsTip: r, slippageValuePercent: a, gasSettings: s, slippageWarningColor: o, slippageWarningMessage: l, tipWarningColor: i, tipWarningMessage: c, prioWarningColor: d, prioWarningMessage: u, isInInfernoMode: p, hasCustomRpc: h, useMevProtection: m, label: g="More options"}) => {
    const {t: x} = we()
      , b = bw()
      , {openEditModal: f} = QSe()
      , A = y.useCallback(( () => {
        f(e ?? void 0)
    }
    ), [f, e]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: e || b ? "flex-end" : "space-between",
        width: "100%",
        gap: 1,
        onClick: A,
        sx: WIe,
        divider: FIe,
        children: [(e || b) && v.jsx(C, {
            flexGrow: 1e4,
            children: v.jsx(S, {
                ...UIe,
                children: e ? v.jsxs(k, {
                    ..._Ie,
                    children: ["Gas", " ", v.jsx(k, {
                        ..._Ie,
                        color: e === xc.BUY ? "positive.main" : "negative.main",
                        children: t || "-"
                    })]
                }) : b ? v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.value",
                    children: g
                }) : null
            })
        }), p ? v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            pr: 2,
            children: [v.jsx(Cf, {}), v.jsx(k, {
                variant: "paragraph1",
                color: "originalPrimary.main",
                children: x("Inferno mode active")
            })]
        }) : v.jsxs(v.Fragment, {
            children: [v.jsx(z, {
                title: u ?? "",
                children: v.jsxs(S, {
                    ...UIe,
                    children: [v.jsx(wy, {
                        size: BIe,
                        color: d ?? void 0
                    }), v.jsx(k, {
                        ..._Ie,
                        color: d ?? _Ie.color,
                        children: RIe(null == s ? void 0 : s.prio)
                    })]
                })
            }), r && v.jsx(z, {
                title: c,
                children: v.jsxs(S, {
                    ...UIe,
                    children: [v.jsx(_k, {
                        size: BIe,
                        color: i ?? void 0
                    }), v.jsx(k, {
                        ..._Ie,
                        color: i ?? _Ie.color,
                        children: RIe(null == s ? void 0 : s.tip)
                    })]
                })
            }), v.jsx(z, {
                title: l,
                children: v.jsxs(S, {
                    ...UIe,
                    children: [v.jsx(Uk, {
                        size: BIe,
                        color: o ?? void 0
                    }), v.jsx(k, {
                        ..._Ie,
                        color: o ?? _Ie.color,
                        children: DIe(a)
                    })]
                })
            }), n && v.jsxs(S, {
                ...UIe,
                children: [m ? v.jsx(Py, {
                    size: BIe
                }) : v.jsx(Oy, {
                    size: BIe
                }), v.jsx(k, {
                    ..._Ie,
                    color: o ?? _Ie.color,
                    children: x(m ? "On" : "Off")
                })]
            }), h && v.jsx(S, {
                ...UIe,
                children: v.jsx(k, {
                    ..._Ie,
                    children: "RPC"
                })
            })]
        })]
    })
}
))
  , RIe = e => {
    const t = Number(e);
    return !t || isNaN(t) ? Ud : UI(t > 1 ? wI(t, {
        precision: 2,
        symbol: ""
    }) : EI(t, {
        precision: 3
    }))
}
  , DIe = e => {
    const t = Number(e);
    return t && !isNaN(t) ? UI(t >= 1 ? wI(t, {
        precision: 0,
        symbol: "%",
        symbolPosition: yI.END
    }) : `${EI(t, {
        precision: 1
    })}%`) : Ud
}
  , BIe = 14
  , _Ie = {
    variant: "paragraph3",
    color: "text.value",
    fontWeight: 400
}
  , UIe = {
    direction: "row",
    gap: .5,
    flexGrow: 2,
    height: BIe,
    alignItems: "flex-end",
    sx: {
        ":last-of-type": {
            justifyContent: "flex-end",
            flexGrow: 1
        },
        ":first-of-type": {
            justifyContent: "flex-start",
            flexGrow: 1
        }
    }
}
  , WIe = {
    "&:hover": {
        cursor: "pointer"
    }
}
  , FIe = v.jsx(Ee, {
    orientation: "vertical",
    flexItem: !0,
    sx: {
        ":first-of-type": {
            display: "none"
        },
        height: 10,
        width: 2,
        m: "auto"
    }
})
  , VIe = y.memo(( ({chain: e, specificType: t, gasSettings: n, slippageValuePercent: r, supportsMevProtection: a, supportsTip: s, useMevProtection: o, transactionFeeInUsd: l, side: i, slippageWarningColor: c, slippageWarningMessage: d, tipWarningColor: u, tipWarningMessage: p, isInInfernoMode: h, hasCustomRpc: m, supportsCustomRpc: g}) => {
    const x = D()
      , {settings: b} = rf()
      , {requiresReselect: f} = QSe()
      , A = y.useMemo(( () => {
        if (!n || !(null == b ? void 0 : b.solanaStopOrderMaxRevertRetry) || !_d.includes(e) || Ac(t) !== rc.STOP)
            return null;
        const r = (b.solanaStopOrderMaxRevertRetry + 1) * Number(n.prio ?? "0");
        return r && r >= .1 ? {
            message: `Max retry is ${b.solanaStopOrderMaxRevertRetry}. Order fees may cost up to ${UI(r.toFixed(3))} SOL`,
            color: r >= .5 ? x.palette.error.main : x.palette.warning.main
        } : null
    }
    ), [e, n, null == b ? void 0 : b.solanaStopOrderMaxRevertRetry, t, x]);
    return v.jsx(S, {
        alignItems: "center",
        direction: "row",
        children: f ? v.jsxs(k, {
            color: "warning.main",
            variant: "paragraph3",
            textAlign: "center",
            width: "100%",
            sx: HIe,
            children: [v.jsx(C, {
                display: "flex",
                height: 16,
                width: 16,
                sx: zIe,
                children: v.jsx(ey, {
                    color: "inherit"
                })
            }), "Select P1, P2 or P3 preset above"]
        }) : v.jsx(LIe, {
            side: i,
            transactionFeeInUsd: l,
            supportsMevProtection: a,
            supportsTip: s,
            slippageValuePercent: r,
            gasSettings: n,
            slippageWarningColor: c,
            slippageWarningMessage: d,
            tipWarningColor: u,
            tipWarningMessage: p,
            useMevProtection: o && !(g && m),
            prioWarningColor: (null == A ? void 0 : A.color) ?? null,
            prioWarningMessage: (null == A ? void 0 : A.message) ?? null,
            isInInfernoMode: h,
            hasCustomRpc: g && m
        })
    })
}
))
  , HIe = e => ({
    display: "flex",
    gap: .5,
    alignItems: "center",
    justifyContent: "center",
    ml: -1,
    color: e.palette.warning.main
})
  , zIe = {
    transform: "rotate(180deg)"
}
  , $Ie = y.memo(( ({size: e, error: t, disabled: n, children: r, annotation: a, sx: s={}}) => {
    const o = IY(e);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(S, {
            sx: e => ({
                height: o,
                borderRadius: 1,
                border: `1px solid ${EY({
                    theme: e,
                    disabled: n,
                    error: t
                })}`,
                [`.${Ot.root}`]: {
                    backgroundColor: "transparent !important"
                },
                [`.${Ot.notchedOutline}`]: {
                    border: "none !important"
                },
                ..."function" == typeof s ? s(e) : s
            }),
            children: "function" == typeof r ? r({
                size: e,
                error: t,
                disabled: n
            }) : r
        }), "function" == typeof a ? a({
            size: e,
            error: t,
            disabled: n
        }) : a]
    })
}
))
  , GIe = y.memo(( ({sliderPercentageValue: e, onPercentageChange: t, range: n=QIe, reverse: r=!1, handleInteractionStart: a=c.noop, handleInteractionEnd: s=c.noop}) => v.jsx(Z, {
    onMouseDown: a,
    onTouchStart: a,
    onChangeCommitted: s,
    onTouchEnd: s,
    marks: [25, 50, 75, 125, 150, 175].map((e => ({
        value: e
    }))),
    sx: e => qIe(e, r),
    min: n[0],
    max: n[1],
    value: e,
    onChange: async (e, n) => {
        const r = Array.isArray(n) ? n[0] : n;
        await t(r)
    }
})))
  , qIe = (e, t) => ({
    "& .MuiSlider-thumb": {
        ...XIe,
        transition: "none",
        color: e.palette.text.label,
        border: `2px solid ${e.palette.background.primary}`
    },
    "& .MuiSlider-rail": {
        transition: "none",
        color: t ? e.palette.text.label : e.palette.text.disabled,
        height: "4px",
        opacity: 1
    },
    "& .MuiSlider-track": {
        transition: "none",
        opacity: 1,
        height: "2px",
        color: `${t ? e.palette.text.disabled : e.palette.text.label} !important`
    },
    "& .MuiSlider-mark": {
        color: e.palette.background.primary,
        width: YIe,
        height: KIe
    },
    "& .MuiSlider-markActive": {
        backgroundColor: e.palette.background.primary,
        opacity: 1
    }
})
  , KIe = 4
  , YIe = 3
  , XIe = {
    height: 18,
    width: 18,
    borderRadius: "50%",
    boxShadow: "none",
    "&, &:hover, &.Mui-selected, &.Mui-active, &.Mui-focusVisible, &::after": {
        boxShadow: "none"
    }
}
  , QIe = [0, 100]
  , ZIe = e => e.replace(/\.$/, "")
  , JIe = y.memo(( () => {
    const e = ode()
      , t = Zce((e => !e.marketStats || c.isNil(e.baseTokenDecimals) || c.isNil(e.marketStats.basePriceInUsdUi) || c.isNil(e.marketStats.baseTokenTotalSupply) ? null : new sB({
        decimals: e.baseTokenDecimals
    },BigInt(e.marketStats.baseTokenTotalSupply)).multiply(e.marketStats.basePriceInUsdUi).toNumber()))
      , n = xw()
      , {values: {triggerPrice: r, specificType: a, priceInputMode: s, priceFdvValue: o}, setFieldValue: l, setFieldTouched: i} = Tn()
      , d = y.useMemo(( () => s === rB.FDV), [s])
      , u = y.useRef(null)
      , p = y.useCallback(( () => {
        var e;
        null == (e = u.current) || e.focus()
    }
    ), [])
      , [h,m] = JC(!1)
      , g = y.useRef(null === e ? null : e.toString());
    y.useEffect(( () => {
        g.current = null === e ? null : e.toString()
    }
    ), [e]);
    const [x,b] = y.useState(null === e ? null : e.toString())
      , [f,A] = y.useState(null)
      , w = y.useCallback((async ({target: {value: n}}) => {
        if (g.current && b(g.current),
        d && (!g.current || !t))
            return;
        A(null);
        const r = QR(n)
          , a = d ? t ? MI((Number(e) * Number(r) / t).toFixed(36)) : "" : r;
        d && await l("priceFdvValue", r),
        await l("triggerPrice", a),
        await i("triggerPrice"),
        m(!0)
    }
    ), [d, t, e, l, i, m]);
    y.useEffect(( () => {
        x && !isNaN(Number(x)) && 0 !== Number(x) || e && b(null === e ? null : e.toString())
    }
    ), [e, x]);
    const j = y.useMemo(( () => e && Number(e) && r && null !== r ? Number(r ?? 0) * (t || 0) / Number(e) : null), [r, e, t])
      , T = y.useMemo(( () => e && t && o ? Number(e) * Number(o) / t : null), [e, t, o])
      , I = y.useMemo(( () => x && r && null !== r ? Number(r ?? 0) / Number(x) * 100 : null), [r, x])
      , E = y.useCallback((async n => {
        if (null === !x || isNaN(Number(x)))
            return;
        const r = QR(UI((Number(x) * (n / 100)).toFixed(36)))
          , a = WAe(r, 4);
        if (d) {
            if (!e)
                return;
            await l("priceFdvValue", MI((Number(r) * (t || 0) / Number(e)).toFixed(2)))
        }
        await l("triggerPrice", Number(r).toFixed(a)),
        await i("triggerPrice")
    }
    ), [x, d, l, i, e, t])
      , [M,N] = y.useState(!1)
      , P = () => {
        L(!1),
        N(!0)
    }
      , [O,L] = y.useState(!1)
      , R = () => {
        L(!0)
    }
      , D = () => {
        L(!0)
    }
      , B = () => {
        L(!1)
    }
      , _ = y.useMemo(( () => a !== ic.TAKE_PROFIT), [a])
      , [U,W] = y.useState("");
    y.useEffect(( () => {
        O || null !== I && W(LI(Math.abs(100 - Number(I.toFixed(2))), {
            symbol: 0 === Math.round(100 - I) ? "" : Math.round(100 - I) > 0 ? "-" : "+",
            padSymbol: !1,
            symbolPosition: yI.START,
            maxPrecision: null === f ? Math.abs(100 - I) < .1 ? 0 : 2 : f,
            minPrecision: null === f ? Math.abs(100 - I) < .1 ? 0 : 2 : f
        }))
    }
    ), [I, _, O, f]);
    const F = y.useCallback((async (e, t=!1) => {
        g.current && b(g.current);
        const n = QR(AI(e));
        if ("" === n)
            return await E(100),
            void W("");
        const r = Number(`${_ ? "-" : "+"}${ZIe(n)}`);
        if (isNaN(r))
            return;
        const a = _ ? Math.max(-100, r) : r;
        W(`${_ ? t ? "-" : "" : "+"}${n}`),
        await E(100 + a)
    }
    ), [E, _])
      , V = y.useCallback((async ({target: {value: e}}) => {
        A(null),
        await F(e)
    }
    ), [F])
      , H = y.useMemo(( () => null === I ? 100 : Number(I.toFixed(0))), [I])
      , $ = async e => {
        A(0),
        await F((e - 100).toString(), !0),
        m(!0)
    }
      , G = y.useMemo(( () => wB.includes(a)), [a])
      , q = y.useCallback((n => {
        if (n.stopPropagation(),
        n.preventDefault(),
        s === rB.PRICE) {
            if (isNaN(Number(e)))
                return;
            l("priceFdvValue", (Number(r ?? 0) * (t || 0) / Number(e)).toFixed(2))
        }
        l("priceInputMode", s === rB.FDV ? rB.PRICE : rB.FDV)
    }
    ), [e, t, s, l, r]);
    return v.jsx(C, {
        children: v.jsx(Zn, {
            name: d ? "priceFdvValue" : "triggerPrice",
            children: ({field: e, form: {errors: t}}) => {
                const r = !!c.get(t, "triggerPrice")
                  , a = null === e.value;
                return v.jsxs(S, {
                    gap: 1,
                    mt: n ? 0 : "-5px",
                    children: [v.jsx(S, {
                        children: v.jsx($Ie, {
                            size: "medium",
                            error: r,
                            children: v.jsx(C, {
                                display: "flex",
                                onClick: p,
                                flexGrow: 1,
                                children: v.jsx(z, {
                                    placement: "top-end",
                                    title: v.jsx(k, {
                                        variant: "paragraph3",
                                        children: d ? null !== T ? isNaN(T) ? "" : `Target price ${LI(T, {
                                            symbol: ""
                                        })}` : "" : null !== j ? isNaN(j) ? "" : `MCap ${OI(j, {
                                            collapseExponent: !0
                                        })}` : ""
                                    }),
                                    open: h || M,
                                    PopperProps: {
                                        modifiers: [{
                                            name: "offset",
                                            options: {
                                                offset: [0, n ? -10 : 0]
                                            }
                                        }]
                                    },
                                    children: v.jsx(je, {
                                        inputRef: u,
                                        ...e,
                                        disabled: a,
                                        onChange: w,
                                        onBlur: t => {
                                            e.onBlur(t),
                                            N(!1)
                                        }
                                        ,
                                        onFocus: P,
                                        value: e.value ?? "",
                                        "data-pseudotype": "numberLike",
                                        inputMode: "decimal",
                                        size: "medium",
                                        fullWidth: !0,
                                        inputProps: {
                                            ...Su,
                                            style: {
                                                textAlign: "right"
                                            },
                                            inputMode: "decimal"
                                        },
                                        startAdornment: v.jsx(We, {
                                            position: "start",
                                            children: v.jsx(S, {
                                                direction: "row",
                                                alignItems: "center",
                                                gap: .25,
                                                sx: e => ({
                                                    color: e.palette.text.label,
                                                    ...G ? {
                                                        "&:hover": {
                                                            cursor: "pointer",
                                                            color: e.palette.text.value
                                                        }
                                                    } : {}
                                                }),
                                                onClick: G ? q : void 0,
                                                children: v.jsx(GC, {
                                                    title: d ? v.jsxs(S, {
                                                        gap: 1,
                                                        children: [v.jsx(k, {
                                                            variant: "inherit",
                                                            color: "inherit",
                                                            children: "Stop orders are executed according to the target price. The MCap displayed here is for your reference only and is NOT used in order execution."
                                                        }), v.jsx(k, {
                                                            variant: "inherit",
                                                            color: "inherit",
                                                            children: "Make sure the target price corresponding to this MCap is the price you want the order to trigger at."
                                                        })]
                                                    }) : "",
                                                    children: v.jsxs(k, {
                                                        variant: "paragraph1",
                                                        color: "inherit",
                                                        sx: {
                                                            display: "flex",
                                                            gap: .25
                                                        },
                                                        children: [d ? "Target MCap" : "Stop price", G && v.jsx(C, {
                                                            mt: .25,
                                                            children: v.jsx(oy, {
                                                                color: "inherit",
                                                                size: 12
                                                            })
                                                        })]
                                                    })
                                                })
                                            })
                                        }),
                                        endAdornment: a ? v.jsx(Ie, {
                                            width: 150
                                        }) : v.jsx(We, {
                                            position: "end",
                                            children: v.jsx(k, {
                                                sx: {
                                                    font: "inherit"
                                                },
                                                color: r ? "negative.main" : "text.label",
                                                children: "$"
                                            })
                                        }),
                                        error: r
                                    })
                                })
                            })
                        })
                    }), v.jsxs(S, {
                        direction: "row",
                        gap: 2,
                        alignItems: "center",
                        justifyContent: "space-between",
                        children: [v.jsx(GIe, {
                            sliderPercentageValue: H,
                            onPercentageChange: $,
                            range: _ ? [1, 100] : [100, 200],
                            reverse: _,
                            handleInteractionStart: D,
                            handleInteractionEnd: B
                        }), v.jsx(je, {
                            ...e,
                            onChange: V,
                            onBlur: t => {
                                e.onBlur(t),
                                L(!1)
                            }
                            ,
                            onFocus: R,
                            value: U,
                            "data-pseudotype": "numberLike",
                            inputMode: "decimal",
                            size: "medium",
                            sx: e => ({
                                maxWidth: 95,
                                backgroundColor: "transparent",
                                border: `1px solid ${e.palette.background.borderMain}`
                            }),
                            inputProps: {
                                ...Su,
                                style: {
                                    textAlign: n ? "right" : "center",
                                    paddingLeft: 0
                                },
                                inputMode: "decimal"
                            },
                            endAdornment: v.jsx(We, {
                                position: "end",
                                children: v.jsx(k, {
                                    sx: {
                                        font: "inherit"
                                    },
                                    color: "text.label",
                                    children: "%"
                                })
                            }),
                            error: r
                        })]
                    })]
                })
            }
        })
    })
}
))
  , eEe = (e, t) => {
    const [n,r=""] = e.split(".")
      , [a,s=""] = t.split(".");
    if (n.length > a.length)
        return 1;
    if (n.length < a.length)
        return -1;
    if (n > a)
        return 1;
    if (n < a)
        return -1;
    const o = Math.max(r.length, s.length)
      , l = r.padEnd(o, "0")
      , i = s.padEnd(o, "0");
    return l > i ? 1 : l < i ? -1 : 0
}
  , tEe = e => c.capitalize((e => kc.get(e) ?? e)(e).toLowerCase())
  , nEe = (e, t, n, r) => {
    if (n === rc.MARKET || null === n)
        return 1;
    if (!t)
        return 1;
    if (!e || !Number(e) || isNaN(Number(t)) || isNaN(Number(e)))
        return 1;
    const a = Number(t) / Number(e);
    return r === xc.BUY ? 0 !== a ? 1 / a : 0 : a
}
  , rEe = (e, t) => t === nB.PERCENTAGE ? "Percentage" : tEe(Tc(e))
  , aEe = y.memo(( ({walletsCount: e, quoterData: t, inputCurrencyPrice: n, quoteCurrencySymbol: r, baseCurrencySymbol: a, baseDecimals: s, quoteDecimals: o}) => {
    const {values: {specificType: l, quantityValue: i, quantityPercentageValue: c, quantityInputMode: d, triggerPrice: u}} = Tn()
      , p = ode()
      , h = y.useMemo(( () => {
        if (d !== nB.PERCENTAGE)
            return "";
        const e = Tc(l) === bc.BASE ? r : a;
        if (t.status === ox.INITIAL)
            return `~${LI(0, {
                symbol: e
            })}`;
        if (t.status !== ox.READY)
            return `~${LI(0, {
                symbol: e
            })}`;
        const n = Ac(l)
          , i = jc(l)
          , c = nEe(null === p ? null : p.toString(), u || null, n, i);
        return `~${fc(t.data.quantity.value) ? LI(new sB({
            decimals: t.data.quantity.unit === bc.BASE ? s : o
        },BigInt(t.data.quantity.value)).toNumber() * c, {
            symbol: e,
            collapseExponent: !0,
            maxPrecision: 2,
            noTrailingZeros: !0
        }) : ""}`
    }
    ), [a, s, p, d, r, o, t, l, u]);
    return y.useMemo(( () => {
        const t = jc(l) === xc.BUY ? "buy" : "sell"
          , r = e > 1 ? `${t} on ${e} wallets, ` : "";
        if (d === nB.PERCENTAGE)
            return c && "0" !== c && h ? `${r}${c}% of tokens ${e > 1 ? " per wallet" : ""}.${e > 1 ? "" : ` Now ${h}`}` : "";
        const a = ( ({inputCurrencyPrice: e, specificType: t, displayedBasePriceInUsd: n}) => {
            if (e)
                return e;
            if (Tc(t) !== bc.BASE)
                return null;
            if (!n)
                return null;
            const r = Number(n);
            return isNaN(r) ? null : r
        }
        )({
            inputCurrencyPrice: n,
            specificType: l,
            displayedBasePriceInUsd: null === p ? null : p.toString()
        });
        if (isNaN(Number(i)) || null === a)
            return "";
        const s = `~${OI(Number(i) * a, {
            collapseExponent: !0
        })}`
          , o = e > 1 ? `${r}${s}${e > 1 ? " total" : ""}` : s;
        return v.jsx(k, {
            variant: "paragraph3",
            children: o
        })
    }
    ), [d, n, l, p, i, c, h, e])
}
))
  , sEe = y.memo(( ({label: e, onClick: t}) => v.jsx(V, {
    disableRipple: !1,
    variant: "tertiary",
    size: "xxsmall",
    onClick: t,
    sx: oEe,
    children: v.jsx(k, {
        variant: "paragraph3",
        color: "text.value",
        sx: lEe,
        children: e
    })
})))
  , oEe = e => ({
    transition: "none",
    borderRadius: 2,
    p: 0,
    px: 0,
    height: 28,
    flex: 1,
    border: `1px solid ${e.palette.background.borderMain}`,
    backgroundColor: "transparent",
    "&:focus": {
        backgroundColor: "transparent",
        borderColor: e.palette.background.borderMain
    },
    "&:hover": {
        backgroundColor: "transparent",
        borderColor: e.palette.background.borderSecondary
    }
})
  , lEe = {
    display: "flex",
    alignItems: "center",
    height: 15,
    gap: "1px"
}
  , iEe = y.memo(( ({onClick: e, unit: t, quoteCurrency: n, chain: r}) => {
    const {settings: a, extraInputPresets: s} = rf()
      , o = y.useMemo(( () => yCe(t, n, r, (null == a ? void 0 : a.amountInputPresets) || null, !1)), [t, n, r, null == a ? void 0 : a.amountInputPresets])
      , l = y.useMemo(( () => s ? yCe(t, n, r, (null == a ? void 0 : a.extraAmountInputPresets) || null, !1) : null), [s, t, n, r, null == a ? void 0 : a.extraAmountInputPresets]);
    return v.jsx(S, {
        gap: .75,
        children: [o, ...l ? [l] : []].map(( (t, n) => v.jsx(S, {
            direction: "row",
            gap: 1,
            children: t.map(( (t, n) => v.jsx(sEe, {
                onClick: () => {
                    e(t.value)
                }
                ,
                label: t.label
            }, n)))
        }, n)))
    })
}
))
  , cEe = y.memo(( ({percentageValue: e, onPercentageChange: t, percentageInputDisplayValue: n, onInputPercentageChange: r, onInputFocus: a, onInputBlur: s, error: o, showInput: l=!0}) => {
    const i = xw();
    return v.jsxs(S, {
        direction: "row",
        gap: 2,
        alignItems: "center",
        justifyContent: "space-between",
        height: 40,
        children: [v.jsx(GIe, {
            sliderPercentageValue: e,
            onPercentageChange: t
        }), l && v.jsx(je, {
            onChange: r,
            onFocus: a,
            onBlur: s,
            value: n,
            "data-pseudotype": "numberLike",
            inputMode: "decimal",
            size: "medium",
            sx: e => ({
                maxWidth: 95,
                backgroundColor: "transparent",
                border: `1px solid ${e.palette.background.borderMain}`
            }),
            inputProps: {
                ...dEe,
                style: {
                    textAlign: i ? "right" : "center",
                    paddingLeft: 0
                },
                inputMode: "decimal"
            },
            endAdornment: v.jsx(We, {
                position: "end",
                children: v.jsx(k, {
                    sx: {
                        font: "inherit"
                    },
                    color: "text.label",
                    children: "%"
                })
            }),
            error: o
        })]
    })
}
))
  , dEe = {
    [vu]: "true"
}
  , uEe = y.memo(( ({baseCurrencySymbol: e, quoteCurrencySymbol: t, baseBalance: n, baseDecimals: r, baseCurrency: a, quoteBalance: s, quoteDecimals: o, quoteCurrency: l, chain: i, quoterData: c, walletsCount: d, padreFeeBps: u}) => {
    var p, h;
    const {t: m} = we()
      , g = xw()
      , {values: {specificType: x, quantityValue: b, quantityPercentageValue: f, executionOptions: A, previousQuantityValue: w, previousQuantityPercentageValue: j, quantityInputMode: T, isInInfernoMode: I}, errors: {quantityValue: E}, touched: {quantityValue: M}, setFieldValue: N, setFieldTouched: P} = Tn()
      , O = y.useRef(null)
      , L = y.useRef(null)
      , R = y.useCallback(( () => {
        var e;
        null == (e = O.current) || e.focus()
    }
    ), [])
      , {settings: D} = rf()
      , [B,_] = JC(!1)
      , U = y.useCallback((async ({target: {value: e}}) => {
        const t = T === nB.PERCENTAGE
          , n = QR(e);
        await N(t ? "quantityPercentageValue" : "quantityValue", n),
        _(!0),
        N(t ? "previousQuantityPercentageValue" : "previousQuantityValue", n),
        N("awaitingOrderId", null),
        ne("")
    }
    ), [T, N, _])
      , W = y.useMemo(( () => {
        const e = Tc(x)
          , t = jc(x);
        return e === bc.BASE && t === xc.SELL ? new sB({
            decimals: r
        },BigInt(n)) : e === bc.QUOTE && t === xc.BUY ? new sB({
            decimals: o
        },BigInt(s)) : null
    }
    ), [n, r, s, o, x])
      , V = y.useMemo(( () => {
        var e, t;
        return W ? jc(x) === xc.SELL ? W : hB(W.getRawAmount(), a, {
            address: l,
            decimals: o
        }, i, (null == (e = A.gasSettings) ? void 0 : e.tip) ?? null, (null == (t = A.gasSettings) ? void 0 : t.prio) ?? null, "0" !== n, void 0 !== u ? BigInt(u) : void 0, I, A.useMevProtection) : null
    }
    ), [W, x, a, l, o, i, null == (p = A.gasSettings) ? void 0 : p.tip, null == (h = A.gasSettings) ? void 0 : h.prio, A.useMevProtection, n, u, I])
      , H = y.useMemo(( () => T === nB.PERCENTAGE ? isNaN(Number(f)) ? 0 : Number(f) : !W || isNaN(Number(b)) ? 0 : (null == V ? void 0 : V.greaterThan(0)) ? eEe(V.toString(), b) ? Math.round(Number(b) / V.toNumber() * 100) : 100 : 0), [T, W, b, V, f])
      , $ = y.useMemo(( () => {
        const e = Tc(x) === bc.QUOTE ? o : r;
        return W && W.toNumber() ? Math.min((e => {
            const t = WAe(e, 4);
            return Math.max(2, t)
        }
        )(W.toNumber()), e) : Math.min(4, e)
    }
    ), [W, r, o, x])
      , G = y.useCallback((async e => {
        const t = T === nB.PERCENTAGE;
        if (L.current && (L.current.value = e.toFixed(0)),
        !(null == V ? void 0 : V.greaterThan(0)) && !t)
            return await N("quantityValue", ""),
            void (await P("quantityValue", !0, !1));
        if (N("awaitingOrderId", null),
        100 === e)
            return await N(t ? "quantityPercentageValue" : "quantityValue", t ? e.toString() : null == V ? void 0 : V.toExact()),
            P(t ? "quantityPercentageValue" : "quantityValue", !0, !1),
            void _(!0);
        if (t)
            return await N("quantityPercentageValue", e.toString()),
            void (await P("quantityPercentageValue", !0, !1));
        const n = (Math.floor(Math.max((null == V ? void 0 : V.toNumber()) ?? 0, 0) * (e / 100) * Math.pow(10, $)) / Math.pow(10, $)).toFixed($);
        await N("quantityValue", n),
        await P("quantityValue", !0, !1),
        _(!0)
    }
    ), [T, V, N, $, P, _])
      , q = y.useCallback((async e => {
        await G(e)
    }
    ), [G])
      , K = y.useCallback((async e => {
        ne(e.toString()),
        await G(e)
    }
    ), [G])
      , [Y,X] = y.useState(!1)
      , Q = y.useCallback(( () => {
        X(!0)
    }
    ), [])
      , Z = y.useCallback(( () => {
        X(!1)
    }
    ), [])
      , [J,ee] = y.useState("")
      , [te,ne] = y.useState("");
    y.useEffect(( () => {
        b || ne("")
    }
    ), [b]),
    y.useEffect(( () => {
        Y || ee(LI(Math.abs(Number(H.toFixed(2))), {
            symbol: "",
            maxPrecision: Math.abs(H) < .1 ? 0 : 2,
            minPrecision: Math.abs(H) < .1 ? 0 : 2
        }))
    }
    ), [Y, H]);
    const re = y.useCallback((async ({target: {value: e}}) => {
        const t = QR(AI(e))
          , n = Number(`${ZIe(t)}`);
        isNaN(n) || (ee(`${t}`),
        await G(Number(t)))
    }
    ), [G])
      , ae = y.useCallback((async e => {
        const t = QR(AI(e.target.value));
        ne(t),
        await re(e)
    }
    ), [re])
      , [se,oe] = y.useState(null);
    y.useEffect(( () => {
        oe(null)
    }
    ), [x]),
    y.useEffect(( () => {
        if (c.status !== ox.READY)
            return;
        const e = c.data.inputCurrencyPriceInUsd;
        isNaN(Number(e)) || oe(Number(e))
    }
    ), [c]);
    const [le,ie] = y.useState(!1)
      , ce = () => {
        ie(!0)
    }
      , de = y.useCallback((async e => {
        await Promise.all([N("quantityValue", e.toString()), N("awaitingOrderId", null)]),
        P("quantityValue", !0),
        _(!0)
    }
    ), [P, N, _])
      , {quantityButtonUnit: ue, quantityButtonOnClick: pe} = y.useMemo(( () => jc(x) === xc.BUY ? {
        quantityButtonUnit: vCe.QUANTITY,
        quantityButtonOnClick: de
    } : {
        quantityButtonUnit: vCe.PERCENTAGE,
        quantityButtonOnClick: K
    }), [K, de, x])
      , he = "medium"
      , me = (null == D ? void 0 : D.quickInputMode) ?? _x
      , ge = g && jc(x) === xc.SELL && me !== Fh.SLIDER && T === nB.VALUE
      , xe = y.useCallback((async () => {
        if (T === nB.PERCENTAGE) {
            if (!j)
                return;
            await Promise.all([N("quantityPercentageValue", j), N("previousQuantityPercentageValue", null), N("awaitingOrderId", null)])
        } else
            w && (await Promise.all([N("quantityValue", w), N("previousQuantityValue", null), N("awaitingOrderId", null)]),
            ne(""))
    }
    ), [j, w, T, N])
      , be = y.useMemo(( () => CB.includes(x) || d > 1 && AB.includes(x)), [d, x]);
    y.useEffect(( () => {
        be || T !== nB.PERCENTAGE ? d > 1 && be && (N("quantityInputMode", nB.PERCENTAGE, !1),
        N("quantityPercentageValue", ""),
        ne("")) : (N("quantityInputMode", nB.VALUE, !1),
        N("quantityPercentageValue", ""),
        ne(""))
    }
    ), [d, be, T, N]);
    const fe = y.useCallback((e => {
        e.stopPropagation(),
        e.preventDefault(),
        N("quantityInputMode", T === nB.PERCENTAGE ? nB.VALUE : nB.PERCENTAGE),
        N(T === nB.PERCENTAGE ? "quantityPercentageValue" : "quantityValue", ""),
        ne("")
    }
    ), [T, N])
      , ve = y.useMemo(( () => e => ({
        color: e.palette.text.label,
        ...be ? {
            "&:hover": {
                cursor: d > 1 ? "help" : "pointer",
                color: e.palette.text.value
            }
        } : {}
    })), [be, d])
      , Se = y.useMemo(( () => ({
        ref: L,
        ...Su,
        style: {
            textAlign: g ? "right" : "center",
            marginTop: "2px"
        },
        inputMode: "decimal"
    })), [g]);
    return v.jsx(C, {
        children: v.jsxs(S, {
            gap: 1,
            flexDirection: "column",
            children: [v.jsxs(S, {
                display: "grid",
                gridTemplateColumns: "repeat(4, 1fr)",
                width: "100%",
                gap: 1,
                children: [v.jsx(S, {
                    gridColumn: ge ? "span 3" : "span 4",
                    onClick: R,
                    children: v.jsx($Ie, {
                        size: he,
                        error: M && !!E,
                        children: ({disabled: n}) => v.jsxs(S, {
                            direction: "row",
                            children: [v.jsxs(C, {
                                display: "flex",
                                alignItems: "center",
                                flex: "0 0 100px",
                                px: "14px",
                                gap: .75,
                                children: [v.jsx(S, {
                                    alignItems: "center",
                                    onClick: be && d <= 1 ? fe : void 0,
                                    sx: ve,
                                    children: v.jsx(GC, {
                                        title: T === nB.PERCENTAGE ? "Amount will be determined based on the holding at the moment of trigger" : "",
                                        children: v.jsxs(k, {
                                            variant: "paragraph1",
                                            color: "inherit",
                                            sx: pEe,
                                            children: [rEe(x, T), be && d <= 1 && v.jsx(C, {
                                                mt: .25,
                                                children: v.jsx(oy, {
                                                    color: "inherit",
                                                    size: 12
                                                })
                                            })]
                                        })
                                    })
                                }), (T === nB.PERCENTAGE ? j && !f : w && !b) && v.jsx(z, {
                                    title: m("Restore previous"),
                                    children: v.jsx(C, {
                                        component: "span",
                                        sx: {
                                            mb: .5
                                        },
                                        children: v.jsx(F, {
                                            sx: {
                                                p: .5
                                            },
                                            onClick: xe,
                                            children: v.jsx(Ov, {
                                                size: 12
                                            })
                                        })
                                    })
                                })]
                            }), v.jsx(C, {
                                flexGrow: 1,
                                children: v.jsx(Zn, {
                                    name: T === nB.VALUE ? "quantityValue" : "quantityPercentageValue",
                                    children: ({field: a}) => v.jsx(z, {
                                        placement: g ? "top-end" : "top",
                                        title: v.jsx(aEe, {
                                            walletsCount: d,
                                            quoterData: c,
                                            inputCurrencyPrice: se,
                                            quoteCurrencySymbol: t,
                                            baseCurrencySymbol: e,
                                            baseDecimals: r,
                                            quoteDecimals: o
                                        }),
                                        open: B || le,
                                        PopperProps: {
                                            modifiers: [{
                                                name: "offset",
                                                options: {
                                                    offset: [0, g ? -10 : 0]
                                                }
                                            }]
                                        },
                                        children: v.jsx(je, {
                                            inputRef: O,
                                            ...a,
                                            onChange: U,
                                            onBlur: e => {
                                                a.onBlur(e),
                                                ie(!1)
                                            }
                                            ,
                                            onFocus: ce,
                                            size: he,
                                            placeholder: "0",
                                            disabled: n,
                                            error: M && !!E,
                                            inputProps: {
                                                ...Su,
                                                style: {
                                                    fontVariant: "paragraph1",
                                                    textAlign: "right"
                                                },
                                                inputMode: "decimal"
                                            },
                                            "data-pseudotype": "numberLike",
                                            inputMode: "decimal",
                                            fullWidth: !0,
                                            endAdornment: v.jsx(C, {
                                                display: "flex",
                                                alignItems: "center",
                                                ml: .75,
                                                children: v.jsx(k, {
                                                    variant: "paragraph1",
                                                    color: "text.label",
                                                    ...Nu,
                                                    noWrap: !0,
                                                    sx: {
                                                        maxWidth: 60
                                                    },
                                                    children: T === nB.PERCENTAGE ? "%" : Tc(x) === bc.BASE ? e : "ETH" === t ? mM : t
                                                })
                                            })
                                        })
                                    })
                                })
                            })]
                        })
                    })
                }), ge && v.jsx(C, {
                    children: v.jsx(je, {
                        value: te,
                        onChange: ae,
                        placeholder: "0",
                        inputProps: Se,
                        size: he,
                        "data-pseudotype": "numberLike",
                        inputMode: "decimal",
                        endAdornment: v.jsx(C, {
                            display: "flex",
                            alignItems: "center",
                            ml: .75,
                            mt: .25,
                            mr: "1px",
                            children: v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                ...Nu,
                                children: "%"
                            })
                        })
                    })
                })]
            }), me === Fh.BUTTONS || jc(x) === xc.BUY ? v.jsx(iEe, {
                onClick: pe,
                unit: ue,
                quoteCurrency: l,
                chain: i
            }) : v.jsx(cEe, {
                percentageValue: H,
                onPercentageChange: q,
                percentageInputDisplayValue: J,
                onInputPercentageChange: re,
                onInputFocus: Q,
                onInputBlur: Z,
                error: !!E,
                showInput: T === nB.VALUE
            })]
        })
    })
}
))
  , pEe = {
    display: "flex",
    gap: .25
}
  , hEe = y.memo(( ({chain: e, field: t, previousSideValues: n, setPreviousSideValues: r}) => {
    const {t: a} = we()
      , {settings: s} = rf()
      , {selectedPreset: o} = QSe()
      , {setFieldValue: l, setFieldTouched: i, values: {quantityValue: c, specificType: d}} = Tn()
      , u = y.useCallback((async (t, a) => {
        if (!s)
            return;
        const u = a;
        r((e => ({
            ...e,
            [u === xc.BUY ? xc.SELL : xc.BUY]: c
        })));
        const {oppositeType: p, desiredSide: h} = gEe[d];
        h !== u && (await l("specificType", p),
        await i("specificType", !0)),
        await l("quantityValue", n[u]),
        await i("quantityValue", !1),
        await l("previousQuantityValue", null),
        await l("awaitingOrderId", null);
        const m = Kb(s.orderPresets ?? null, o, e, u);
        if (zb(o)) {
            if (!$b.includes(e))
                return;
            return await l("isInInfernoMode", !0, !0),
            void i("isInInfernoMode")
        }
        const g = [];
        m && null !== m.mevProtection && g.push(l("executionOptions.useMevProtection", m.mevProtection)),
        (null == m ? void 0 : m.slippage) && g.push(l("slippageValuePercent", m.slippage)),
        (null == m ? void 0 : m.prio) && g.push(l("executionOptions.gasSettings.prio", m.prio)),
        (null == m ? void 0 : m.tip) && g.push(l("executionOptions.gasSettings.tip", m.tip)),
        m && null !== m.mevProtection && g.push(i("executionOptions.useMevProtection")),
        (null == m ? void 0 : m.slippage) && g.push(i("slippageValuePercent")),
        (null == m ? void 0 : m.prio) && g.push(i("executionOptions.gasSettings.prio")),
        (null == m ? void 0 : m.tip) && g.push(i("executionOptions.gasSettings.tip")),
        $b.includes(e) && g.push(l("isInInfernoMode", !1)),
        await Promise.all(g)
    }
    ), [e, n, c, o, i, l, r, s, d])
      , p = y.useMemo(( () => [{
        value: xc.BUY,
        color: "positive",
        label: a("Buy")
    }, {
        value: xc.SELL,
        color: "negative",
        label: a("Sell"),
        backgroundText: !0
    }]), [a]);
    return v.jsx(IH, {
        value: jc(t.value),
        items: p,
        size: "xxsmall",
        onChange: u
    })
}
))
  , mEe = y.memo(( ({chain: e}) => {
    const {lastViewedSide: t, setLastViewedSide: n} = _H()
      , [r,a] = y.useState({
        [xc.BUY]: "",
        [xc.SELL]: ""
    })
      , {values: {specificType: s}} = Tn();
    return y.useEffect(( () => {
        const e = jc(s);
        t !== e && n(e)
    }
    ), [t, n, s]),
    v.jsx(Zn, {
        name: "specificType",
        children: ({field: t}) => v.jsx(hEe, {
            previousSideValues: r,
            setPreviousSideValues: a,
            chain: e,
            field: t
        })
    })
}
))
  , gEe = {
    [ic.MARKET_BUY]: {
        oppositeType: ic.MARKET_SELL,
        desiredSide: xc.BUY
    },
    [ic.MARKET_SELL]: {
        oppositeType: ic.MARKET_BUY,
        desiredSide: xc.SELL
    },
    [ic.STOP_LOSS]: {
        oppositeType: ic.BUY_DIP,
        desiredSide: xc.SELL
    },
    [ic.TAKE_PROFIT]: {
        oppositeType: ic.BUY_DIP,
        desiredSide: xc.SELL
    },
    [ic.BUY_DIP]: {
        oppositeType: ic.STOP_LOSS,
        desiredSide: xc.BUY
    },
    [ic.TRAILING_STOP_LOSS]: {
        oppositeType: ic.BUY_DIP,
        desiredSide: xc.SELL
    },
    [ic.DEV_SELL_BUY]: {
        oppositeType: ic.DEV_SELL_SELL,
        desiredSide: xc.BUY
    },
    [ic.DEV_SELL_SELL]: {
        oppositeType: ic.DEV_SELL_BUY,
        desiredSide: xc.SELL
    }
}
  , xEe = y.memo(( ({chain: e}) => {
    const {setFieldValue: t, setFieldTouched: n} = Tn()
      , {t: r} = we()
      , a = y.useCallback((e => {
        t("specificType", e.target.value),
        n("specificType", !0),
        t("previousQuantityValue", null)
    }
    ), [n, t]);
    return v.jsx(Zn, {
        name: "specificType",
        children: ({field: t}) => v.jsx(fEe, {
            field: t,
            onChange: a,
            t: r,
            chain: e
        })
    })
}
))
  , bEe = {
    p: 0,
    height: bu.XXSMALL,
    width: "100%"
}
  , fEe = y.memo(( ({field: e, onChange: t, t: n, chain: r}) => {
    const a = jc(e.value)
      , s = y.useMemo(( () => ({
        [xc.BUY]: [{
            label: n("Market"),
            type: ic.MARKET_BUY
        }, {
            label: n("Buy Dip"),
            type: ic.BUY_DIP
        }, ...YR.has(r) ? [{
            label: n("Dev Sell"),
            type: ic.DEV_SELL_BUY
        }] : []],
        [xc.SELL]: [{
            label: n("Market"),
            type: ic.MARKET_SELL
        }, {
            label: n("Stop Loss"),
            type: ic.STOP_LOSS
        }, {
            label: n("Take Profit"),
            type: ic.TAKE_PROFIT
        }, {
            label: n("Trailing SL"),
            type: ic.TRAILING_STOP_LOSS
        }, ...YR.has(r) ? [{
            label: n("Dev Sell"),
            type: ic.DEV_SELL_SELL
        }] : []]
    })), [r, n]);
    return v.jsx(it, {
        sx: bEe,
        value: e.value,
        onChange: t,
        notched: !1,
        children: s[a].map((e => v.jsx(te, {
            value: e.type,
            children: v.jsx(k, {
                variant: "paragraph3",
                children: e.label
            })
        }, e.label)))
    })
}
))
  , vEe = y.memo(( () => {
    const {t: e} = we()
      , {errors: {trailingDelta: t}, touched: {trailingDelta: n}, setFieldValue: r, setFieldTouched: a} = Tn()
      , s = "medium"
      , o = y.useCallback((async ({target: {value: e}}) => {
        const t = QR(AI(e))
          , n = "" === t || isNaN(Number(t)) ? "" : Number(t) > 100 ? "100" : t;
        await r("trailingDelta", n),
        a("trailingDelta", !0)
    }
    ), [r, a])
      , l = y.useRef(null)
      , i = y.useCallback(( () => {
        var e;
        null == (e = l.current) || e.focus()
    }
    ), []);
    return v.jsx(C, {
        children: v.jsx(S, {
            gap: 1,
            flexDirection: "column",
            children: v.jsx(S, {
                display: "grid",
                gridTemplateColumns: "repeat(4, 1fr)",
                width: "100%",
                gap: 1.25,
                children: v.jsx(S, {
                    gridColumn: "span 4",
                    onClick: i,
                    children: v.jsx($Ie, {
                        size: s,
                        error: n && !!t,
                        children: ({disabled: r}) => v.jsxs(S, {
                            direction: "row",
                            children: [v.jsx(z, {
                                title: e("Once your order is placed, the system tracks the peak price and sets your stop loss trigger at delta % below it."),
                                children: v.jsx(C, {
                                    display: "flex",
                                    alignItems: "center",
                                    flex: "0 0 110px",
                                    px: "14px",
                                    gap: .75,
                                    children: v.jsx(k, {
                                        variant: "paragraph1",
                                        color: "text.label",
                                        sx: {
                                            display: "flex",
                                            gap: .25
                                        },
                                        children: "Trailing Delta"
                                    })
                                })
                            }), v.jsx(C, {
                                flexGrow: 1,
                                children: v.jsx(Zn, {
                                    name: "trailingDelta",
                                    children: ({field: e}) => v.jsx(je, {
                                        ref: l,
                                        ...e,
                                        onChange: o,
                                        onBlur: t => {
                                            e.onBlur(t)
                                        }
                                        ,
                                        size: s,
                                        placeholder: "0",
                                        disabled: r,
                                        error: n && !!t,
                                        inputProps: {
                                            ...Su,
                                            style: {
                                                textAlign: "right"
                                            },
                                            inputMode: "decimal"
                                        },
                                        "data-pseudotype": "numberLike",
                                        inputMode: "decimal",
                                        fullWidth: !0,
                                        endAdornment: v.jsx(C, {
                                            display: "flex",
                                            alignItems: "center",
                                            ml: .75,
                                            children: v.jsx(k, {
                                                variant: "paragraph1",
                                                color: "text.label",
                                                ...Nu,
                                                children: "%"
                                            })
                                        })
                                    })
                                })
                            })]
                        })
                    })
                })
            })
        })
    })
}
))
  , SEe = y.memo(( ({chain: e}) => {
    const {t: t} = we()
      , {includeExitStrategies: n, toggleIncludeExitStrategies: r} = KR()
      , {values: {hasExitStrategies: a}, setFieldValue: s} = Tn();
    return y.useEffect(( () => {
        s("hasExitStrategies", n)
    }
    ), [n, s]),
    v.jsxs(S, {
        gap: .5,
        children: [v.jsx(WR, {
            label: t("Exit Strategy"),
            isChecked: a,
            onClick: r
        }), a && v.jsx(rD, {
            chain: e
        })]
    })
}
))
  , yEe = y.memo((e => v.jsxs(S, {
    direction: "row",
    gap: 1,
    children: [v.jsx(mEe, {
        chain: e.chainId
    }), v.jsx(S, {
        width: kEe,
        alignItems: "center",
        children: v.jsx(xEe, {
            chain: e.chainId
        })
    })]
})))
  , kEe = 115
  , CEe = e => {
    switch (e) {
    case Pd.SOLANA:
        return Jv;
    case Pd.ETH_MAINNET:
    case Pd.BASE:
        return Df;
    case Pd.BSC:
        return rk;
    default:
        return null
    }
}
  , AEe = y.memo(( ({quoteForExecutionCurrencySymbol: e, baseCurrencySymbol: t, baseDecimals: n, quoteForExecutionDecimals: r, quoteForExecutionCurrency: a, quoterData: s, isMultiWallet: o, totalBaseBalance: l, chainId: i}) => {
    const c = D()
      , {font: d} = Vb()
      , {values: {specificType: u, quantityValue: p, triggerPrice: h, quantityInputMode: m, quantityPercentageValue: g}} = Tn()
      , x = ode()
      , b = Nde()
      , f = y.useMemo(( () => jc(u)), [u])
      , A = y.useMemo(( () => {
        const e = Ac(u)
          , t = nEe(null === x ? null : x.toString(), h || null, e, f)
          , a = m === nB.PERCENTAGE && o ? isNaN(Number(g)) ? "0" : (l * (Number(g) / 100)).toString() : p
          , s = sCe({
            side: jc(u),
            baseDecimals: n,
            quoteDecimals: r,
            cpQuoteInputs: b,
            quantityValue: a
        });
        return s ? s * t : s
    }
    ), [u, x, h, f, m, o, g, l, p, n, r, b])
      , w = y.useMemo(( () => {
        if (s.status === ox.INITIAL)
            return null;
        if (s.status !== ox.READY)
            return null;
        const e = Ac(u)
          , t = nEe(null === x ? null : x.toString(), h || null, e, f);
        return fc(s.data.quantity.value) ? new sB({
            decimals: s.data.quantity.unit === bc.BASE ? n : r
        },BigInt(s.data.quantity.value)).toNumber() * t : null
    }
    ), [n, x, r, s, f, u, h])
      , [j,T] = y.useMemo(( () => {
        const n = Tc(u) === bc.BASE ? e : t
          , r = ru(a) && f === xc.SELL ? CEe(i) : null
          , s = A ?? w;
        if (!s || isNaN(s))
            return [r ? "" : n, null];
        return [`${r || !s ? "" : "~"}${0 === s ? "" : LI(s, {
            symbol: r ? "" : n,
            collapseExponent: !0,
            maxPrecision: 2,
            noTrailingZeros: !0
        })}`, r]
    }
    ), [u, e, t, a, f, i, A, w]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        height: 16,
        children: [T && v.jsx(k, {
            ...jB,
            color: "background.primary",
            children: "~"
        }), T && v.jsx(C, {
            display: "flex",
            mt: d === ku.PADRE_PLEX ? -.25 : 0,
            children: v.jsx(T, {
                color: c.palette.background.primary
            })
        }), v.jsx(k, {
            ...jB,
            color: "background.primary",
            children: j
        })]
    })
}
))
  , wEe = (e, t, n, r, a, s) => {
    const o = Tc(t) === bc.QUOTE ? new sB({
        decimals: s
    },BigInt(r)) : new sB({
        decimals: a
    },BigInt(n));
    return isNaN(Number(e)) ? "" : o.multiply(Number(e) / 100).toExact()
}
  , jEe = 2.5
  , TEe = () => {
    const {values: e, setFieldValue: t} = Tn()
      , n = Zce((e => e.fdvInUsdUiRef))
      , r = mde()
      , {subscribeLineChange: a, unsubscribeLineChange: s} = OIe();
    y.useEffect(( () => {
        const o = c.debounce((a => {
            (null == r ? void 0 : r.current) && (e.priceInputMode === rB.FDV && t("priceFdvValue", (a * ((null == n ? void 0 : n.current) || 0) / Number(r.current)).toFixed(2)),
            t("triggerPrice", IEe(a.toFixed(20))))
        }
        ), 50);
        return a(o),
        () => s()
    }
    ), [t, a, s, e.priceInputMode, r, n])
}
  , IEe = e => {
    const t = Number(e);
    if (0 === t)
        return 0;
    const n = Math.max(2, WAe(e));
    return t.toFixed(n)
}
  , EEe = y.memo(( ({marketId: e, baseCurrencySymbol: t, quoteForExecutionCurrencySymbol: n, chainId: r, walletsAddresses: a, baseCurrency: s, baseDecimals: o, quoteForExecutionCurrency: l, quoteForExecutionDecimals: i, baseBalances: d, quoteForExecutionBalances: u, padreFeeBps: p, protocol: h}) => {
    var m, g, x, b, f, A, w, j;
    const {t: T} = we()
      , I = D()
      , {font: E} = Vb()
      , M = Zce((e => !(!e.marketStats || c.isNil(e.baseTokenDecimals) || c.isNil(e.marketStats.basePriceInUsdUi) || c.isNil(e.marketStats.baseTokenTotalSupply)) && 0 !== new sB({
        decimals: e.baseTokenDecimals
    },BigInt(e.marketStats.baseTokenTotalSupply)).multiply(e.marketStats.basePriceInUsdUi).toNumber()));
    TEe();
    const {setNewOrderData: N} = OIe()
      , {values: P, errors: O, setFieldValue: L, setFieldTouched: B, validateField: _, isValid: U, isSubmitting: W, resetForm: F, initialValues: H} = Tn()
      , {requiresReselect: $} = QSe();
    (e => {
        const {values: t, setFieldValue: n, setFieldTouched: r, validateForm: a} = Tn()
          , {selectedPreset: s} = QSe()
          , {settings: o} = rf()
          , [l,i] = y.useState(void 0);
        y.useEffect(( () => {
            if (!o)
                return;
            const d = Kb(o.orderPresets ?? null, s, e, jc(t.specificType));
            if (void 0 !== l && c.isEqual(l, d))
                return;
            const u = zb(s);
            (async () => {
                if (u) {
                    if (!$b.includes(e))
                        return;
                    return await n("isInInfernoMode", !0, !0),
                    void r("isInInfernoMode")
                }
                const t = [];
                d && null !== d.mevProtection && t.push(n("executionOptions.useMevProtection", d.mevProtection)),
                (null == d ? void 0 : d.slippage) && t.push(n("slippageValuePercent", d.slippage)),
                (null == d ? void 0 : d.prio) && t.push(n("executionOptions.gasSettings.prio", d.prio)),
                (null == d ? void 0 : d.tip) && t.push(n("executionOptions.gasSettings.tip", d.tip)),
                d && (null === d.customRpcUrl ? (t.push(n("customRpcUrl", "")),
                t.push(r("customRpcUrl", !1))) : (t.push(n("customRpcUrl", d.customRpcUrl)),
                t.push(r("customRpcUrl")))),
                d && null !== d.mevProtection && t.push(r("executionOptions.useMevProtection")),
                (null == d ? void 0 : d.slippage) && t.push(r("slippageValuePercent")),
                (null == d ? void 0 : d.prio) && t.push(r("executionOptions.gasSettings.prio")),
                (null == d ? void 0 : d.tip) && t.push(r("executionOptions.gasSettings.tip")),
                (null == d ? void 0 : d.customRpcUrl) && t.push(r("customRpcUrl")),
                t.push(n("isInInfernoMode", !1)),
                t.push(r("isInInfernoMode")),
                i(d),
                await Promise.all(t),
                await a()
            }
            )()
        }
        ), [e, l, s, r, n, o, a, t.specificType])
    }
    )(r);
    const G = y.useRef(H);
    G.current = H;
    const {setQuotePayload: q, invalidate: K, quoterData: Y} = Uke()
      , {hasLimitRawSigningPolicy: X} = UD((e => e))
      , {slimOrderStatus: Q} = FG(P.awaitingOrderId, !0);
    y.useEffect(( () => {
        Q.status === ox.ERROR && (L("awaitingOrderId", null),
        L("quantityValue", ""),
        L("quantityPercentageValue", "")),
        Q.status === ox.READY && ([sc.CANCELED, sc.EXECUTION_FAILED].includes(Q.data.orderStatus) && L("awaitingOrderId", null),
        Q.data.orderStatus === sc.FILLED && (L("awaitingOrderId", null),
        L("quantityValue", ""),
        L("quantityPercentageValue", "")))
    }
    ), [Q, L]),
    y.useEffect(( () => {
        P.isInInfernoMode && !$b.includes(r) && (L("isInInfernoMode", !1, !0),
        B("isInInfernoMode"))
    }
    ), [r, B, L, P.isInInfernoMode]);
    const {hasApiAuthenticator: Z} = YT()
      , {isSessionActive: ee, isLoadingSessionInfo: te, openNewSession: ne, isUnlocking: re} = $K()
      , ae = y.useCallback(( (t, n=!1) => {
        if (!a.length)
            return void K();
        if (!t || "0" === t)
            return void K();
        if (!/^\d+(\.\d+)?$/.test(t))
            return void K();
        const c = Tc(P.specificType)
          , d = c === bc.BASE ? o : i
          , [u,p] = t.split(".");
        (null == p ? void 0 : p.length) > d && (t = `${u}.${p.slice(0, d)}`),
        q({
            payload: {
                chain: r,
                pair: {
                    baseCurrency: s,
                    quoteCurrency: l
                },
                side: jc(P.specificType),
                quantity: {
                    unit: c,
                    value: sB.fromFractionalAmount({
                        decimals: d
                    }, t).getRawAmount().toString()
                },
                marketIds: [e],
                gasSettings: WB(r, P.executionOptions.gasSettings, P.executionOptions.useMevProtection, P.isInInfernoMode),
                walletsAddresses: a
            },
            force: n,
            rapidPolling: kB.includes(h.type)
        })
    }
    ), [P.specificType, P.executionOptions.gasSettings, P.executionOptions.useMevProtection, P.isInInfernoMode, o, i, q, r, s, l, e, a, K, h])
      , se = y.useMemo(( () => c.reduce(Object.values(d), ( (e, t) => e = (BigInt(e) + BigInt(t)).toString()), "0")), [d])
      , oe = y.useMemo(( () => new sB({
        decimals: o
    },BigInt(se)).toNumber()), [o, se]);
    y.useEffect(( () => {
        const e = u[a[0]] ?? "0";
        ae(P.quantityInputMode === nB.PERCENTAGE ? wEe(P.quantityPercentageValue, P.specificType, se, e, o, i) : P.quantityValue, !0)
    }
    ), [P.quantityValue, P.specificType, P.quantityInputMode, ae, P.quantityPercentageValue, d, u, o, i, a, se]),
    y.useEffect(( () => {
        F({
            values: G.current
        })
    }
    ), [e, F]);
    const le = y.useMemo(( () => Od.includes(r) || Ld.includes(r) && !!P.executionOptions.useMevProtection), [r, P.executionOptions.useMevProtection])
      , ie = y.useMemo(( () => Dd.includes(r)), [r])
      , ce = y.useMemo(( () => Bd.includes(r)), [r])
      , de = y.useMemo(( () => jc(P.specificType) === xc.BUY ? T("Buy") : T("Sell")), [P.specificType, T]);
    y.useEffect(( () => {
        _("quantityValue"),
        _("quantityPercentageValue")
    }
    ), [d, u, _]),
    y.useEffect(( () => {
        N({
            quantityValue: P.quantityValue,
            specificType: P.specificType,
            triggerPrice: P.triggerPrice,
            quantityInputMode: P.quantityInputMode,
            quantityPercentageValue: P.quantityPercentageValue
        })
    }
    ), [P.quantityValue, P.specificType, P.triggerPrice, P.quantityInputMode, P.quantityPercentageValue, N]),
    y.useEffect(( () => {
        wB.includes(P.specificType) || P.priceInputMode !== rB.FDV || L("priceInputMode", rB.PRICE)
    }
    ), [L, P.specificType, P.priceInputMode]);
    const ue = y.useMemo(( () => {
        var e, t, n;
        if (1 !== a.length)
            return !1;
        const o = u[a[0]] ?? "0"
          , c = d[a[0]] ?? "0"
          , h = hB(BigInt(o), s, {
            address: l,
            decimals: i
        }, r, (null == (e = P.executionOptions.gasSettings) ? void 0 : e.tip) ?? null, (null == (t = P.executionOptions.gasSettings) ? void 0 : t.prio) ?? null, "0" !== c, void 0 !== p ? BigInt(p) : void 0, P.isInInfernoMode, P.executionOptions.useMevProtection);
        return (null == (n = O.quantityValue) ? void 0 : n.startsWith(YD)) || !h.greaterThan(0) && !!o && "0" !== o
    }
    ), [u, s, l, i, r, null == (m = P.executionOptions.gasSettings) ? void 0 : m.tip, null == (g = P.executionOptions.gasSettings) ? void 0 : g.prio, P.executionOptions.useMevProtection, P.isInInfernoMode, d, p, O, a])
      , pe = W
      , he = W || !U || !a.length || ue || !!P.awaitingOrderId || !e || !M || $
      , [me,ge] = y.useState(!1)
      , xe = y.useMemo(( () => me && !he && !pe), [he, pe, me])
      , be = y.useCallback(( () => {
        ge(!0)
    }
    ), [])
      , fe = y.useCallback(( () => {
        ge(!1)
    }
    ), [])
      , ve = y.useMemo(( () => Y.status === ox.LOADING ? null : Y.status !== ox.READY ? Ud : OI(Number(Y.data.transactionFeeInUsd))), [Y])
      , [Se,ye] = y.useMemo(( () => {
        if (Ac(P.specificType) === rc.DEV_SOLD)
            return ["Create dev sell order", !1];
        if (Ac(P.specificType) === rc.STOP)
            return [`Create ${de} order`, !1];
        const e = isNaN(Number(P.quantityPercentageValue)) ? null : Number(P.quantityPercentageValue) / 100
          , a = jc(P.specificType) === xc.BUY
          , s = P.quantityInputMode !== nB.PERCENTAGE || a ? Number(P.quantityValue) : null === e ? null : Number(oe) * e
          , o = null !== s && s > 0
          , i = LI(s ?? 0, {
            collapseExponent: !0,
            maxPrecision: 3,
            noTrailingZeros: !0
        });
        if (a) {
            const e = ru(l) ? CEe(r) : null;
            return [v.jsxs(S, {
                direction: "row",
                gap: .25,
                alignItems: "center",
                height: 16,
                children: [`${ht(de)}${o ? ` ${e ? "" : i}` : ""}`, o ? e ? v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    children: [v.jsx(C, {
                        display: "flex",
                        mt: E === ku.PADRE_PLEX ? -.25 : 0,
                        children: v.jsx(e, {
                            color: I.palette.background.primary
                        })
                    }), i]
                }) : ` ${n}` : ""]
            }), o]
        }
        return [`${ht(de)} ${o ? ` ${i}` : ""} ${t}`, o]
    }
    ), [P.specificType, P.quantityPercentageValue, P.quantityInputMode, P.quantityValue, oe, de, l, r, E, I.palette.background.primary, n, t])
      , {chainStats: ke} = FV()
      , Ce = y.useMemo(( () => {
        const e = c.get(O, "executionOptions.gasSettings.tip");
        return ( (e, t, n, r, a, s, o) => {
            if (o)
                return null;
            if (n)
                return {
                    color: s.palette.error.main,
                    message: n
                };
            const l = null == r ? void 0 : r.perChain[a];
            if (!e || !l || "evm" === l.type)
                return null;
            const i = l.stats.tipUi
              , c = Number((null == t ? void 0 : t.tip) ?? "0");
            return null === i || Number(c.toFixed(20)) >= Number(i.toFixed(20)) ? null : {
                color: s.palette.warning.main,
                message: "Network is busy, consider increasing tip"
            }
        }
        )(le, P.executionOptions.gasSettings || null, e || null, ke, r, I, Bd.includes(r) && !!P.customRpcUrl)
    }
    ), [r, ke, O, le, I, P.executionOptions.gasSettings, P.customRpcUrl])
      , Ae = wde()
      , je = jde()
      , Te = y.useMemo(( () => {
        const e = a.length ? u[a[0]] ?? "0" : "0"
          , t = Number(e) / Number(10 ** i);
        return ( (e, t, n, r, a, s, o, l) => {
            if (!n)
                return null;
            const i = Number(n);
            if (isNaN(i))
                return null;
            const c = jc(r);
            if (l && c === xc.BUY && s && !isNaN(i)) {
                const e = o * (1 + i / 100);
                if (e > s)
                    return {
                        color: a.palette.warning.main,
                        message: `Buy may require up to ${UI(LI(e, {
                            collapseExponent: !0,
                            maxPrecision: 3,
                            minPrecision: 3,
                            symbol: ""
                        }))} SOL (${UI(LI(o, {
                            collapseExponent: !0,
                            maxPrecision: 3,
                            minPrecision: 3,
                            symbol: ""
                        }))} SOL * ${jI(i + 100, {
                            omitSign: !0,
                            precision: 0
                        })})`
                    }
            }
            const d = c === xc.BUY ? e : t;
            if (!d)
                return null;
            const u = Number(d);
            return i <= u ? 0 === u ? {
                color: a.palette.error.main,
                message: "Slippage is low"
            } : {
                color: a.palette.error.main,
                message: "Slippage lower than tax, transaction will likely fail"
            } : i <= u + jEe ? 0 === u ? {
                color: a.palette.error.main,
                message: "Slippage is low"
            } : {
                color: a.palette.warning.main,
                message: "Slippage close to tax, transaction might fail"
            } : null
        }
        )(Ae, je, P.slippageValuePercent, P.specificType, I, t, isNaN(Number(P.quantityValue)) ? 0 : Number(P.quantityValue), 1 === a.length && (h.type === Rc.PUMP_FUN || h.type === Rc.PUMP_SWAP))
    }
    ), [a, u, i, Ae, je, P.slippageValuePercent, P.specificType, P.quantityValue, I, h.type])
      , Ie = y.useMemo(( () => a.some((e => {
        d[e]
    }
    ))), [d, a])
      , Ee = y.useMemo(( () => {
        var e, t, n, s;
        if ($)
            return T("Gas preset not selected");
        if (!a.length)
            return "";
        if (ue) {
            const n = JD({
                chain: r,
                value: jc(P.specificType) === xc.SELL ? null : P.quantityValue,
                tip: (null == (e = P.executionOptions.gasSettings) ? void 0 : e.tip) ?? void 0,
                prio: (null == (t = P.executionOptions.gasSettings) ? void 0 : t.prio) ?? void 0,
                decimals: i,
                quoteAddress: l,
                padreFeeBps: p,
                hasBaseToken: Ie,
                useMevProtection: P.executionOptions.useMevProtection,
                isInInfernoMode: P.isInInfernoMode
            });
            return P.isInInfernoMode ? v.jsxs(S, {
                gap: .5,
                children: [v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    children: n
                }), v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    children: `Inferno mode requires a buffer of at least ${pB} SOL, but the actual tip & prio spent will likely be lower.`
                })]
            }) : n
        }
        if (!M)
            return "Market has no liquidity";
        if (P.awaitingOrderId)
            return "Waiting for the previous transaction to finalize";
        const o = null == (n = O.executionOptions) ? void 0 : n.gasSettings
          , c = o && "object" == typeof o ? o.prio ?? null : null
          , d = o && "object" == typeof o ? o.tip ?? null : null
          , u = d ? d.replace("Value", "Tip") : c ? c.replace("Value", "Prio") : null;
        return O.quantityValue ?? O.quantityPercentageValue ?? O.trailingDelta ?? O.customRpcUrl ?? u ?? (null == (s = O.executionOptions) ? void 0 : s.useMevProtection) ?? ""
    }
    ), [T, ue, Ie, M, P.awaitingOrderId, P.specificType, P.quantityValue, null == (x = P.executionOptions.gasSettings) ? void 0 : x.tip, null == (b = P.executionOptions.gasSettings) ? void 0 : b.prio, P.executionOptions.useMevProtection, P.isInInfernoMode, O.quantityValue, O.quantityPercentageValue, O.trailingDelta, O.customRpcUrl, null == (f = O.executionOptions) ? void 0 : f.useMevProtection, null == (A = O.executionOptions) ? void 0 : A.gasSettings, r, i, l, p, a, $])
      , Me = y.useMemo(( () => v.jsx(rt, {
        orientation: "horizontal",
        unmountOnExit: !0,
        in: pe,
        children: v.jsx(J, {
            size: 16,
            color: jc(P.specificType) === xc.BUY ? "positive" : "negative"
        })
    })), [pe, P.specificType])
      , Ne = y.useMemo(( () => e => ({
        px: 1.25,
        transition: "none",
        borderRadius: "24px",
        "&.Mui-disabled": {
            backgroundColor: `${jc(P.specificType) === xc.BUY ? e.palette.success.main : e.palette.error.main}80`,
            color: e.palette.background.primary
        }
    })), [P.specificType]);
    return v.jsxs(S, {
        gap: 1.5,
        "data-testid": "order-form-content",
        mt: 1,
        children: [v.jsx(yEe, {
            chainId: r
        }), v.jsxs(S, {
            gap: 1,
            children: [Ac(P.specificType) === rc.STOP && v.jsx(JIe, {}), P.specificType === ic.TRAILING_STOP_LOSS && v.jsx(vEe, {}), v.jsx(uEe, {
                baseCurrencySymbol: t,
                quoteCurrencySymbol: n,
                baseBalance: 1 === a.length ? d[a[0]] ?? "0" : "0",
                baseDecimals: o,
                baseCurrency: s,
                quoteBalance: 1 === a.length ? u[a[0]] ?? "0" : "0",
                quoteDecimals: i,
                quoteCurrency: l,
                chain: r,
                quoterData: Y,
                walletsCount: a.length,
                padreFeeBps: p
            })]
        }), uc.includes(P.specificType) && v.jsx(SEe, {
            chain: r
        }), v.jsx(VIe, {
            chain: r,
            specificType: P.specificType,
            slippageValuePercent: P.slippageValuePercent,
            gasSettings: P.executionOptions.gasSettings,
            useMevProtection: P.executionOptions.useMevProtection,
            supportsMevProtection: ie,
            supportsTip: le,
            transactionFeeInUsd: ve,
            side: jc(P.specificType),
            slippageWarningColor: (null == Te ? void 0 : Te.color) ?? null,
            slippageWarningMessage: (null == Te ? void 0 : Te.message) ?? null,
            tipWarningColor: (null == Ce ? void 0 : Ce.color) ?? null,
            tipWarningMessage: (null == Ce ? void 0 : Ce.message) ?? null,
            isInInfernoMode: P.isInInfernoMode,
            hasCustomRpc: !!P.customRpcUrl,
            supportsCustomRpc: ce
        }), v.jsx(S, {
            direction: "row",
            gap: 1,
            children: ee || te || Z ? !1 === X && r === Pd.BSC ? v.jsx(PIe, {
                iconSize: 16,
                label: "Enable BSC",
                message: "To start trading on BSC, please click below"
            }) : v.jsx(v.Fragment, {
                children: v.jsx(z, {
                    title: Ee,
                    children: v.jsx(C, {
                        component: "span",
                        width: "100%",
                        children: v.jsx(V, {
                            fullWidth: !0,
                            type: "submit",
                            variant: "secondary",
                            color: jc(P.specificType) === xc.BUY ? "positive" : "negative",
                            disabled: he,
                            onMouseOver: be,
                            onMouseOut: fe,
                            startIcon: Me,
                            size: "large",
                            sx: Ne,
                            onClick: NEe,
                            children: $ ? v.jsx(k, {
                                ...jB,
                                color: "background.primary",
                                children: T("Gas preset not selected")
                            }) : a.length ? ue ? v.jsx(k, {
                                ...jB,
                                color: "background.primary",
                                children: "Insufficient funds" + (R ? `, requires ${ZD({
                                    chain: r,
                                    value: jc(P.specificType) === xc.SELL ? "0" : P.quantityValue,
                                    tip: (null == (w = P.executionOptions.gasSettings) ? void 0 : w.tip) ?? void 0,
                                    prio: (null == (j = P.executionOptions.gasSettings) ? void 0 : j.prio) ?? void 0,
                                    decimals: i,
                                    quoteAddress: l,
                                    padreFeeBps: p,
                                    hasBaseToken: Ie,
                                    useMevProtection: P.executionOptions.useMevProtection
                                }) ?? `${gB[r]} ${r === Pd.SOLANA ? "SOL" : r === Pd.BSC ? "BNB" : "ETH"}`}` : "")
                            }) : v.jsxs(S, {
                                direction: "row",
                                width: "100%",
                                alignItems: "center",
                                justifyContent: ye ? "space-between" : "center",
                                gap: .5,
                                px: ye ? 2 : 0,
                                children: [v.jsx(k, {
                                    ...jB,
                                    color: "background.primary",
                                    children: Se
                                }), v.jsx(AEe, {
                                    baseCurrencySymbol: t,
                                    quoteForExecutionCurrencySymbol: n,
                                    baseDecimals: o,
                                    quoteForExecutionDecimals: i,
                                    quoterData: Y,
                                    isMultiWallet: a.length > 1,
                                    totalBaseBalance: oe,
                                    quoteForExecutionCurrency: l,
                                    chainId: r
                                })]
                            }) : v.jsx(k, {
                                ...jB,
                                color: "background.primary",
                                children: T("No wallets selected")
                            })
                        })
                    })
                })
            }) : v.jsx(V, {
                startIcon: re ? v.jsx(J, {
                    color: "inherit",
                    size: 16
                }) : v.jsx(vk, {
                    color: "inherit"
                }),
                disabled: re || !e,
                fullWidth: !0,
                onClick: () => ne(!1),
                size: "large",
                children: v.jsx(k, {
                    variant: "inherit",
                    color: "inherit",
                    lineHeight: 1,
                    children: "Unlock trading"
                })
            })
        }), v.jsx(MEe, {
            requestQuoterData: ae,
            walletsAddresses: a,
            baseDecimals: o,
            quoteDecimals: i,
            baseBalances: d,
            quoteForExecutionBalances: u,
            shouldWarm: xe,
            chainId: r,
            baseCurrency: s,
            quoteCurrency: l,
            marketId: e
        })]
    })
}
))
  , MEe = y.memo(( ({requestQuoterData: e, walletsAddresses: t, baseDecimals: n, quoteDecimals: r, baseBalances: a, quoteForExecutionBalances: s, shouldWarm: o, chainId: l, baseCurrency: i, quoteCurrency: c, marketId: d}) => (( (e, t, n, r, a, s) => {
    const o = ode()
      , {values: l, setFieldValue: i, validateField: c} = Tn()
      , d = y.useCallback((async () => {
        await i("triggerPrice", o ? IEe(o.toString()) : null),
        await c("triggerPrice")
    }
    ), [o, c, i])
      , u = NA(l.specificType);
    y.useEffect(( () => {
        const o = t.reduce(( (e, t) => t in a ? (BigInt(e) + BigInt(a[t])).toString() : e), "0").toString()
          , i = t.reduce(( (e, t) => t in s ? (BigInt(e) + BigInt(s[t])).toString() : e), "0").toString();
        u !== l.specificType && (Ac(l.specificType) === rc.STOP && d(),
        t.length && e(l.quantityInputMode === nB.PERCENTAGE ? wEe(l.quantityPercentageValue, l.specificType, o, i, n, r) : l.quantityValue, !0))
    }
    ), [l.specificType, t, u, d, e, l.quantityValue, l.quantityInputMode, l.quantityPercentageValue, a, s, n, r])
}
)(e, t, n, r, a, s),
Hke(o, t, l, i, c, d),
null)))
  , NEe = () => {
    np.info("Order form button clicked")
}
  , PEe = y.memo(( ({onClose: e, onProceed: t}) => {
    const {t: n} = we()
      , [r,a] = y.useState(!1)
      , s = y.useCallback(( () => {
        t(r)
    }
    ), [r, t])
      , o = y.useCallback(( () => {
        a((e => !e))
    }
    ), []);
    return v.jsxs(S, {
        gap: 1.5,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "h2",
                children: n("Transaction warning")
            }), v.jsx(F, {
                onClick: e,
                sx: OEe,
                children: v.jsx(kS, {})
            })]
        }), v.jsx(Ee, {}), v.jsxs(S, {
            gap: 3,
            pt: .5,
            children: [v.jsxs(S, {
                gap: .75,
                children: [v.jsxs(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: [n("This token has"), " ", v.jsx(C, {
                        component: "span",
                        color: "error.main",
                        fontWeight: 800,
                        children: n("dangerously low liquidity")
                    })]
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: n("Trade at your own risk")
                })]
            }), v.jsx(WR, {
                label: n("Don't show again for current market protocol"),
                isChecked: r,
                onClick: o,
                textVariant: "paragraph3"
            })]
        }), v.jsx(Ee, {}), v.jsx(V, {
            fullWidth: !0,
            size: "small",
            variant: "secondary",
            color: "error",
            onClick: s,
            children: v.jsx(k, {
                variant: "paragraph1",
                color: "background.default",
                children: n("Send Order Anyway")
            })
        })]
    })
}
))
  , OEe = {
    p: .5
}
  , LEe = y.memo(( ({isOpen: e, onResolve: t}) => {
    const n = y.useCallback(( () => {
        t(!1, !1)
    }
    ), [t])
      , r = y.useCallback((e => {
        t(!0, e)
    }
    ), [t]);
    return v.jsx(Sw, {
        open: e,
        onClose: n,
        stackSx: DEe,
        maxDesktopWidth: REe,
        minDesktopWidth: REe,
        children: v.jsx(PEe, {
            onClose: n,
            onProceed: r
        })
    })
}
))
  , REe = 400
  , DEe = {
    p: 2,
    pb: 1.5
}
  , BEe = (e, t, n, r, a, s) => {
    if (!t || n > 1)
        return ( (e, t, n, r, a) => {
            const s = gc(ED(a));
            if (t < 1 || t > s || n < 0 || n >= t)
                throw new Error("Invalid input");
            if (1 === t)
                return e;
            const o = 10000n
              , l = lb(r, {
                min: 0,
                max: 25
            });
            if (0 === l || t > 5)
                return e / BigInt(t);
            const i = 1 / t
              , c = l / 100 * i
              , d = (t - 1) / 2;
            let u = Array.from({
                length: t
            }, ( (e, t) => BigInt(((i + c * (t - d)) * Number(o)).toFixed(0))));
            const p = u.reduce(( (e, t) => e + t), 0n)
              , h = o - p;
            u = u.map(( (e, t) => t < Number(h) ? e + 1n : e));
            let m = u.map((t => e * t / o));
            const g = m.reduce(( (e, t) => e + t), 0n)
              , x = e - g;
            return m = m.map(( (e, t) => t < Number(x) ? e + 1n : e)),
            m[n]
        }
        )(BigInt(e), n, r, a, s).toString();
    const l = BigInt(e)
      , i = t + t / BigInt(_Ee);
    return l > t && l <= i ? (o(new Error(`Tried to send a bit higher than max balance quantity. Max ${t} current ${l}`)),
    t.toString()) : e
}
  , _Ee = 1e4
  , UEe = (e, t, n, r, a, s, o, l) => {
    const i = e.quantityInputMode === nB.PERCENTAGE
      , c = AB.includes(e.specificType) && a > 1
      , d = (null == t ? void 0 : t.getRawAmount()) ?? null;
    return i ? c ? BEe(null !== d ? (d * BigInt(e.quantityPercentageValue) / 100n).toString() : "0", d, 1, 0, o, l) : {
        type: "pct",
        pctValue: e.quantityPercentageValue
    } : BEe(( ({quantityValue: e, specificType: t}, {baseDecimals: n, quoteDecimals: r}) => sB.fromFractionalAmount({
        decimals: Tc(t) === bc.BASE ? n : r
    }, e).getRawAmount().toString())(e, {
        baseDecimals: n,
        quoteDecimals: r
    }), d, a, s, o, l)
}
  , WEe = {
    default: !1,
    pumpfun: !1,
    launchlab: !1,
    boop: !1,
    "meteora-curve": !1,
    moonit: !1,
    heaven: !1,
    "token-mill": !1,
    sugar: !1,
    fourmeme: !1,
    wagmi: !1,
    vista: !1,
    bonk: !1,
    believe: !1,
    moonshot: !1,
    jup: !1,
    bags: !1,
    tvt: !1,
    lfj: !1,
    daos: !1
}
  , FEe = y.memo(( ({marketId: e, marketInfo: t, initialSpecificType: n}) => {
    const r = Ax()
      , {trackCreatedOrder: a} = hf()
      , {tradePageOriginRef: s} = Qce()
      , o = y.useMemo(( () => loe(t)), [t])
      , l = zV()
      , i = qV()
      , {settings: d} = rf()
      , {selectedPreset: u} = QSe()
      , {acked: p, skipAck: m} = ( (e, t) => {
        const [n,r] = Mx("padreV2-lowLiquidityAcked", WEe);
        return y.useMemo(( () => {
            const a = t ?? e ?? "default"
              , s = n[a] ?? !1;
            return {
                acked: s,
                skipAck: () => {
                    s || r((e => ({
                        ...e,
                        [a]: !0
                    })))
                }
            }
        }
        ), [n, e, t, r])
    }
    )(t.launchpad, t.launchpadAux)
      , g = Cde(t.launchpad, t.launchpadAux)
      , {exitStrategies: x, includeExitStrategies: b} = KR()
      , {selectedWalletsAddresses: f, ethSubOrgId: S, solSubOrgId: k, compatibleWallets: C, credentialIds: A, refreshBalances: w} = Gde()
      , j = pK()
      , T = mde()
      , I = xde()
      , {isSessionActive: E, openModal: M} = $K()
      , {userStats: N} = rH()
      , P = y.useMemo(( () => {
        if (!e)
            return null;
        const t = mg(e);
        if ("eth-like" === t.type)
            return S;
        if ("sol" === t.type)
            return k;
        throw new Error("Unknown market type")
    }
    ), [e, S, k])
      , {showModal: O} = gU()
      , L = kde()
      , R = y.useMemo(( () => ({
        chainId: t.chain,
        baseCurrency: t.baseToken.address,
        baseCurrencySymbol: t.baseToken.symbol,
        baseDecimals: t.baseToken.decimals,
        uid: r ?? "",
        walletsAddresses: f,
        marketId: e,
        ethSubOrgId: S,
        solSubOrgId: k,
        padreAvatarUrl: (null == L ? void 0 : L.padreAvatarUrl) ?? null,
        protocol: t.protocol,
        devAddress: t.baseToken.deployer
    })), [r, t, L, e, f, S, k])
      , D = y.useMemo(( () => ({
        ...c.reduce(f, ( (e, t) => {
            if (!C)
                return e;
            const n = C.find(( ({wallet: {publicAddress: e}}) => ng(e) === ng(t)));
            return n ? (e.baseBalances[t] = n.balances.base.rawAmount ?? "0",
            e.quoteForExecutionBalances[t] = n.balances.quoteForExecution.rawAmount ?? "0",
            e.nativeBalances[t] = n.balances.native.rawAmount ?? "0",
            e) : e
        }
        ), {
            baseBalances: {},
            quoteForExecutionBalances: {},
            nativeBalances: {}
        }),
        baseCurrencySymbol: t.baseToken.symbol,
        quoteForExecutionCurrencySymbol: o.symbol,
        credentialIds: A,
        subOrgId: P,
        padreFeeBps: N.status === ox.READY ? N.data.feeBps : void 0
    })), [t.baseToken.symbol, o, C, f, A, P, N])
      , B = y.useRef(u);
    B.current = u;
    const _ = y.useRef(b);
    _.current = b;
    const U = (e => {
        const t = y.useRef(e);
        return c.isEqual(t.current, e) || (t.current = e),
        t.current
    }
    )(null == d ? void 0 : d.orderPresets)
      , W = y.useMemo(( () => {
        var e, t, r, a, s, o, l;
        const i = (c = R.chainId,
        {
            specificType: ic.MARKET_BUY,
            quantityValue: "",
            quantityPercentageValue: "",
            quantityInputMode: nB.VALUE,
            slippageValuePercent: "20",
            executionOptions: {
                gasSettings: uB(c),
                useMevProtection: Dd.includes(c)
            },
            customRpcUrl: "",
            triggerPrice: "",
            priceFdvValue: "",
            priceInputMode: rB.PRICE,
            ttlSeconds: null,
            expiresAtTimespan: "6 hours",
            previousQuantityValue: null,
            previousQuantityPercentageValue: null,
            awaitingOrderId: null,
            trailingDelta: "",
            isInInfernoMode: !1,
            hasExitStrategies: !1
        });
        var c;
        const d = n ?? i.specificType
          , u = jc(d)
          , p = B.current ? Kb(U ?? null, B.current, R.chainId, u) : null
          , h = !!B.current && zb(B.current)
          , m = {
            ...i
        };
        return p ? {
            ...m,
            hasExitStrategies: _.current,
            isInInfernoMode: h,
            specificType: d,
            slippageValuePercent: h ? m.slippageValuePercent : (null == (e = null == p ? void 0 : p.slippage) ? void 0 : e.toString()) ?? m.slippageValuePercent,
            customRpcUrl: (null == p ? void 0 : p.customRpcUrl) ?? m.customRpcUrl,
            executionOptions: {
                useMevProtection: p ? h ? m.executionOptions.useMevProtection : p.mevProtection ?? m.executionOptions.useMevProtection : m.executionOptions.useMevProtection,
                gasSettings: {
                    prio: p ? h ? (null == (t = m.executionOptions.gasSettings) ? void 0 : t.prio) ?? "0" : p.prio ?? (null == (r = m.executionOptions.gasSettings) ? void 0 : r.prio) ?? "0" : (null == (a = m.executionOptions.gasSettings) ? void 0 : a.prio) ?? "0",
                    tip: p ? h ? (null == (s = m.executionOptions.gasSettings) ? void 0 : s.tip) ?? "0" : p.tip ?? (null == (o = m.executionOptions.gasSettings) ? void 0 : o.tip) ?? "0" : (null == (l = m.executionOptions.gasSettings) ? void 0 : l.tip) ?? "0"
                }
            }
        } : m
    }
    ), [R.chainId, n, U])
      , F = y.useMemo(( () => dB({
        quoteForExecutionDecimals: o.decimals,
        quoteForExecutionCurrency: o.address,
        quoteForExecutionCurrencySymbol: o.symbol,
        ...kt(R, ["chainId", "baseDecimals", "baseCurrency", "baseCurrencySymbol", "walletsAddresses", "devAddress"]),
        ...kt(D, ["baseBalances", "quoteForExecutionBalances", "padreFeeBps"]),
        hasBaseToken: 1 !== R.walletsAddresses.length || "0" !== D.baseBalances[R.walletsAddresses[0]]
    })), [R, D, o])
      , V = Zce((e => {
        var t, n, r;
        return (null == (n = null == (t = e.marketStats) ? void 0 : t.marketProtocol) ? void 0 : n.type) === Rc.PUMP_FUN && !1 === (null == (r = e.marketStats) ? void 0 : r.isLaunchpadCompleted)
    }
    ))
      , {getTxnSign: H} = fU()
      , {get: z} = qke()
      , {getPadreLutData: $} = y.useContext(zD)
      , [G,q] = y.useState(!1)
      , K = y.useRef(null)
      , Y = y.useCallback(( (e, t) => {
        var n;
        return null == (n = K.current) ? void 0 : n.call(K, e, t)
    }
    ), [])
      , X = y.useCallback((async (n, {setSubmitting: r, setFieldValue: c}) => {
        const u = {
            type: n.specificType,
            chain: R.chainId,
            baseCurrency: R.baseCurrency,
            quoteCurreny: o.address,
            baseSymbol: R.baseCurrencySymbol,
            quoteSymbol: o.symbol,
            marketId: R.marketId,
            originWidget: Dp.WIDGET,
            selectedWalletsAddressesAmount: R.walletsAddresses.length,
            executionOptions: n.executionOptions,
            isInInfernoMode: n.isInInfernoMode,
            quantityValue: n.quantityValue,
            quantityPercentageValue: n.quantityPercentageValue,
            priceInputMode: n.priceInputMode,
            slippageValuePercent: n.slippageValuePercent,
            triggerPrice: n.triggerPrice,
            trailingDelta: n.trailingDelta
        };
        if (!d)
            return void np.warn("Order hasn't been sent - settings loading", {
                orderInfo: u
            });
        if (!E)
            return M(),
            void np.warn("Order hasn't been sent - missing active session", {
                orderInfo: u
            });
        const b = (null == T ? void 0 : T.current) ?? null
          , v = (null == I ? void 0 : I.current) ?? null;
        if (!R.walletsAddresses.length)
            return np.warn("Order hasn't been sent - no wallet selected", {
                orderInfo: u
            }),
            void j({
                message: pu.noWalletSelected,
                type: "warning"
            }, "no-wallet-selected");
        const S = CB.includes(n.specificType) || R.walletsAddresses.length > 1 && AB.includes(n.specificType)
          , y = n.quantityInputMode === nB.PERCENTAGE;
        if (!S && y || n.quantityInputMode === nB.VALUE && R.walletsAddresses.length > 1 && AB.includes(n.specificType))
            return np.warn("Order hasn't been sent - unsupported input mode", {
                orderInfo: u
            }),
            void j({
                message: uu.unsupportedInputMode,
                type: "error"
            }, "order-form-unsupported-quantity-input-mode-error");
        const k = R.walletsAddresses.some((e => D.baseBalances[e] && "0" !== D.baseBalances[e]));
        if (jc(n.specificType) === xc.SELL && !k)
            return np.warn("Order hasn't been sent - no token value", {
                orderInfo: u
            }),
            void j({
                message: pu.youDontHaveToken,
                type: "warning"
            }, "padre-order-form-missing-value-warning");
        if (y ? !n.quantityPercentageValue || isNaN(Number(n.quantityPercentageValue)) || 0 === Number(n.quantityPercentageValue) : !n.quantityValue || isNaN(Number(n.quantityValue)) || 0 === Number(n.quantityValue))
            return np.warn("Order hasn't been sent - missing form valaues", {
                orderInfo: u
            }),
            void j({
                message: (C = y ? "Percentage" : Tc(n.specificType) === bc.BASE ? "Amount" : "Total",
                `Please enter ${C}`),
                snackName: pu.missingValue,
                type: "warning"
            }, "padre-order-form-missing-value-warning");
        var C;
        if (g && !p) {
            if (!(await new Promise((e => {
                K.current = (t, n) => {
                    e(t),
                    q(!1),
                    K.current = null,
                    n && m()
                }
                ,
                q(!0)
            }
            ))))
                return void np.warn("Order hasn't been sent - missing low liquidity ack", {
                    orderInfo: u
                })
        }
        r(!0);
        const A = Ac(n.specificType) === rc.STOP ? isNaN(Number(n.triggerPrice)) ? null : Number(n.triggerPrice) : b ?? null
          , N = isNaN(Number(b)) ? null : Number(b)
          , P = ( (e, t, n) => {
            if (Ac(e) !== rc.STOP)
                return !0;
            if (null === n)
                return !1;
            if (null === t)
                return !1;
            const r = wc(e);
            return !r || (r === nc.GREATER ? n > t : t > n)
        }
        )(n.specificType, N, A);
        if (!P)
            return np.warn("Order hasn't been sent - stop price mismatch", {
                orderInfo: u
            }),
            void j({
                message: hu(n.specificType),
                snackName: pu.priceMismatch,
                type: "error"
            }, "padre-price-value-mismatch");
        const L = Math.min((null == d ? void 0 : d.solanaStopOrderMaxRevertRetry) ?? 0, 10)
          , _ = Ac(n.specificType);
        try {
            const r = h();
            let p = null;
            const m = R.walletsAddresses.map(( (a, s) => (async () => {
                try {
                    const u = vU()
                      , S = ( ({values: e, baseDecimals: t, quoteForExecutionDecimals: n, baseBalance: r, quoteForExecutionBalance: a, baseCurrency: s, quoteForExecutionCurrency: o, chain: l, padreFeeBps: i, useMevProtection: c, isInInfernoMode: d}) => {
                        var u, p;
                        const h = Tc(e.specificType)
                          , m = jc(e.specificType);
                        let g = null;
                        return h === bc.BASE && m === xc.SELL && (g = new sB({
                            decimals: t
                        },BigInt(r))),
                        h === bc.QUOTE && m === xc.BUY && (g = new sB({
                            decimals: n
                        },BigInt(a))),
                        g ? jc(e.specificType) === xc.SELL ? g : hB(g.getRawAmount(), s, {
                            address: o,
                            decimals: n
                        }, l, (null == (u = e.executionOptions.gasSettings) ? void 0 : u.tip) ?? null, (null == (p = e.executionOptions.gasSettings) ? void 0 : p.prio) ?? null, "0" !== r, void 0 !== i ? BigInt(i) : void 0, d, c) : null
                    }
                    )({
                        values: n,
                        baseDecimals: R.baseDecimals,
                        quoteForExecutionDecimals: o.decimals,
                        baseBalance: D.baseBalances[a] ?? "0",
                        quoteForExecutionBalance: D.quoteForExecutionBalances[a] ?? "0",
                        baseCurrency: R.baseCurrency,
                        quoteForExecutionCurrency: o.address,
                        chain: R.chainId,
                        padreFeeBps: D.padreFeeBps,
                        useMevProtection: n.executionOptions.useMevProtection,
                        isInInfernoMode: n.isInInfernoMode
                    });
                    if (R.walletsAddresses.length > 1 && (!S || S.getRawAmount() <= 0n))
                        return {
                            orderId: ""
                        };
                    const y = UEe(n, S, R.baseDecimals, o.decimals, R.walletsAddresses.length, s, d.multiWalletsTradeSpread ?? 2, R.chainId)
                      , k = ru(o.address) && Ej(t.quoteToken.address)
                      , C = MB({
                        ...R,
                        ...n,
                        validatedQuantityValue: y,
                        quoteForExecutionCurrency: o.address,
                        quoteForExecutionDecimals: o.decimals
                    }, u, L, V, x, b, v, o.address, r, B.current, YR.has(R.chainId));
                    if (ac(C))
                        try {
                            d.multiWalletsTradeDelay && s && jc(n.specificType) === xc.BUY && await Hu(1e3 * d.multiWalletsTradeDelay * s);
                            const t = await BV(a, C, z(e, a), H, $());
                            t && (C.signV2 = t)
                        } catch (g) {
                            np.error("Error during FE sign, falling back to old mechanism", {
                                createOrderRequest: C,
                                err: g
                            })
                        }
                    if (k && ac(C) && !C.signV2)
                        throw new Error("Failed to sign market order for quote subsitute");
                    const A = DV({
                        uid: R.uid,
                        chainId: R.chainId,
                        walletAddress: a,
                        request: C,
                        origin: Dp.WIDGET,
                        marketQuoteToken: t.quoteToken.address
                    });
                    C.type === rc.MARKET && 1 === f.length && j({
                        onOrderResolve: l,
                        onFill: () => {
                            w()
                        }
                        ,
                        onOpenSummary: O,
                        orderIdPromise: A,
                        variant: lK.SLIM_ORDER_STATUS,
                        orderSnackDetails: {
                            customAutoTimeoutDuration: i,
                            orderType: C.type,
                            tradeSide: C.tradeParams.side,
                            baseSymbol: D.baseCurrencySymbol,
                            baseValue: C.tradeParams.side === xc.SELL ? isNaN(Number(n.quantityValue)) || "" === n.quantityValue ? n.quantityPercentageValue ? `${n.quantityPercentageValue}%` : "" : UI(LI(_V(Number(n.quantityValue), R.walletsAddresses.length, s, d.multiWalletsTradeSpread ?? 2, R.chainId), {
                                collapseExponent: !0,
                                symbol: ""
                            })) : "",
                            quoteSymbol: D.quoteForExecutionCurrencySymbol,
                            quoteValue: C.tradeParams.side === xc.BUY ? isNaN(Number(n.quantityValue)) ? "" : UI(LI(_V(Number(n.quantityValue), R.walletsAddresses.length, s, d.multiWalletsTradeSpread ?? 2, R.chainId), {
                                collapseExponent: !0,
                                symbol: ""
                            })) : "",
                            tokenAddress: R.baseCurrency,
                            padreAvatarUrl: R.padreAvatarUrl,
                            chain: R.chainId,
                            showLowBalanceWarning: !1
                        }
                    }, "order-slim-status");
                    const T = AU({
                        orderType: C.type,
                        quantity: C.tradeParams.quantity,
                        basePriceInUsdUi: b,
                        basePriceInQuoteUi: v,
                        baseDecimals: R.baseDecimals,
                        quoteDecimals: o.decimals
                    });
                    p = null === T ? p : (p ?? 0) + T;
                    const I = await A;
                    return C.type === rc.MARKET && (null == d ? void 0 : d.clearOrderAfterSuccessfulTxn) && 1 === R.walletsAddresses.length && c("awaitingOrderId", I.orderId),
                    C.type === rc.STOP && j({
                        message: (h = jc(n.specificType),
                        m = D.baseCurrencySymbol,
                        `${Jd(h)} ${iu(m)} order has been created`),
                        type: "success"
                    }, "order-created-success"),
                    C.type === rc.TRAILING_STOP && j({
                        message: uu.trailingStopLossCreated,
                        type: "success"
                    }, "order-created-success-trailing-stop-loss"),
                    C.type === rc.DEV_SOLD && j({
                        message: uu.devSellCreated,
                        type: "success"
                    }, "order-created-success-dev-sold"),
                    I
                } catch (fNe) {
                    return np.error("Order hasn't been sent - exception thrown during processing order", {
                        orderInfo: u,
                        e: fNe
                    }),
                    j({
                        message: uu.unknownError,
                        snackName: pu.createFail,
                        type: "error"
                    }, "error-create-order"),
                    {
                        orderId: ""
                    }
                }
                var h, m
            }
            )()))
              , g = MB({
                ...R,
                ...n,
                validatedQuantityValue: "0",
                quoteForExecutionCurrency: o.address,
                quoteForExecutionDecimals: o.decimals
            }, "", 0, V, x, b, v, o.address, "multiWalletId", B.current, YR.has(R.chainId));
            R.walletsAddresses.length > 1 && g.type === rc.MARKET && j({
                onOrderResolve: l,
                onFill: () => {
                    w()
                }
                ,
                orderIdPromises: m,
                variant: lK.MULTI_ORDER_STATUS,
                orderSnackDetails: {
                    customAutoTimeoutDuration: i,
                    orderType: g.type,
                    tradeSide: g.tradeParams.side,
                    baseSymbol: D.baseCurrencySymbol,
                    baseValue: g.tradeParams.side === xc.SELL ? isNaN(Number(n.quantityValue)) || "" === n.quantityValue ? n.quantityPercentageValue ? `${n.quantityPercentageValue}%` : "" : UI(LI(Number(n.quantityValue), {
                        collapseExponent: !0,
                        symbol: ""
                    })) : "",
                    quoteSymbol: D.quoteForExecutionCurrencySymbol,
                    quoteValue: g.tradeParams.side === xc.BUY ? isNaN(Number(n.quantityValue)) ? "" : UI(LI(Number(n.quantityValue), {
                        collapseExponent: !0,
                        symbol: ""
                    })) : "",
                    tokenAddress: R.baseCurrency,
                    padreAvatarUrl: R.padreAvatarUrl,
                    chain: R.chainId
                }
            }, "order-multi-status"),
            await Promise.allSettled(m),
            a({
                chain: R.chainId,
                specificType: n.specificType,
                originWidget: Dp.WIDGET,
                isMultiWallet: f.length > 1,
                estimatedUsd: p,
                tradePageOrigin: s.current ?? nT.OTHER
            }),
            _ === rc.MARKET && !(null == d ? void 0 : d.clearOrderAfterSuccessfulTxn) && R.walletsAddresses.length > 1 && (c("previousQuantityValue", n.quantityValue),
            c("previousQuantityPercetnageValue", n.quantityValue)),
            _ === rc.STOP && (c("awaitingOrderId", null),
            c("previousQuantityValue", null),
            c("previousQuantityPercentageValue", null)),
            _ === rc.TRAILING_STOP && (c("awaitingOrderId", null),
            c("previousQuantityValue", null),
            c("previousQuantityPercentageValue", null)),
            _ === rc.DEV_SOLD && (c("awaitingOrderId", null),
            c("previousQuantityValue", null),
            c("previousQuantityPercentageValue", null)),
            (null == d ? void 0 : d.clearOrderAfterSuccessfulTxn) && _ !== rc.STOP || await c("quantityValue", "")
        } catch (fNe) {
            j({
                message: uu.unknownError,
                snackName: pu.unknownError,
                type: "error"
            }, "error-create-unknown-error")
        } finally {
            r(!1)
        }
    }
    ), [t.quoteToken.address, o, E, T, I, R, d, M, j, D.baseBalances, D.quoteForExecutionBalances, D.padreFeeBps, D.baseCurrencySymbol, D.quoteForExecutionCurrencySymbol, V, x, a, f.length, O, w, g, l, H, $, e, z, i, p, m, s]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(Ln, {
            initialValues: W,
            validationSchema: F,
            onSubmit: X,
            enableReinitialize: !0,
            validateOnMount: !0,
            children: v.jsx(Rn, {
                "data-testid": "order-form",
                children: v.jsx(EEe, {
                    baseCurrencySymbol: D.baseCurrencySymbol,
                    quoteForExecutionCurrencySymbol: D.quoteForExecutionCurrencySymbol,
                    baseBalances: D.baseBalances,
                    quoteForExecutionBalances: D.quoteForExecutionBalances,
                    nativeBalances: D.nativeBalances,
                    subOrgId: D.subOrgId,
                    credentialIds: D.credentialIds,
                    chainId: R.chainId,
                    walletsAddresses: R.walletsAddresses,
                    marketId: R.marketId,
                    baseCurrency: R.baseCurrency,
                    quoteForExecutionCurrency: o.address,
                    baseDecimals: R.baseDecimals,
                    quoteForExecutionDecimals: o.decimals,
                    protocol: R.protocol,
                    padreFeeBps: D.padreFeeBps
                })
            })
        }), v.jsx(LEe, {
            isOpen: G,
            onResolve: Y
        })]
    })
}
))
  , VEe = ({severity: e, title: t, titleAdornment: n, children: r, additionalContent: a, ...s}) => {
    const o = y.useMemo(( () => r ? v.jsx(k, {
        color: "text.primary",
        variant: "bodyRegular",
        children: r
    }) : null), [r])
      , l = y.useMemo(( () => {
        const t = "error" === e ? Ck : wk
          , n = e || "primary";
        return v.jsx(t, {
            color: n,
            size: HEe
        })
    }
    ), [e]);
    return v.jsxs(S, {
        p: 1.5,
        gap: 1,
        bgcolor: "background.tertiary",
        borderRadius: 1,
        mb: 2,
        ...s,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 2,
            height: t ? HEe : void 0,
            alignItems: t ? "flex-start" : "center",
            children: [v.jsx(C, {
                height: HEe,
                flex: `0 0 ${HEe}`,
                children: l
            }), t ? v.jsxs(S, {
                flex: "1 1 1px",
                direction: "row",
                alignItems: "baseline",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    color: "text.label",
                    variant: "labelLarge",
                    pt: e => (HEe - Number(e.typography.labelLarge.fontSize)) / 2 + "px",
                    children: t
                }), n && v.jsx(k, {
                    color: "text.meta",
                    variant: "bodySmall",
                    children: n
                })]
            }) : o]
        }), t ? o : null, a ?? null]
    })
}
  , HEe = 18
  , zEe = ({betterPoolMarketId: e}) => {
    const {t: t} = we();
    return v.jsx(rt, {
        in: !!e,
        children: v.jsx(VEe, {
            title: t("Sub-optimal market"),
            severity: "error",
            children: v.jsxs(S, {
                gap: .25,
                alignItems: "center",
                direction: "row",
                children: [v.jsx(k, {
                    color: "inherit",
                    variant: "inherit",
                    children: t("Better liquidity available in")
                }), v.jsxs($, {
                    component: Jn,
                    to: `${tT.TRADE}${e ? uT(e) : ""}`,
                    sx: {
                        gap: .5,
                        px: .25,
                        borderRadius: 1,
                        cursor: "pointer",
                        alignItems: "center",
                        color: "text.meta",
                        "&:hover": {
                            color: "text.primary",
                            transition: "color 200ms ease-in-out"
                        }
                    },
                    children: [v.jsx(k, {
                        variant: "inherit",
                        sx: {
                            color: "inherit"
                        },
                        children: t("other market")
                    }), v.jsx(Gy, {
                        color: "inherit"
                    })]
                })]
            })
        })
    })
}
  , $Ee = y.memo(( ({chain: e, tokenAddress: t}) => v.jsxs(v.Fragment, {
    children: ["Token is a honeypot according to", " ", v.jsxs(C, {
        component: "a",
        target: "_blank",
        href: kA(e, t) || "#",
        sx: e => ({
            display: "inline-flex",
            cursor: "pointer",
            textDecoration: "none",
            color: e.palette.gold[500],
            gap: "3px"
        }),
        children: [v.jsx(Sf, {
            size: GEe,
            color: "inherit"
        }), "honeypot.is"]
    })]
})))
  , GEe = 12
  , qEe = y.memo(( ({chain: e}) => {
    const {selectedPreset: t, setSelectedPreset: n, openEditModal: r, requiresReselect: a} = QSe()
      , s = y.useCallback((async () => {
        $b.includes(e) && (zb(t) || n("Inferno"))
    }
    ), [e, t, n]);
    return v.jsxs(S, {
        direction: "row",
        gap: .25,
        children: [KEe.map((e => {
            const s = !a && e === t;
            return v.jsx(fH, {
                label: yH(e),
                onClick: () => {
                    s ? r() : n(e)
                }
                ,
                useFlex: !1,
                typographyColor: s ? "primary.main" : "text.label"
            }, e)
        }
        )), $b.includes(e) && v.jsx(fH, {
            label: yH("Inferno", 14, 0, t && zb(t)),
            onClick: s,
            useFlex: !1
        }, "Inferno")]
    })
}
))
  , KEe = Object.values(zh)
  , YEe = y.memo(( ({isVisible: e, severity: t, label: n, onClose: r, Icon: a=gy}) => {
    const s = D()
      , {colorSkin: o, defaultThemeSkin: l} = Vb()
      , {textColor: i, backgroundColor: c} = y.useMemo(( () => ( (e, t, n, r) => {
        const {palette: a} = e;
        return t > 2 ? {
            textColor: n === rg.INDIGO || r === Xh.INDIGO ? a.background.default : a.error.main,
            backgroundColor: a.error.background
        } : t > 1 ? {
            textColor: a.yellow[500],
            backgroundColor: a.yellow[800]
        } : t > 0 ? {
            textColor: a.lavender[500],
            backgroundColor: `${a.lavender[500]}33`
        } : {
            textColor: a.text.primary,
            backgroundColor: a.background.secondary
        }
    }
    )(s, t, o, l)), [s, t, o, l]);
    return v.jsx(rt, {
        in: e,
        children: v.jsxs(C, {
            display: "flex",
            sx: {
                bgcolor: c,
                borderRadius: "4px",
                width: "100%",
                py: .75,
                px: 1,
                gap: 1,
                mb: 1,
                justifyContent: r ? "space-between" : "flex-start"
            },
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1,
                children: [v.jsx(S, {
                    alignItems: "center",
                    justifyContent: "center",
                    maxWidth: XEe,
                    children: v.jsx(Ck, {
                        size: XEe,
                        color: i
                    })
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: i,
                    children: n
                })]
            }), r && v.jsx(F, {
                sx: {
                    p: 0
                },
                onClick: r,
                children: v.jsx(a, {
                    size: XEe
                })
            })]
        })
    })
}
))
  , XEe = 14
  , QEe = y.memo((e => {
    const {t: t} = we()
      , {settings: n} = rf()
      , {openEditModal: r} = QSe()
      , a = y.useCallback(( () => {
        r()
    }
    ), [r])
      , [s,o] = Mx("padreV2-orderWidgetCollapsed", !1)
      , l = y.useCallback(( () => {
        o((e => !e))
    }
    ), [o])
      , [i,c] = Mx("padreV2-orderWidgetWalletSelectMode", eye.SELECT)
      , d = y.useCallback(( (e, t) => {
        c(t)
    }
    ), [c])
      , {openModal: u} = q6()
      , p = y.useMemo(( () => ({
        chain: e.marketInfo.chain,
        tokenAddress: e.marketInfo.baseToken.address
    })), [e.marketInfo.baseToken.address, e.marketInfo.chain])
      , h = jIe(e.marketId, e.marketInfo.baseToken.address, e.marketInfo.chain)
      , m = kde()
      , g = Zce((e => {
        var t;
        return !!(null == (t = e.marketStats) ? void 0 : t.baseTokenAudit) && e.marketStats.baseTokenAudit.chain !== Pd.SOLANA && (e.marketStats.baseTokenAudit.isHoneypotAccordingToHoneypotIs || !1)
    }
    ))
      , x = Zce((e => {
        var t;
        return !!(null == (t = e.marketStats) ? void 0 : t.baseTokenAudit) && e.marketStats.baseTokenAudit.chain === Pd.SOLANA && e.marketStats.baseTokenAddress !== Kc && e.marketStats.baseTokenAddress !== Yc && e.marketStats.baseTokenAddress !== Xc && (e.marketStats.baseTokenAudit.isFreezeAuthorityEnabled || !1)
    }
    ))
      , b = y.useMemo(( () => {
        const {deployer: t} = e.marketInfo.baseToken
          , n = null == m ? void 0 : m.displayedTokenCreator;
        return !(!n || !t) && ng(n) !== ng(t)
    }
    ), [e.marketInfo.baseToken, null == m ? void 0 : m.displayedTokenCreator])
      , f = Cde(e.marketInfo.launchpad, e.marketInfo.launchpadAux)
      , k = y.useMemo(( () => loe(e.marketInfo)), [e.marketInfo])
      , C = y.useMemo(( () => !!k.address && !ru(k.address)), [k.address])
      , A = y.useCallback(( () => {
        u(H6.SETTINGS, z6.TRADING)
    }
    ), [u])
      , [w,j] = Mx("padreV2-skipFreezeableStorageKey", !1)
      , [T,I] = y.useState(!1)
      , E = y.useCallback((e => {
        I(!0),
        e && j(!0)
    }
    ), [j])
      , {hiddenPairs: M} = SX()
      , N = y.useMemo(( () => !!M && (M[kX(e.marketInfo.baseToken.address, e.marketInfo.chain)] ?? !1)), [M, e.marketInfo.baseToken.address, e.marketInfo.chain])
      , P = y.useMemo(( () => (null == n ? void 0 : n.devBlacklist) ? new Set(n.devBlacklist) : new Set([])), [null == n ? void 0 : n.devBlacklist])
      , O = y.useMemo(( () => {
        const {deployer: t} = e.marketInfo.baseToken;
        return !!t && P.has(t)
    }
    ), [P, e.marketInfo.baseToken])
      , L = e.marketInfo.chain ?? null
      , R = (null == m ? void 0 : m.padreAvatarUrl) ?? null
      , D = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.isLaunchpadCompleted) ?? null
    }
    ))
      , [B,_] = dx("padreV2-bscBetaAcked", !1)
      , U = y.useCallback(( () => {
        _(!0)
    }
    ), [_])
      , [W,V] = Mx("padreV2-lastHiddenWarningsCloses", [])
      , H = y.useCallback(( () => {
        V((e => [ZEe(p.chain, p.tokenAddress), ...e].slice(0, 30)))
    }
    ), [V, p])
      , z = y.useMemo(( () => W.includes(ZEe(p.chain, p.tokenAddress))), [W, p])
      , [$,G] = Mx("padreV2-lastBlacklistWarningsCloses", [])
      , q = y.useCallback(( () => {
        const {deployer: t} = e.marketInfo.baseToken;
        t && G((e => [t, ...e].slice(0, 30)))
    }
    ), [e.marketInfo.baseToken, G])
      , K = y.useMemo(( () => {
        const {deployer: t} = e.marketInfo.baseToken;
        return !!t && $.includes(t)
    }
    ), [$, e.marketInfo.baseToken])
      , Y = y.useMemo(( () => e.marketInfo.protocol.type === Rc.BOOP || b || g || x || f || N && !z || !!n && !n.disableNonNativeWarn && C || !!h || !B && L === Pd.BSC), [h, B, L, x, z, N, g, f, C, b, e.marketInfo.protocol.type, n]);
    return v.jsxs(S, {
        children: [v.jsx(YEe, {
            severity: 1,
            isVisible: !B && L === Pd.BSC,
            label: t("BSC support is currently in beta."),
            onClose: U
        }), v.jsx(YEe, {
            severity: 2,
            isVisible: e.marketInfo.protocol.type === Rc.BOOP,
            label: t("Boop trading is in beta. Stay cautious")
        }), v.jsx(YEe, {
            severity: 3,
            isVisible: b,
            label: t("Token created off-chain, dev trying to impersonate another creator.")
        }), v.jsx(YEe, {
            severity: 3,
            isVisible: g,
            label: v.jsx($Ee, {
                chain: e.marketInfo.chain,
                tokenAddress: e.marketInfo.baseToken.address
            })
        }), v.jsx(YEe, {
            severity: 3,
            isVisible: x,
            label: t("Tokens can be frozen and prevented from trading.")
        }), v.jsx(YEe, {
            severity: 3,
            isVisible: f,
            label: t("Liquidity is low, your trade will incur a high price impact.")
        }), v.jsx(YEe, {
            severity: 2,
            isVisible: N && !z,
            label: t("Token is in your hidden list."),
            onClose: H
        }), v.jsx(YEe, {
            severity: 2,
            isVisible: O && !K,
            label: t("Token dev in your blacklist."),
            onClose: q
        }), v.jsx(YEe, {
            severity: 3,
            isVisible: !!n && !n.disableNonNativeWarn && C,
            label: t("Market uses a non-native quote currency."),
            onClose: A,
            Icon: Ky
        }), v.jsx(zEe, {
            betterPoolMarketId: h
        }), !e.hidePositionBox && v.jsx(FSe, {
            marketInfo: e.marketInfo
        }), !e.hidePositionBox && v.jsx(Ee, {
            sx: tMe,
            flexItem: !0
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            width: "100%",
            gap: 1,
            mb: s ? -1 : 1,
            mt: e.hidePositionBox && !Y ? -1 : 0,
            ml: -1,
            children: [v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                children: [v.jsx(F, {
                    onClick: a,
                    sx: nMe,
                    children: v.jsx(Ny, {})
                }), v.jsx(qEe, {
                    chain: e.marketInfo.chain
                })]
            }), v.jsxs(S, {
                gap: 1,
                mr: -1,
                direction: "row",
                alignItems: "center",
                children: [!s && v.jsx(S, {
                    minWidth: 2 * eMe,
                    children: v.jsx(IH, {
                        size: "xxsmall",
                        value: i,
                        onChange: d,
                        items: JEe,
                        maxItemWidth: eMe
                    })
                }), v.jsx(F, {
                    sx: rMe,
                    onClick: l,
                    children: s ? v.jsx(yy, {}) : v.jsx(Sy, {})
                })]
            })]
        }), !s && !!L && v.jsx(mye, {
            walletSelectMode: i,
            chain: L,
            padreAvatarUrl: R
        }), !s && v.jsx(EIe, {
            chain: e.marketInfo.chain,
            blur: x && !T && !w || !!D,
            protocol: e.marketInfo.protocol,
            isFreezeable: x,
            isFreezableAcknowledged: T || w,
            acknowledgeFreezeable: E,
            children: v.jsx(FEe, {
                ...e
            })
        })]
    })
}
))
  , ZEe = (e, t) => `${eg(e)}-${ng(t)}`
  , JEe = [{
    value: eye.TABLE,
    label: v.jsx(C, {
        display: "flex",
        children: v.jsx(Vk, {
            color: "inherit"
        })
    })
}, {
    value: eye.SELECT,
    label: v.jsx(C, {
        display: "flex",
        children: v.jsx(pS, {
            color: "inherit"
        })
    })
}]
  , eMe = 28
  , tMe = {
    mx: -2,
    mb: 1
}
  , nMe = {
    p: .5
}
  , rMe = {
    p: .25
}
  , aMe = y.memo(( ({marketId: e, marketInfo: t, toggleInstantMode: n}) => {
    const {t: r} = we()
      , a = D()
      , s = bxe()
      , [o,l] = y.useState(!1)
      , i = y.useCallback(( () => {
        l(!0)
    }
    ), [])
      , c = y.useCallback(( () => {
        l(!1)
    }
    ), [])
      , [d,u] = y.useState(ic.MARKET_BUY)
      , p = y.useCallback((async () => {
        await u(ic.MARKET_BUY),
        i()
    }
    ), [i])
      , h = y.useCallback((async () => {
        await u(ic.MARKET_SELL),
        i()
    }
    ), [i]);
    return v.jsxs(S, {
        "data-testid": "order-widget-drawer-controls",
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            children: [v.jsx(V, {
                color: "primary",
                variant: "secondary",
                onClick: n,
                sx: oMe,
                children: v.jsx(ay, {
                    size: 20,
                    color: a.palette.primary.main
                })
            }), v.jsx(V, {
                ...sMe,
                color: "success",
                variant: "secondary",
                onClick: p,
                children: r("Buy")
            }), v.jsx(V, {
                ...sMe,
                color: "error",
                variant: "secondary",
                onClick: h,
                children: r("Sell")
            })]
        }), v.jsx(_R, {
            "data-testid": "order-widget-drawer",
            anchor: "bottom",
            open: o,
            onOpen: i,
            onClose: c,
            disableSwipeToOpen: !0,
            keepMounted: !1,
            children: v.jsx(jR, {
                isOpen: o,
                hideHandle: !0,
                children: v.jsx(S, {
                    mb: `${s}px`,
                    children: v.jsx(QEe, {
                        marketId: e,
                        initialSpecificType: d,
                        marketInfo: t
                    })
                })
            })
        })]
    })
}
))
  , sMe = {
    variant: "primary",
    sx: {
        flex: "1 1 1px"
    }
}
  , oMe = e => ({
    minWidth: 40,
    width: 40,
    pr: .5,
    pl: .25,
    gap: .5,
    color: e.palette.primary.main,
    borderColor: e.palette.primary.main,
    backgroundColor: "transparent",
    "&:hover": {
        borderColor: e.palette.primary.main,
        backgroundColor: e.palette.background.buttonDefault
    },
    "&:focus": {
        borderColor: e.palette.primary.main,
        backgroundColor: "transparent"
    }
});
var lMe, iMe, cMe, dMe, uMe, pMe, hMe, mMe, gMe, xMe, bMe, fMe, vMe, SMe, yMe, kMe, CMe, AMe, wMe, jMe, TMe, IMe, EMe, MMe, NMe, PMe, OMe, LMe, RMe, DMe, BMe, _Me, UMe, WMe, FMe, VMe, HMe, zMe, $Me, GMe, qMe, KMe, YMe, XMe, QMe, ZMe, JMe, eNe, tNe, nNe, rNe, aNe, sNe, oNe, lNe, iNe, cNe, dNe, uNe, pNe, hNe, mNe, gNe, xNe, bNe, fNe, vNe, SNe, yNe, kNe, CNe, ANe, wNe, jNe, TNe, INe, ENe, MNe, NNe, PNe, ONe;
function LNe(e, t) {
    const n = {
        ...e
    };
    for (const r in t)
        "object" != typeof e[r] || null === e[r] || Array.isArray(e[r]) ? void 0 !== t[r] && (n[r] = t[r]) : n[r] = LNe(e[r], t[r]);
    return n
}
(fNe = lMe || (lMe = {})).UnknownAction = "UnknownAction",
fNe.Spinner = "Spinner",
fNe.Loading = "Loading",
fNe.AlertAdd = "Alert.Add",
fNe.AlertEdit = "Alert.Edit",
fNe.AlertsClone = "Alerts.Clone",
fNe.AlertsRemove = "Alerts.Remove",
fNe.AlertsRemoveAll = "Alerts.RemoveAll",
fNe.AlertsRemoveFiltered = "Alerts.RemoveFiltered",
fNe.AlertsRemoveAllInactive = "Alerts.RemoveAllInactive",
fNe.AlertsRemoveFires = "Alerts.RemoveFires",
fNe.AlertsRestart = "Alerts.Restart",
fNe.AlertsRestartAllInactive = "Alerts.RestartAllInactive",
fNe.AlertsRestartFilteredInactive = "Alerts.RestartFilteredInactive",
fNe.AlertsStop = "Alerts.Stop",
fNe.AlertsStopAll = "Alerts.StopAll",
fNe.AlertsStopFilteredActive = "Alerts.StopFilteredActive",
fNe.AlertsExportFiresToCSV = "Alerts.ExportFiresToCSV",
fNe.AlertsLogClear = "AlertsLog.Clear",
fNe.ChartAddIndicatorToAllCharts = "Chart.AddIndicatorToAllCharts",
fNe.ChartAddSymbolToWatchList = "Chart.AddSymbolToWatchList",
fNe.ChartAlertLabelToggleExtendLines = "Chart.AlertLabel.ToggleExtendLines",
fNe.ChartApplyIndicatorsToAllCharts = "Chart.ApplyIndicatorsToAllCharts",
fNe.ChartIndicatorApplyChildIndicator = "Chart.Indicator.ApplyChildIndicator",
fNe.ChartIndicatorApplyFinancials = "Chart.Indicator.ApplyFinancials",
fNe.ChartIndicatorAbout = "Chart.Indicator.About",
fNe.ChartIndicatorPineLogs = "Chart.Indicator.PineLogs",
fNe.ChartIndicatorPineSource = "Chart.Indicator.PineSource",
fNe.ChartIndicatorAddFavorites = "Chart.Indicator.AddFavorites",
fNe.ChartChangeTimeZone = "Chart.ChangeTimeZone",
fNe.ChartClipboardCopyPrice = "Chart.Clipboard.CopyPrice",
fNe.ChartClipboardCopyLineTools = "Chart.Clipboard.CopyLineTools",
fNe.ChartClipboardCopySource = "Chart.Clipboard.CopySource",
fNe.ChartClipboardPasteSource = "Chart.Clipboard.PasteSource",
fNe.ChartCrosshairLockVerticalCursor = "Chart.Crosshair.LockVerticalCursor",
fNe.ChartCrosshairPlusButtonDrawHorizontalLine = "Chart.Crosshair.PlusButton.DrawHorizontalLine",
fNe.ChartCustomActionId = "Chart.CustomActionId",
fNe.ChartDialogsShowChangeInterval = "Chart.Dialogs.ShowChangeInterval",
fNe.ChartDialogsShowChangeSymbol = "Chart.Dialogs.ShowChangeSymbol",
fNe.ChartDialogsShowCompareOrAddSymbol = "Chart.Dialogs.ShowCompareOrAddSymbol",
fNe.ChartDialogsShowGeneralSettings = "Chart.Dialogs.ShowGeneralSettings",
fNe.ChartDialogsShowGeneralSettingsLegendTab = "Chart.Dialogs.ShowGeneralSettings.LegendTab",
fNe.ChartDialogsShowGeneralSettingsSymbolTab = "Chart.Dialogs.ShowGeneralSettings.SymbolTab",
fNe.ChartDialogsShowGeneralScalesTab = "Chart.Dialogs.ShowGeneralSettings.ScalesTab",
fNe.ChartDialogsShowGeneralSettingsEventsAndAlertsTab = "Chart.Dialogs.ShowGeneralSettings.EventsAndAlertsTab",
fNe.ChartDialogsShowGoToDate = "Chart.Dialogs.ShowGoToDate",
fNe.ChartDialogsShowInsertIndicators = "Chart.Dialogs.ShowInsertIndicators",
fNe.ChartDialogsShowInsertFinancials = "Chart.Dialogs.ShowInsertFinancials",
fNe.ChartDialogsShowSymbolInfo = "Chart.Dialogs.ShowSymbolInfo",
fNe.ChartDrawingToolbarToggleVisibility = "Chart.DrawingToolbar.ToggleVisibility",
fNe.ChartExternalActionId = "Chart.ExternalActionId",
fNe.ChartFavoriteDrawingToolsToolbarHide = "Chart.FavoriteDrawingToolsToolbar.Hide",
fNe.ChartIndicatorShowSettingsDialog = "Chart.Indicator.ShowSettingsDialog",
fNe.ChartLegendToggleLastDayChangeValuesVisibility = "Chart.Legend.ToggleLastDayChangeValuesVisibility",
fNe.ChartLinkingGroupSync = "Chart.LinkingGroupSync",
fNe.ChartLinkingGroupSyncChangeGroup = "Chart.LinkingGroupSync.ChangeGroup",
fNe.ChartLegendToggleBarChangeValuesVisibility = "Chart.Legend.ToggleBarChangeValuesVisibility",
fNe.ChartLegendTogglePriceSourceVisibility = "Chart.Legend.TogglePriceSourceVisibility",
fNe.ChartLegendToggleIndicatorArgumentsVisibility = "Chart.Legend.ToggleIndicatorArgumentsVisibility",
fNe.ChartLegendToggleIndicatorTitlesVisibility = "Chart.Legend.ToggleIndicatorTitlesVisibility",
fNe.ChartLegendToggleIndicatorValuesVisibility = "Chart.Legend.ToggleIndicatorValuesVisibility",
fNe.ChartLegendToggleOhlcValuesVisibility = "Chart.Legend.ToggleOhlcValuesVisibility",
fNe.ChartLegendToggleOpenMarketStatusVisibility = "Chart.Legend.ToggleOpenMarketStatusVisibility",
fNe.ChartLegendToggleSymbolVisibility = "Chart.Legend.ToggleSymbolVisibility",
fNe.ChartLegendToggleVolumeVisibility = "Chart.Legend.ToggleVolumeVisibility",
fNe.ChartLines = "Chart.Lines",
fNe.ChartLinesToggleBidAskLinesVisibility = "Chart.Lines.ToggleBidAskLinesVisibility",
fNe.ChartLinesToggleHighLowLinesVisibility = "Chart.Lines.ToggleHighLowLinesVisibility",
fNe.ChartLinesToggleAverageLineVisibility = "Chart.Lines.ToggleAverageLineVisibility",
fNe.ChartLinesTogglePrePostMarketLineVisibility = "Chart.Lines.TogglePrePostMarketLineVisibility",
fNe.ChartLinesTogglePrePostMarketPriceLineVisibility = "Chart.Lines.TogglePrePostMarketPriceLineVisibility",
fNe.ChartLinesToggleSeriesPrevCloseLineVisibility = "Chart.Lines.ToggleSeriesPrevCloseLineVisibility",
fNe.ChartLinesToggleSeriesPriceLineVisibility = "Chart.Lines.ToggleSeriesPriceLineVisibility",
fNe.ChartLineToolBarsPatternToggleFlipped = "Chart.LineTool.BarsPattern.ToggleFlipped",
fNe.ChartLineToolBarsPatternToggleMirrored = "Chart.LineTool.BarsPattern.ToggleMirrored",
fNe.ChartLineToolClone = "Chart.LineTool.Clone",
fNe.ChartLineToolCreateLimitOrderFromState = "Chart.LineTool.CreateLimitOrderFromState",
fNe.ChartLineToolElliotChangeDegreeProperty = "Chart.LineTool.Elliot.ChangeDegreeProperty",
fNe.ChartLineToolNoSync = "Chart.LineTool.NoSync",
fNe.ChartLineToolPitchforkChangeTypeToInside = "Chart.LineTool.Pitchfork.ChangeTypeToInside",
fNe.ChartLineToolPitchforkChangeTypeToModifiedSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToModifiedSchiff",
fNe.ChartLineToolPitchforkChangeTypeToOriginal = "Chart.LineTool.Pitchfork.ChangeTypeToOriginal",
fNe.ChartLineToolPitchforkChangeTypeToSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToSchiff",
fNe.ChartLineToolSyncInLayout = "Chart.LineTool.SyncInLayout",
fNe.ChartLineToolSyncGlobally = "Chart.LineTool.SyncGlobally",
fNe.ChartLineToolTemplates = "Chart.LineTool.Templates",
fNe.ChartLineToolTemplatesApply = "Chart.LineTool.Templates.Apply",
fNe.ChartLineToolTemplatesApplyDefaults = "Chart.LineTool.Templates.ApplyDefaults",
fNe.ChartLineToolTemplatesSaveAs = "Chart.LineTool.Templates.SaveAs",
fNe.ChartLineToolToolbarChangeFontSizeProperty = "Chart.LineTool.Toolbar.ChangeFontSizeProperty",
fNe.ChartLineToolToolbarChangeLineStyleToDashed = "Chart.LineTool.Toolbar.ChangeLineStyleToDashed",
fNe.ChartLineToolToolbarChangeLineStyleToDotted = "Chart.LineTool.Toolbar.ChangeLineStyleToDotted",
fNe.ChartLineToolToolbarChangeLineStyleToSolid = "Chart.LineTool.Toolbar.ChangeLineStyleToSolid",
fNe.ChartMarksToggleVisibility = "Chart.Marks.ToggleVisibility",
fNe.ChartMoveChartInLayout = "Chart.MoveChartInLayout",
fNe.ChartMoveChartInLayoutBack = "Chart.MoveChartInLayout.Back",
fNe.ChartMoveChartInLayoutForward = "Chart.MoveChartInLayout.Forward",
fNe.ChartTpoResetAllMergesAndSplits = "Chart.TPO.ResetAllMergesAndSplits",
fNe.ChartTpoSplitBlock = "Chart.TPO.SplitBlock",
fNe.ChartTpoMergeBlock = "Chart.TPO.MergeBlock",
fNe.ChartObjectTreeShow = "Chart.ObjectTree.Show",
fNe.ChartDataWindowShow = "Chart.DataWindow.Show",
fNe.ChartPaneControlsDeletePane = "Chart.PaneControls.DeletePane",
fNe.ChartPaneControlsMaximizePane = "Chart.PaneControls.MaximizePane",
fNe.ChartPaneControlsMinimizePane = "Chart.PaneControls.MinimizePane",
fNe.ChartPaneControlsMovePaneDown = "Chart.PaneControls.MovePaneDown",
fNe.ChartPaneControlsMovePaneUp = "Chart.PaneControls.MovePaneUp",
fNe.ChartPaneControlsCollapsePane = "Chart.PaneControls.CollapsePane",
fNe.ChartPaneControlsRestorePane = "Chart.PaneControls.RestorePane",
fNe.ChartPriceScaleLabels = "Chart.PriceScale.Labels",
fNe.ChartPriceScaleLabelsToggleBidAskLabelsVisibility = "Chart.PriceScale.Labels.ToggleBidAskLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleHighLowPriceLabelsVisibility = "Chart.PriceScale.Labels.ToggleHighLowPriceLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleAveragePriceLabelVisibility = "Chart.PriceScale.Labels.ToggleAveragePriceLabelVisibility",
fNe.ChartPriceScaleLabelsToggleIndicatorsNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsNameLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleIndicatorsValueLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsValueLabelsVisibility",
fNe.ChartPriceScaleLabelsTogglePrePostMarketLabelsVisibility = "Chart.PriceScale.Labels.TogglePrePostMarketLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleNoOverlappingLabelsVisibility = "Chart.PriceScale.Labels.ToggleNoOverlappingLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleSeriesLastValueVisibility = "Chart.PriceScale.Labels.ToggleSeriesLastValueVisibility",
fNe.ChartPriceScaleLabelsToggleSymbolNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleSymbolNameLabelsVisibility",
fNe.ChartPriceScaleLabelsToggleSymbolPrevCloseValueVisibility = "Chart.PriceScale.Labels.ToggleSymbolPrevCloseValueVisibility",
fNe.ChartPriceScaleMergeAllScales = "Chart.PriceScale.MergeAllScales",
fNe.ChartPriceScaleMergeAllScalesToLeft = "Chart.PriceScale.MergeAllScalesToLeft",
fNe.ChartPriceScaleMergeAllScalesToRight = "Chart.PriceScale.MergeAllScalesToRight",
fNe.ChartPriceScaleMoveToLeft = "Chart.PriceScale.MoveToLeft",
fNe.ChartPriceScaleMoveToRight = "Chart.PriceScale.MoveToRight",
fNe.ChartPriceScaleReset = "Chart.PriceScale.Reset",
fNe.ChartPriceScaleToggleAddOrderPlusButtonVisibility = "Chart.PriceScale.ToggleAddOrderPlusButtonVisibility",
fNe.ChartPriceScaleToggleAutoScale = "Chart.PriceScale.ToggleAutoScale",
fNe.ChartPriceScaleToggleAutoScaleSeriesOnly = "Chart.PriceScale.ToggleAutoScaleSeriesOnly",
fNe.ChartPriceScaleToggleCountdownToBarCloseVisibility = "Chart.PriceScale.ToggleCountdownToBarCloseVisibility",
fNe.ChartPriceScaleToggleIndexedTo100 = "Chart.PriceScale.ToggleIndexedTo100",
fNe.ChartPriceScaleToggleInvertScale = "Chart.PriceScale.ToggleInvertScale",
fNe.ChartPriceScaleToggleLogarithmic = "Chart.PriceScale.ToggleLogarithmic",
fNe.ChartPriceScaleTogglePercentage = "Chart.PriceScale.TogglePercentage",
fNe.ChartPriceScaleToggleRegular = "Chart.PriceScale.ToggleRegular",
fNe.ChartRedo = "Chart.Redo",
fNe.ChartRemoveAllIndicators = "Chart.RemoveAllIndicators",
fNe.ChartRemoveAllIndicatorsAndLineTools = "Chart.RemoveAllIndicatorsAndLineTools",
fNe.ChartRemoveAllLineTools = "Chart.RemoveAllLineTools",
fNe.ChartScalesReset = "Chart.Scales.Reset",
fNe.ChartScalesToggleLockPriceToBarRatio = "Chart.Scales.ToggleLockPriceToBarRatio",
fNe.ChartScrollToLineTool = "Chart.ScrollToLineTool",
fNe.ChartSelectedObjectHide = "Chart.SelectedObject.Hide",
fNe.ChartSelectedObjectRemove = "Chart.SelectedObject.Remove",
fNe.ChartSelectedObjectShow = "Chart.SelectedObject.Show",
fNe.ChartSelectedObjectShowSettingsDialog = "Chart.SelectedObject.ShowSettingsDialog",
fNe.ChartSelectedObjectToggleLocked = "Chart.SelectedObject.ToggleLocked",
fNe.ChartSeriesPriceScaleToggleAutoScale = "Chart.Series.PriceScale.ToggleAutoScale",
fNe.ChartSeriesPriceScaleToggleIndexedTo100 = "Chart.Series.PriceScale.ToggleIndexedTo100",
fNe.ChartSeriesPriceScaleToggleInvertPriceScale = "Chart.Series.PriceScale.ToggleInvertPriceScale",
fNe.ChartSeriesPriceScaleToggleLogarithmic = "Chart.Series.PriceScale.ToggleLogarithmic",
fNe.ChartSeriesPriceScaleTogglePercentage = "Chart.Series.PriceScale.TogglePercentage",
fNe.ChartSeriesPriceScaleToggleRegular = "Chart.Series.PriceScale.ToggleRegular",
fNe.ChartSessionBreaksToggleVisibility = "Chart.SessionBreaks.ToggleVisibility",
fNe.ChartSetSession = "Chart.SetSession",
fNe.ChartSourceChangePriceScale = "Chart.Source.ChangePriceScale",
fNe.ChartSourceMergeDown = "Chart.Source.MergeDown",
fNe.ChartSourceMergeUp = "Chart.Source.MergeUp",
fNe.ChartSourceMoveToNoScale = "Chart.Source.MoveToNoScale",
fNe.ChartSourceMoveToOtherScale = "Chart.Source.MoveToOtherScale",
fNe.ChartSourceMoveToPane = "Chart.Source.MoveToPane",
fNe.ChartSourceUnmergeDown = "Chart.Source.UnmergeDown",
fNe.ChartSourceUnmergeUp = "Chart.Source.UnmergeUp",
fNe.ChartSourceVisualOrder = "Chart.Source.VisualOrder",
fNe.ChartSourceVisualOrderBringForward = "Chart.Source.VisualOrder.BringForward",
fNe.ChartSourceVisualOrderBringToFront = "Chart.Source.VisualOrder.BringToFront",
fNe.ChartSourceVisualOrderSendBackward = "Chart.Source.VisualOrder.SendBackward",
fNe.ChartSourceVisualOrderSendToBack = "Chart.Source.VisualOrder.SendToBack",
fNe.ChartSourceResetInputPoints = "Chart.Source.ResetInputPoints",
fNe.ChartThemeApply = "Chart.Theme.Apply",
fNe.ChartThemeApplyCustom = "Chart.Theme.Apply.Custom",
fNe.ChartThemeSaveAs = "Chart.Theme.SaveAs",
fNe.ChartTimeScaleReset = "Chart.TimeScale.Reset",
fNe.ChartUndo = "Chart.Undo",
fNe.ChartShowAllIdeas = "Chart.ShowAllIdeas",
fNe.ChartShowIdeasOfFollowedUsers = "Chart.ShowIdeasOfFollowedUsers",
fNe.ChartShowMyIdeasOnly = "Chart.ShowMyIdeasOnly",
fNe.ChartToggleVisibilityAllLineTools = "Chart.ToggleVisibility.AllLineTools",
fNe.ChartToggleVisibilityContinuousContractSwitch = "Chart.ToggleVisibility.ContinuousContractSwitch",
fNe.ChartToggleVisibilityContractExpiration = "Chart.ToggleVisibility.ContractExpiration",
fNe.ChartToggleVisibilityDividends = "Chart.ToggleVisibility.Dividends",
fNe.ChartToggleVisibilityEarnings = "Chart.ToggleVisibility.Earnings",
fNe.ChartToggleVisibilityEconomicEvents = "Chart.ToggleVisibility.EconomicEvents",
fNe.ChartToggleVisibilitySplits = "Chart.ToggleVisibility.Splits",
fNe.ChartToggleVisibilityLatestNewsAndMinds = "Chart.ToggleVisibility.LatestNewsAndMinds",
fNe.ChartSourceIntervalsVisibility = "Chart.Source.IntervalsVisibility",
fNe.ChartSourceIntervalsVisibilityCurrentAndAbove = "Chart.Source.IntervalsVisibility.CurrentAndAbove",
fNe.ChartSourceIntervalsVisibilityCurrentAndBelow = "Chart.Source.IntervalsVisibility.CurrentAndBelow",
fNe.ChartSourceIntervalsVisibilityOnlyCurrent = "Chart.Source.IntervalsVisibility.Current",
fNe.ChartSourceIntervalsVisibilityAll = "Chart.Source.IntervalsVisibility.All",
fNe.NoteCreate = "Note.Create",
fNe.NoteEdit = "Note.Edit",
fNe.NoteRemove = "Note.Remove",
fNe.ObjectsTreeCreateGroup = "ObjectsTree.CreateGroup",
fNe.ObjectsTreeRemoveItem = "ObjectsTree.RemoveItem",
fNe.ObjectsTreeRenameItem = "ObjectsTree.RenameItem",
fNe.ObjectsTreeToggleItemLocked = "ObjectsTree.ToggleItemLocked",
fNe.ObjectsTreeToggleItemVisibility = "ObjectsTree.ToggleItemVisibility",
fNe.PineEditorConsoleCopyMessage = "PineEditor.Console.CopyMessage",
fNe.PineEditorConsoleToggleVisibility = "PineEditor.Console.ToggleVisibility",
fNe.PineEditorConsoleClear = "PineEditor.Console.Clear",
fNe.ScreenerAddSymbolToCompare = "Screener.AddSymbolToCompare",
fNe.ScreenerColumnRemove = "Screener.Column.Remove",
fNe.ScreenerFilterChange = "Screener.Filter.Change",
fNe.ScreenerFilterReset = "Screener.Filter.Reset",
fNe.ScreenerOpenSymbolChart = "Screener.OpenSymbolChart",
fNe.ScreenerOpenSymbolOverview = "Screener.OpenSymbolOverview",
fNe.ScreenerToggleVisibilityCurrency = "Screener.ToggleVisibility.Currency",
fNe.ScreenerToggleVisibilityDescription = "Screener.ToggleVisibility.Description",
fNe.ScreenerToggleVisibilityRating = "Screener.ToggleVisibility.Rating",
fNe.ScreenerToggleVisibilitySymbolType = "Screener.ToggleVisibility.SymbolType",
fNe.TradingCancelOrder = "Trading.CancelOrder",
fNe.TradingClosePosition = "Trading.ClosePosition",
fNe.TradingCustomActionId = "Trading.CustomActionId",
fNe.TradingDOMPlaceLimitOrder = "Trading.DOMPlaceLimitOrder",
fNe.TradingDOMPlaceMarketOrder = "Trading.DOMPlaceMarketOrder",
fNe.TradingDOMPlaceStopLimitOrder = "Trading.DOMPlaceStopLimitOrder",
fNe.TradingDOMPlaceStopOrder = "Trading.DOMPlaceStopOrder",
fNe.TradingEditOrder = "Trading.EditOrder",
fNe.TradingModifyPosition = "Trading.ModifyPosition",
fNe.TradingReversePosition = "Trading.ReversePosition",
fNe.TradingSellBuyButtonsToggleVisibility = "Trading.SellBuyButtonsToggleVisibility",
fNe.TradingTradeFromChart = "Trading.TradeFromChart",
fNe.TradingNoOverlapMode = "Trading.NoOverlapMode",
fNe.TradingShowSelectBrokerPanel = "Trading.ShowSelectBrokerPanel",
fNe.TradingOrderTitle = "Trading.OrderTitle",
fNe.TradingPositionTitle = "Trading.PositionTitle",
fNe.WatchlistActions = "Watchlist.Actions",
fNe.WatchlistAddSelectedSymbolsToCompare = "Watchlist.AddSelectedSymbolsToCompare ",
fNe.WatchlistAddSymbolToCompare = "Watchlist.AddSymbolToCompare",
fNe.WatchlistAddSymbolToSection = "Watchlist.AddSymbolToSection",
fNe.WatchlistChangeFlaggedGroupColor = "Watchlist.ChangeFlaggedGroupColor",
fNe.WatchlistAddSymbol = "Watchlist.AddSymbol",
fNe.WatchlistCreate = "Watchlist.Create",
fNe.WatchlistAddSelectedSymbols = "Watchlist.AddSelectedSymbols",
fNe.WatchlistAddSelectedSymbolsLists = "Watchlist.AddSelectedSymbols.Lists",
fNe.WatchlistGetDisplayedTickerDescription = "Watchlist.GetDisplayedTickerDescription",
fNe.WatchlistCreateSection = "Watchlist.CreateSection",
fNe.WatchlistFlagSelectedSymbols = "Watchlist.FlagSelectedSymbols",
fNe.WatchlistFlagSymbol = "Watchlist.FlagSymbol",
fNe.WatchlistOpenSymbolChart = "Watchlist.OpenSymbolChart",
fNe.WatchlistOpenSymbolOverview = "Watchlist.OpenSymbolOverview",
fNe.WatchlistRemoveSection = "Watchlist.RemoveSection",
fNe.WatchlistRemoveSymbol = "Watchlist.RemoveSymbol",
fNe.WatchlistRenameSection = "Watchlist.RenameSection",
fNe.WatchlistUnflagAllSymbols = "Watchlist.UnflagAllSymbols",
fNe.WatchlistUnflagSelectedSymbols = "Watchlist.UnflagSelectedSymbols",
fNe.WatchlistUnflagSymbol = "Watchlist.UnflagSymbol",
(iMe || (iMe = {})).extractErrorReason = function(e) {
    return e.params[1]
}
,
function(e) {
    e.Default = "default",
    e.FullSingleSession = "full_single_session"
}(cMe || (cMe = {})),
function(e) {
    e.PeriodBack = "period-back",
    e.TimeRange = "time-range"
}(dMe || (dMe = {})),
function(e) {
    e.PeriodBack = "period-back",
    e.TimeRange = "time-range"
}(uMe || (uMe = {})),
function(e) {
    e.Open = "market",
    e.Pre = "pre_market",
    e.Post = "post_market",
    e.Close = "out_of_session",
    e.Holiday = "holiday"
}(pMe || (pMe = {})),
function(e) {
    e.Separator = "separator",
    e.Action = "action"
}(hMe || (hMe = {})),
function(e) {
    e[e.All = 0] = "All",
    e[e.BarMarks = 1] = "BarMarks",
    e[e.TimeScaleMarks = 2] = "TimeScaleMarks"
}(mMe || (mMe = {})),
function(e) {
    e[e.Line = 0] = "Line",
    e[e.Histogram = 1] = "Histogram",
    e[e.Cross = 3] = "Cross",
    e[e.Area = 4] = "Area",
    e[e.Columns = 5] = "Columns",
    e[e.Circles = 6] = "Circles",
    e[e.LineWithBreaks = 7] = "LineWithBreaks",
    e[e.AreaWithBreaks = 8] = "AreaWithBreaks",
    e[e.StepLine = 9] = "StepLine",
    e[e.StepLineWithDiamonds = 10] = "StepLineWithDiamonds",
    e[e.StepLineWithBreaks = 11] = "StepLineWithBreaks"
}(gMe || (gMe = {})),
function(e) {
    e.Line = "line",
    e.Colorer = "colorer",
    e.BarColorer = "bar_colorer",
    e.BgColorer = "bg_colorer",
    e.TextColorer = "text_colorer",
    e.OhlcColorer = "ohlc_colorer",
    e.CandleWickColorer = "wick_colorer",
    e.CandleBorderColorer = "border_colorer",
    e.UpColorer = "up_colorer",
    e.DownColorer = "down_colorer",
    e.Shapes = "shapes",
    e.Chars = "chars",
    e.Arrows = "arrows",
    e.Data = "data",
    e.DataOffset = "dataoffset",
    e.OhlcOpen = "ohlc_open",
    e.OhlcHigh = "ohlc_high",
    e.OhlcLow = "ohlc_low",
    e.OhlcClose = "ohlc_close"
}(xMe || (xMe = {})),
(bMe || (bMe = {})).AlertCondition = "alertcondition",
function(e) {
    e[e.None = 0] = "None",
    e[e.Pane = 1] = "Pane",
    e[e.DataWindow = 2] = "DataWindow",
    e[e.PriceScale = 4] = "PriceScale",
    e[e.StatusLine = 8] = "StatusLine",
    e[e.All = 15] = "All"
}(fMe || (fMe = {})),
function(e) {
    e[e.None = 0] = "None",
    e[e.Pane = 1] = "Pane",
    e[e.DataWindow = 2] = "DataWindow",
    e[e.PriceScale = 4] = "PriceScale",
    e[e.StatusLine = 8] = "StatusLine",
    e[e.All = 15] = "All"
}(vMe || (vMe = {})),
function(e) {
    e.OhlcBars = "ohlc_bars",
    e.OhlcCandles = "ohlc_candles"
}(SMe || (SMe = {})),
function(e) {
    e.Auto = "auto",
    e.Tiny = "tiny",
    e.Small = "small",
    e.Normal = "normal",
    e.Large = "large",
    e.Huge = "huge"
}(yMe || (yMe = {})),
function(e) {
    e.Integer = "integer",
    e.Float = "float",
    e.Price = "price",
    e.Bool = "bool",
    e.Text = "text",
    e.Symbol = "symbol",
    e.Session = "session",
    e.Source = "source",
    e.Resolution = "resolution",
    e.Time = "time",
    e.BarTime = "bar_time",
    e.Color = "color",
    e.Textarea = "text_area"
}(kMe || (kMe = {})),
function(e) {
    e[e.None = 0] = "None",
    e[e.DataWindow = 2] = "DataWindow",
    e[e.StatusLine = 8] = "StatusLine",
    e[e.All = 15] = "All"
}(CMe || (CMe = {})),
function(e) {
    e.InitialCapital = "initial_capital",
    e.Currency = "currency",
    e.DefaultQTYValue = "default_qty_value",
    e.DefaultQTYType = "default_qty_type",
    e.Pyramiding = "pyramiding",
    e.ComissionValue = "commission_value",
    e.ComissionType = "commission_type",
    e.BacktestFillLimitsAssumtion = "backtest_fill_limits_assumption",
    e.Slippage = "slippage",
    e.CalcOnOrderFills = "calc_on_order_fills",
    e.CalcOnEveryTick = "calc_on_every_tick",
    e.MarginLong = "margin_long",
    e.MarginShort = "margin_short",
    e.UseBarMagnifier = "use_bar_magnifier",
    e.ProcessOrdersOnClose = "process_orders_on_close",
    e.FillOrdersOnStandardOHLC = "fill_orders_on_standard_ohlc"
}(AMe || (AMe = {})),
function(e) {
    e.Fixed = "fixed",
    e.CashPerOrder = "cash_per_order",
    e.PercentOfEquity = "percent_of_equity"
}(wMe || (wMe = {})),
function(e) {
    e.Percent = "percent",
    e.CashPerContract = "cash_per_contract",
    e.CashPerOrder = "cash_per_order"
}(jMe || (jMe = {})),
function(e) {
    e.FirstBar = "first_visible_bar_time",
    e.LastBar = "last_visible_bar_time",
    e.Realtime = "subscribeRealtime"
}(TMe || (TMe = {})),
function(e) {
    e.FgColor = "__chart_fgcolor",
    e.BgColor = "__chart_bgcolor"
}(IMe || (IMe = {})),
function(e) {
    e[e.Right = 0] = "Right",
    e[e.Left = 1] = "Left",
    e[e.NoScale = 2] = "NoScale"
}(EMe || (EMe = {})),
function(e) {
    e[e.Right = 0] = "Right",
    e[e.Left = 1] = "Left",
    e[e.None = 2] = "None"
}(MMe || (MMe = {})),
function(e) {
    e.TypePlots = "plot_plot",
    e.TypeHlines = "hline_hline"
}(NMe || (NMe = {})),
function(e) {
    e[e.StopLoss = 0] = "StopLoss",
    e[e.TrailingStop = 1] = "TrailingStop",
    e[e.GuaranteedStop = 2] = "GuaranteedStop"
}(PMe || (PMe = {})),
(OMe || (OMe = {})).Symbol = "symbol",
function(e) {
    e[e.PopUp = 0] = "PopUp",
    e[e.Notification = 1] = "Notification"
}(LMe || (LMe = {})),
function(e) {
    e[e.CONNECTED = 1] = "CONNECTED",
    e[e.CONNECTING = 2] = "CONNECTING",
    e[e.DISCONNECTED = 3] = "DISCONNECTED",
    e[e.ERROR = 4] = "ERROR"
}(RMe || (RMe = {})),
function(e) {
    e[e.Connected = 1] = "Connected",
    e[e.Connecting = 2] = "Connecting",
    e[e.Disconnected = 3] = "Disconnected",
    e[e.Error = 4] = "Error"
}(DMe || (DMe = {})),
function(e) {
    e[e.LIMIT = 1] = "LIMIT",
    e[e.MARKET = 2] = "MARKET",
    e[e.STOP = 3] = "STOP",
    e[e.STOPLIMIT = 4] = "STOPLIMIT"
}(BMe || (BMe = {})),
function(e) {
    e[e.Limit = 1] = "Limit",
    e[e.Market = 2] = "Market",
    e[e.Stop = 3] = "Stop",
    e[e.StopLimit = 4] = "StopLimit"
}(_Me || (_Me = {})),
function(e) {
    e[e.BUY = 1] = "BUY",
    e[e.SELL = -1] = "SELL"
}(UMe || (UMe = {})),
function(e) {
    e[e.Buy = 1] = "Buy",
    e[e.Sell = -1] = "Sell"
}(WMe || (WMe = {})),
function(e) {
    e[e.CANCELED = 1] = "CANCELED",
    e[e.FILLED = 2] = "FILLED",
    e[e.INACTIVE = 3] = "INACTIVE",
    e[e.PLACING = 4] = "PLACING",
    e[e.REJECTED = 5] = "REJECTED",
    e[e.WORKING = 6] = "WORKING"
}(FMe || (FMe = {})),
function(e) {
    e[e.ALL = 0] = "ALL",
    e[e.CANCELED = 1] = "CANCELED",
    e[e.FILLED = 2] = "FILLED",
    e[e.INACTIVE = 3] = "INACTIVE",
    e[e.REJECTED = 5] = "REJECTED",
    e[e.WORKING = 6] = "WORKING"
}(VMe || (VMe = {})),
function(e) {
    e[e.Canceled = 1] = "Canceled",
    e[e.Filled = 2] = "Filled",
    e[e.Inactive = 3] = "Inactive",
    e[e.Placing = 4] = "Placing",
    e[e.Rejected = 5] = "Rejected",
    e[e.Working = 6] = "Working"
}(HMe || (HMe = {})),
function(e) {
    e[e.All = 0] = "All",
    e[e.Canceled = 1] = "Canceled",
    e[e.Filled = 2] = "Filled",
    e[e.Inactive = 3] = "Inactive",
    e[e.Rejected = 5] = "Rejected",
    e[e.Working = 6] = "Working"
}(zMe || (zMe = {})),
function(e) {
    e[e.Order = 1] = "Order",
    e[e.Position = 2] = "Position"
}($Me || ($Me = {})),
function(e) {
    e[e.ORDER = 1] = "ORDER",
    e[e.POSITION = 2] = "POSITION"
}(GMe || (GMe = {})),
function(e) {
    e[e.Order = 1] = "Order",
    e[e.Position = 2] = "Position",
    e[e.IndividualPosition = 3] = "IndividualPosition"
}(qMe || (qMe = {})),
function(e) {
    e[e.StopLoss = 0] = "StopLoss",
    e[e.TakeProfit = 1] = "TakeProfit",
    e[e.TrailingStop = 2] = "TrailingStop",
    e[e.GuaranteedStop = 3] = "GuaranteedStop"
}(KMe || (KMe = {})),
function(e) {
    e[e.LIMITPRICE = 1] = "LIMITPRICE",
    e[e.STOPPRICE = 2] = "STOPPRICE",
    e[e.TAKEPROFIT = 3] = "TAKEPROFIT",
    e[e.STOPLOSS = 4] = "STOPLOSS"
}(YMe || (YMe = {})),
function(e) {
    e[e.LimitPrice = 1] = "LimitPrice",
    e[e.StopPrice = 2] = "StopPrice",
    e[e.TakeProfit = 3] = "TakeProfit",
    e[e.StopLoss = 4] = "StopLoss",
    e[e.Quantity = 5] = "Quantity"
}(XMe || (XMe = {})),
function(e) {
    e[e.ERROR = 0] = "ERROR",
    e[e.SUCCESS = 1] = "SUCCESS"
}(QMe || (QMe = {})),
function(e) {
    e[e.Error = 0] = "Error",
    e[e.Success = 1] = "Success"
}(ZMe || (ZMe = {})),
function(e) {
    e[e.Demo = 1] = "Demo",
    e[e.Real = 0] = "Real"
}(JMe || (JMe = {})),
function(e) {
    e.Information = "information",
    e.Warning = "warning",
    e.Error = "error"
}(eNe || (eNe = {})),
function(e) {
    e.Demo = "demo",
    e.Live = "live"
}(tNe || (tNe = {})),
function(e) {
    e[e.LogOut = 0] = "LogOut",
    e[e.FailedRestoring = 1] = "FailedRestoring",
    e[e.Offline = 2] = "Offline",
    e[e.APIError = 3] = "APIError",
    e[e.TwoFactorRequired = 4] = "TwoFactorRequired",
    e[e.CancelAuthorization = 5] = "CancelAuthorization",
    e[e.TimeOutForAuthorization = 6] = "TimeOutForAuthorization",
    e[e.OauthError = 7] = "OauthError",
    e[e.BrokenConnection = 8] = "BrokenConnection",
    e[e.FailedSignIn = 9] = "FailedSignIn"
}(nNe || (nNe = {})),
function(e) {
    e[e.None = 0] = "None",
    e[e.Pips = 1] = "Pips",
    e[e.Ticks = 2] = "Ticks"
}(rNe || (rNe = {})),
function(e) {
    e.Halted = "HALTED",
    e.NotShortable = "NOT-SHORTABLE",
    e.HardToBorrow = "HARD-TO-BORROW"
}(aNe || (aNe = {})),
function(e) {
    e[e.Limit = 1] = "Limit",
    e[e.Stop = 2] = "Stop"
}(sNe || (sNe = {})),
function(e) {
    e.Disallowed = "disallowed",
    e.Allowed = "allowed",
    e.AllowedWithWarning = "allowed_with_warning"
}(oNe || (oNe = {})),
function(e) {
    e.PlaceOrder = "place_order",
    e.ModifyOrder = "modify_order",
    e.CancelOrder = "cancel_order",
    e.ModifyPosition = "modify_position",
    e.ClosePosition = "close_position",
    e.ModifyIndividualPosition = "modify_individual_position",
    e.CloseIndividualPosition = "close_individual_position",
    e.CloseNetPosition = "close_net_position"
}(lNe || (lNe = {})),
function(e) {
    e.Date = "date",
    e.DateOrDateTime = "dateOrDateTime",
    e.Default = "default",
    e.Fixed = "fixed",
    e.FixedInCurrency = "fixedInCurrency",
    e.VariablePrecision = "variablePrecision",
    e.FormatQuantity = "formatQuantity",
    e.FormatPrice = "formatPrice",
    e.FormatPriceForexSup = "formatPriceForexSup",
    e.FormatPriceInCurrency = "formatPriceInCurrency",
    e.IntegerSeparated = "integerSeparated",
    e.LocalDate = "localDate",
    e.LocalDateOrDateTime = "localDateOrDateTime",
    e.Percentage = "percentage",
    e.Pips = "pips",
    e.Profit = "profit",
    e.ProfitInInstrumentCurrency = "profitInInstrumentCurrency",
    e.Side = "side",
    e.PositionSide = "positionSide",
    e.Status = "status",
    e.Symbol = "symbol",
    e.Text = "text",
    e.Type = "type",
    e.MarginPercent = "marginPercent",
    e.Empty = "empty"
}(iNe || (iNe = {})),
function(e) {
    e[e.LastPriceAndPercentageValue = 0] = "LastPriceAndPercentageValue",
    e[e.LastValueAccordingToScale = 1] = "LastValueAccordingToScale"
}(cNe || (cNe = {})),
function(e) {
    e[e.Solid = 0] = "Solid",
    e[e.Dotted = 1] = "Dotted",
    e[e.Dashed = 2] = "Dashed"
}(dNe || (dNe = {})),
function(e) {
    e[e.Offline = 0] = "Offline",
    e[e.Resolving = 1] = "Resolving",
    e[e.Loading = 2] = "Loading",
    e[e.Ready = 3] = "Ready",
    e[e.InvalidSymbol = 4] = "InvalidSymbol",
    e[e.Snapshot = 5] = "Snapshot",
    e[e.EOD = 6] = "EOD",
    e[e.Pulse = 7] = "Pulse",
    e[e.Delayed = 8] = "Delayed",
    e[e.DelayedSteaming = 9] = "DelayedSteaming",
    e[e.NoBars = 10] = "NoBars",
    e[e.Replay = 11] = "Replay",
    e[e.Error = 12] = "Error",
    e[e.CalculationError = 13] = "CalculationError",
    e[e.UnsupportedResolution = 14] = "UnsupportedResolution"
}(uNe || (uNe = {})),
function(e) {
    e[e.Markers = 0] = "Markers",
    e[e.Stepline = 1] = "Stepline",
    e[e.Simple = 2] = "Simple"
}(pNe || (pNe = {})),
function(e) {
    e[e.Bar = 0] = "Bar",
    e[e.Candle = 1] = "Candle",
    e[e.Line = 2] = "Line",
    e[e.Area = 3] = "Area",
    e[e.Renko = 4] = "Renko",
    e[e.Kagi = 5] = "Kagi",
    e[e.PnF = 6] = "PnF",
    e[e.LineBreak = 7] = "LineBreak",
    e[e.HeikinAshi = 8] = "HeikinAshi",
    e[e.HollowCandle = 9] = "HollowCandle",
    e[e.Baseline = 10] = "Baseline",
    e[e.Range = 11] = "Range",
    e[e.HiLo = 12] = "HiLo",
    e[e.Column = 13] = "Column",
    e[e.LineWithMarkers = 14] = "LineWithMarkers",
    e[e.Stepline = 15] = "Stepline",
    e[e.HLCArea = 16] = "HLCArea",
    e[e.VolFootprint = 17] = "VolFootprint",
    e[e.TPO = 18] = "TPO",
    e[e.VolCandle = 19] = "VolCandle",
    e[e.SVP = 20] = "SVP"
}(hNe || (hNe = {})),
function(e) {
    e.TwentyFourHours = "24-hours",
    e.TwelveHours = "12-hours"
}(mNe || (mNe = {})),
function(e) {
    e[e.Initial = 2] = "Initial",
    e[e.SeriesZOrderIsAlwaysZero = 3] = "SeriesZOrderIsAlwaysZero",
    e[e.Current = 3] = "Current"
}(gNe || (gNe = {})),
function(e) {
    e[e.Money = 0] = "Money",
    e[e.Pips = 1] = "Pips",
    e[e.Percentage = 2] = "Percentage"
}(xNe || (xNe = {})),
function(e) {
    e[e.Left = 0] = "Left",
    e[e.Center = 1] = "Center",
    e[e.Right = 2] = "Right"
}(bNe || (bNe = {})),
xNe.Money,
xNe.Money,
bNe.Right,
function(e) {
    e[e.Background = 0] = "Background",
    e[e.Foreground = 1] = "Foreground",
    e[e.Topmost = 2] = "Topmost"
}(vNe || (vNe = {})),
function(e) {
    e[e.Unavailable = 0] = "Unavailable",
    e[e.AvailableReadonlyAlwaysDisabled = 1] = "AvailableReadonlyAlwaysDisabled",
    e[e.AvailableReadonlyAlwaysEnabled = 2] = "AvailableReadonlyAlwaysEnabled",
    e[e.Available = 3] = "Available"
}(SNe || (SNe = {})),
function(e) {
    e[e.ViewportChangeUserAction = 0] = "ViewportChangeUserAction",
    e[e.DataUpdate = 1] = "DataUpdate",
    e[e.SeriesRestart = 2] = "SeriesRestart",
    e[e.SeriesCompleted = 3] = "SeriesCompleted",
    e[e.StudyCreation = 4] = "StudyCreation"
}(yNe || (yNe = {})),
function(e) {
    e[e.Chart = 0] = "Chart"
}(kNe || (kNe = {})),
function(e) {
    e.AlwaysOn = "alwaysOn",
    e.VisibleOnMouseOver = "visibleOnMouseOver",
    e.AlwaysOff = "alwaysOff"
}(CNe || (CNe = {})),
function(e) {
    e[e.Normal = 0] = "Normal",
    e[e.Log = 1] = "Log",
    e[e.Percentage = 2] = "Percentage",
    e[e.IndexedTo100 = 3] = "IndexedTo100"
}(ANe || (ANe = {})),
function(e) {
    e[e.Bars = 0] = "Bars",
    e[e.Candles = 1] = "Candles",
    e[e.Line = 2] = "Line",
    e[e.Area = 3] = "Area",
    e[e.HeikenAshi = 8] = "HeikenAshi",
    e[e.HollowCandles = 9] = "HollowCandles",
    e[e.Baseline = 10] = "Baseline",
    e[e.HiLo = 12] = "HiLo",
    e[e.Column = 13] = "Column",
    e[e.LineWithMarkers = 14] = "LineWithMarkers",
    e[e.Stepline = 15] = "Stepline",
    e[e.HLCArea = 16] = "HLCArea",
    e[e.VolCandle = 19] = "VolCandle",
    e[e.Renko = 4] = "Renko",
    e[e.Kagi = 5] = "Kagi",
    e[e.PointAndFigure = 6] = "PointAndFigure",
    e[e.LineBreak = 7] = "LineBreak"
}(wNe || (wNe = {})),
(jNe || (jNe = {})).Value = "_seriesId",
function(e) {
    e.LeftToRight = "left_to_right",
    e.RightToLeft = "right_to_left"
}(TNe || (TNe = {})),
function(e) {
    e.Relative = "relative",
    e.Absolute = "absolute"
}(INe || (INe = {})),
function(e) {
    e.UpDown = "Up/Down",
    e.Total = "Total",
    e.Delta = "Delta"
}(ENe || (ENe = {})),
function(e) {
    e.AboveBar = "AboveBar",
    e.BelowBar = "BelowBar",
    e.Top = "Top",
    e.Bottom = "Bottom",
    e.Right = "Right",
    e.Left = "Left",
    e.Absolute = "Absolute",
    e.AbsoluteUp = "AbsoluteUp",
    e.AbsoluteDown = "AbsoluteDown"
}(MNe || (MNe = {})),
function(e) {
    e.Left = "left",
    e.Center = "center",
    e.Right = "right"
}(NNe || (NNe = {})),
function(e) {
    e.Top = "top",
    e.Middle = "middle",
    e.Bottom = "bottom"
}(PNe || (PNe = {})),
function(e) {
    e[e.Solid = 0] = "Solid",
    e[e.Dotted = 1] = "Dotted",
    e[e.Dashed = 2] = "Dashed"
}(ONe || (ONe = {}));
const RNe = {
    width: 800,
    height: 500,
    interval: "1D",
    timezone: "Etc/UTC",
    container: "",
    library_path: "",
    locale: "en",
    widgetbar: {
        details: !1,
        watchlist: !1,
        news: !1,
        datawindow: !1,
        watchlist_settings: {
            default_symbols: []
        }
    },
    overrides: {
        "mainSeriesProperties.showCountdown": !1
    },
    studies_overrides: {},
    trading_customization: {
        position: {},
        order: {}
    },
    brokerConfig: {
        configFlags: {}
    },
    fullscreen: !1,
    autosize: !1,
    disabled_features: [],
    enabled_features: [],
    debug: !1,
    logo: {},
    time_frames: [{
        text: "5y",
        resolution: "1W"
    }, {
        text: "1y",
        resolution: "1W"
    }, {
        text: "6m",
        resolution: "120"
    }, {
        text: "3m",
        resolution: "60"
    }, {
        text: "1m",
        resolution: "30"
    }, {
        text: "5d",
        resolution: "5"
    }, {
        text: "1d",
        resolution: "1"
    }],
    client_id: "0",
    user_id: "0",
    charts_storage_api_version: "1.0",
    favorites: {
        intervals: [],
        chartTypes: [],
        indicators: [],
        drawingTools: []
    }
}
  , DNe = JSON.parse('[{"iso":"ar","dir":"rtl","language":"ar"},{"iso":"pt","dir":"ltr","language":"pt"},{"iso":"ca","dir":"ltr","language":"ca_ES"},{"iso":"cs","dir":"ltr","language":"cs"},{"iso":"de","dir":"ltr","language":"de"},{"iso":"en","dir":"ltr","language":"en"},{"iso":"es","dir":"ltr","language":"es"},{"iso":"fa","dir":"rtl","language":"fa"},{"iso":"fr","dir":"ltr","language":"fr"},{"iso":"he","dir":"rtl","language":"he_IL"},{"iso":"hu","dir":"ltr","language":"hu_HU"},{"iso":"id","dir":"ltr","language":"id_ID"},{"iso":"en","dir":"ltr","language":"en"},{"iso":"it","dir":"ltr","language":"it"},{"iso":"ja","dir":"ltr","language":"ja"},{"iso":"ko","dir":"ltr","language":"ko"},{"iso":"ms","dir":"ltr","language":"ms_MY"},{"iso":"pl","dir":"ltr","language":"pl"},{"iso":"ru","dir":"ltr","language":"ru"},{"iso":"sv","dir":"ltr","language":"sv"},{"iso":"th","dir":"ltr","language":"th"},{"iso":"tr","dir":"ltr","language":"tr"},{"iso":"vi","dir":"ltr","language":"vi"},{"iso":"zh-Hans","dir":"ltr","language":"zh"},{"iso":"zh-Hant","dir":"ltr","language":"zh_TW"},{"iso":"el","dir":"ltr","language":"el"},{"iso":"nl","dir":"ltr","language":"nl_NL"},{"iso":"ro","dir":"ltr","language":"ro"}]');
let BNe = !1;
const _Ne = class {
    constructor(e) {
        var t, n;
        if (this._id = `tradingview_${(1048576 * (1 + Math.random()) | 0).toString(16).substring(1)}`,
        this._ready = !1,
        this._readyHandlers = [],
        this._onWindowResize = this._autoResizeChart.bind(this),
        !e.datafeed)
            throw new Error("Datafeed is not defined");
        (null === (t = e.overrides) || void 0 === t ? void 0 : t["mainSeriesProperties.priceAxisProperties.lockScale"]) && delete e.overrides["mainSeriesProperties.priceAxisProperties.lockScale"],
        this._options = LNe(RNe, e),
        "dark" === (null !== (n = this._options.theme) && void 0 !== n ? n : "light").toLowerCase() && void 0 === this._options.loading_screen && (this._options.loading_screen = {
            backgroundColor: "#131722"
        }),
        (this._options.debug || this._options.debug_broker) && (BNe || (BNe = !0)),
        this._innerWindowLoaded = new Promise((e => {
            this._innerWindowResolver = e
        }
        )),
        this._create()
    }
    setDebugMode(e) {
        this._innerAPI().setDebugMode(e)
    }
    onChartReady(e) {
        this._ready ? e.call(this) : this._readyHandlers.push(e)
    }
    headerReady() {
        return this._innerWindowLoaded.then(( () => this._innerWindow().headerReady()))
    }
    onGrayedObjectClicked(e) {
        this._doWhenInnerApiLoaded((t => {
            t.onGrayedObjectClicked(e)
        }
        ))
    }
    onShortcut(e, t) {
        this._doWhenInnerWindowLoaded((n => {
            n.createShortcutAction(e, t)
        }
        ))
    }
    subscribe(e, t) {
        this._doWhenInnerApiLoaded((n => {
            n.subscribe(e, t)
        }
        ))
    }
    unsubscribe(e, t) {
        this._doWhenInnerApiLoaded((n => {
            n.unsubscribe(e, t)
        }
        ))
    }
    chart(e) {
        return this._innerAPI().chart(e)
    }
    getLanguage() {
        return this._options.locale
    }
    setSymbol(e, t, n) {
        this._innerAPI().changeSymbol(e, t, n)
    }
    remove() {
        window.removeEventListener("resize", this._onWindowResize),
        this._readyHandlers.splice(0, this._readyHandlers.length),
        delete window[this._id],
        this._iFrame.parentNode && this._iFrame.parentNode.removeChild(this._iFrame)
    }
    closePopupsAndDialogs() {
        this._doWhenInnerApiLoaded((e => {
            e.closePopupsAndDialogs()
        }
        ))
    }
    selectLineTool(e, t) {
        this._innerAPI().selectLineTool(e, t)
    }
    selectedLineTool() {
        return this._innerAPI().selectedLineTool()
    }
    save(e, t) {
        this._innerAPI().saveChart(e, t)
    }
    load(e, t) {
        this._innerAPI().loadChart({
            json: e,
            extendedData: t
        })
    }
    getSavedCharts(e) {
        this._innerAPI().getSavedCharts(e)
    }
    loadChartFromServer(e) {
        this._innerAPI().loadChartFromServer(e)
    }
    saveChartToServer(e, t, n) {
        this._innerAPI().saveChartToServer(e, t, n)
    }
    removeChartFromServer(e, t) {
        this._innerAPI().removeChartFromServer(e, t)
    }
    onContextMenu(e) {
        this._doWhenInnerApiLoaded((t => {
            t.onContextMenu(e)
        }
        ))
    }
    createButton(e) {
        return this._innerWindow().createButton(e)
    }
    createDropdown(e) {
        return this._innerWindow().createDropdown(e)
    }
    showNoticeDialog(e) {
        this._doWhenInnerApiLoaded((t => {
            t.showNoticeDialog(e)
        }
        ))
    }
    showConfirmDialog(e) {
        this._doWhenInnerApiLoaded((t => {
            t.showConfirmDialog(e)
        }
        ))
    }
    showLoadChartDialog() {
        this._innerAPI().showLoadChartDialog()
    }
    showSaveAsChartDialog() {
        this._innerAPI().showSaveAsChartDialog()
    }
    symbolInterval() {
        return this._innerAPI().getSymbolInterval()
    }
    mainSeriesPriceFormatter() {
        return this._innerAPI().mainSeriesPriceFormatter()
    }
    getIntervals() {
        return this._innerAPI().getIntervals()
    }
    getStudiesList() {
        return this._innerAPI().getStudiesList()
    }
    getStudyInputs(e) {
        return this._innerAPI().getStudyInputs(e)
    }
    getStudyStyles(e) {
        return this._innerAPI().getStudyStyles(e)
    }
    addCustomCSSFile(e) {
        this._innerWindow().addCustomCSSFile(e)
    }
    applyOverrides(e) {
        this._options = LNe(this._options, {
            overrides: e
        }),
        this._doWhenInnerWindowLoaded((t => {
            t.applyOverrides(e)
        }
        ))
    }
    applyStudiesOverrides(e) {
        this._doWhenInnerWindowLoaded((t => {
            t.applyStudiesOverrides(e)
        }
        ))
    }
    watchList() {
        return this._innerAPI().watchlist()
    }
    news() {
        return this._innerAPI().news()
    }
    widgetbar() {
        return this._innerAPI().widgetbar()
    }
    activeChart() {
        return this._innerAPI().activeChart()
    }
    activeChartIndex() {
        return this._innerAPI().activeChartIndex()
    }
    setActiveChart(e) {
        return this._innerAPI().setActiveChart(e)
    }
    chartsCount() {
        return this._innerAPI().chartsCount()
    }
    layout() {
        return this._innerAPI().layout()
    }
    setLayout(e) {
        this._innerAPI().setLayout(e)
    }
    layoutName() {
        return this._innerAPI().layoutName()
    }
    resetLayoutSizes(e) {
        this._innerAPI().resetLayoutSizes(e)
    }
    changeTheme(e, t) {
        return this._innerWindow().changeTheme(e, t)
    }
    getTheme() {
        return this._innerWindow().getTheme()
    }
    takeScreenshot() {
        this._doWhenInnerApiLoaded((e => {
            e.takeScreenshot()
        }
        ))
    }
    lockAllDrawingTools() {
        return this._innerAPI().lockAllDrawingTools()
    }
    hideAllDrawingTools() {
        return this._innerAPI().hideAllDrawingTools()
    }
    drawOnAllChartsEnabled() {
        return this._innerAPI().drawOnAllChartsEnabled()
    }
    drawOnAllCharts(e) {
        this._innerAPI().drawOnAllCharts(e)
    }
    magnetEnabled() {
        return this._innerAPI().magnetEnabled()
    }
    magnetMode() {
        return this._innerAPI().magnetMode()
    }
    undoRedoState() {
        return this._innerAPI().undoRedoState()
    }
    setIntervalLinkingEnabled(e) {
        this._innerAPI().setIntervalLinkingEnabled(e)
    }
    setDateRangeLinkingEnabled(e) {
        this._innerAPI().setDateRangeLinkingEnabled(e)
    }
    setTimeFrame(e) {
        this._innerAPI().setTimeFrame(e)
    }
    symbolSync() {
        return this._innerAPI().symbolSync()
    }
    intervalSync() {
        return this._innerAPI().intervalSync()
    }
    crosshairSync() {
        return this._innerAPI().crosshairSync()
    }
    timeSync() {
        return this._innerAPI().timeSync()
    }
    dateRangeSync() {
        return this._innerAPI().dateRangeSync()
    }
    setFeatureEnabled(e, t) {
        this._innerAPI().setFeatureEnabled(e, t)
    }
    getAllFeatures() {
        return this._innerWindow().getAllFeatures()
    }
    clearUndoHistory() {
        return this._innerAPI().clearUndoHistory()
    }
    undo() {
        return this._innerAPI().undo()
    }
    redo() {
        return this._innerAPI().redo()
    }
    startFullscreen() {
        this._innerAPI().startFullscreen()
    }
    exitFullscreen() {
        this._innerAPI().exitFullscreen()
    }
    takeClientScreenshot(e) {
        return this._innerAPI().takeClientScreenshot(e)
    }
    navigationButtonsVisibility() {
        return this._innerWindow().getNavigationButtonsVisibility()
    }
    paneButtonsVisibility() {
        return this._innerWindow().getPaneButtonsVisibility()
    }
    dateFormat() {
        return this._innerWindow().getDateFormat()
    }
    timeHoursFormat() {
        return this._innerWindow().getTimeHoursFormat()
    }
    currencyAndUnitVisibility() {
        return this._innerWindow().getCurrencyAndUnitVisibility()
    }
    supportedChartTypes() {
        return this._innerAPI().supportedChartTypes()
    }
    watermark() {
        return this._innerAPI().watermark()
    }
    customSymbolStatus() {
        return this._innerWindow().customSymbolStatus()
    }
    setCSSCustomProperty(e, t) {
        if (!1 === e.startsWith("--"))
            throw new Error("customPropertyName should begin with a double hyphen");
        this._innerWindow().document.body.style.setProperty(e, t)
    }
    getCSSCustomPropertyValue(e) {
        if (!1 === e.startsWith("--"))
            throw new Error("customPropertyName should begin with a double hyphen");
        const t = this._innerWindow().document.body
          , n = t.style.getPropertyValue(e);
        return n || getComputedStyle(t).getPropertyValue(e)
    }
    unloadUnusedCharts() {
        this._innerAPI().unloadUnusedCharts()
    }
    async customThemes() {
        return this._innerWindow().customThemes()
    }
    linking() {
        return this._innerAPI().linking
    }
    _innerAPI() {
        return this._innerWindow().tradingViewApi
    }
    _innerWindow() {
        return this._iFrame.contentWindow
    }
    _doWhenInnerWindowLoaded(e) {
        this._ready ? e(this._innerWindow()) : this._innerWindowLoaded.then(( () => {
            e(this._innerWindow())
        }
        ))
    }
    _doWhenInnerApiLoaded(e) {
        this._doWhenInnerWindowLoaded((t => {
            t.doWhenApiIsReady(( () => e(this._innerAPI())))
        }
        ))
    }
    _autoResizeChart() {
        this._options.fullscreen && (this._iFrame.style.height = window.innerHeight + "px",
        UNe && setTimeout(( () => {
            this._iFrame.style.height = window.innerHeight + "px"
        }
        ), 30))
    }
    async _create() {
        var e, t, n, r;
        const a = null !== (t = null === (e = this._options.enabled_features) || void 0 === e ? void 0 : e.includes("iframe_loading_same_origin")) && void 0 !== t && t
          , s = a || null !== (r = null === (n = this._options.enabled_features) || void 0 === n ? void 0 : n.includes("iframe_loading_compatibility_mode")) && void 0 !== r && r
          , [o,l] = this._render(!s, a)
          , i = this._options.container
          , c = "string" == typeof i ? document.getElementById(i) : i;
        if (null === c)
            throw new Error(`There is no such element - #${this._options.container}`);
        c.innerHTML = o,
        this._iFrame = c.querySelector(`#${this._id}`);
        const d = this._iFrame;
        a && await this._innerWindowEvent("sameOriginLoad"),
        s && d.contentWindow && (d.contentWindow.document.open(),
        d.contentWindow.document.write(l),
        d.contentWindow.document.close()),
        this._innerWindow().addEventListener("innerWindowLoad", function(e) {
            if (void 0 === e)
                throw new Error("_innerWindowResolver is undefined");
            return e
        }(this._innerWindowResolver), {
            once: !0
        }),
        (this._options.autosize || this._options.fullscreen) && (d.style.width = "100%",
        this._options.fullscreen || (d.style.height = "100%")),
        window.addEventListener("resize", this._onWindowResize),
        this._onWindowResize(),
        this._innerWindowLoaded.then(( () => {
            try {
                this._innerWindow().widgetReady(( () => {
                    this._ready = !0;
                    for (const t of this._readyHandlers)
                        try {
                            t.call(this)
                        } catch (e) {}
                    this._innerWindow().initializationFinished()
                }
                ))
            } catch (e) {
                if (e instanceof Error && /widgetReady is not a function/.test(e.message))
                    throw new Error(`There was an error when loading the library. Usually this error means the library failed to load its static files. Check that the library files are available at ${window.location.host}/${this._options.library_path || ""} or correct the library_path option.`)
            }
        }
        ))
    }
    _innerWindowEvent(e) {
        return new Promise((t => {
            this._innerWindow().addEventListener(e, t, {
                once: !0
            })
        }
        ))
    }
    _render(e, t) {
        var n;
        const r = window;
        if (r[this._id] = {
            datafeed: this._options.datafeed,
            customFormatters: this._options.custom_formatters,
            brokerFactory: this._options.broker_factory,
            overrides: this._options.overrides,
            studiesOverrides: this._options.studies_overrides,
            tradingCustomization: this._options.trading_customization,
            disabledFeatures: this._options.disabled_features,
            enabledFeatures: this._options.enabled_features,
            brokerConfig: this._options.broker_config || this._options.brokerConfig,
            restConfig: this._options.restConfig,
            favorites: this._options.favorites,
            logo: this._options.logo,
            numeric_formatting: this._options.numeric_formatting,
            rss_news_feed: this._options.rss_news_feed,
            rss_news_title: this._options.rss_news_title,
            newsProvider: this._options.news_provider,
            loadLastChart: this._options.load_last_chart,
            saveLoadAdapter: this._options.save_load_adapter,
            loading_screen: this._options.loading_screen,
            settingsAdapter: this._options.settings_adapter,
            getCustomIndicators: this._options.custom_indicators_getter,
            additionalSymbolInfoFields: this._options.additional_symbol_info_fields,
            headerWidgetButtonsMode: this._options.header_widget_buttons_mode,
            customTranslateFunction: this._options.custom_translate_function,
            symbolSearchComplete: this._options.symbol_search_complete,
            contextMenu: this._options.context_menu,
            settingsOverrides: this._options.settings_overrides,
            timeframe: this._options.timeframe,
            customTimezones: this._options.custom_timezones,
            customChartDescriptionFunction: this._options.custom_chart_description_function,
            customThemes: this._options.custom_themes,
            imageStorageAdapter: this._options.image_storage_adapter
        },
        this._options.saved_data)
            r[this._id].chartContent = {
                json: this._options.saved_data
            },
            this._options.saved_data_meta_info && (r[this._id].chartContentExtendedData = this._options.saved_data_meta_info);
        else if (!this._options.load_last_chart && !this._options.symbol)
            throw new Error("Symbol is not defined: either 'symbol' or 'load_last_chart' option must be set");
        if (this._options.library_path && this._options.library_path.endsWith("/"),
        this._options.locale) {
            const e = encodeURIComponent(this._options.locale);
            DNe.findIndex((t => t.language === e)) >= 0 || (this._options.locale = "en")
        }
        const a = function(e, t) {
            var n;
            const r = new URL(`${e || ""}`,location.href).href
              , a = JSON.parse('["bundles/runtime.0c59f90a8699f12ff40f.js","bundles/__LANG__.2312.a9353e46c20c3019a091.js","bundles/9662.03109f673cda5962c847.css","bundles/7346.a2efeed47130dd4e832c.js","bundles/library.8fdacc60e5256d6fcc84.js"]')
              , s = encodeURIComponent(t)
              , o = null !== (n = DNe.find((e => e.language === s))) && void 0 !== n ? n : {
                iso: "en",
                dir: "ltr"
            }
              , l = `lang="${o.iso}" dir="${o.dir}"`;
            return `<!DOCTYPE html><html ${(i = {
                bundles: `\n${function(e, t, n) {
                    if (void 0 === e)
                        return "";
                    const r = []
                      , a = [];
                    for (const s of e)
                        s.endsWith(".js") ? r.push(`<script defer crossorigin="anonymous" src="${s.replace("__LANG__", n)}"><\/script>`) : s.endsWith(".css") && a.push(`<link type="text/css" href="${t ? s.replace(/\.css$/i, ".rtl.css") : s}" rel="stylesheet"/>`);
                    return [...r, ...a].join("\n")
                }(a, "rtl" === o.dir, s)}\n`,
                localeLanguage: s,
                htmlAttrs: l,
                libraryPath: r
            }).htmlAttrs}><head><base href="${i.libraryPath}"><meta charset="utf-8"><script>window===window.parent&&(location.href="about:blank")<\/script> ${i.bundles} </head><body class="chart-page unselectable on-widget"><div class="loading-indicator" id="loading-indicator"></div><script>var JSServer={},__initialEnabledFeaturesets=["charting_library"]<\/script><script>(function() {\n\t\twindow.urlParams = (function () {\n\t\t\tvar match,\n\t\t\t\tpl\t = /\\+/g,  // Regex for replacing addition symbol with a space\n\t\t\t\tsearch = /([^&=]+)=?([^&]*)/g,\n\t\t\t\tdecode = function (s) { return decodeURIComponent(s.replace(pl, ' ')).replace(/<\\/?[^>]+(>|$)/g, ''); },\n\t\t\t\tquery = function() {\n\t\t\t\t\t// We don't use hash on the url because: safari 13 throws an error if you attempt this\n\t\t\t\t\t// on a blob, and safari 14 will strip hash from blob urls.\n\t\t\t\t\tif (frameElement && frameElement.dataset.widgetOptions) {\n\t\t\t\t\t\treturn frameElement.dataset.widgetOptions;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow "Unexpected use of this page";\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tresult = {};\n\n\t\t\twhile (match = search.exec(query)) {\n\t\t\t\tresult[decode(match[1])] = decode(match[2]);\n\t\t\t}\n\n\t\t\tvar additionalSettingsObject = window.parent[result.uid];\n\n\t\t\tvar customObjectNames = ['datafeed', 'customFormatters', 'brokerFactory', 'save_load_adapter', 'customTranslateFunction', 'contextMenu'];\n\n\t\t\tfor (var p in additionalSettingsObject) {\n\t\t\t\tif (customObjectNames.indexOf(p) === -1) {\n\t\t\t\t\tresult[p] = JSON.stringify(additionalSettingsObject[p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t})();\n\n\t\twindow.locale = urlParams.locale;\n\t\twindow.language = urlParams.locale; // a very big attention needed here\n\t\twindow.customTranslateFunction = window.parent[urlParams.uid].customTranslateFunction;\n\t\twindow.customChartDescriptionFunction = window.parent[urlParams.uid].customChartDescriptionFunction;\n\n\t\twindow.addCustomCSSFile = function(href) {\n\t\t\tvar link = document.createElement('link');\n\t\t\tlink.setAttribute('type', 'text/css');\n\t\t\tlink.setAttribute('rel', 'stylesheet');\n\t\t\tlink.setAttribute('href', href);\n\t\t\tlink.setAttribute('cross-origin', 'anonymous');\n\n\t\t\twindow.loadedCustomCss = new Promise((resolve) => {\n\t\t\t\tlink.onload = resolve;\n\t\t\t\tlink.onerror = resolve;\n\t\t\t});\n\t\t\tdocument.body.appendChild(link);\n\t\t};\n\n\t\twindow.loadedCustomCss = Promise.resolve();\n\t\tif (!!urlParams.customCSS) {\n\t\t\twindow.addCustomCSSFile(urlParams.customCSS);\n\t\t}\n\n\t\tvar loadingScreenParams = {};\n\n\t\tif (typeof urlParams.loading_screen === 'string') {\n\t\t\ttry {\n\t\t\t\tloadingScreenParams = JSON.parse(urlParams.loading_screen);\n\t\t\t} catch(e) {}\n\t\t}\n\n\t\tvar loadingIndicatorElement = document.getElementById('loading-indicator');\n\n\t\tif (loadingScreenParams.backgroundColor) {\n\t\t\tloadingIndicatorElement.style = 'background-color: ' + loadingScreenParams.backgroundColor;\n\t\t}\n\n\t\t!function(){"use strict";var t,e=new WeakMap;!function(t){t[t.Element=1]="Element",t[t.Document=9]="Document"}(t||(t={}));var n={mini:"xsmall",xxsmall:"xxsmall",xsmall:"xsmall",small:"small",medium:"medium",large:"large"};var s,i,o,r,l,c=(void 0===l&&(l=""),s='<div class="tv-spinner '.concat(l,'" role="progressbar"></div>'),o=function(n,s){var i,o;return i=null==s?document.documentElement:s.nodeType===t.Document?s.documentElement:s,e&&(o=e.get(i)),o||((o=i.ownerDocument.createRange()).selectNodeContents(i),e&&e.set(i,o)),o.createContextualFragment(n)}(s,i),null!==(r=o.firstElementChild)&&o.removeChild(r),r),a=function(){function t(t){this._shown=!1,this._el=c.cloneNode(!0),this.setSize(n[t||"large"])}return t.prototype.spin=function(t){return this._el.classList.add("tv-spinner--shown"),void 0===this._container&&(this._container=t,void 0!==t&&t.appendChild(this._el)),this._shown=!0,this},t.prototype.stop=function(t){return t&&void 0!==this._container&&this._container.removeChild(this._el),this._el&&this._el.classList.remove("tv-spinner--shown"),this._shown=!1,this},t.prototype.setStyle=function(t){var e=this;return Object.keys(t).forEach((function(n){var s=t[n];void 0!==s&&e._el.style.setProperty(n,s)})),this},t.prototype.style=function(){return this._el.style},t.prototype.setSize=function(t){var e=void 0!==t?"tv-spinner--size_".concat(t):"";return this._el.className="tv-spinner ".concat(e," ").concat(this._shown?"tv-spinner--shown":""),this},t.prototype.getEl=function(){return this._el},t.prototype.destroy=function(){this.stop(),delete this._el,delete this._container},t}();window.Spinner=a}();\n\n\n\t\tvar spinnerColor = (loadingScreenParams.foregroundColor) ? loadingScreenParams.foregroundColor : undefined;\n\n\t\tvar loadingSpinner = new Spinner('large').setStyle({\n\t\t\t'--tv-spinner-color': spinnerColor,\n\t\t\tzIndex: String(2e9),\n\t\t});\n\t\tloadingSpinner.getEl().classList.add('spinner');\n\t\tloadingSpinner.spin(loadingIndicatorElement);\n\t})();<\/script></body></html>`;
            var i
        }(this._options.library_path || "", this._options.locale);
        let s = new URL("about:blank");
        if (e) {
            const e = new Blob([a],{
                type: "text/html"
            })
              , t = URL.createObjectURL(e);
            s = new URL(t)
        } else if (t) {
            const e = null !== (n = this._options.library_path) && void 0 !== n ? n : "/";
            s = new URL(e + "sameorigin.html",location.origin)
        }
        const o = "symbol=" + encodeURIComponent(this._options.symbol || "") + "&interval=" + encodeURIComponent(this._options.interval) + (this._options.toolbar_bg ? "&toolbarbg=" + encodeURIComponent(this._options.toolbar_bg.replace("#", "")) : "") + (this._options.studies_access ? "&studiesAccess=" + encodeURIComponent(JSON.stringify(this._options.studies_access)) : "") + "&widgetbar=" + encodeURIComponent(JSON.stringify(this._options.widgetbar)) + (this._options.drawings_access ? "&drawingsAccess=" + encodeURIComponent(JSON.stringify(this._options.drawings_access)) : "") + "&timeFrames=" + encodeURIComponent(JSON.stringify(this._options.time_frames)) + "&locale=" + encodeURIComponent(this._options.locale) + "&uid=" + encodeURIComponent(this._id) + "&clientId=" + encodeURIComponent(String(this._options.client_id)) + "&userId=" + encodeURIComponent(String(this._options.user_id)) + (this._options.charts_storage_url ? "&chartsStorageUrl=" + encodeURIComponent(this._options.charts_storage_url) : "") + (this._options.charts_storage_api_version ? "&chartsStorageVer=" + encodeURIComponent(this._options.charts_storage_api_version) : "") + (this._options.custom_css_url ? "&customCSS=" + encodeURIComponent(this._options.custom_css_url) : "") + (this._options.custom_font_family ? "&customFontFamily=" + encodeURIComponent(this._options.custom_font_family) : "") + (this._options.auto_save_delay ? "&autoSaveDelay=" + encodeURIComponent(String(this._options.auto_save_delay)) : "") + "&debug=" + encodeURIComponent(String(this._options.debug)) + (this._options.debug_broker ? "&debugBroker=" + encodeURIComponent(String(this._options.debug_broker)) : "") + (this._options.snapshot_url ? "&snapshotUrl=" + encodeURIComponent(this._options.snapshot_url) : "") + (this._options.timezone ? "&timezone=" + encodeURIComponent(this._options.timezone) : "") + (this._options.study_count_limit ? "&studyCountLimit=" + encodeURIComponent(String(this._options.study_count_limit)) : "") + (this._options.symbol_search_request_delay ? "&ssreqdelay=" + encodeURIComponent(String(this._options.symbol_search_request_delay)) : "") + (this._options.compare_symbols ? "&compareSymbols=" + encodeURIComponent(JSON.stringify(this._options.compare_symbols)) : "") + (this._options.theme ? "&theme=" + encodeURIComponent(String(this._options.theme)) : "") + (this._options.header_widget_buttons_mode ? "&header_widget_buttons_mode=" + encodeURIComponent(String(this._options.header_widget_buttons_mode)) : "") + (this._options.time_scale ? "&time_scale=" + encodeURIComponent(JSON.stringify(this._options.time_scale)) : "");
        return [`<iframe\n\t\tversion="CL v28.5.0 (internal id fb6f897f @ 2024-12-18T12:27:11.562Z)" id="${this._id}" name="${this._id}" src="${s.href}" data-widget-options="${o}"\n\t\t${this._options.autosize || this._options.fullscreen ? "" : `width="${this._options.width}" height="${this._options.height}"`} title="Financial Chart" frameborder="0" allowTransparency="true" scrolling="no" allowfullscreen style="display:block;">\n\t</iframe>`, a]
    }
}
;
"undefined" != typeof window && (window.TradingView = window.TradingView || {},
window.TradingView.version = function() {
    return "CL v28.5.0 (internal id fb6f897f @ 2024-12-18T12:27:11.562Z)"
}
);
const UNe = !("undefined" == typeof window || !window.navigator || !window.navigator.userAgent) && window.navigator.userAgent.includes("CriOS")
  , WNe = e => {
    let t = 2166136261;
    for (let n = 0; n < e.length; n++)
        t ^= e.charCodeAt(n),
        t = 16777619 * t >>> 0;
    return t >>> 0
}
  , FNe = {
    userSelect: "none",
    lineHeight: 2,
    cursor: "pointer"
}
  , VNe = {
    variant: "h2"
}
  , HNe = "#90A8FA99"
  , zNe = "#F7DC8599"
  , $Ne = "#90A8FA99"
  , GNe = "#F7DC8599"
  , qNe = "#17C671EE"
  , KNe = "#E73A44EE"
  , YNe = {
    [Lx.FILL]: {
        colorSettingsValueKey: "fillLineColor",
        defaultColor: HNe
    },
    [Lx.SELL]: {
        colorSettingsValueKey: "exitLineColor",
        defaultColor: zNe
    },
    [Lx.TOP_HOLDERS_ENTRY]: {
        colorSettingsValueKey: "top10HoldersEntryLineColor",
        defaultColor: $Ne
    },
    [Lx.TOP_HOLDERS_EXIT]: {
        colorSettingsValueKey: "top10HoldersExitLineColor",
        defaultColor: GNe
    },
    [Lx.PRICE_ALERT_ABOVE]: {
        colorSettingsValueKey: "abovePriceAlertLineColor",
        defaultColor: qNe
    },
    [Lx.PRICE_ALERT_BELOW]: {
        colorSettingsValueKey: "belowPriceAlertLineColor",
        defaultColor: KNe
    }
}
  , XNe = [Lx.FILL, Lx.SELL, Lx.TOP_HOLDERS_ENTRY, Lx.TOP_HOLDERS_EXIT, Lx.PRICE_ALERT_ABOVE, Lx.PRICE_ALERT_BELOW]
  , QNe = [Rx.KOL, Rx.MIGRATION_PRICE, Rx.MIGRATION_TIME]
  , ZNe = (e, t) => {
    switch (t) {
    case Lx.FILL:
        return e("Average fill");
    case Lx.SELL:
        return e("Average exit");
    case Lx.TOP_HOLDERS_ENTRY:
        return e("Top 10 holders entry");
    case Lx.TOP_HOLDERS_EXIT:
        return e("Top 10 holders exit");
    case Lx.PRICE_ALERT_ABOVE:
        return e("Price alert above");
    case Lx.PRICE_ALERT_BELOW:
        return e("Price alert below")
    }
}
  , JNe = (e, t) => {
    switch (t) {
    case Rx.KOL:
        return e("KOL bars");
    case Rx.MIGRATION_PRICE:
        return e("Migration price");
    case Rx.MIGRATION_TIME:
        return e("Migration time")
    }
}
  , ePe = (e, t) => {
    switch (t) {
    case Rx.MIGRATION_PRICE:
        return e("Price");
    case Rx.MIGRATION_TIME:
        return e("Time")
    }
}
  , tPe = {
    dev: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    mine: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    specific: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    group: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    kol: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    sniper: {
        applicableColorSettings: ["text", "buy", "sell"]
    },
    mayhem: {
        applicableColorSettings: ["text", "buy", "sell"]
    }
}
  , nPe = (e, t) => {
    switch (t) {
    case "dev":
        return e("Dev trades");
    case "mine":
        return e("My trades");
    case "specific":
        return e("Tracked wallets");
    case "group":
        return e("Alpha mentions");
    case "kol":
        return e("KOL trades");
    case "sniper":
        return e("Sniper trades");
    case "mayhem":
        return e("Mayhem trades")
    }
}
  , rPe = {
    dev: {
        buy: "DB",
        sell: "DS"
    },
    mine: {
        buy: "B",
        sell: "S"
    },
    specific: {
        buy: "B",
        sell: "S"
    },
    group: {
        buy: "",
        sell: ""
    },
    kol: {
        buy: "KB",
        sell: "KS"
    },
    sniper: {
        buy: "SB",
        sell: "SS"
    },
    mayhem: {
        buy: "MB",
        sell: "MS"
    }
}
  , aPe = ["mine", "dev", "sniper", "mayhem", "specific", "kol", "group"]
  , sPe = y.memo(( ({hideLines: e, setHideLines: t, hideMarkers: n, setHideMarkers: r, ...a}) => {
    const {t: s} = we()
      , o = y.useCallback(( () => t((e => !e))), [t])
      , l = y.useCallback(( () => r((e => !e))), [r]);
    return v.jsx(ae, {
        anchorReference: "anchorPosition",
        transformOrigin: {
            vertical: "top",
            horizontal: "left"
        },
        slotProps: oPe,
        ...a,
        children: v.jsx(S, {
            children: v.jsxs(S, {
                direction: "row",
                children: [v.jsx(lPe, {
                    title: s("Lines"),
                    hideItems: e,
                    toggleHideItems: o,
                    children: v.jsxs(v.Fragment, {
                        children: [XNe.map((e => v.jsx(dPe, {
                            visibilityKey: e,
                            children: ZNe(s, e)
                        }, e))), QNe.map((e => v.jsx(dPe, {
                            visibilityKey: e,
                            children: JNe(s, e)
                        }, e)))]
                    })
                }), v.jsx(Ee, {
                    orientation: "vertical",
                    flexItem: !0
                }), v.jsx(lPe, {
                    title: s("Markers"),
                    hideItems: n,
                    toggleHideItems: l,
                    children: v.jsx(v.Fragment, {
                        children: aPe.map((e => v.jsx(uPe, {
                            visibilityKey: e,
                            children: nPe(s, e)
                        }, e)))
                    })
                })]
            })
        })
    })
}
))
  , oPe = {
    root: {
        sx: {
            zIndex: 1e4
        }
    },
    paper: {
        sx: e => ({
            borderRadius: 1.5,
            background: e.palette.background.secondary
        })
    }
}
  , lPe = y.memo(( ({title: e, hideItems: t, toggleHideItems: n, children: r}) => v.jsxs(S, {
    children: [v.jsx(iPe, {
        title: e,
        areAllHidden: t,
        toggleHideItems: n
    }), v.jsx(S, {
        sx: e => ({
            opacity: t ? .5 : 1,
            transition: `opacity ${e.transitions.duration.shortest}ms`
        }),
        children: r
    })]
})))
  , iPe = y.memo(( ({title: e, areAllHidden: t, toggleHideItems: n}) => {
    const {t: r} = we()
      , [a,s,o,l] = y.useMemo(( () => t ? [r("Unhide"), "text.label", Tk, cPe(t)] : [r("Hide"), "text.value", Ek, cPe(t)]), [t, r]);
    return v.jsx(S, {
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        gap: 1,
        px: gPe,
        pt: 1.5,
        pb: 1,
        minHeight: 40,
        children: v.jsxs(S, {
            direction: "row",
            justifyContent: "center",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(k, {
                variant: "h2",
                color: s,
                children: e
            }), v.jsx(GC, {
                title: a,
                offset: -5,
                children: v.jsx(S, {
                    children: v.jsx(F, {
                        sx: l,
                        onClick: n,
                        children: v.jsx(o, {
                            size: hPe,
                            color: "inherit"
                        })
                    })
                })
            })]
        })
    })
}
))
  , cPe = e => t => ({
    color: e ? t.palette.text.primary : t.palette.text.label,
    "&:hover": {
        color: t.palette.text.primary
    }
})
  , dPe = y.memo(( ({visibilityKey: e, children: t}) => {
    const {chartLinesVisibility: n, setChartLinesVisibility: r, setHideChartLines: a} = rf()
      , s = n[e]
      , o = y.useCallback(( () => {
        r((t => {
            const n = t[e];
            return n || a(!1),
            {
                ...t,
                [e]: !n
            }
        }
        ))
    }
    ), [e, r, a]);
    return v.jsx(pPe, {
        isVisible: s,
        onClick: o,
        children: t
    })
}
))
  , uPe = y.memo(( ({visibilityKey: e, children: t}) => {
    const {chartMarkersVisibility: n, setChartMarkersVisibility: r, setHideChartMarkers: a} = rf()
      , s = n[e]
      , o = y.useCallback(( () => {
        r((t => {
            const n = t[e];
            return n || a(!1),
            {
                ...t,
                [e]: !n
            }
        }
        ))
    }
    ), [r, e, a]);
    return v.jsx(pPe, {
        isVisible: s,
        onClick: o,
        children: t
    })
}
))
  , pPe = y.memo(( ({isVisible: e, onClick: t, children: n}) => v.jsx(te, {
    dense: !0,
    disableRipple: !0,
    sx: xPe,
    onClick: t,
    children: v.jsxs(S, {
        direction: "row",
        gap: mPe,
        children: [v.jsx(xy, {
            size: hPe,
            color: e ? "inherit" : "transparent"
        }), v.jsx(k, {
            variant: "paragraph3",
            children: n
        })]
    })
})))
  , hPe = 12
  , mPe = 1
  , gPe = 1.5
  , xPe = {
    px: gPe,
    py: 1
}
  , bPe = "padre-keyboard-capture-script";
var fPe = (e => (e.PRICE = "price",
e.MARKET_CAP = "marketCap",
e))(fPe || {});
function vPe(e=!1) {
    window.tvWidget && window.tvWidget.headerReady().then((async () => {
        var e;
        const t = null == (e = window.tvWidget) ? void 0 : e.activeChart()
          , n = null == t ? void 0 : t.getPanes();
        null == n || n.forEach((e => {
            const t = e.getMainSourcePriceScale();
            if (!t)
                return;
            const n = t.isAutoScale()
              , r = t.getVisiblePriceRange();
            r && (t.setVisiblePriceRange(r),
            t.setAutoScale(n))
        }
        ))
    }
    )).catch((e => {}
    ))
}
const SPe = (e, t) => {
    const n = i(1e3 * e);
    switch (t) {
    case og.SECOND:
    case ig.S3:
    case ig.S5:
    case lg.S15:
        return n.format("HH:mm:ss");
    case og.MINUTE:
    case lg.M5:
        return n.format("HH:mm");
    case og.HOUR:
    case lg.H4:
        return n.format("MMM'DD HH:mm");
    case og.DAY:
        return n.format("MMM'DD")
    }
}
  , yPe = (e, t) => ({
    "volume.volume.color.0": t,
    "volume.volume.color.1": e
})
  , kPe = (e, t) => ({
    "mainSeriesProperties.candleStyle.upColor": e,
    "mainSeriesProperties.candleStyle.borderUpColor": e,
    "mainSeriesProperties.candleStyle.wickUpColor": e,
    "mainSeriesProperties.hollowCandleStyle.upColor": e,
    "mainSeriesProperties.hollowCandleStyle.borderUpColor": e,
    "mainSeriesProperties.hollowCandleStyle.wickUpColor": e,
    "mainSeriesProperties.haStyle.upColor": e,
    "mainSeriesProperties.haStyle.borderUpColor": e,
    "mainSeriesProperties.haStyle.wickUpColor": e,
    "mainSeriesProperties.barStyle.upColor": e,
    "mainSeriesProperties.hlcAreaStyle.highLineColor": e,
    "mainSeriesProperties.renkoStyle.upColor": e,
    "mainSeriesProperties.renkoStyle.borderUpColor": e,
    "mainSeriesProperties.renkoStyle.wickUpColor": e,
    "mainSeriesProperties.pbStyle.upColor": e,
    "mainSeriesProperties.pbStyle.borderUpColor": e,
    "mainSeriesProperties.kagiStyle.upColor": e,
    "mainSeriesProperties.pnfStyle.upColor": e,
    "mainSeriesProperties.baselineStyle.topLineColor": e,
    "mainSeriesProperties.renkoStyle.upColorProjection": Me(e, .2),
    "mainSeriesProperties.renkoStyle.borderUpColorProjection": Me(e, .2),
    "mainSeriesProperties.pbStyle.upColorProjection": Me(e, .2),
    "mainSeriesProperties.pbStyle.borderUpColorProjection": Me(e, .2),
    "mainSeriesProperties.kagiStyle.upColorProjection": Me(e, .2),
    "mainSeriesProperties.pnfStyle.upColorProjection": Me(e, .2),
    "mainSeriesProperties.columnStyle.upColor": $t(e, .5),
    "mainSeriesProperties.hlcAreaStyle.highCloseFillColor": $t(e, .2),
    "mainSeriesProperties.baselineStyle.topFillColor1": $t(e, .28),
    "mainSeriesProperties.baselineStyle.topFillColor2": $t(e, .05),
    "mainSeriesProperties.candleStyle.downColor": t,
    "mainSeriesProperties.candleStyle.borderDownColor": t,
    "mainSeriesProperties.candleStyle.wickDownColor": t,
    "mainSeriesProperties.hollowCandleStyle.downColor": t,
    "mainSeriesProperties.hollowCandleStyle.borderDownColor": t,
    "mainSeriesProperties.hollowCandleStyle.wickDownColor": t,
    "mainSeriesProperties.haStyle.downColor": t,
    "mainSeriesProperties.haStyle.borderDownColor": t,
    "mainSeriesProperties.haStyle.wickDownColor": t,
    "mainSeriesProperties.barStyle.downColor": t,
    "mainSeriesProperties.hlcAreaStyle.lowLineColor": t,
    "mainSeriesProperties.renkoStyle.downColor": t,
    "mainSeriesProperties.renkoStyle.borderDownColor": t,
    "mainSeriesProperties.renkoStyle.wickDownColor": t,
    "mainSeriesProperties.pbStyle.downColor": t,
    "mainSeriesProperties.pbStyle.borderDownColor": t,
    "mainSeriesProperties.kagiStyle.downColor": t,
    "mainSeriesProperties.pnfStyle.downColor": t,
    "mainSeriesProperties.baselineStyle.bottomLineColor": t,
    "mainSeriesProperties.renkoStyle.downColorProjection": Me(t, .2),
    "mainSeriesProperties.renkoStyle.borderDownColorProjection": Me(t, .2),
    "mainSeriesProperties.pbStyle.downColorProjection": Me(t, .2),
    "mainSeriesProperties.pbStyle.borderDownColorProjection": Me(t, .2),
    "mainSeriesProperties.kagiStyle.downColorProjection": Me(t, .2),
    "mainSeriesProperties.pnfStyle.downColorProjection": Me(t, .2),
    "mainSeriesProperties.columnStyle.downColor": $t(t, .5),
    "mainSeriesProperties.hlcAreaStyle.closeLowFillColor": $t(t, .2),
    "mainSeriesProperties.baselineStyle.bottomFillColor1": $t(t, .28),
    "mainSeriesProperties.baselineStyle.bottomFillColor2": $t(t, .05)
})
  , CPe = (e, t) => t === rg.VIOLET ? "#171B27" : e.background.default
  , APe = "https://content.padre.gg/mayhem-color2.png"
  , wPe = (e, t, n, r, a, s, o) => {
    var l, i, c;
    const [d,u,p,h,m,g] = t
      , x = `${u}-${h}-${p}`
      , b = (null == (l = null == n ? void 0 : n.get(p)) ? void 0 : l.emoji) ?? null
      , f = (null == (i = null == n ? void 0 : n.get(p)) ? void 0 : i.name) ?? null
      , v = (null == r ? void 0 : r.get(p)) ?? null
      , S = (null == (c = null == r ? void 0 : r.get(p)) ? void 0 : c.name) ?? null
      , y = "mayhem" === e ? APe : v && !b ? Jwe(v.walletAddress) : null;
    return EPe(x, e, h, u, m, String(g), a, s, p, b, y, f ?? S, o)
}
  , jPe = (e, t, n) => {
    if (t === xc.BUY)
        switch (e) {
        case "mayhem":
            return "MB";
        case "sniper":
            return "SB";
        case "dev":
            return "DB";
        case "mine":
        case "specific":
            return "B";
        case "group":
            return n ?? "G";
        case "kol":
            return n ?? "KB"
        }
    switch (e) {
    case "mayhem":
        return "MS";
    case "sniper":
        return "SS";
    case "dev":
        return "DS";
    case "mine":
    case "specific":
        return "S";
    case "group":
        return n ?? "G";
    case "kol":
        return n ?? "KS"
    }
}
;
let TPe = null;
const IPe = e => {
    const t = ( () => {
        if (null === TPe)
            try {
                TPe = new Map(Er)
            } catch (W$e) {
                TPe = new Map
            }
        return TPe
    }
    )().get(e);
    if (t)
        return `https://cdn.jsdelivr.net/npm/@svgmoji/openmoji@2.0.0/svg/${t}.svg`
}
  , EPe = (e, t, n, r, a, s, o, l, i, c, d, u, p) => {
    const h = n
      , m = Number(s)
      , g = null !== o && null !== l ? Number(s) * Number(o) / 10 ** l : null
      , {color: x, labelFontColor: b} = ( (e, t, n) => {
        const r = n[t] ?? Kg[t]
          , a = e === xc.BUY ? r.buy ?? Kg[t].buy : r.sell ?? Kg[t].sell
          , s = r.text ?? Kg[t].text;
        return "mayhem" === t ? {
            color: {
                background: "#000000",
                border: Gt(a, .5)
            },
            labelFontColor: s
        } : {
            color: {
                background: a,
                border: Gt(a, .5)
            },
            labelFontColor: s
        }
    }
    )(r, t, p ?? Kg);
    let f = r === xc.BUY ? "Bought" : "Sold";
    if ("mayhem" === t && (f = r === xc.BUY ? "Mayhem Agent Bought" : "Mayhem Agent Sold"),
    "sniper" === t && (f = r === xc.BUY ? "Sniper Bought" : "Sniper Sold"),
    "dev" === t && (f = r === xc.BUY ? "Dev Bought" : "Dev Sold"),
    "specific" === t && (f = r === xc.BUY ? "Trader Bought" : "Trader Sold"),
    "mine" === t && (f = r === xc.BUY ? "You Bought" : "You Sold"),
    "group" === t) {
        const e = `${i.slice(0, 4)}...${i.slice(-4)}`
          , t = u ? `${u}` : e;
        f = r === xc.BUY ? `${t} bought` : `${t} sold`
    }
    if ("kol" === t) {
        const e = `${i.slice(0, 4)}...${i.slice(-4)}`
          , t = u ? `${u}` : e;
        f = r === xc.BUY ? `${t} bought` : `${t} sold`
    }
    return {
        id: e,
        time: h,
        color: x,
        text: `${f} ${OI(a, {
            precision: 2,
            symbol: "$",
            collapseExponent: !0
        })} at ${OI(g ?? m, {
            precision: g ? 2 : Math.max(2, WAe(s)),
            symbol: "$",
            collapseExponent: !0
        })}${g ? " Market Cap" : ""}`,
        label: jPe(t, r, c),
        imageUrl: (c ? IPe(c) : void 0) ?? d ?? void 0,
        labelFontColor: b,
        borderWidth: 2,
        minSize: 22
    }
}
  , MPe = e => `ri.alpha.${e.type}.${e.groupId}.${e.channelId}.${e.messageId}`
  , NPe = e => e.startsWith("ri.alpha.")
  , PPe = "padreV2-chartSettings"
  , OPe = new Set(["IntervalWidget.quicks", "StyleWidget.quicks", "chart.favoriteLibraryIndicators", "chart.favoriteDrawings", "chart.cursorPreference", "time_hours_format"])
  , LPe = e => OPe.has(e) || e.startsWith("properties_dialog") || e.startsWith("linetool") || e.startsWith("drawings") || e.startsWith("chart.favorite") || e.startsWith("ChartToolsHideMode") || e.startsWith("ChartDrawingToolbarWidget") || e.startsWith("BarsMarksContainer");
class RPe {
    constructor() {
        t(this, "initialSettings"),
        this.loadSettings()
    }
    setValue(e, t) {
        if (!LPe(e))
            return;
        const n = this.loadFromLocalStorage();
        n[e] = t,
        this.saveToLocalStorage(n)
    }
    removeValue(e) {
        if (!LPe(e))
            return;
        const t = this.loadFromLocalStorage();
        delete t[e],
        this.saveToLocalStorage(t)
    }
    loadFromLocalStorage() {
        try {
            const e = localStorage.getItem(PPe);
            return e ? JSON.parse(e) : {}
        } catch (W$e) {
            return {}
        }
    }
    saveToLocalStorage(e) {
        try {
            localStorage.setItem(PPe, JSON.stringify(e))
        } catch (W$e) {}
    }
    loadSettings() {
        this.initialSettings = this.loadFromLocalStorage()
    }
}
function DPe(e) {
    return void 0 === e ? "" : "string" == typeof e ? e : e.message
}
class BPe {
    constructor(e, t) {
        this._datafeedUrl = e,
        this._requester = t
    }
    getQuotes(e) {
        return new Promise(( (t, n) => {
            this._requester.sendRequest(this._datafeedUrl, "quotes", {
                symbols: e
            }).then((e => {
                "ok" === e.s ? t(e.d) : n(e.errmsg)
            }
            )).catch((e => {
                const t = DPe(e);
                n(`network error: ${t}`)
            }
            ))
        }
        ))
    }
}
class _Pe {
    constructor(e, t, n) {
        this._datafeedUrl = e,
        this._requester = t,
        this._limitedServerResponse = n
    }
    getBars(e, t, n) {
        const r = {
            symbol: e.ticker || "",
            resolution: t,
            from: n.from,
            to: n.to
        };
        return void 0 !== n.countBack && (r.countback = n.countBack),
        void 0 !== e.currency_code && (r.currencyCode = e.currency_code),
        void 0 !== e.unit_id && (r.unitId = e.unit_id),
        new Promise((async (e, t) => {
            try {
                const t = await this._requester.sendRequest(this._datafeedUrl, "history", r)
                  , n = this._processHistoryResponse(t);
                this._limitedServerResponse && await this._processTruncatedResponse(n, r),
                e(n)
            } catch (fNe) {
                if (fNe instanceof Error || "string" == typeof fNe) {
                    t(DPe(fNe))
                }
            }
        }
        ))
    }
    async _processTruncatedResponse(e, t) {
        let n = e.bars.length;
        try {
            for (; this._limitedServerResponse && this._limitedServerResponse.maxResponseLength > 0 && this._limitedServerResponse.maxResponseLength === n && t.from < t.to; ) {
                t.countback && (t.countback = t.countback - n),
                "earliestFirst" === this._limitedServerResponse.expectedOrder ? t.from = Math.round(e.bars[e.bars.length - 1].time / 1e3) : t.to = Math.round(e.bars[0].time / 1e3);
                const r = await this._requester.sendRequest(this._datafeedUrl, "history", t)
                  , a = this._processHistoryResponse(r);
                n = a.bars.length,
                "earliestFirst" === this._limitedServerResponse.expectedOrder ? (a.bars[0].time === e.bars[e.bars.length - 1].time && a.bars.shift(),
                e.bars.push(...a.bars)) : (a.bars[a.bars.length - 1].time === e.bars[0].time && a.bars.pop(),
                e.bars.unshift(...a.bars))
            }
        } catch (fNe) {
            if (fNe instanceof Error || "string" == typeof fNe) {
                DPe(fNe)
            }
        }
    }
    _processHistoryResponse(e) {
        if ("ok" !== e.s && "no_data" !== e.s)
            throw new Error(e.errmsg);
        const t = []
          , n = {
            noData: !1
        };
        if ("no_data" === e.s)
            n.noData = !0,
            n.nextTime = e.nextTime;
        else {
            const n = void 0 !== e.v
              , r = void 0 !== e.o;
            for (let a = 0; a < e.t.length; ++a) {
                const s = {
                    time: 1e3 * e.t[a],
                    close: parseFloat(e.c[a]),
                    open: parseFloat(e.c[a]),
                    high: parseFloat(e.c[a]),
                    low: parseFloat(e.c[a])
                };
                r && (s.open = parseFloat(e.o[a]),
                s.high = parseFloat(e.h[a]),
                s.low = parseFloat(e.l[a])),
                n && (s.volume = parseFloat(e.v[a])),
                t.push(s)
            }
        }
        return {
            bars: t,
            meta: n
        }
    }
}
class UPe {
    constructor(e, t) {
        this._subscribers = {},
        this._requestsPending = 0,
        this._historyProvider = e,
        setInterval(this._updateData.bind(this), t)
    }
    subscribeBars(e, t, n, r) {
        this._subscribers.hasOwnProperty(r) || (this._subscribers[r] = {
            lastBarTime: null,
            listener: n,
            resolution: t,
            symbolInfo: e
        },
        e.name)
    }
    unsubscribeBars(e) {
        delete this._subscribers[e]
    }
    _updateData() {
        if (!(this._requestsPending > 0)) {
            this._requestsPending = 0;
            for (const e in this._subscribers)
                this._requestsPending += 1,
                this._updateDataForSubscriber(e).then(( () => {
                    this._requestsPending -= 1,
                    this._requestsPending
                }
                )).catch((e => {
                    this._requestsPending -= 1,
                    DPe(e),
                    this._requestsPending
                }
                ))
        }
    }
    _updateDataForSubscriber(e) {
        const t = this._subscribers[e]
          , n = parseInt((Date.now() / 1e3).toString())
          , r = n - function(e, t) {
            let n = 0;
            n = "D" === e || "1D" === e ? t : "M" === e || "1M" === e ? 31 * t : "W" === e || "1W" === e ? 7 * t : t * parseInt(e) / 1440;
            return 24 * n * 60 * 60
        }(t.resolution, 10);
        return this._historyProvider.getBars(t.symbolInfo, t.resolution, {
            from: r,
            to: n,
            countBack: 2,
            firstDataRequest: !1
        }).then((t => {
            this._onSubscriberDataReceived(e, t)
        }
        ))
    }
    _onSubscriberDataReceived(e, t) {
        if (!this._subscribers.hasOwnProperty(e))
            return;
        const n = t.bars;
        if (0 === n.length)
            return;
        const r = n[n.length - 1]
          , a = this._subscribers[e];
        if (null !== a.lastBarTime && r.time < a.lastBarTime)
            return;
        if (null !== a.lastBarTime && r.time > a.lastBarTime) {
            if (n.length < 2)
                throw new Error("Not enough bars in history for proper pulse update. Need at least 2.");
            const e = n[n.length - 2];
            a.listener(e)
        }
        a.lastBarTime = r.time,
        a.listener(r)
    }
}
class WPe {
    constructor(e) {
        this._subscribers = {},
        this._requestsPending = 0,
        this._timers = null,
        this._quotesProvider = e
    }
    subscribeQuotes(e, t, n, r) {
        this._subscribers[r] = {
            symbols: e,
            fastSymbols: t,
            listener: n
        },
        this._createTimersIfRequired()
    }
    unsubscribeQuotes(e) {
        delete this._subscribers[e],
        0 === Object.keys(this._subscribers).length && this._destroyTimers()
    }
    _createTimersIfRequired() {
        if (null === this._timers) {
            const e = window.setInterval(this._updateQuotes.bind(this, 1), 1e4)
              , t = window.setInterval(this._updateQuotes.bind(this, 0), 6e4);
            this._timers = {
                fastTimer: e,
                generalTimer: t
            }
        }
    }
    _destroyTimers() {
        null !== this._timers && (clearInterval(this._timers.fastTimer),
        clearInterval(this._timers.generalTimer),
        this._timers = null)
    }
    _updateQuotes(e) {
        if (!(this._requestsPending > 0))
            for (const t in this._subscribers) {
                this._requestsPending++;
                const n = this._subscribers[t];
                this._quotesProvider.getQuotes(1 === e ? n.fastSymbols : n.symbols).then((e => {
                    this._requestsPending--,
                    this._subscribers.hasOwnProperty(t) && (n.listener(e),
                    this._requestsPending)
                }
                )).catch((e => {
                    this._requestsPending--,
                    DPe(e),
                    this._requestsPending
                }
                ))
            }
    }
}
function FPe(e, t, n, r) {
    const a = e[t];
    return !Array.isArray(a) || r && !Array.isArray(a[0]) ? a : a[n]
}
function VPe(e, t, n) {
    return e + (void 0 !== t ? "_%|#|%_" + t : "") + (void 0 !== n ? "_%|#|%_" + n : "")
}
class HPe {
    constructor(e, t, n) {
        this._exchangesList = ["NYSE", "FOREX", "AMEX"],
        this._symbolsInfo = {},
        this._symbolsList = [],
        this._datafeedUrl = e,
        this._datafeedSupportedResolutions = t,
        this._requester = n,
        this._readyPromise = this._init(),
        this._readyPromise.catch((e => {}
        ))
    }
    resolveSymbol(e, t, n) {
        return this._readyPromise.then(( () => {
            const r = this._symbolsInfo[VPe(e, t, n)];
            return void 0 === r ? Promise.reject("invalid symbol") : Promise.resolve(r)
        }
        ))
    }
    searchSymbols(e, t, n, r) {
        return this._readyPromise.then(( () => {
            const a = []
              , s = 0 === e.length;
            e = e.toUpperCase();
            for (const r of this._symbolsList) {
                const o = this._symbolsInfo[r];
                if (void 0 === o)
                    continue;
                if (n.length > 0 && o.type !== n)
                    continue;
                if (t && t.length > 0 && o.exchange !== t)
                    continue;
                const l = o.name.toUpperCase().indexOf(e)
                  , i = o.description.toUpperCase().indexOf(e);
                if (s || l >= 0 || i >= 0) {
                    if (!a.some((e => e.symbolInfo === o))) {
                        const e = l >= 0 ? l : 8e3 + i;
                        a.push({
                            symbolInfo: o,
                            weight: e
                        })
                    }
                }
            }
            const o = a.sort(( (e, t) => e.weight - t.weight)).slice(0, r).map((e => {
                const t = e.symbolInfo;
                return {
                    symbol: t.name,
                    full_name: `${t.exchange}:${t.name}`,
                    description: t.description,
                    exchange: t.exchange,
                    params: [],
                    type: t.type,
                    ticker: t.name
                }
            }
            ));
            return Promise.resolve(o)
        }
        ))
    }
    _init() {
        const e = []
          , t = {};
        for (const n of this._exchangesList)
            t[n] || (t[n] = !0,
            e.push(this._requestExchangeData(n)));
        return Promise.all(e).then(( () => {
            this._symbolsList.sort()
        }
        ))
    }
    _requestExchangeData(e) {
        return new Promise(( (t, n) => {
            this._requester.sendRequest(this._datafeedUrl, "symbol_info", {
                group: e
            }).then((r => {
                try {
                    this._onExchangeDataReceived(e, r)
                } catch (W$e) {
                    return void n(W$e instanceof Error ? W$e : new Error(`SymbolsStorage: Unexpected exception ${W$e}`))
                }
                t()
            }
            )).catch((e => {
                DPe(e),
                t()
            }
            ))
        }
        ))
    }
    _onExchangeDataReceived(e, t) {
        let n = 0;
        try {
            const e = t.symbol.length
              , r = void 0 !== t.ticker;
            for (; n < e; ++n) {
                const e = t.symbol[n]
                  , a = FPe(t, "exchange-listed", n)
                  , s = FPe(t, "exchange-traded", n)
                  , o = s + ":" + e
                  , l = FPe(t, "currency-code", n)
                  , i = FPe(t, "unit-id", n)
                  , c = r ? FPe(t, "ticker", n) : e
                  , d = {
                    ticker: c,
                    name: e,
                    base_name: [a + ":" + e],
                    listed_exchange: a,
                    exchange: s,
                    currency_code: l,
                    original_currency_code: FPe(t, "original-currency-code", n),
                    unit_id: i,
                    original_unit_id: FPe(t, "original-unit-id", n),
                    unit_conversion_types: FPe(t, "unit-conversion-types", n, !0),
                    description: FPe(t, "description", n),
                    has_intraday: zPe(FPe(t, "has-intraday", n), !1),
                    visible_plots_set: zPe(FPe(t, "visible-plots-set", n), void 0),
                    minmov: FPe(t, "minmovement", n) || FPe(t, "minmov", n) || 0,
                    minmove2: FPe(t, "minmove2", n) || FPe(t, "minmov2", n),
                    fractional: FPe(t, "fractional", n),
                    pricescale: FPe(t, "pricescale", n),
                    type: FPe(t, "type", n),
                    session: FPe(t, "session-regular", n),
                    session_holidays: FPe(t, "session-holidays", n),
                    corrections: FPe(t, "corrections", n),
                    timezone: FPe(t, "timezone", n),
                    supported_resolutions: zPe(FPe(t, "supported-resolutions", n, !0), this._datafeedSupportedResolutions),
                    has_daily: zPe(FPe(t, "has-daily", n), !0),
                    intraday_multipliers: zPe(FPe(t, "intraday-multipliers", n, !0), ["1", "5", "15", "30", "60"]),
                    has_weekly_and_monthly: FPe(t, "has-weekly-and-monthly", n),
                    has_empty_bars: FPe(t, "has-empty-bars", n),
                    volume_precision: zPe(FPe(t, "volume-precision", n), 0),
                    format: "price"
                };
                this._symbolsInfo[c] = d,
                this._symbolsInfo[e] = d,
                this._symbolsInfo[o] = d,
                void 0 === l && void 0 === i || (this._symbolsInfo[VPe(c, l, i)] = d,
                this._symbolsInfo[VPe(e, l, i)] = d,
                this._symbolsInfo[VPe(o, l, i)] = d),
                this._symbolsList.push(e)
            }
        } catch (W$e) {
            throw new Error(`SymbolsStorage: API error when processing exchange ${e} symbol #${n} (${t.symbol[n]}): ${Object(W$e).message}`)
        }
    }
}
function zPe(e, t) {
    return void 0 !== e ? e : t
}
function $Pe(e, t, n) {
    const r = e[t];
    return Array.isArray(r) ? r[n] : r
}
class GPe {
    constructor(e, t, n, r=1e4, a) {
        this._configuration = {
            supports_search: !1,
            supports_group_request: !0,
            supported_resolutions: ["1", "5", "15", "30", "60", "1D", "1W", "1M"],
            supports_marks: !1,
            supports_timescale_marks: !1
        },
        this._symbolsStorage = null,
        this._datafeedURL = e,
        this._requester = n,
        this._historyProvider = new _Pe(e,this._requester,a),
        this._quotesProvider = t,
        this._dataPulseProvider = new UPe(this._historyProvider,r),
        this._quotesPulseProvider = new WPe(this._quotesProvider),
        this._configurationReadyPromise = this._requestConfiguration().then((e => {
            null === e && (e = {
                supports_search: !1,
                supports_group_request: !0,
                supported_resolutions: ["1", "5", "15", "30", "60", "1D", "1W", "1M"],
                supports_marks: !1,
                supports_timescale_marks: !1
            }),
            this._setupWithConfiguration(e)
        }
        ))
    }
    onReady(e) {
        this._configurationReadyPromise.then(( () => {
            e(this._configuration)
        }
        ))
    }
    getQuotes(e, t, n) {
        this._quotesProvider.getQuotes(e).then(t).catch(n)
    }
    subscribeQuotes(e, t, n, r) {
        this._quotesPulseProvider.subscribeQuotes(e, t, n, r)
    }
    unsubscribeQuotes(e) {
        this._quotesPulseProvider.unsubscribeQuotes(e)
    }
    getMarks(e, t, n, r, a) {
        if (!this._configuration.supports_marks)
            return;
        const s = {
            symbol: e.ticker || "",
            from: t,
            to: n,
            resolution: a
        };
        this._send("marks", s).then((e => {
            if (!Array.isArray(e)) {
                const t = [];
                for (let n = 0; n < e.id.length; ++n)
                    t.push({
                        id: $Pe(e, "id", n),
                        time: $Pe(e, "time", n),
                        color: $Pe(e, "color", n),
                        text: $Pe(e, "text", n),
                        label: $Pe(e, "label", n),
                        labelFontColor: $Pe(e, "labelFontColor", n),
                        minSize: $Pe(e, "minSize", n),
                        borderWidth: $Pe(e, "borderWidth", n),
                        hoveredBorderWidth: $Pe(e, "hoveredBorderWidth", n),
                        imageUrl: $Pe(e, "imageUrl", n),
                        showLabelWhenImageLoaded: $Pe(e, "showLabelWhenImageLoaded", n)
                    });
                e = t
            }
            r(e)
        }
        )).catch((e => {
            DPe(e),
            r([])
        }
        ))
    }
    getTimescaleMarks(e, t, n, r, a) {
        if (!this._configuration.supports_timescale_marks)
            return;
        const s = {
            symbol: e.ticker || "",
            from: t,
            to: n,
            resolution: a
        };
        this._send("timescale_marks", s).then((e => {
            if (!Array.isArray(e)) {
                const t = [];
                for (let n = 0; n < e.id.length; ++n)
                    t.push({
                        id: $Pe(e, "id", n),
                        time: $Pe(e, "time", n),
                        color: $Pe(e, "color", n),
                        label: $Pe(e, "label", n),
                        tooltip: $Pe(e, "tooltip", n),
                        imageUrl: $Pe(e, "imageUrl", n),
                        showLabelWhenImageLoaded: $Pe(e, "showLabelWhenImageLoaded", n)
                    });
                e = t
            }
            r(e)
        }
        )).catch((e => {
            DPe(e),
            r([])
        }
        ))
    }
    getServerTime(e) {
        this._configuration.supports_time && this._send("time").then((t => {
            const n = parseInt(t);
            isNaN(n) || e(n)
        }
        )).catch((e => {
            DPe(e)
        }
        ))
    }
    searchSymbols(e, t, n, r) {
        if (this._configuration.supports_search) {
            const a = {
                limit: 30,
                query: e.toUpperCase(),
                type: n,
                exchange: t
            };
            this._send("search", a).then((e => {
                if (void 0 !== e.s)
                    return e.errmsg,
                    void r([]);
                r(e)
            }
            )).catch((e => {
                DPe(e),
                r([])
            }
            ))
        } else {
            if (null === this._symbolsStorage)
                throw new Error("UdfCompatibleDatafeed: inconsistent configuration (symbols storage)");
            this._symbolsStorage.searchSymbols(e, t, n, 30).then(r).catch(r.bind(null, []))
        }
    }
    resolveSymbol(e, t, n, r) {
        const a = r && r.currencyCode
          , s = r && r.unitId;
        function o(e) {
            t(e)
        }
        if (this._configuration.supports_group_request) {
            if (null === this._symbolsStorage)
                throw new Error("UdfCompatibleDatafeed: inconsistent configuration (symbols storage)");
            this._symbolsStorage.resolveSymbol(e, a, s).then(o).catch(n)
        } else {
            const t = {
                symbol: e
            };
            void 0 !== a && (t.currencyCode = a),
            void 0 !== s && (t.unitId = s),
            this._send("symbols", t).then((e => {
                if (void 0 !== e.s)
                    n("unknown_symbol");
                else {
                    const t = e.name
                      , n = e.listed_exchange ?? e["exchange-listed"]
                      , r = e.exchange ?? e["exchange-traded"];
                    o({
                        ...e,
                        name: t,
                        base_name: [n + ":" + t],
                        listed_exchange: n,
                        exchange: r,
                        ticker: e.ticker,
                        currency_code: e.currency_code ?? e["currency-code"],
                        original_currency_code: e.original_currency_code ?? e["original-currency-code"],
                        unit_id: e.unit_id ?? e["unit-id"],
                        original_unit_id: e.original_unit_id ?? e["original-unit-id"],
                        unit_conversion_types: e.unit_conversion_types ?? e["unit-conversion-types"],
                        has_intraday: e.has_intraday ?? e["has-intraday"] ?? !1,
                        visible_plots_set: e.visible_plots_set ?? e["visible-plots-set"],
                        minmov: e.minmovement ?? e.minmov ?? 0,
                        minmove2: e.minmovement2 ?? e.minmove2,
                        session: e.session ?? e["session-regular"],
                        session_holidays: e.session_holidays ?? e["session-holidays"],
                        supported_resolutions: e.supported_resolutions ?? e["supported-resolutions"] ?? this._configuration.supported_resolutions ?? [],
                        has_daily: e.has_daily ?? e["has-daily"] ?? !0,
                        intraday_multipliers: e.intraday_multipliers ?? e["intraday-multipliers"] ?? ["1", "5", "15", "30", "60"],
                        has_weekly_and_monthly: e.has_weekly_and_monthly ?? e["has-weekly-and-monthly"],
                        has_empty_bars: e.has_empty_bars ?? e["has-empty-bars"],
                        volume_precision: e.volume_precision ?? e["volume-precision"],
                        format: e.format ?? "price"
                    })
                }
            }
            )).catch((e => {
                DPe(e),
                n("unknown_symbol")
            }
            ))
        }
    }
    getBars(e, t, n, r, a) {
        this._historyProvider.getBars(e, t, n).then((e => {
            r(e.bars, e.meta)
        }
        )).catch(a)
    }
    subscribeBars(e, t, n, r, a) {
        this._dataPulseProvider.subscribeBars(e, t, n, r)
    }
    unsubscribeBars(e) {
        this._dataPulseProvider.unsubscribeBars(e)
    }
    _requestConfiguration() {
        return this._send("config").catch((e => (DPe(e),
        null)))
    }
    _send(e, t) {
        return this._requester.sendRequest(this._datafeedURL, e, t)
    }
    _setupWithConfiguration(e) {
        if (this._configuration = e,
        void 0 === e.exchanges && (e.exchanges = []),
        !e.supports_search && !e.supports_group_request)
            throw new Error("Unsupported datafeed configuration. Must either support search, or support group request");
        !e.supports_group_request && e.supports_search || (this._symbolsStorage = new HPe(this._datafeedURL,e.supported_resolutions || [],this._requester)),
        JSON.stringify(e)
    }
}
const qPe = (e, t, n) => {
    if (!(e => Bg.includes(e))(e))
        return null;
    switch (e) {
    case "config":
        return Ug;
    case "symbols":
        return ( (e, t) => {
            const n = mg(e);
            return {
                name: e,
                description: t,
                data_status: "streaming",
                delay: 0,
                exchange: "On-Chain",
                format: "volume",
                has_daily: !0,
                has_intraday: !0,
                has_seconds: _g.includes(n.chain),
                has_ticks: !1,
                has_weekly_and_monthly: !1,
                listed_exchange: "Uniswap",
                minmov: 1,
                pricescale: Math.pow(10, 15),
                session: "24x7",
                timezone: "UTC",
                type: "crypto",
                seconds_multipliers: ["1", "3", "5", "15"],
                intraday_multipliers: ["1", "5", "60", "240"],
                monthly_multipliers: [],
                volume_precision: 10
            }
        }
        )(t, n);
    default:
        return null
    }
}
;
class KPe {
    constructor(e, t, n=!1) {
        this.marketId = e,
        this.marketDescription = t,
        this.log = n
    }
    sendRequest(e, t, n) {
        const r = qPe(t, this.marketId, this.marketDescription);
        if (r)
            return Promise.resolve(r);
        this.logMessage("New request: " + t);
        const a = (e => "history" === e ? "getHistory" : null)(t);
        if (!a || !n)
            throw new Error("Unsupported method");
        if ("getHistory" === a) {
            const e = n;
            return pm.getHistory(e.symbol, e.from, e.to, e.resolution, e.countback)
        }
    }
    logMessage(e) {
        this.log
    }
}
class YPe extends GPe {
    constructor(e, n, r, a, s, o, l, i, c, d, u, p, h, m) {
        const g = new KPe(e,n);
        super(r, new BPe(r,g), g),
        t(this, "feedPerGuid", new Map),
        this.marketId = e,
        this.resetData = a,
        this.deployerAddress = s,
        this.snipersRef = o,
        this.getMarksSettingsAsyncRef = l,
        this.trackedWalletsInfo = i,
        this.trackedKolsInfo = c,
        this.feedPerResolution = d,
        this.tradesProxy = u,
        this.getMarksProvider = p,
        this.getGroupMentionMarks = h,
        this.getDexPaidMark = m
    }
    async getMarks(e, t, n, r) {
        var a, s, l, i, d;
        if (!this._configuration.supports_marks)
            return;
        const u = await this.getMarksSettingsAsyncRef.current()
          , p = this.getGroupMentionMarks()
          , h = this.getDexPaidMark()
          , m = [];
        u.showMyTrades && c.forEach(u.selectedWalletsAddresses, (r => {
            var a;
            m.push(null == (a = this.getMarksProvider("mine", null, null, null, null, r)) ? void 0 : a.getMarks(e, t, n))
        }
        )),
        u.showMayhemTrades && m.push(null == (a = this.getMarksProvider("mayhem", null, null, null, null, null)) ? void 0 : a.getMarks(e, t, n)),
        u.showSniperTrades && this.snipersRef.current && m.push(null == (s = this.getMarksProvider("sniper", null, null, null, null, null)) ? void 0 : s.getMarks(e, t, n)),
        u.focusedTraders && c.forEach(u.focusedTraders, (r => {
            var a;
            m.push(null == (a = this.getMarksProvider("specific", null, null, null, null, r)) ? void 0 : a.getMarks(e, t, n))
        }
        )),
        u.showTrackedTrades && m.push(null == (l = this.getMarksProvider("group", this.trackedWalletsInfo.current.hash, this.trackedWalletsInfo.current.map, null, null, null)) ? void 0 : l.getMarks(e, t, n)),
        u.showKolsTrades && m.push(null == (i = this.getMarksProvider("kol", null, null, this.trackedKolsInfo.current.hash, this.trackedKolsInfo.current.map, null)) ? void 0 : i.getMarks(e, t, n)),
        u.showDevTrades && this.deployerAddress && !twe(this.deployerAddress) && m.push(null == (d = this.getMarksProvider("dev", null, null, null, null, this.deployerAddress)) ? void 0 : d.getMarks(e, t, n));
        const g = new Set;
        Promise.allSettled(m).then((e => {
            const a = e.flatMap((e => {
                var t;
                if ("rejected" === e.status)
                    return [];
                {
                    const n = [];
                    return null == (t = e.value) || t.forEach((e => {
                        g.has(e.id) || (g.add(e.id),
                        n.push(e))
                    }
                    )),
                    n
                }
            }
            ))
              , s = [];
            p.forEach((e => {
                g.has(e.id) || (g.add(e.id),
                s.push(e))
            }
            )),
            h && h.time >= t && h.time <= n && !g.has(h.id) && (g.add(h.id),
            s.push(h)),
            r([...a, ...s])
        }
        )).catch((e => {
            o(e),
            r([])
        }
        ))
    }
    getBars(e, t, n, r, a) {
        let s = this.feedPerResolution.get(t);
        s || (this.feedPerResolution.set(t, {
            feed: new Rg(this.marketId,t,this.tradesProxy),
            listeners: 0
        }),
        s = this.feedPerResolution.get(t)),
        null == s || s.feed.getBars(n).then((s => {
            switch (s.type) {
            case "fetch-from-server":
                super.getBars(e, t, n, (e => {
                    const t = T(dt([...e, ...s.partial.map(XPe)], (e => e.time)), "ts", "asc");
                    r(t, {
                        noData: 0 === t.length
                    })
                }
                ), a);
                break;
            case "no-data":
                r([], {
                    noData: !0
                });
                break;
            case "data":
                r(s.candles.map((e => XPe(e))), {})
            }
        }
        )).catch((e => {
            a(e)
        }
        ))
    }
    subscribeBars(e, t, n, r, a) {
        let s = this.feedPerResolution.get(t);
        if (!s) {
            const e = {
                feed: new Rg(this.marketId,t,this.tradesProxy),
                listeners: 0
            };
            this.feedPerResolution.set(t, e),
            s = this.feedPerResolution.get(t)
        }
        s.listeners += 1,
        s.feed.subscribe({
            symbolInfo: e,
            resetCacheData: () => {
                a(),
                this.resetData()
            }
        }, (e => {
            n(XPe(e))
        }
        )),
        this.feedPerGuid.set(r, s.feed)
    }
    unsubscribeBars(e) {
        const t = this.feedPerGuid.get(e);
        if (t) {
            this.feedPerGuid.delete(e);
            const n = this.feedPerResolution.get(t.resolution);
            n && (n.listeners -= 1,
            n.listeners <= 0 && (n.feed.close(),
            this.feedPerResolution.delete(t.resolution)))
        }
    }
}
const XPe = e => ({
    open: e[up],
    high: e[pp],
    close: e[hp],
    low: e[mp],
    volume: e[gp],
    time: 1e3 * e[xp]
})
  , QPe = e => {
    const {colorSkin: t, customStyleConfig: n, customStyleConfig2: r} = Vb()
      , [a,s] = y.useState(null)
      , o = NA(e === rg.CUSTOM ? n : r)
      , [l,i] = y.useState(null);
    return y.useEffect(( () => {
        let e = !1;
        if (!l)
            return (async () => {
                const t = await fetch("/fonts/InterVariable/Inter-VariableFont_slnt,wght.ttf")
                  , n = await t.blob()
                  , r = URL.createObjectURL(n);
                e || i(r)
            }
            )(),
            () => {
                e = !0
            }
    }
    ), [l]),
    y.useEffect(( () => {
        if (!l)
            return;
        if (e !== t)
            return void (a && (URL.revokeObjectURL(a),
            s(null)));
        const i = e === rg.CUSTOM ? n : r;
        if (a && c.isEqual(o, i))
            return;
        const d = tX(t, n, r)
          , u = `\n    .theme-dark:root {\n    --tv-color-toolbar-button-text-active: ${d.primary.main}; /* theme.palette.primary.main */\n    --tv-color-toolbar-button-text: ${d.text.label}; /* theme.palette.text.label */\n    --tv-color-toolbar-button-text-active-hover: ${d.primary.main}; /* theme.palette.primary.main */\n    --tv-spinner-color: ${d.text.label}; /* theme.palette.text.label */\n    --tv-color-platform-background: ${d.background.secondary}; /* theme.palette.background.secondary */\n    --tv-color-toolbar-button-background-hover: ${d.background.buttonHover}; /* theme.palette.background.buttonHover */\n    --tv-color-toolbar-toggle-button-background: ${d.text.label}; /* theme.palette.text.label */\n    --tv-color-toolbar-toggle-button-background-active: ${d.primary.main}; /* theme.palette.primary.main */\n    --tv-color-toolbar-toggle-button-background-active-hover: ${d.primary.main}; /* theme.palette.primary.main */\n    --tv-color-toolbar-divider-background: ${d.background.borderMain}; /* theme.background.borderMain */\n    --tv-color-pane-background: ${d.background.default}; /* theme.palette.background.default */\n    --tv-color-popup-background: ${d.background.secondary}; /* theme.palette.background.secondary */\n    --tv-color-toolbar-button-background-hover: ${d.background.buttonHover}; /* Hover state */\n    --tv-color-toolbar-button-background-active: ${d.background.buttonActive}; /* Active state */\n    --tv-color-toolbar-button-background-expanded: ${d.background.buttonActive}; /* Expanded menu state */\n    --tv-color-toolbar-dropdown-hover-bg: ${d.background.buttonHover};\n    --tv-color-item-active-bg: ${d.background.buttonHover};\n    --tv-color-toolbar-dropdown-bg: ${d.background.buttonHover};\n    --tv-color-toolbar-dropdown-hover-bg: ${d.background.buttonHover};\n    --tv-color-toolbar-popup-bg: ${d.background.buttonHover};\n    --tv-color-toolbar-popup-hover-bg: ${d.background.buttonHover};\n    [data-role="menuitem"]:hover {\n        background-color: ${d.background.buttonHover}; /* Change to your desired color */\n    }\n    }\n    /* \n    /* used for inside of the chart as custom_font_family in widgetOptions: ChartingLibraryWidgetOptions */\n    @font-face {\n    font-family: "Inter";\n    src: url(${l})\n    format("truetype-variations");\n    font-weight: "100 1000";\n    }\n\n    /* used for toolbars */\n    * {\n    font-family: "Inter";\n    font-feature-settings: "ss04";\n    }\n\n\n    /* copied from common.css */\n    div[data-name="series-properties-dialog"]\n    div[data-section-name$="SymbolMinTick"] {\n    display: none;\n    }\n\n    .custom-button {\n      box-sizing: border-box;\n      height: calc(100% - 4px);\n      width: 34px;\n      border-radius: var(--tv-toolbar-explicit-hover-border-radius, 4px);\n      transition:\n        background-color 60ms ease,\n        opacity 60ms ease,\n        color 60ms ease;\n      padding: 0 5px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .custom-button:hover,\n    .custom-button:active {\n      background: var(--tv-color-toolbar-button-background-hover, #f0f3fa);\n    }\n  `
          , p = new Blob([u],{
            type: "text/css"
        })
          , h = URL.createObjectURL(p);
        s(h),
        a && URL.revokeObjectURL(a)
    }
    ), [t, a, n, o, l, r, e]),
    a
}
  , ZPe = (e, t) => {
    const n = (e => `${e.channelId}`)(t)
      , r = e.lastMention.get(n);
    return !r || t.timestamp > r + 15 ? (e.lastMention.set(n, t.timestamp),
    e.mentions.push((e => ({
        type: e.type,
        groupId: e.groupId,
        channelId: e.channelId,
        messageId: e.messageId,
        timestamp: e.timestamp,
        groupUiId: e.uiGroupId
    }))(t)),
    {
        ...e
    }) : e
}
  , JPe = e => c.orderBy(e, (e => e.timestamp), "asc")
  , eOe = (e, t) => {
    switch (t.type) {
    case "init":
        return JPe(t.snapshot.mentions).reduce(ZPe, {
            mentions: [],
            lastMention: new Map
        });
    case "update":
        {
            const n = e ?? {
                mentions: [],
                lastMention: new Map
            };
            return JPe(t.update.newMentions).reduce(ZPe, n)
        }
    default:
        throw new hj("Unknown smart feed message type",{
            exhaustiveCheck: t
        })
    }
}
  , tOe = e => {
    const t = lb(e, {
        min: 0,
        max: 100
    });
    return Math.round(t / 100 * 255).toString(16).padStart(2, "0").toUpperCase()
}
  , nOe = {
    " ": .28,
    ".": .2,
    ",": .2,
    "'": .2,
    "`": .2,
    ":": .3,
    ";": .3,
    "!": .32,
    "?": .5,
    "<": .45,
    ">": .45,
    i: .35,
    l: .35,
    I: .35,
    "|": .3,
    "/": .4,
    "\\": .4,
    "(": .4,
    ")": .4,
    "[": .4,
    "]": .4,
    "{": .45,
    "}": .45,
    "%": 1,
    "@": .95,
    W: .9,
    M: .9,
    1: .45
}
  , rOe = 80
  , aOe = "#FFFFFF00";
let sOe = !1
  , oOe = !1;
const lOe = e => {
    const t = Math.max(0, Math.min(100, e)) / 100 * 150;
    return Number.isFinite(t) ? t : 0
}
  , iOe = (e, t) => t ? 0 : e
  , cOe = (e, t, n, r, a) => {
    const s = `${iu(e, 15)} ${hM} ${t < .01 ? "<0.01%" : jI(t, {
        precision: t > 10 ? 0 : t > .1 ? 1 : 2,
        omitSign: !0
    })}`;
    if (!n)
        return s;
    const o = r - 112 - a - ( (e, t) => {
        const n = Array.from(e);
        let r = 0;
        const a = n.length >= 2 && " " === n[1] && new RegExp("\\P{ASCII}","u").test(n[0] ?? "");
        a && (r += 1.25 * t);
        for (let s = a ? 2 : 0; s < n.length; s += 1) {
            const e = n[s];
            r += (nOe[e] ?? .6) * t
        }
        return r
    }
    )(s, 11) - 18
      , l = Math.round(o / 3.08);
    return s + " ".repeat(Math.max(0, l))
}
  , dOe = (e, t) => {
    try {
        e.setExtendLeft(t)
    } catch (fNe) {
        sOe || (sOe = !0)
    }
    const n = e;
    if ("function" == typeof n.setExtendRight)
        try {
            n.setExtendRight(!t)
        } catch (fNe) {
            oOe || (oOe = !0)
        }
}
  , uOe = (e, t, n, r, a) => {
    const {chartHoldersLinesPosition: s, chartHoldersLinesMode: o, walletGroups: l, customWalletNames: i, customWalletEmojis: c, customWalletOnChart: d} = rf()
      , u = UX((e => e.entries))
      , p = Tve(r)
      , {data: h} = Hwe(a, p, null)
      , m = Ade()
      , g = vde()
      , x = y.useMemo(( () => {
        if (!a)
            return null;
        try {
            return mg(a).chain
        } catch (fNe) {
            return null
        }
    }
    ), [a])
      , b = y.useMemo(( () => {
        switch (o) {
        case Nx.KOLS:
            {
                const e = new Map;
                return u.forEach(( (t, n) => {
                    x && n !== x || t.status === ox.READY && t.data.forEach(( (t, n) => {
                        e.set(n, t.name)
                    }
                    ))
                }
                )),
                e
            }
        case Nx.TRACKED_GROUPS:
            {
                const e = new Map;
                if (!l)
                    return e;
                const t = l.flatMap((e => e.addresses));
                for (const n of t) {
                    const t = ng(n);
                    if (!(d[t] ?? !0) || e.has(t))
                        continue;
                    const r = i[t] ?? null
                      , a = `${c[t] ?? rI} ${r ?? t2(t, iZ.END, 4)}`;
                    e.set(t, a)
                }
                return e
            }
        default:
            throw new Error(`Unknown chartHoldersLinesMode ${o}`)
        }
    }
    ), [o, c, i, d, u, x, l]);
    ( ({items: e, showOnChart: t, chartApiRef: n, chartWidth: r, opacity: a=rOe, showOnLeft: s=!1}) => {
        const o = y.useRef({})
          , l = y.useMemo(( () => e ?? []), [e])
          , i = y.useCallback(( () => {
            const e = o.current;
            for (const t of Object.keys(e)) {
                try {
                    e[t].remove()
                } catch (fNe) {}
                delete e[t]
            }
        }
        ), []);
        y.useEffect(( () => {
            if (!t)
                return void i();
            const e = n.current;
            if (!e)
                return;
            const c = o.current
              , d = new Set(l.filter((e => null !== e.value)).map((e => e.id)));
            for (const t of Object.keys(c))
                if (!d.has(t)) {
                    try {
                        c[t].remove()
                    } catch (fNe) {}
                    delete c[t]
                }
            for (const t of l) {
                const {id: n, label: o, holdingPercent: l, value: i, lengthValue: d, color: u} = t;
                if (null === i)
                    continue;
                const p = `${u}${tOe(a)}`
                  , h = c[n]
                  , m = lOe(d)
                  , g = iOe(m, s)
                  , x = cOe(o, l, s, r, m);
                if (h)
                    try {
                        h.setPrice(i),
                        h.setLineColor(p),
                        h.setLineLength(g, "pixel"),
                        h.setText(x),
                        h.setBodyFont(Yg),
                        h.setBodyTextColor(p),
                        h.setBodyBorderColor(aOe),
                        h.setBodyBackgroundColor(aOe),
                        dOe(h, s)
                    } catch (fNe) {}
                else
                    try {
                        const t = e.createOrderLine().setText("").setQuantity("").setLineColor(p).setLineStyle(0).setLineWidth(1).setLineLength(g, "pixel").setEditable(!1).setCancellable(!1).setPrice(i).setText(x).setBodyFont(Yg).setBodyTextColor(p).setBodyBorderColor(aOe).setBodyBackgroundColor(aOe);
                        dOe(t, s),
                        c[n] = t
                    } catch (fNe) {}
            }
        }
        ), [n, r, l, i, t, s, a]),
        y.useEffect(( () => () => i()), [i])
    }
    )({
        items: y.useMemo(( () => {
            if (!(null == h ? void 0 : h.queue))
                return null;
            if (!b.size)
                return null;
            const e = [];
            for (const t of h.queue.values()) {
                const n = ng(t.walletAddress);
                if (!n)
                    continue;
                const r = b.get(n);
                if (!r)
                    continue;
                const a = gOe(t, m, x);
                if (null === a || !Number.isFinite(a) || a <= 0)
                    continue;
                const s = Number(xOe(t.amountString, g).toFixed(2))
                  , o = mOe(s);
                e.push({
                    id: n,
                    label: r,
                    value: a,
                    lengthValue: o,
                    holdingPercent: s,
                    color: hOe(n)
                })
            }
            return e.length ? e : null
        }
        ), [m, g, x, h, b]),
        showOnChart: e,
        chartApiRef: t,
        chartWidth: n,
        showOnLeft: s === Px.LEFT
    })
}
  , pOe = ["#FF6B6B", "#FFA94D", "#FFD43B", "#69DB7C", "#38D9A9", "#4DABF7", "#748FFC", "#9775FA", "#DA77F2", "#F783AC", "#F59F00", "#40C057", "#15AABF", "#228BE6", "#5C7CFA", "#BE4BDB", "#E64980", "#82C91E", "#FAB005", "#12B886"]
  , hOe = e => {
    const t = e.toLowerCase();
    let n = 0;
    for (let r = 0; r < t.length; r += 1)
        n += t.charCodeAt(r);
    return pOe[n % pOe.length]
}
  , mOe = e => {
    if (!Number.isFinite(e) || e <= .1)
        return 5;
    if (e >= 4)
        return 100;
    return 5 + 95 * ((e - .1) / 3.9)
}
  , gOe = (e, t, n) => {
    if (null === e.totalBoughtUsd || null === e.amountBought || 0 === e.amountBought)
        return null;
    if (n === Pd.SOLANA) {
        if (null == t || t < 0)
            return null;
        const n = e.amountBought / 10 ** t;
        return n && Number.isFinite(n) ? e.totalBoughtUsd / n : null
    }
    return e.totalBoughtUsd / e.amountBought
}
  , xOe = (e, t) => {
    if (!t)
        return 0;
    try {
        const n = BigInt(t);
        if (0n === n)
            return 0;
        const r = BigInt(e ?? "0");
        return Number(10000n * r / n) / 100
    } catch {
        return 0
    }
}
  , bOe = ["dev", "group", "mine", "specific", "kol", "sniper", "mayhem"]
  , fOe = {
    dev: !0,
    group: !0,
    kol: !0,
    mayhem: !0,
    mine: !0,
    sniper: !0,
    specific: !0
};
( () => {
    if (!c.isEqual(Object.keys(fOe).sort(), bOe.sort()))
        throw new Error("getColorsHash: TChartMarkersColors and MARK_TYPES keys length mismatch. add new keys to MARK_TYPES")
}
)();
const vOe = ["buy", "sell", "text"]
  , SOe = e => bOe.map((t => vOe.map((n => {
    var r;
    return null == (r = e[t]) ? void 0 : r[n]
}
)))).flat().join("-").replace("#", "")
  , yOe = SOe(Kg);
class kOe {
    constructor(e, n, r, a, s, o, l, i, c, d) {
        t(this, "oldestTs", null),
        t(this, "snapshot", []),
        t(this, "existingIds", new Set),
        this.marksType = e,
        this.deployerAddress = n,
        this.snipersRef = r,
        this.trackedWalletsInfo = a,
        this.trackedKolsInfo = s,
        this.walletAddress = o,
        this.baseTokenTotalSupplyRef = l,
        this.baseTokenTotalDecimalsRef = i,
        this.tradesProxy = c,
        this.chartMarkersColors = d
    }
    provideTrade(e) {
        var t;
        if ("mine" === this.marksType && e.maker !== this.walletAddress)
            return !1;
        const n = this.trackedWalletsInfo ? this.trackedWalletsInfo.get(e.maker) : void 0
          , r = this.trackedKolsInfo ? this.trackedKolsInfo.get(e.maker) : void 0;
        if ("sniper" === this.marksType && !(null == (t = this.snipersRef.current) ? void 0 : t.has(e.maker)))
            return !1;
        if ("mayhem" === this.marksType && !_1.has(e.maker))
            return !1;
        if ("group" === this.marksType) {
            if (!n)
                return !1;
            if (!1 === n.onChart || (n.minTradeSize ?? 0) > Number(e.amountInUsd))
                return !1
        }
        if ("kol" === this.marksType && !r)
            return !1;
        if ("dev" === this.marksType && e.maker !== this.deployerAddress)
            return !1;
        if ("specific" === this.marksType && e.maker !== this.walletAddress)
            return !1;
        const a = ( (e, t, n, r, a, s, o) => {
            var l, i;
            const {side: c, timestamp: d, maker: u, amountInUsd: p, priceInUsd: h} = t
              , m = `${c}-${d}-${u}`
              , g = (null == (l = null == n ? void 0 : n.get(u)) ? void 0 : l.emoji) ?? null
              , x = (null == (i = null == n ? void 0 : n.get(u)) ? void 0 : i.name) ?? null
              , b = (null == r ? void 0 : r.get(u)) ?? null
              , f = (null == b ? void 0 : b.name) ?? null
              , v = "mayhem" === e ? APe : b && !g ? Jwe(b.walletAddress) : null;
            return EPe(m, e, d, c, Number(p), String(h), a, s, u, g, v, x ?? f, o)
        }
        )(this.marksType, e, this.trackedWalletsInfo, this.trackedKolsInfo, this.baseTokenTotalSupplyRef.current, this.baseTokenTotalDecimalsRef.current, this.chartMarkersColors);
        return !this.existingIds.has(String(a.id)) && (this.existingIds.add(String(a.id)),
        this.snapshot.push(a),
        this.oldestTs = Math.min(this.oldestTs ?? a.time, a.time),
        !0)
    }
    async getMarks(e, t, n) {
        var r;
        null == (r = this.tradesProxy.trades) || r.forEach((e => {
            this.provideTrade(e)
        }
        ));
        const a = this.snapshot.filter((e => e.time >= t && e.time <= n))
          , s = COe(t, n, this.oldestTs);
        if (s) {
            (await this.helper(e, s.computedFrom, s.computedTo)).forEach((e => {
                this.existingIds.has(String(e.id)) || ((!this.oldestTs || this.oldestTs > e.time) && (this.oldestTs = e.time),
                this.snapshot.push(e),
                this.existingIds.add(String(e.id)),
                a.push(e))
            }
            )),
            (!this.oldestTs || this.oldestTs > t) && (this.oldestTs = t)
        }
        return a
    }
    async helper(e, t, n) {
        const r = [];
        var a;
        "mine" === this.marksType && r.push(pm.getTradesForMarks(e.ticker ?? "", "mine", t, n, this.walletAddress, null)),
        "specific" === this.marksType && r.push(pm.getTradesForMarks(e.ticker ?? "", "specific", t, n, this.walletAddress, null)),
        "dev" === this.marksType && r.push(pm.getTradesForMarks(e.ticker ?? "", "dev", t, n, this.walletAddress, null)),
        "group" === this.marksType && r.push(pm.getTradesForMarks(e.ticker ?? "", "group", t, n, null, "")),
        "kol" === this.marksType && r.push(pm.getTrackedKolsTradesForMarks(e.ticker ?? "", t, n)),
        "mayhem" === this.marksType && r.push(pm.getTradesForMayhemMarks(e.ticker ?? "", t, n)),
        "sniper" === this.marksType && this.snipersRef.current && this.snipersRef.current.size > 0 && r.push(pm.getTradesForSniperMarks(e.ticker ?? "", t, n, (a = Array.from(this.snipersRef.current),
        dp.encode(JSON.stringify(a)))));
        const s = new Set;
        return Promise.allSettled(r).then((e => e.flatMap((e => {
            if ("rejected" === e.status)
                return [];
            {
                const t = []
                  , n = e.value;
                for (let e = 0; e < n.tradesForMarks.length; ++e) {
                    const r = wPe(this.marksType, n.tradesForMarks[e], this.trackedWalletsInfo, this.trackedKolsInfo, this.baseTokenTotalSupplyRef.current, this.baseTokenTotalDecimalsRef.current, this.chartMarkersColors);
                    s.has(r.id) || (s.add(r.id),
                    t.push(r))
                }
                return t
            }
        }
        )))).catch((e => []))
    }
}
const COe = (e, t, n) => {
    let r = t;
    return null !== n && e >= n ? null : (null !== n && (r = n),
    {
        computedFrom: e,
        computedTo: r
    })
}
  , AOe = (e, t, n, r, a) => {
    const [s,o] = y.useState(null);
    y.useEffect(( () => {
        if (r) {
            if (a.current && (n || s))
                if (n || !s) {
                    if (!n || s)
                        return s && n ? (s.setPrice(n),
                        s.setLineColor(t),
                        s.setBodyFont(Yg),
                        void s.setBodyTextColor(t)) : void 0;
                    try {
                        const r = a.current.createOrderLine().setText("").setQuantity("").setLineColor(t).setLineStyle(2).setLineWidth(1).setPrice(n).setText(e).setBodyFont(Yg).setBodyTextColor(t).setBodyBorderColor("#FFFFFF00").setBodyBackgroundColor("#FFFFFF00").setEditable(!1);
                        o(r)
                    } catch (fNe) {}
                } else
                    try {
                        s.remove()
                    } catch (fNe) {} finally {
                        o(null)
                    }
        } else if (s)
            try {
                s.remove()
            } catch (fNe) {} finally {
                o(null)
            }
    }
    ), [a, r, n, s, t, e])
}
  , wOe = (e, t) => {
    const {originalStaticMarketInfo: n} = Qce()
      , r = hde(n)
      , a = Zce((e => {
        var t, n;
        return (null == (n = null == (t = e.marketStats) ? void 0 : t.pumpFunGaze) ? void 0 : n.migrationPriceInUsd) ?? null
    }
    ), c.isEqual)
      , s = y.useMemo(( () => {
        if (!r || !a)
            return !1;
        return !(!!r.preMigrationMarketId && !nTe.includes(r.protocol.type)) && e
    }
    ), [r, a, e]);
    AOe("Migration", jOe, a, s, t)
}
  , jOe = "#767676"
  , TOe = "#767676"
  , IOe = ({items: e, showOnChart: t, chartApiRef: n, color: r, onRemove: a}) => {
    const s = y.useRef({})
      , o = y.useRef(new Set)
      , [l,i] = y.useState(0)
      , c = y.useMemo(( () => e ?? []), [e])
      , d = y.useCallback((e => {
        (async () => {
            try {
                await a(e) || (o.current.delete(e),
                i((e => e + 1)))
            } catch (fNe) {
                o.current.delete(e),
                i((e => e + 1))
            }
        }
        )()
    }
    ), [a]);
    y.useEffect(( () => {
        if (!t)
            return void ( () => {
                const e = s.current;
                for (const t of Object.keys(e)) {
                    try {
                        e[t].remove()
                    } catch (fNe) {}
                    delete e[t]
                }
            }
            )();
        const e = n.current;
        if (!e)
            return;
        const a = s.current
          , l = new Set(c.filter((e => null !== e.value && void 0 !== e.value)).filter((e => !o.current.has(e.id))).map((e => e.id)));
        for (const t of Object.keys(a))
            if (!l.has(t)) {
                try {
                    a[t].remove()
                } catch (fNe) {}
                delete a[t]
            }
        for (const t of c) {
            const {id: n, label: l, value: i} = t;
            if (null == i)
                continue;
            if (o.current.has(n))
                continue;
            const c = a[n];
            if (c)
                try {
                    c.setPrice(i),
                    c.setLineColor(r),
                    c.setBodyFont(Yg),
                    c.setBodyTextColor(r),
                    c.setCancelButtonBackgroundColor(r),
                    c.setCancelButtonBorderColor(r),
                    c.setText(l)
                } catch (fNe) {}
            else
                try {
                    const t = e.createOrderLine().setText("").setQuantity("").setLineColor(r).setLineStyle(2).setLineWidth(1).setLineLength(100).setPrice(i).setText(l).setBodyFont(Yg).setBodyTextColor(r).setBodyBorderColor("#FFFFFF00").setBodyBackgroundColor("#FFFFFF00").setCancellable(!0).setCancelButtonBackgroundColor(r).setCancelButtonIconColor("#FFFFFF").setCancelButtonBorderColor(r).setCancelTooltip("Remove");
                    t.onCancel(( () => {
                        o.current.add(n);
                        try {
                            t.remove()
                        } catch (fNe) {}
                        delete s.current[n];
                        try {
                            d(n)
                        } catch (fNe) {}
                    }
                    )),
                    a[n] = t
                } catch (fNe) {}
        }
        for (const t of Array.from(o.current))
            c.find((e => e.id === t)) || o.current.delete(t);
        return () => {}
    }
    ), [n, t, r, c, a, d, l])
}
  , EOe = (e, t) => `${LI(e, {
    collapseExponent: !0,
    desiredDigits: 3,
    noTrailingZeros: !0,
    symbol: "$",
    padSymbol: !1,
    symbolPosition: yI.START
})}${"usd-price" === t ? "" : " MC"}`
  , MOe = () => v.jsx(Ee, {
    sx: NOe
})
  , NOe = {
    mx: -3
}
  , POe = y.memo(( ({title: e, summaryContent: t, isDeactivated: n, children: r}) => {
    const a = y.useMemo(( () => ({
        ...ROe,
        opacity: n ? .5 : 1
    })), [n]);
    return v.jsxs(Un, {
        disableGutters: !0,
        defaultExpanded: !0,
        sx: OOe,
        children: [v.jsx(Wn, {
            sx: LOe,
            expandIcon: v.jsx(er, {
                fontSize: "small"
            }),
            children: t || v.jsx(k, {
                ...VNe,
                children: e
            })
        }), v.jsx(Fn, {
            sx: a,
            children: r
        })]
    })
}
))
  , OOe = {
    background: "transparent",
    boxShadow: "none",
    "&:before": {
        opacity: "0 !important"
    }
}
  , LOe = {
    px: 0
}
  , ROe = {
    pt: 0,
    px: 0
}
  , DOe = y.memo(( () => {
    const {t: e} = we()
      , {colorSkin: t, defaultThemeSkin: n} = Vb()
      , {chartForceAutoScale: r, toggleChartForceAutoScale: a} = rf();
    return v.jsx(S, {
        gap: 2,
        children: v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "h2",
                component: "label",
                htmlFor: BOe,
                sx: FNe,
                children: e("Open chart with auto scale")
            }), v.jsx(Ue, {
                id: BOe,
                onChange: a,
                color: r ? "positive" : "neutral",
                size: t === rg.INDIGO || n === Xh.INDIGO ? "small" : "medium",
                checked: r
            })]
        })
    })
}
))
  , BOe = "settings-chart-general-autoscale"
  , _Oe = y.memo(( ({isChecked: e, setIsChecked: t, label: n, children: r, id: a}) => {
    const s = y.useCallback((e => {
        t(e.target.checked)
    }
    ), [t])
      , o = y.useMemo(( () => t => ({
        opacity: e ? 1 : .5,
        transition: `opacity ${t.transitions.duration.shortest}ms `
    })), [e]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 2,
        minHeight: 42,
        children: [v.jsx(UR, {
            checked: e,
            onChange: s,
            disableRipple: !0,
            id: a
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            flexGrow: 1,
            gap: 1,
            alignItems: "center",
            sx: o,
            children: [v.jsx(k, {
                variant: "paragraph3",
                component: "label",
                htmlFor: a,
                sx: FNe,
                children: n
            }), v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.5,
                flexGrow: 1,
                justifyContent: "flex-end",
                children: r
            })]
        })]
    })
}
))
  , UOe = y.memo(( ({onClick: e}) => {
    const {t: t} = we();
    return v.jsx(GC, {
        title: t("Restore default"),
        children: v.jsx(F, {
            onClick: e,
            sx: WOe,
            children: v.jsx(_S, {
                size: 14,
                color: "inherit"
            })
        })
    })
}
))
  , WOe = e => ({
    p: .25,
    width: 22,
    height: 22,
    background: e.palette.black[700],
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.primary
    }
})
  , FOe = ({sx: e, ...t}) => {
    const {colorSkin: n} = Vb()
      , r = D()
      , a = y.useMemo(( () => CPe(r.palette, n)), [r.palette, n])
      , s = y.useMemo(( () => ({
        flex: "0 0 80px",
        borderRadius: 1,
        backgroundColor: a,
        cursor: "crosshair"
    })), [a])
      , o = y.useMemo(( () => ( (e, t) => {
        if (null == t && null == e)
            return;
        const n = e => null !== e && "object" == typeof e && !Array.isArray(e)
          , r = (e, t) => {
            if (null == e)
                return [];
            if (Array.isArray(e))
                return e.map((e => "function" == typeof e ? e(t) : e)).filter((e => n(e)));
            if ("function" == typeof e) {
                const n = e(t);
                return r(n, t)
            }
            return n(e) ? [e] : []
        }
        ;
        if ("function" == typeof t || "function" == typeof e)
            return n => {
                const a = "function" == typeof e ? e(n) : e
                  , s = "function" == typeof t ? t(n) : t
                  , o = r(a, n)
                  , l = r(s, n);
                if (0 !== o.length || 0 !== l.length)
                    return Object.assign({}, ...o, ...l)
            }
            ;
        if (Array.isArray(e) || Array.isArray(t)) {
            const n = null == e ? [] : Array.isArray(e) ? e : [e]
              , r = null == t ? [] : Array.isArray(t) ? t : [t];
            if (0 === n.length && 0 === r.length)
                return;
            return [...n, ...r]
        }
        return {
            ...e ?? {},
            ...t ?? {}
        }
    }
    )(s, e)), [s, e]);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        gap: .2,
        sx: o,
        ...t
    })
}
  , VOe = ({color: e, hidden: t}) => {
    const n = y.useMemo(( () => n => ({
        height: 32,
        px: 1.5,
        "--linePreviewColor": e,
        "&::before": {
            content: '""',
            opacity: t ? 0 : 1,
            display: "block",
            flexGrow: 1,
            height: 2,
            backgroundImage: `\n          linear-gradient(to right, var(--linePreviewColor) 45%, transparent 0%),\n          linear-gradient(to right, ${e} 45%, transparent 0%)\n          `,
            backgroundPosition: "bottom center",
            backgroundSize: "10px 1px",
            backgroundRepeat: "repeat-x",
            transition: `opacity ${n.transitions.duration.shortest}ms, --linePreviewColor ${n.transitions.duration.shortest}ms`
        }
    })), [t, e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(tr, {
            styles: "\n          @property --linePreviewColor {\n            syntax: '<color>';\n            inherits: true;\n            initial-value: transparent;\n          }\n        "
        }), v.jsx(FOe, {
            sx: n
        })]
    })
}
  , HOe = y.memo(( ({lineType: e}) => {
    const {settings: t, updateLineColor: n, chartLinesVisibility: r, setChartLinesVisibility: a, setHideChartLines: s} = rf()
      , {t: o} = we()
      , {colorSettingsValueKey: l, defaultColor: i} = y.useMemo(( () => YNe[e]), [e])
      , c = r[e]
      , d = y.useCallback((t => {
        a((n => (n[e] || s(!1),
        {
            ...n,
            [e]: t
        })))
    }
    ), [a, e, s])
      , u = null == t ? void 0 : t[l]
      , [p,h] = y.useState(u ?? i)
      , m = y.useCallback((t => {
        n(t, e)
    }
    ), [e, n])
      , g = y.useCallback(( () => {
        p && (m(p),
        d(!0))
    }
    ), [p, m, d])
      , x = y.useCallback(( () => {
        m(i),
        d(!0)
    }
    ), [i, m, d]);
    return y.useEffect(( () => {
        u && h(u)
    }
    ), [u]),
    p ? v.jsxs(_Oe, {
        label: ZNe(o, e),
        isChecked: c,
        setIsChecked: d,
        id: `settings-chart-lines-${e}`,
        children: [v.jsx(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: v.jsx(y3, {
                label: null,
                tooltipTitle: o("Line color"),
                selectedColor: p,
                setSelectedColor: h,
                defaultColor: p,
                enableAlpha: !0,
                onCloseCallback: g
            })
        }), v.jsx(VOe, {
            color: p,
            hidden: !c
        }), v.jsx(UOe, {
            onClick: x
        })]
    }) : v.jsx(Ie, {
        variant: "rounded",
        height: zOe,
        width: "100%"
    })
}
))
  , zOe = 42
  , $Oe = y.memo(( () => {
    const {t: e} = we()
      , {chartLinesVisibility: t, setChartLinesVisibility: n} = rf()
      , r = t[Rx[Rx.MIGRATION_PRICE]]
      , a = y.useCallback((e => {
        n({
            ...t,
            [Rx[Rx.MIGRATION_PRICE]]: e
        })
    }
    ), [n, t])
      , s = t[Rx[Rx.MIGRATION_TIME]]
      , o = y.useCallback((e => {
        n({
            ...t,
            [Rx[Rx.MIGRATION_TIME]]: e
        })
    }
    ), [n, t])
      , l = y.useCallback((e => {
        n({
            ...t,
            [Rx[Rx.MIGRATION_PRICE]]: e,
            [Rx[Rx.MIGRATION_TIME]]: e
        })
    }
    ), [n, t]);
    return v.jsx(v.Fragment, {
        children: v.jsxs(_Oe, {
            label: e("Migration"),
            isChecked: r || s,
            setIsChecked: l,
            id: "settings-chart-lines-migration",
            children: [v.jsx(GOe, {
                isVisible: r,
                setIsVisible: a,
                label: ePe(e, Rx.MIGRATION_PRICE),
                id: "settings-chart-lines-migration-price"
            }), v.jsx(GOe, {
                isVisible: s,
                setIsVisible: o,
                label: ePe(e, Rx.MIGRATION_TIME),
                id: "settings-chart-lines-migration-time"
            })]
        })
    })
}
))
  , GOe = y.memo(( ({id: e, isVisible: t, setIsVisible: n, label: r}) => {
    const a = y.useCallback((e => {
        n(e.target.checked)
    }
    ), [n]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        minWidth: 70,
        children: [v.jsx(UR, {
            checked: t,
            onChange: a,
            disableRipple: !0,
            id: e
        }), v.jsx(k, {
            component: "label",
            htmlFor: e,
            variant: "paragraph3",
            sx: FNe,
            children: r
        })]
    })
}
))
  , qOe = Rx.KOL
  , KOe = y.memo(( () => {
    const {t: e} = we()
      , {chartHoldersLinesPosition: t, setChartHoldersLinesPosition: n, chartHoldersLinesMode: r, setChartHoldersLinesMode: a, chartLinesVisibility: s, setChartLinesVisibility: o} = rf()
      , l = s[qOe]
      , i = y.useCallback((e => {
        o({
            ...s,
            [qOe]: e
        })
    }
    ), [o, s])
      , c = y.useCallback(( (e, t) => {
        n(t)
    }
    ), [n])
      , d = y.useMemo(( () => pZ(e, YOe)), [e])
      , u = y.useCallback(( (e, t) => {
        a(t)
    }
    ), [a])
      , p = y.useMemo(( () => pZ(e, XOe)), [e]);
    return v.jsx(_Oe, {
        label: JNe(e, qOe),
        isChecked: l,
        setIsChecked: i,
        id: "settings-chart-lines-top-kol",
        children: v.jsxs(S, {
            direction: {
                xs: "column",
                sm: "row"
            },
            gap: {
                xs: 1,
                sm: 2.5
            },
            alignItems: {
                xs: "flex-end",
                sm: "center"
            },
            children: [v.jsx(GC, {
                title: e("Holders to display"),
                children: v.jsx(S, {
                    children: v.jsx(IH, {
                        items: p,
                        size: "xxsmall",
                        value: r,
                        onChange: u,
                        maxItemWidth: 56,
                        minItemWidth: 56
                    })
                })
            }), v.jsx(GC, {
                title: e("Position on chart"),
                children: v.jsx(S, {
                    children: v.jsx(IH, {
                        items: d,
                        size: "xxsmall",
                        value: t,
                        onChange: c,
                        maxItemWidth: 56,
                        minItemWidth: 56
                    })
                })
            })]
        })
    })
}
))
  , YOe = [{
    value: Px.LEFT,
    label: "Left"
}, {
    value: Px.RIGHT,
    label: "Right"
}]
  , XOe = [{
    value: Nx.KOLS,
    label: "KOLs"
}, {
    value: Nx.TRACKED_GROUPS,
    label: "Tracked"
}]
  , QOe = y.memo(( () => v.jsxs(S, {
    gap: .5,
    children: [XNe.map((e => v.jsx(HOe, {
        lineType: e
    }, e))), v.jsx(KOe, {}), v.jsx($Oe, {})]
})))
  , ZOe = ({label: e, bgColor: t="#000", textColor: n="#fff", hidden: r}) => {
    const a = y.useMemo(( () => e => ({
        opacity: r ? 0 : 1,
        width: 26,
        height: 26,
        background: t,
        border: `2px solid ${Gt(t, .5)}`,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "50%",
        transition: e.transitions.create(["opacity", "background-color", "border-color"], {
            duration: e.transitions.duration.shortest
        })
    })), [t, r]);
    return v.jsx(C, {
        sx: a,
        children: v.jsx(k, {
            fontFamily: Cu.INTER,
            variant: "paragraph3",
            color: n,
            children: e
        })
    })
}
  , JOe = y.memo(( ({id: e, markerType: t, initialColors: n}) => {
    const {updateChartMarkersColors: r, chartMarkersVisibility: a, setChartMarkersVisibility: s, setHideChartMarkers: o} = rf()
      , {t: l} = we()
      , {applicableColorSettings: i} = y.useMemo(( () => tPe[t]), [t])
      , c = a[t]
      , d = y.useCallback((e => {
        s((n => (n[t] || o(!1),
        {
            ...n,
            [t]: e
        })))
    }
    ), [t, s, o])
      , [u,p] = y.useState(n)
      , h = y.useCallback(( (e, t) => {
        p((n => ({
            ...n,
            [t]: e
        })))
    }
    ), [])
      , m = y.useCallback(( () => {
        r(u, t),
        d(!0)
    }
    ), [u, t, r, d])
      , g = y.useCallback((e => {
        d(e.target.checked)
    }
    ), [d])
      , x = y.useCallback(( () => {
        r(Kg[t], t),
        d(!0)
    }
    ), [t, r, d]);
    y.useEffect(( () => {
        n && p(n)
    }
    ), [n]);
    const b = y.useMemo(( () => e => ({
        opacity: c ? 1 : .5,
        transition: `opacity ${e.transitions.duration.shortest}ms `
    })), [c]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 2,
        minHeight: 42,
        children: [v.jsx(UR, {
            id: e,
            checked: c,
            onChange: g,
            disableRipple: !0
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            flexGrow: 1,
            gap: 1,
            alignItems: "center",
            sx: b,
            children: [v.jsx(k, {
                variant: "paragraph3",
                component: "label",
                htmlFor: e,
                sx: FNe,
                children: nPe(l, t)
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.5,
                flexGrow: 1,
                justifyContent: "flex-end",
                children: [v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: i.map((e => v.jsx(eLe, {
                        markerType: t,
                        colorType: e,
                        initialColor: u[e],
                        updateColor: h,
                        onCloseCallback: m
                    }, `${t}-${e}`)))
                }), v.jsxs(FOe, {
                    gap: 1,
                    justifyContent: "center",
                    height: 42,
                    children: [v.jsx(ZOe, {
                        label: rPe[t].buy,
                        bgColor: u.buy,
                        textColor: u.text,
                        hidden: !c
                    }), v.jsx(ZOe, {
                        label: rPe[t].sell,
                        bgColor: u.sell,
                        textColor: u.text,
                        hidden: !c
                    })]
                }), v.jsx(UOe, {
                    onClick: x
                })]
            })]
        })]
    })
}
))
  , eLe = y.memo(( ({updateColor: e, colorType: t, markerType: n, onCloseCallback: r, initialColor: a}) => {
    const {t: s} = we()
      , o = y.useCallback((n => {
        e(n, t)
    }
    ), [t, e])
      , l = Kg[n][t]
      , i = a ?? l
      , c = String(t).charAt(0).toUpperCase() + String(t).slice(1);
    return v.jsx(y3, {
        label: null,
        tooltipTitle: s("{{colorType}} color", {
            colorType: c
        }),
        enableAlpha: !0,
        selectedColor: i,
        setSelectedColor: o,
        defaultColor: l,
        onCloseCallback: r
    }, `${n}-${t}`)
}
))
  , tLe = y.memo(( () => {
    const {settings: e} = rf()
      , t = y.useMemo(( () => e ? e.chartMarkersColors ?? Kg : null), [e]);
    return v.jsx(S, {
        gap: .5,
        children: aPe.map((e => {
            if (!t)
                return v.jsx(Ie, {
                    variant: "rounded",
                    height: 42,
                    width: "100%"
                });
            const n = t[e] || Kg[e];
            return v.jsx(JOe, {
                id: `settings-chart-markers-${e}`,
                markerType: e,
                initialColors: n
            }, e)
        }
        ))
    })
}
))
  , nLe = y.memo(( () => {
    const {t: e} = we()
      , {hideChartLines: t, setHideChartLines: n, hideChartMarkers: r, setHideChartMarkers: a} = rf()
      , s = y.useCallback((e => {
        n((e => !e)),
        e.stopPropagation()
    }
    ), [n])
      , o = y.useMemo(( () => v.jsx(rLe, {
        title: e("Lines"),
        isHidden: t,
        onButtonClick: s
    })), [t, e, s])
      , l = y.useCallback((e => {
        a((e => !e)),
        e.stopPropagation()
    }
    ), [a])
      , i = y.useMemo(( () => v.jsx(rLe, {
        title: e("Markers"),
        isHidden: r,
        onButtonClick: l
    })), [r, e, l]);
    return v.jsxs(S, {
        mt: -2,
        children: [v.jsx(POe, {
            title: "General",
            children: v.jsx(DOe, {})
        }), v.jsx(MOe, {}), v.jsx(POe, {
            summaryContent: o,
            isDeactivated: t,
            children: v.jsx(S, {
                gap: 2,
                children: v.jsx(QOe, {})
            })
        }), v.jsx(MOe, {}), v.jsx(POe, {
            summaryContent: i,
            isDeactivated: r,
            children: v.jsx(S, {
                gap: 2,
                children: v.jsx(tLe, {})
            })
        })]
    })
}
))
  , rLe = y.memo(( ({title: e, isHidden: t, onButtonClick: n}) => {
    const {t: r} = we()
      , a = t ? Ek : Tk;
    return v.jsxs(S, {
        direction: "row",
        justifyContent: "center",
        alignItems: "center",
        gap: .5,
        color: t ? "text.label" : "text.primary",
        children: [v.jsx(k, {
            ...VNe,
            children: e
        }), v.jsx(GC, {
            title: r(t ? "Unhide" : "Hide"),
            offset: -5,
            children: v.jsx(S, {
                children: v.jsx(F, {
                    onClick: n,
                    sx: aLe,
                    children: v.jsx(a, {
                        color: "inherit"
                    })
                })
            })
        })]
    })
}
))
  , aLe = e => ({
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.primary
    }
})
  , sLe = "tv-chart-container"
  , oLe = Intl.DateTimeFormat().resolvedOptions().timeZone
  , lLe = []
  , iLe = (e, t) => {
    const n = (e => {
        switch (e) {
        case ku.PADRE_PLEX:
            return "padrePlex";
        case ku.GEIST:
            return "geist";
        case ku.INTER:
        default:
            return "padrePlex"
        }
    }
    )(t);
    switch (e) {
    case rg.DARK:
        return `/chartStyles/${n}/chartingLibraryStylesDark.css`;
    case rg.GREY:
        return `/chartStyles/${n}/chartingLibraryStylesGrey.css`;
    case rg.GREEN:
        return `/chartStyles/${n}/chartingLibraryStylesGreen.css`;
    case rg.PURPLE:
        return `/chartStyles/${n}/chartingLibraryStylesPurple.css`;
    case rg.VIOLET:
        return `/chartStyles/${n}/chartingLibraryStylesViolet.css`;
    case rg.MONOKAI:
        return `/chartStyles/${n}/chartingLibraryStylesMonokai.css`;
    case rg.INDIGO:
        return `/chartStyles/${n}/chartingLibraryStylesIndigo.css`;
    case rg.NOIR:
        return `/chartStyles/${n}/chartingLibraryStylesNoir.css`;
    case rg.TERMINAL:
        return `/chartStyles/${n}/chartingLibraryStylesTerminal.css`;
    case rg.CUSTOM:
    case rg.CUSTOM_2:
        return
    }
}
  , cLe = y.memo(( ({originalMarketId: e, deployerAddress: t, baseTokenAddress: r, marketDescription: a, snipersRef: s, snipersSize: o, baseTokenTotalSupplyRef: l, baseTokenTotalDecimalsRef: d, marketPriceRef: u, isTotalSupplyLoading: p}) => {
    const h = bw()
      , {isLandscape: g} = OR()
      , {setChartData: x} = OIe()
      , b = Owe((e => e.tradesProxy))
      , {focusedTraders: f, tradesLocation: S, panelFocusedTraders: k} = jwe()
      , A = y.useMemo(( () => S === XAe.PANEL && h ? k : f), [f, h, k, S])
      , {openModal: w} = r6()
      , j = Zce((e => {
        var t, n;
        return (null == (n = null == (t = e.marketStats) ? void 0 : t.baseTokenSocials) ? void 0 : n.dexscreenerUpdatedAt) ?? null
    }
    ), c.isEqual)
      , T = Vwe()
      , {registerNewMarkIfNeeded: I, getMarksProvider: E} = ( (e, t, n, r, a, s) => {
        const {settings: o} = rf()
          , [l,i] = Mx("padreV2-candlesChartMarksColors", {
            colors: Kg,
            hash: yOe
        });
        y.useEffect(( () => {
            if (!(null == o ? void 0 : o.chartMarkersColors))
                return;
            const e = SOe(o.chartMarkersColors);
            e !== l.hash && i({
                colors: o.chartMarkersColors,
                hash: e
            })
        }
        ), [l, i, null == o ? void 0 : o.chartMarkersColors]);
        const c = y.useMemo(( () => e ? {
            originalMarketId: e,
            providers: new Map
        } : null), [e])
          , d = y.useCallback(( (e, o, i, d, u, p) => {
            if (!c)
                return null;
            if ("group" === e && (!i || !o || p))
                throw new Error("Tracked info and hash is required for this mark type");
            if ("kol" === e && (!u || !d || p))
                throw new Error("Tracked info and hash is required for this mark type");
            if ("mayhem" === e && (u || d || p))
                throw new Error("Wallet address, trackedKolsInfo, trackedKolsHash should be skipped for mayhem markType");
            if ("sniper" === e && (u || d || p))
                throw new Error("Wallet address, trackedKolsInfo, trackedKolsHash should be skipped for sniper markType");
            if (["dev", "specific"].includes(e) && !p)
                throw new Error("Wallet address is required for this mark type");
            const h = `${"group" === e ? o ?? "empty" : "mayhem" === e ? "mayhem" : "kol" === e ? `kol-${d ?? "empty"}` : "sniper" === e ? "sniper" : "dev" === e ? `${e}` : `${e}-${p}`}-${l.hash}`
              , m = c.providers.get(h);
            if (!m) {
                const o = new kOe(e,t,n,i,u,p,r,a,s,l.colors);
                return c.providers.set(h, o),
                o
            }
            return m
        }
        ), [c, s, t, n, l, r, a])
          , u = y.useCallback(( (e, r, a, s, o, l) => {
            var i, c, u, p, h, m, g;
            let x = !1;
            return r.showMayhemTrades && _1.has(e.maker) && (x = (null == (i = d("mayhem", null, null, null, null, null)) ? void 0 : i.provideTrade(e)) || x),
            r.focusedTraders && r.focusedTraders.includes(e.maker) && (x = (null == (c = d("specific", null, null, null, null, e.maker)) ? void 0 : c.provideTrade(e)) || x),
            r.showDevTrades && t && e.maker === t && (x = (null == (u = d("dev", null, null, null, null, e.maker)) ? void 0 : u.provideTrade(e)) || x),
            r.showSniperTrades && n.current && n.current.has(e.maker) && (x = (null == (p = d("sniper", null, null, null, null, null)) ? void 0 : p.provideTrade(e)) || x),
            r.showMyTrades && r.selectedWalletsAddresses.includes(e.maker) && (x = (null == (h = d("mine", null, null, null, null, e.maker)) ? void 0 : h.provideTrade(e)) || x),
            r.showTrackedTrades && (null == s ? void 0 : s.has(e.maker)) && (x = (null == (m = d("group", a, s, null, null, null)) ? void 0 : m.provideTrade(e)) || x),
            r.showKolsTrades && (null == l ? void 0 : l.has(e.maker)) && (x = (null == (g = d("kol", null, null, o, l, null)) ? void 0 : g.provideTrade(e)) || x),
            x
        }
        ), [d, t, n]);
        return y.useMemo(( () => ({
            registerNewMarkIfNeeded: u,
            getMarksProvider: d
        })), [u, d])
    }
    )(e, t, s, l, d, b)
      , M = y.useRef(w);
    M.current = w;
    const {walletGroups: N, customWalletEmojis: P, customWalletNames: O, customWalletOnChart: L, chartForceAutoScale: B, chartLinesVisibility: _, chartMarkersVisibility: U, hideChartLines: W, setHideChartLines: F, hideChartMarkers: V, setHideChartMarkers: H} = rf()
      , z = y.useRef(B);
    z.current = B;
    const $ = y.useRef(null)
      , {selectedWalletsAddresses: G} = Gde()
      , {setHasChartRendered: K} = qbe()
      , {user: Y} = VK()
      , {openModal: X} = q6()
      , [Q,Z] = y.useState(!1)
      , [J,ee] = y.useState(!1)
      , te = y.useRef(null)
      , ne = y.useRef(null)
      , re = y.useRef(null)
      , ae = y.useRef(null)
      , [se,oe] = y.useState({
        width: 0,
        height: 0
    })
      , le = QPe(rg.CUSTOM)
      , ie = QPe(rg.CUSTOM_2)
      , ce = y.useMemo(( () => le ?? ie ?? null), [le, ie])
      , {colorSkin: de, font: ue} = Vb()
      , pe = D()
      , [he,me] = Mx("padreV2-tvPriceMarketCapSwitch", fPe.MARKET_CAP)
      , ge = y.useRef(he)
      , xe = y.useRef(null)
      , {createPriceAlert: be} = Iue()
      , fe = y.useCallback((async (t, n) => {
        if (!e)
            return;
        const r = ge.current === fPe.PRICE ? t : t * Number(l.current ?? 1) / 10 ** (d.current ?? 0);
        be({
            targetValue: r,
            direction: n,
            type: ge.current === fPe.PRICE ? "usd-price" : "usd-mkt-cap",
            marketId: e
        })
    }
    ), [d, l, be, e])
      , ve = y.useRef(fe);
    y.useEffect(( () => {
        ve.current = fe
    }
    ), [fe]);
    const [Se,ye] = y.useState(!1)
      , ke = y.useRef(null)
      , Ce = y.useRef(null)
      , Ae = U.dev
      , je = U.mine
      , Te = U.specific
      , Ie = U.kol
      , Ee = U.sniper
      , Me = U.mayhem
      , Ne = U.group
      , Pe = _[Lx.FILL]
      , Oe = _[Lx.SELL]
      , Le = _[Lx.TOP_HOLDERS_ENTRY]
      , Re = _[Lx.TOP_HOLDERS_EXIT]
      , De = _[Lx.PRICE_ALERT_ABOVE]
      , Be = _[Lx.PRICE_ALERT_BELOW]
      , _e = _[Rx.KOL]
      , Ue = _[Rx.MIGRATION_TIME]
      , We = _[Rx.MIGRATION_PRICE]
      , Fe = y.useMemo(( () => {
        if (!e)
            return null;
        try {
            return mg(e)
        } catch (W$e) {
            return null
        }
    }
    ), [e])
      , Ve = (null == Fe ? void 0 : Fe.chain) ?? null
      , [He,ze,$e] = y.useMemo(( () => {
        if (!N)
            return [new Map, "none", !0];
        const e = c.reduce(N, ( (e, t) => (c.forEach(t.addresses, (n => {
            var r;
            e.set(n, {
                name: O[n] ?? t.name,
                emoji: P[n] ?? $j(t.icon, t.emoji),
                onChart: L[n] ?? !0,
                minTradeSize: c.isNil(t.minChartTradeUsd) ? null : Math.min(t.minChartTradeUsd, (null == (r = e.get(n)) ? void 0 : r.minTradeSize) ?? 1 / 0)
            })
        }
        )),
        e)), new Map);
        return [e, `${WNe(Array.from(e.keys()).join("-"))}-${WNe(Array.from(e.values()).map((e => `${e.emoji}=${e.onChart}`)).join("-"))}-${e.size}`, !1]
    }
    ), [N, O, P, L])
      , Ge = y.useRef({
        hash: ze,
        map: He
    });
    Ge.current = {
        hash: ze,
        map: He
    };
    const {data: qe, status: Ke} = (e => {
        const t = y.useContext(WX);
        if (!t)
            throw new Error("useTrackedKols must be used within a TrackedKolsContextProvider");
        const {ensureTrackedKols: n} = t;
        if (y.useEffect(( () => {
            e && n(e)
        }
        ), [e, n]),
        !e)
            return {
                data: VX,
                status: ox.INITIAL,
                isLoading: !1,
                error: void 0
            };
        const r = t.getTrackedKolsEntry(e);
        switch (r.status) {
        case ox.READY:
            return {
                data: r.data,
                status: r.status,
                isLoading: !1,
                error: void 0
            };
        case ox.ERROR:
            return {
                data: VX,
                status: r.status,
                isLoading: !1,
                error: r.error
            };
        case ox.LOADING:
            return {
                data: VX,
                status: r.status,
                isLoading: !0,
                error: void 0
            };
        case ox.INITIAL:
        default:
            return {
                data: VX,
                status: r.status,
                isLoading: !1,
                error: void 0
            }
        }
    }
    )(Ve)
      , Ye = y.useMemo(( () => Ke !== ox.READY ? `status-${Ke}` : qe.size ? `tracked-kols--${qe.size}` : "none"), [qe, Ke])
      , Xe = y.useRef({
        hash: Ye,
        map: qe
    });
    Xe.current = {
        hash: Ye,
        map: qe
    };
    const Qe = y.useRef({
        showMyTrades: !V && je,
        showSniperTrades: !V && Ee,
        showDevTrades: !V && Ae,
        showTrackedTrades: !V && Te,
        showKolsTrades: !V && Ie,
        showMayhemTrades: !V && Me,
        focusedTraders: A,
        selectedWalletsAddresses: G
    })
      , Ze = !!Ve && $p.has(Ve) && (Ke === ox.INITIAL || Ke === ox.LOADING)
      , Je = ( (e, t, n, r) => {
        const a = y.useRef([])
          , s = y.useRef(t);
        s.current = t;
        const o = y.useRef(n);
        o.current = n;
        const l = y.useRef(r);
        return l.current = r,
        y.useEffect(( () => {
            t || n || r || !a.current.length || (a.current.reverse().forEach((e => e())),
            a.current = [])
        }
        ), [t, n, r]),
        y.useRef((async () => ((s.current || o.current || l.current) && await new Promise((e => {
            a.current.push(e)
        }
        )),
        e.current)))
    }
    )(Qe, $e, p, Ze);
    ( (e, t) => {
        const {originalStaticMarketInfo: n} = Qce()
          , {settings: r} = rf()
          , a = n ? bg(n.chain, n.baseToken.address) : null
          , {selectedWalletsAddresses: s} = Gde()
          , {portfolioData: o} = Xde()
          , l = y.useMemo(( () => {
            if (!s.length || !a)
                return null;
            if (!o)
                return null;
            const e = gSe(s, o, a);
            if (!e)
                return null;
            const {avgFillPriceInUsdUi: t} = e;
            return t
        }
        ), [s, a, o])
          , i = y.useMemo(( () => (null == r ? void 0 : r.fillLineColor) ?? HNe), [null == r ? void 0 : r.fillLineColor]);
        AOe("Avg. Fill Price", i, l, e, t)
    }
    )(!W && Pe && Q, te),
    ( (e, t) => {
        const {originalStaticMarketInfo: n} = Qce()
          , {selectedWalletsAddresses: r} = Gde()
          , {portfolioData: a} = Xde()
          , {settings: s} = rf()
          , o = n ? bg(n.chain, n.baseToken.address) : null
          , l = y.useMemo(( () => {
            if (!r.length || !o)
                return null;
            if (!a)
                return null;
            const e = gSe(r, a, o);
            return e ? e.avgSellFillPriceInUsdUi : null
        }
        ), [r, o, a])
          , i = y.useMemo(( () => (null == s ? void 0 : s.exitLineColor) ?? zNe), [null == s ? void 0 : s.exitLineColor]);
        AOe("Avg. Exit Price", i, l, e, t)
    }
    )(!W && Oe && Q, te),
    ( (e, t, n) => {
        const {originalStaticMarketInfo: r} = Qce()
          , {settings: a} = rf()
          , [s,o] = y.useMemo(( () => [(null == a ? void 0 : a.top10HoldersEntryLineColor) ?? $Ne, (null == a ? void 0 : a.top10HoldersExitLineColor) ?? GNe]), [null == a ? void 0 : a.top10HoldersEntryLineColor, null == a ? void 0 : a.top10HoldersExitLineColor])
          , l = Tve((null == r ? void 0 : r.baseToken.address) ?? null)
          , i = Ade()
          , d = y.useMemo(( () => l ? l.queue.getTopN(10) : null), [l])
          , [u,p] = y.useMemo(( () => {
            if (!d || m.isNil(i))
                return [null, null];
            const [e,t,n,r] = c.reduce(d, ( (e, t) => {
                const n = t.totalBoughtUsd && t.amountBought ? t.totalBoughtUsd / t.amountBought : null;
                n && (e[0] += n * 10 ** i,
                e[1]++);
                const r = t.totalSoldUsd && t.amountSold ? t.totalSoldUsd / t.amountSold : null;
                return r && (e[2] += r * 10 ** i,
                e[3]++),
                e
            }
            ), [0, 0, 0, 0]);
            return [e && t ? e / t : null, n && r ? n / r : null]
        }
        ), [d, i]);
        AOe("Avg. Top 10 Holders Entry", s, u, e, n),
        AOe("Avg. Top 10 Holders Exit", o, p, t, n)
    }
    )(!W && Le && Q, !W && Re && Q, te),
    ( (e, t, n, r) => {
        const {priceAlerts: a, removePriceAlert: s} = Iue()
          , {settings: o} = rf()
          , l = vde()
          , i = Ade()
          , d = y.useCallback(( (e, t) => {
            if ("usd-price" === e)
                return t;
            if (!l || !i)
                return null;
            const n = Number(l);
            return isFinite(n) && 0 !== n ? t * 10 ** i / n : null
        }
        ), [l, i])
          , [u,p] = y.useMemo(( () => {
            if (!a || !r)
                return [[], []];
            const e = Object.values(a.alertsLookup).filter((e => "marketId" === e.definedOn.type && e.definedOn.marketId === r)).filter((e => !e.isPaused))
              , [t,n] = c.partition(e, (e => e.direction === nc.GREATER));
            return [t, n]
        }
        ), [r, a])
          , h = y.useMemo(( () => u.map((e => ({
            id: e.alertId,
            label: EOe(e.targetValue, e.type),
            value: d(e.type, e.targetValue)
        }))).filter((e => null !== e.value))), [u, d])
          , m = y.useMemo(( () => p.map((e => ({
            id: e.alertId,
            label: EOe(e.targetValue, e.type),
            value: d(e.type, e.targetValue)
        }))).filter((e => null !== e.value))), [p, d])
          , g = y.useCallback((async e => {
            try {
                return await s(e)
            } catch (fNe) {
                return !1
            }
        }
        ), [s])
          , [x,b] = y.useMemo(( () => [(null == o ? void 0 : o.abovePriceAlertLineColor) ?? qNe, (null == o ? void 0 : o.belowPriceAlertLineColor) ?? KNe]), [null == o ? void 0 : o.abovePriceAlertLineColor, null == o ? void 0 : o.belowPriceAlertLineColor]);
        IOe({
            items: h,
            showOnChart: e,
            chartApiRef: n,
            color: x,
            onRemove: g
        }),
        IOe({
            items: m,
            showOnChart: t,
            chartApiRef: n,
            color: b,
            onRemove: g
        })
    }
    )(!W && De && Q && !!e, !W && Be && Q && !!e, te, e),
    uOe(!W && _e && Q && !!e && !!r && !!se.width, te, se.width ?? 0, r, e),
    ( (e, t, n) => {
        const r = Ide()
          , a = y.useRef(null);
        y.useEffect(( () => {
            if (!(e && t.current && n && r))
                return;
            const s = t.current
              , o = () => {
                const e = s.getVisibleRange();
                if (!e)
                    return;
                const {from: t, to: n} = e;
                if (r >= t && r <= n) {
                    if (!a.current) {
                        const e = s.createShape({
                            time: r,
                            price: 0
                        }, {
                            shape: "vertical_line",
                            disableSave: !0,
                            disableSelection: !0,
                            disableUndo: !0,
                            lock: !0,
                            text: "Migration - - - - ",
                            overrides: {
                                showLabel: !0,
                                showPrice: !1,
                                showHelp: !1,
                                linewidth: 1,
                                fontsize: 12,
                                linecolor: TOe,
                                textcolor: TOe,
                                vertLabelsAlign: "bottom",
                                linestyle: 2
                            }
                        });
                        a.current = e
                    }
                } else if (a.current) {
                    try {
                        s.removeEntity(a.current)
                    } catch (fNe) {}
                    a.current = null
                }
            }
            ;
            return o(),
            s.onVisibleRangeChanged().subscribe(null, o),
            () => {
                try {
                    s.onVisibleRangeChanged().unsubscribe(null, o)
                } catch (fNe) {}
                if (a.current) {
                    try {
                        s.removeEntity(a.current)
                    } catch (fNe) {}
                    a.current = null
                }
            }
        }
        ), [e, r, t, n])
    }
    )(Ue && Q, te, e);
    const et = Fwe();
    ( (e, t, n) => {
        const r = y.useRef(null)
          , a = D();
        y.useEffect(( () => {
            if (!e || !t.current || !n)
                return;
            const s = t.current
              , o = () => {
                const t = s.getVisibleRange();
                if (!t || !(null == e ? void 0 : e.startTs) || !e.endTs)
                    return;
                const {from: n, to: o} = t;
                if (e.startTs >= n && e.endTs <= o) {
                    if (!r.current && e.startTs) {
                        const t = s.createShape({
                            time: e.startTs,
                            price: 0
                        }, {
                            shape: "vertical_line",
                            disableSave: !0,
                            disableSelection: !0,
                            disableUndo: !0,
                            lock: !0,
                            overrides: {
                                showLabel: !0,
                                showPrice: !1,
                                showHelp: !1,
                                linewidth: 1,
                                fontsize: 12,
                                linecolor: a.palette.success[500],
                                textcolor: a.palette.success[500],
                                vertLabelsAlign: "bottom",
                                linestyle: 0
                            }
                        });
                        r.current = t
                    }
                } else if (r.current) {
                    try {
                        s.removeEntity(r.current)
                    } catch (fNe) {}
                    r.current = null
                }
            }
            ;
            return o(),
            s.onVisibleRangeChanged().subscribe(null, o),
            () => {
                try {
                    s.onVisibleRangeChanged().unsubscribe(null, o)
                } catch (fNe) {}
                if (r.current) {
                    try {
                        s.removeEntity(r.current)
                    } catch (fNe) {}
                    r.current = null
                }
            }
        }
        ), [e, t, n, a])
    }
    )(Q ? et : null, te, e),
    wOe(We && Q, te);
    const tt = y.useCallback(( () => {
        window.tvWidget && J && Q && window.tvWidget.onChartReady(( () => {
            var e, t;
            try {
                null == (e = window.tvWidget) || e.activeChart().clearMarks(),
                null == (t = window.tvWidget) || t.activeChart().refreshMarks()
            } catch (W$e) {}
        }
        ))
    }
    ), [J, Q])
      , nt = y.useCallback(( () => {
        window.tvWidget && J && Q && window.tvWidget.onChartReady(( () => {
            var e;
            try {
                null == (e = window.tvWidget) || e.activeChart().refreshMarks()
            } catch (W$e) {}
        }
        ))
    }
    ), [J, Q])
      , {alphaGroups: rt, alphaGroupRefresherRef: at} = JG()
      , st = y.useRef(j)
      , ot = y.useRef(!V && Ne)
      , lt = y.useRef(rt);
    y.useEffect(( () => {
        lt.current = rt
    }
    ), [rt]),
    y.useEffect(( () => {
        ot.current = !V && Ne,
        J && Q && nt()
    }
    ), [V, Ne, J, Q, nt]),
    y.useEffect(( () => {
        J && Q && o > 0 && nt()
    }
    ), [nt, J, Q, o]);
    const it = ( (e, t) => {
        const n = y.useCallback((t => c.isNil(e) ? {
            unsubscribe: () => {}
        } : _m.subscribeAddressGroupMentions(e, t)), [e]);
        return Cx(n, eOe, t)
    }
    )(r, y.useCallback((e => {
        ot.current && e && nt()
    }
    ), [nt]))
      , ct = y.useCallback(( () => {
        ot.current && nt()
    }
    ), [nt]);
    y.useEffect(( () => (at.current = ct,
    () => {
        at.current = null
    }
    )), [ct, at]),
    y.useEffect(( () => {
        const e = st.current;
        st.current = j,
        J && Q && e !== j && nt()
    }
    ), [j, J, Q, nt]);
    const dt = y.useCallback(( () => {
        const e = st.current;
        return e ? (e => ({
            id: "dex-paid",
            time: e,
            color: {
                border: "#FFFFFF",
                background: "#000000"
            },
            text: `Dex paid at ${i.unix(e).format()}`,
            label: "DP",
            imageUrl: "/dexscreener.png",
            labelFontColor: "#000000",
            borderWidth: 2,
            minSize: 22
        }))(e) : null
    }
    ), [])
      , ut = y.useCallback(( () => {
        if (!ot.current)
            return lLe;
        const e = it();
        return e ? e.mentions.map((e => ( (e, t) => {
            const n = (null == t ? void 0 : t.find((t => t.id === e.groupUiId))) ?? null
              , r = `Mentioned in ${(null == n ? void 0 : n.name) ?? "alpha group"}`;
            return {
                id: MPe(e),
                time: e.timestamp,
                color: {
                    background: $g,
                    border: Gt($g, .5)
                },
                text: r,
                label: "M",
                imageUrl: (null == n ? void 0 : n.imageUrl) ?? "https://content.padre.gg/trading_group_default.png",
                labelFontColor: Gg,
                borderWidth: 0,
                minSize: 22
            }
        }
        )(e, lt.current))) : lLe
    }
    ), [it]);
    y.useEffect(( () => {
        const t = t => {
            if (!e)
                return;
            const n = "init" === t.type ? t.snapshot : t.update;
            ywe(Ewe(n)).filter((e => I(e, {
                showSniperTrades: !V && Ee,
                showDevTrades: !V && Ae,
                focusedTraders: A,
                showTrackedTrades: !V && Te,
                showKolsTrades: !V && Ie,
                selectedWalletsAddresses: G,
                showMyTrades: !V && je,
                showMayhemTrades: !V && Me
            }, ze, He, Ye, qe))).length > 0 && nt()
        }
        ;
        return b.smartFeedCallbacks.add(t),
        tt(),
        () => {
            b.smartFeedCallbacks.delete(t)
        }
    }
    ), [b.smartFeedCallbacks, I, e, nt, V, tt, je, G, He, ze, qe, Ye, Ee, Ae, Me, A, Te, Ie, l, d]);
    const {t: pt} = we();
    y.useEffect(( () => {
        nt()
    }
    ), [nt, Ee, Ae, Te, Ie, je, Me, Ne, ze, Ye, V]),
    y.useEffect(( () => {
        e && Q && K(!0)
    }
    ), [e, Q, K]);
    const ht = y.useCallback(( () => {
        if (!window.tvWidget)
            return;
        window.tvWidget.createDropdown;
        const e = window.tvWidget.createButton()
          , t = pt("Fullscreen mode");
        e.setAttribute("title", t),
        e.addEventListener("click", (function() {
            ye((e => !e))
        }
        )),
        e.classList.add("custom-button"),
        ke.current = e
    }
    ), [pt])
      , [mt,gt] = y.useState(!1)
      , xt = y.useCallback(( () => {
        gt(!1)
    }
    ), [])
      , [bt,ft] = y.useState({
        left: 0,
        top: 0
    })
      , vt = y.useRef(null)
      , St = y.useCallback(( () => {
        if (!vt.current || !ae.current)
            return;
        const e = vt.current.getBoundingClientRect()
          , t = ae.current.getBoundingClientRect();
        ft({
            left: e.left + t.left,
            top: e.bottom + window.scrollY + t.top
        }),
        gt((e => !e))
    }
    ), [])
      , yt = y.useCallback(( () => {
        if (!window.tvWidget)
            return;
        const e = window.tvWidget.createButton()
          , t = pt("Visibility");
        e.setAttribute("title", t),
        e.innerHTML = '<span><svg height="20px" width="20px" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path stroke="currentColor" d="M0.666992 8.00002C0.666992 8.00002 3.33366 2.66669 8.00033 2.66669C12.667 2.66669 15.3337 8.00002 15.3337 8.00002C15.3337 8.00002 12.667 13.3334 8.00033 13.3334C3.33366 13.3334 0.666992 8.00002 0.666992 8.00002Z" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>\n<path stroke="currentColor" d="M8.00033 10C9.1049 10 10.0003 9.10459 10.0003 8.00002C10.0003 6.89545 9.1049 6.00002 8.00033 6.00002C6.89576 6.00002 6.00033 6.89545 6.00033 8.00002C6.00033 9.10459 6.89576 10 8.00033 10Z" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>\n</svg></span>',
        e.addEventListener("click", St),
        e.classList.add("custom-button"),
        vt.current = e
    }
    ), [pt, St]);
    y.useEffect(( () => {
        const e = () => {
            xt()
        }
        ;
        return window.addEventListener("resize", e),
        window.addEventListener("scroll", e, {
            passive: !0
        }),
        () => {
            window.removeEventListener("resize", e),
            window.removeEventListener("scroll", e)
        }
    }
    ), [xt]);
    const kt = y.useCallback(( () => {
        if (!window.tvWidget)
            return;
        const e = window.tvWidget.createButton()
          , t = pt("Display settings");
        e.setAttribute("title", t),
        e.innerHTML = '<span><svg height="20px" width="20px" fill="none" viewBox="4 4 16 16">\n<path fill="currentColor" d="M8.5 18a.5.5 0 0 0 .5-.5v-1.55a2.5 2.5 0 0 0 0-4.9V6.5a.5.5 0 0 0-1 0v4.55a2.501 2.501 0 0 0 0 4.9v1.55a.5.5 0 0 0 .5.5m7 0a.5.5 0 0 0 .5-.5v-4.55a2.501 2.501 0 0 0 0-4.9V6.5a.5.5 0 0 0-1 0v1.55a2.5 2.5 0 0 0 0 4.9v4.55a.5.5 0 0 0 .5.5m0-6a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m-7 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"></path>\n</svg></span>',
        e.addEventListener("click", (function() {
            ye(!1),
            X(H6.SETTINGS, z6.CHART)
        }
        )),
        e.classList.add("custom-button")
    }
    ), [pt, X, ye])
      , Ct = y.useCallback(( () => {
        if (!window.tvWidget)
            return;
        const e = window.tvWidget.createButton();
        e.addEventListener("click", (function() {
            me((e => {
                const t = e === fPe.PRICE ? fPe.MARKET_CAP : fPe.PRICE;
                return ge.current = t,
                vPe(),
                t
            }
            ))
        }
        )),
        xe.current = e
    }
    ), [me]);
    y.useEffect(( () => {
        let e = !1;
        if ((de !== rg.CUSTOM && de !== rg.CUSTOM_2 || ce) && te.current)
            return Q || te.current.dataReady(( () => {
                e || (Z(!0),
                ee(!0),
                x({
                    chartApi: te.current,
                    isChartReady: !0
                }))
            }
            )),
            () => {
                e = !0
            }
    }
    ), [de, ce, Q, x]),
    y.useEffect(( () => {
        Z(!1),
        ee(!1),
        x({
            isChartReady: !1,
            chartApi: null
        })
    }
    ), [e, x]),
    y.useEffect(( () => {
        const e = () => {
            var e;
            const n = null == (e = window.document.getElementById(sLe)) ? void 0 : e.querySelector("iframe");
            if (n)
                try {
                    const e = n.contentDocument || n.contentWindow && n.contentWindow.document;
                    if (e) {
                        if (e.getElementById(bPe))
                            return void clearInterval(t);
                        if (e.getElementById(bPe))
                            return;
                        const n = e.createElement("script");
                        n.textContent = '!function(){\n    let n = window.onkeydown,\n        t = window.onkeyup;\n\n    const allowedKeys = new Set(["q", "w", "e", "r", "a", "s", "d", "f", "/", " "]);\n    function o(e){\n      if (!allowedKeys.has(e.key.toLowerCase())) return;\n      window.parent.postMessage({\n        type: "keyEvent",\n        eventType: e.type,\n        key: e.key,\n        code: e.code,\n        keyCode: e.keyCode,\n        which: e.which,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        altKey: e.altKey,\n        metaKey: e.metaKey,\n        repeat: e.repeat\n      }, "*");\n    }\n\n    document.addEventListener("keydown", o, !0);\n    document.addEventListener("keyup", o, !0);\n\n    new MutationObserver(function(e){\n      e.forEach(function(e){\n        e.addedNodes.forEach(function(e){\n          if ("IFRAME" === e.tagName) try {\n            let n = e;\n            n.addEventListener("load", function(){\n              try {\n                var e = n.contentDocument || n.contentWindow.document;\n                e.addEventListener("keydown", o, !0);\n                e.addEventListener("keyup", o, !0);\n              } catch {}\n            })\n          } catch {}\n        })\n      })\n    }).observe(document.body, {childList:!0, subtree:!0});\n\n    console.log("[TradingView Iframe] Keyboard capture active (filtered)");\n  }();',
                        n.id = bPe,
                        e.head.appendChild(n),
                        clearInterval(t)
                    }
                } catch (W$e) {
                    clearInterval(t)
                }
        }
        ;
        e();
        const t = setInterval(e, 2e3);
        return () => {
            clearInterval(t)
        }
    }
    ), []);
    const At = y.useRef(null)
      , wt = y.useRef(null)
      , jt = y.useRef(null);
    y.useEffect(( () => {
        var r;
        if (!b.originalMarketId || e !== b.originalMarketId)
            return;
        if ((de === rg.CUSTOM || de === rg.CUSTOM_2) && !ce)
            return;
        const o = CPe(pe.palette, de)
          , [i,p] = ( (e, t) => t === rg.VIOLET || t === rg.INDIGO ? ["#0C9A81", "#F23546"] : [e.positive.main, e.negative.main])(pe.palette, de)
          , m = {
            "scalesProperties.crosshairLabelBgColorLight": o,
            "scalesProperties.crosshairLabelBgColorDark": o,
            "scalesProperties.showPrePostMarketPriceLabel": !1,
            "scalesProperties.textColor": pe.palette.text.value,
            "scalesProperties.fontSize": ag,
            "paneProperties.background": o,
            "paneProperties.separatorColor": pe.palette.background.borderMain,
            "paneProperties.backgroundType": "solid",
            "mainSeriesProperties.statusViewStyle.showInterval": !1,
            "mainSeriesProperties.statusViewStyle.showExchange": !1,
            ...kPe(i, p)
        }
          , g = {
            ...yPe(i, p)
        };
        let f = !1;
        if (!e || !a || !Y || void 0 === t)
            return;
        const v = Zg(null, de)
          , S = Og(v)
          , y = {
            listeners: 1,
            feed: new Rg(e,S,b)
        };
        $.current = new Map,
        $.current.set(S, y);
        const k = n.resolvedLanguage ?? "en"
          , C = ( (e, t, n) => ({
            priceFormatterFactory: () => ({
                format: r => {
                    const a = e.current === fPe.PRICE ? r : r * Number(t.current ?? 1) / 10 ** (n.current ?? 0);
                    if (0 === a || e.current === fPe.MARKET_CAP && Math.abs(a) < 1e-8)
                        return "0";
                    if (Math.abs(a) < .01)
                        return UI(EI(r, {
                            precision: Math.abs(a) < 1e-18 ? 2 : 3
                        }));
                    const s = OI(Math.abs(a) > 1e3 ? Number(a.toPrecision(3)) : a, {
                        symbol: "",
                        collapseExponent: !0,
                        removeTrailingZerosPrecision: 1,
                        precision: a > 1 ? 2 : 4
                    })
                      , [o,l] = (e => {
                        const t = e.match(/^(.*?)([a-zA-Z])?$/);
                        return t ? [t[2] ? e.slice(0, -1) : e, t[2] ?? ""] : [e, ""]
                    }
                    )(s);
                    return `${UI(o)}${l}`
                }
            }),
            studyFormatterFactory: () => ({
                format: e => void 0 !== e ? OI(e, {
                    symbol: "",
                    collapseExponent: !0
                }) : ""
            })
        }))(ge, l, d);
        if (null !== At.current && At.current[e]) {
            if (At.current[e]) {
                const n = At.current[e]
                  , r = {
                    deployerAddress: t,
                    getMarksProvider: E,
                    registerNewMarkIfNeeded: I,
                    tradesProxy: b,
                    originalMarketId: e,
                    setChartData: x,
                    createPriceMarketCapSwitch: Ct,
                    createFullscreenButton: ht,
                    createVisibilityMenuButton: yt,
                    createSettingsButton: kt,
                    marketDescription: a,
                    baseTokenTotalSupplyRef: l,
                    baseTokenTotalDecimalsRef: d,
                    marketPriceRef: u,
                    user: Y,
                    getMarksSettingsAsyncRef: Je,
                    getGroupMentionMarks: ut,
                    getDexPaidMark: dt
                };
                ( (e, t, n, r) => {
                    if (!n || !r)
                        return;
                    const a = c.reduce(Object.entries(n), ( (e, [t,n]) => {
                        const a = r[t];
                        return void 0 === a ? (e.push(`${t} current value doesn't exist`),
                        e) : a !== n ? (e.push(`${t} changed`),
                        e) : e
                    }
                    ), []);
                    if (!a.length)
                        return;
                    const s = `Chart refreshed despite being loaded on ${e} for user ${t}, because: ${a.join(", ")}`;
                    np.info(s)
                }
                )(e, Y.uid, n, r)
            }
        } else
            At.current = {
                [e]: {
                    deployerAddress: t,
                    getMarksProvider: E,
                    registerNewMarkIfNeeded: I,
                    tradesProxy: b,
                    originalMarketId: e,
                    setChartData: x,
                    createPriceMarketCapSwitch: Ct,
                    createFullscreenButton: ht,
                    createVisibilityMenuButton: yt,
                    createSettingsButton: kt,
                    marketDescription: a,
                    baseTokenTotalSupplyRef: l,
                    baseTokenTotalDecimalsRef: d,
                    marketPriceRef: u,
                    user: Y,
                    getMarksSettingsAsyncRef: Je,
                    getGroupMentionMarks: ut,
                    getDexPaidMark: dt
                }
            };
        return window.tvWidget = new _Ne({
            user_id: `${(null == Y ? void 0 : Y.uid) ?? "anon"}-${de}`,
            container: sLe,
            locale: k,
            datafeed: new YPe(e,a,`${Du.PADRE_BACKEND}/candles`,( () => {
                var e;
                return Z(!1),
                ee(!1),
                x({
                    isChartReady: !1
                }),
                null == (e = window.tvWidget) ? void 0 : e.activeChart().resetData()
            }
            ),t,s,Je,Ge,Xe,$.current,b,E,ut,dt),
            symbol: e,
            interval: v,
            theme: "dark",
            library_path: "/charting_library_v2/",
            custom_css_url: ce ?? iLe(de, ue),
            disabled_features: ["use_localstorage_for_settings", "header_symbol_search", "symbol_search_hot_key", "header_compare", "popup_hints", "save_shortcut", "header_fullscreen_button", "display_market_status", "symbol_search_hot_key", "symbol_info", ...h ? [] : ["timeframes_toolbar"]],
            enabled_features: ["study_templates", "chart_template_storage", "seconds_resolution", "two_character_bar_marks_labels", "items_favoriting"],
            time_scale: {},
            fullscreen: !1,
            autosize: !0,
            timezone: oLe,
            studies_overrides: g,
            overrides: m,
            settings_adapter: new RPe,
            loading_screen: {
                backgroundColor: o
            },
            custom_formatters: C,
            time_frames: [{
                text: "1h",
                resolution: "15s",
                description: "1 Hour"
            }, {
                text: "3d",
                resolution: "15",
                description: "3 Days"
            }, {
                text: "1m",
                resolution: "240",
                description: "1 Month"
            }],
            save_load_adapter: new tx(de),
            auto_save_delay: .1,
            load_last_chart: !0,
            context_menu: {
                items_processor: async (e, t) => {
                    const n = Ce.current
                      , r = null !== n ? C.priceFormatterFactory().format(n) : ""
                      , a = (null == u ? void 0 : u.current) ?? null
                      , s = t.createAction({
                        actionId: "padre-create-alert-above",
                        label: `${pt("Create alert above")} ${r}`,
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4l-7 7h4v7h6v-7h4z"/></svg>',
                        disabled: null === n || n <= 0 || null === a || a > n,
                        onExecute: () => {
                            null !== n && ve.current(n, nc.GREATER)
                        }
                    })
                      , o = t.createAction({
                        actionId: "padre-create-alert-below",
                        label: `${pt("Create alert below")} ${r}`,
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 20l7-7h-4V6H9v7H5z"/></svg>',
                        disabled: null === n || n <= 0 || null === a || a < n,
                        onExecute: () => {
                            null !== n && ve.current(n, nc.LOWER)
                        }
                    })
                      , l = te.current ? te.current.resolution() : null
                      , i = l ? Lg(l) : null
                      , c = wt.current && null !== i ? dg(wt.current, i) : null
                      , d = wt.current && null !== i ? ( (e, t) => dg(e, t) + cg[t])(wt.current, i) : null
                      , p = null === c || null === d || null === i ? null : t.createAction({
                        actionId: "terminal-candle-time-filter",
                        label: `${pt("Show trades from")} ${SPe(c, i)} - ${SPe(d, i)}`,
                        icon: '<svg width="24" height="24" viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 8V12L14.5 14.5M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                        onExecute: () => {
                            null !== c && null !== d && T({
                                startTs: c,
                                endTs: d
                            })
                        }
                    });
                    return [s, o, ...p ? [p] : [], t.createSeparator(), ...e]
                }
            }
        }),
        null == (r = window.tvWidget) || r.onChartReady(( () => {
            var e;
            if (!f && window.tvWidget) {
                if (te.current = window.tvWidget.chart(),
                Z(!0),
                x({
                    isChartReady: !0,
                    chartApi: te.current
                }),
                z.current) {
                    const e = window.tvWidget.chart().getPanes();
                    if (e.length) {
                        const t = e[0].getMainSourcePriceScale();
                        null == t || t.setAutoScale(!0)
                    }
                }
                window.tvWidget.subscribe("onAutoSaveNeeded", ( () => {
                    var e;
                    f || null == (e = window.tvWidget) || e.saveChartToServer(void 0, void 0, {
                        defaultChartName: "Default"
                    })
                }
                ));
                try {
                    window.tvWidget.onContextMenu(( (e, t) => (Ce.current = t,
                    [])))
                } catch (fNe) {}
                null == (e = te.current) || e.crossHairMoved().subscribe(null, (e => {
                    wt.current = e.time
                }
                )),
                window.tvWidget.subscribe("mouse_down", (e => {
                    jt.current = e.clientX
                }
                )),
                window.tvWidget.subscribe("onMarkClick", (e => {
                    const t = String(e).split("-").at(-1);
                    if (t && (Oc(t) || q(t, {
                        strict: !1
                    })))
                        try {
                            M.current(t)
                        } catch (W$e) {}
                    else if ("string" == typeof e && NPe(e)) {
                        const t = (e => {
                            if (!NPe(e))
                                return null;
                            const t = e.split(".");
                            return "dmroaeg4rz" === of(t[2] ?? "") ? `https://trackoors.fun/chats?oId=${t[3]}&cId=${t[4]}&id=${t[5]}` : null
                        }
                        )(e);
                        if (!t)
                            return;
                        try {
                            window.open(t, "_blank")
                        } catch (W$e) {}
                    }
                }
                )),
                window.tvWidget.headerReady().then((async () => {
                    f || (Ct(),
                    f || (yt(),
                    kt(),
                    ht(),
                    ee(!0)))
                }
                )).catch((e => {}
                ))
            }
        }
        )),
        () => {
            var e, t;
            y.listeners -= 1,
            y.listeners <= 0 && (y.feed.close(),
            null == (e = $.current) || e.delete(S)),
            f = !0,
            te.current = null,
            Z(!1),
            ee(!1),
            x({
                chartApi: null,
                isChartReady: !1
            }),
            null == (t = window.tvWidget) || t.remove()
        }
    }
    ), [t, E, T, I, b, e, de, pe.palette, x, Ct, ht, yt, kt, a, l, d, u, Y, h, ce, Je, ue, ut, dt, s, pt]),
    y.useEffect(( () => {
        if (!ne.current)
            return;
        const e = new ResizeObserver((e => {
            const t = e[0]
              , {width: n, height: r} = t.contentRect;
            oe((e => {
                const t = Math.round(n)
                  , a = Math.round(r);
                return e.width === t && e.height === a ? e : {
                    width: t,
                    height: a
                }
            }
            ));
            const a = t.target.querySelector("iframe");
            a && (a.style.width = `${n}px`,
            a.style.height = `${r}px`,
            a.style.transform = "none")
        }
        ));
        return e.observe(ne.current),
        () => {
            e.disconnect()
        }
    }
    )),
    y.useEffect(( () => {
        ye(g)
    }
    ), [g]);
    const Tt = `color: ${pe.palette.primary.main}`
      , It = `color: ${pe.palette.text.label}`;
    y.useEffect(( () => {
        window.tvWidget && window.tvWidget.headerReady().then(( () => {
            null !== ke.current && (ke.current.innerHTML = `<span>${Se ? '<svg xmlns="http://www.w3.org/2000/svg" height="25px" width="25px" viewBox="0 -960 960 960" fill="currentColor"><path d="M240-140v-100H140v-60h160v160h-60Zm420 0v-160h160v60H720v100h-60ZM140-620v-60h100v-100h60v160H140Zm520 0v-160h60v100h100v60H660Z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" height="25px" width="25px" viewBox="0 -960 960 960" fill="currentColor"><path d="M140-140v-160h60v100h100v60H140Zm520 0v-60h100v-100h60v160H640ZM140-620v-160h160v60H200v100h-60Zm620 0v-100H660v-60h160v160h-60Z"/></svg>'}</span>`)
        }
        )).catch((e => {}
        ))
    }
    ), [Se, J]),
    y.useEffect(( () => {
        window.tvWidget && window.tvWidget.headerReady().then(( () => {
            if (null === xe.current)
                return;
            const e = he === fPe.PRICE
              , t = pt(e ? "Switch to market cap chart" : "Switch to price chart");
            xe.current.setAttribute("title", t);
            const n = `<span style="${e ? Tt : It}">${pt("Price")}</span>`
              , r = `<span style="${e ? It : Tt}">${pt("MCap")}</span>`;
            xe.current.innerHTML = `${n} / ${r}`
        }
        )).catch((e => {}
        ))
    }
    ), [pt, Tt, It, J, he]),
    y.useEffect(( () => {
        const e = null == document ? void 0 : document.querySelector('meta[name="theme-color"]')
          , t = CPe(pe.palette, de);
        null == e || e.setAttribute("content", t)
    }
    ), [de, Se, pe.palette]),
    y.useEffect(( () => {
        var e;
        window.tvWidget && J && (null == (e = window.tvWidget) || e.headerReady().then(( () => {
            var e;
            return null == (e = window.tvWidget) ? void 0 : e.onShortcut(27, ( () => {
                ye((e => e ? !e : e))
            }
            ))
        }
        )))
    }
    ), [J]),
    Qe.current = {
        showMyTrades: !V && je,
        showSniperTrades: !V && Ee,
        showDevTrades: !V && Ae,
        showTrackedTrades: !V && Te,
        showKolsTrades: !V && Ie,
        showMayhemTrades: !V && Me,
        focusedTraders: A,
        selectedWalletsAddresses: G
    };
    const {searchBarBlurRef: Et} = fz();
    y.useEffect(( () => {
        var e, t;
        if (!te.current || !Q || R)
            return;
        const n = () => {
            null == Et || Et.current()
        }
          , r = null == (e = re.current) ? void 0 : e.querySelector("iframe");
        return r && (null == (t = r.contentWindow) || t.addEventListener("click", n)),
        () => {
            var e;
            r && (null == (e = r.contentWindow) || e.removeEventListener("click", n))
        }
    }
    ), [te, Q, Et]);
    const Mt = y.useMemo(( () => e => ({
        backgroundColor: CPe(e.palette, de),
        inset: Se ? 0 : void 0,
        zIndex: Se ? 9999 : 0,
        position: Se ? "fixed" : "relative",
        width: "100%",
        height: "100%"
    })), [de, Se])
      , Nt = y.useMemo(( () => e => ({
        zIndex: 1,
        backgroundColor: CPe(e.palette, de),
        visibility: Q && !p ? "hidden" : "visible"
    })), [de, Q, p])
      , Pt = y.useMemo(( () => ({
        opacity: Q && !p ? 1 : 0,
        transition: "none"
    })), [Q, p]);
    return v.jsxs(C, {
        sx: Mt,
        ref: ae,
        children: [v.jsx(C, {
            width: "100%",
            height: "100%",
            position: "absolute",
            sx: Nt,
            children: v.jsx(Ym, {})
        }), v.jsx(C, {
            width: "100%",
            height: "100%",
            position: "absolute",
            ref: re,
            children: v.jsx(C, {
                ref: ne,
                id: sLe,
                width: "100%",
                height: "100%",
                "data-testid": "trading-view-container",
                sx: Pt
            }, e)
        }), v.jsx(sPe, {
            open: mt,
            anchorPosition: bt,
            onClose: xt,
            hideLines: W,
            setHideLines: F,
            hideMarkers: V,
            setHideMarkers: H
        })]
    })
}
))
  , dLe = y.memo(( () => {
    const {originalStaticMarketInfo: e} = Qce()
      , t = vde()
      , n = Ede(e)
      , r = Sve((e => e.snipers))
      , a = y.useRef(r);
    a.current = r ? new Set(Array.from(r)) : null,
    a.current && n && a.current.delete(n);
    const s = mde()
      , o = y.useRef(null)
      , l = (null == e ? void 0 : e.baseToken.decimals) ?? null
      , i = y.useRef(null)
      , c = y.useMemo(( () => !t || m.isNil(l) ? (o.current = null,
    i.current = null,
    !0) : (o.current = BigInt(t),
    i.current = l,
    vPe(!0),
    !1)), [l, t])
      , d = e ? vg(e) : null
      , u = (e => Zce((t => {
        var n, r;
        return (null == (n = null == e ? void 0 : e.baseToken) ? void 0 : n.address) ?? (null == (r = t.marketStats) ? void 0 : r.baseTokenAddress) ?? null
    }
    )))(e)
      , p = y.useMemo(( () => e ? (null == e ? void 0 : e.baseToken.symbol) || (null == e ? void 0 : e.baseToken.name) || "." : null), [e]);
    return v.jsx(cLe, {
        originalMarketId: d,
        deployerAddress: n,
        baseTokenAddress: u,
        marketDescription: p,
        snipersRef: a,
        snipersSize: r.size,
        baseTokenTotalSupplyRef: o,
        baseTokenTotalDecimalsRef: i,
        marketPriceRef: s,
        isTotalSupplyLoading: c
    }, d)
}
))
  , uLe = y.memo(( ({onClick: e, isSelected: t, label: n}) => {
    const r = y.useMemo(( () => e => ({
        minWidth: pLe,
        height: pLe,
        color: t ? e.palette.primary.main : e.palette.text.value,
        background: t ? e.palette.primary.background : "transparent",
        border: "1px solid transparent",
        px: .5,
        gap: .5,
        "&:hover, &:focus": {
            background: e.palette.primary.background,
            borderColor: "transparent",
            color: e.palette.primary.main
        }
    })), [t]);
    return v.jsx(V, {
        onClick: e,
        variant: "tertiary",
        size: "xxsmall",
        sx: r,
        children: "string" == typeof n ? v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            noWrap: !0,
            maxWidth: 50,
            fontWeight: 600,
            children: n
        }) : n
    })
}
))
  , pLe = 24
  , hLe = y.memo(( ({isPanel: e=!1}) => {
    const {t: t} = we()
      , n = Fwe()
      , r = Vwe()
      , a = y.useCallback(( () => {
        r(null)
    }
    ), [r])
      , s = y.useMemo(( () => e ? v.jsx(_y, {
        color: "inherit"
    }) : v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .25,
        children: [v.jsx(_y, {
            color: "inherit"
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            noWrap: !0,
            fontWeight: 600,
            children: "Candle"
        })]
    })), [e]);
    return n ? v.jsx(GC, {
        title: t("Trades filtered by selected candle time range"),
        children: v.jsx(uLe, {
            isSelected: !0,
            label: s,
            onClick: a
        })
    }) : null
}
))
  , mLe = y.memo(( ({devAddress: e, tradesLocation: t, tableMode: n}) => {
    const r = bw()
      , {t: a} = we()
      , {walletGroups: s} = rf()
      , {compatibleWalletsAddresses: o} = Gde()
      , l = y.useMemo(( () => o.map((e => ng(e.publicAddress)))), [o])
      , {focusedTraders: i, focusTraders: d, areTrackedGroupsFocused: u, focusTrackedGroups: p} = jwe()
      , h = y.useCallback(( () => {
        d(null)
    }
    ), [d])
      , m = y.useCallback(( () => {
        h(),
        p(!u)
    }
    ), [h, p, u])
      , g = y.useCallback(( () => {
        p(!1),
        e && (1 === (null == i ? void 0 : i.length) && i[0] === ng(e) ? h() : d([ng(e)]))
    }
    ), [e, i, d, h, p])
      , x = y.useCallback(( () => {
        p(!1),
        h()
    }
    ), [p, h])
      , b = y.useMemo(( () => !(!(null == i ? void 0 : i.length) || !l.length) && c.isEqual([...i].sort(), [...l].sort())), [i, l])
      , f = y.useCallback(( () => {
        l.length && (i && c.isEqual([...i].sort(), [...l].sort()) ? h() : d(l))
    }
    ), [i, d, h, l])
      , C = NA(l, !0);
    y.useEffect(( () => {
        i && !c.isEqual(l, C) && c.isEqual([...i].sort(), [...C].sort()) && d(l)
    }
    ), [d, i, C, l]);
    const A = y.useMemo(( () => r ? {} : {
        overflowX: "scroll",
        minHeight: 26,
        pl: 2,
        pr: 1.25
    }), [r]);
    return (t !== XAe.PANEL && n === oAe.TRADES || [oAe.HOLDERS, oAe.TOP_TRADERS].includes(n)) && v.jsxs(S, {
        className: "padre-no-scroll",
        direction: "row",
        alignItems: "center",
        gap: 1,
        sx: A,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            noWrap: !0,
            minWidth: r ? void 0 : 35,
            children: `${a("Filter")}:`
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            children: [v.jsx(hLe, {}), v.jsx(uLe, {
                isSelected: null === i && !u && !b,
                label: a("All"),
                onClick: x
            }), l && v.jsx(uLe, {
                isSelected: b,
                label: a("Mine"),
                onClick: f
            }), !!e && v.jsx(uLe, {
                isSelected: !!e && 1 === (null == i ? void 0 : i.length) && i[0] === ng(e),
                label: a("Dev"),
                onClick: g
            }), !!(null == s ? void 0 : s.length) && v.jsx(uLe, {
                isSelected: u,
                label: a("Tracked"),
                onClick: m
            })]
        })]
    })
}
))
  , gLe = y.memo(( ({minimumUsdValue: e, setMinimumUsdValue: t, onClose: n, currency: r, setCurrency: a, chain: s}) => {
    const {t: o} = we()
      , [l,i] = y.useState((null == e ? void 0 : e.toString()) ?? "")
      , c = y.useCallback(( () => {
        const e = "" === l || "0" === l || isNaN(Number(l)) ? null : Number(l);
        t(e),
        n()
    }
    ), [l, n, t])
      , d = y.useCallback(( () => {
        t(null),
        n()
    }
    ), [n, t])
      , u = y.useCallback(( ({target: {value: e}}) => {
        const t = QR(e);
        i(t)
    }
    ), [])
      , p = y.useMemo(( () => s ? [{
        value: rwe.USD,
        label: "USD"
    }, {
        value: rwe.QUOTE,
        label: GD(s)
    }] : null), [s])
      , h = y.useCallback(( (e, t) => {
        if (!a || !r)
            return;
        t !== r && a(t)
    }
    ), [r, a]);
    return v.jsx(QQ, {
        onApply: c,
        onClear: d,
        children: v.jsxs(S, {
            gap: 1,
            children: [r && a && p && v.jsx(IH, {
                size: "xxsmall",
                items: p,
                value: r,
                onChange: h
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                children: [v.jsx(k, {
                    variant: "paragraph1",
                    children: o("Minimum value")
                }), v.jsx(je, {
                    value: l,
                    onChange: u,
                    size: "xsmall",
                    placeholder: "0",
                    inputProps: {
                        style: {
                            maxWidth: 50,
                            textAlign: "center"
                        },
                        inputMode: "decimal"
                    },
                    "data-pseudotype": "numberLike",
                    inputMode: "decimal",
                    startAdornment: v.jsx(We, {
                        position: "start",
                        sx: {
                            width: 12
                        },
                        children: v.jsx(S, {
                            alignItems: "center",
                            children: v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.value",
                                noWrap: !0,
                                ...Nu,
                                children: "$"
                            })
                        })
                    })
                })]
            })]
        })
    })
}
))
  , xLe = y.memo(( ({chain: e, onClose: t}) => {
    const {t: n} = we()
      , r = bw()
      , {focusedTraders: a, focusTraders: s, panelFocusedTraders: o, panelFocusTraders: l, tradesLocation: i} = jwe()
      , c = y.useMemo(( () => i === XAe.PANEL && r ? o : a), [a, o, i, r])
      , d = y.useCallback((e => {
        i === XAe.PANEL && r ? l(e) : s(e)
    }
    ), [s, l, i, r])
      , [u,p] = y.useState(c && 1 === c.length ? c[0] : "")
      , h = y.useMemo(( () => (e === Pd.SOLANA ? su : au).test(u)), [e, u])
      , m = y.useCallback(( () => {
        h && (d([u]),
        t())
    }
    ), [d, u, h, t])
      , g = y.useCallback(( () => {
        c && d(null),
        t()
    }
    ), [d, c, t])
      , x = y.useCallback(( ({target: {value: t}}) => {
        if (!e)
            return;
        const n = ( (e, t) => t === Pd.SOLANA ? e.replace(/[^123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]/g, "") : e.startsWith("0") ? "0" === e || "0x" === e ? e : `0x${e.slice(2).replace(/[^0-9a-fA-F]/g, "")}` : "")(t, e);
        p(n)
    }
    ), [e]);
    return v.jsx(QQ, {
        onApply: m,
        onClear: g,
        applyDisabled: !h,
        children: v.jsx(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            children: v.jsx(je, {
                fullWidth: !0,
                disabled: !!c && 1 !== c.length,
                value: c && 1 !== c.length ? n("Multiple") : u,
                onChange: x,
                size: "xsmall",
                placeholder: n("Address"),
                inputProps: {
                    style: {
                        textAlign: "center"
                    }
                }
            })
        })
    })
}
))
  , bLe = ({label: e, hasActiveFilter: t, filtersProps: n, FiltersComponent: r, alignRight: a=!0, showCurrencySwitchIcon: s=!1, grayOut: o=!1}) => {
    const l = D()
      , {buttonProps: i, popoverProps: c} = Fw({
        id: `trades-filters-header-${e}`
    });
    return v.jsxs(v.Fragment, {
        children: [v.jsx(C, {
            component: "span",
            width: "100%",
            sx: {
                cursor: "pointer"
            },
            children: v.jsxs(C, {
                ...i,
                display: "flex",
                alignItems: "center",
                justifyContent: a ? "flex-end" : "flex-start",
                width: "100%",
                sx: {
                    cursor: "pointer",
                    gap: .25,
                    color: l.palette.text.label,
                    ...o ? {
                        "&:hover": {
                            color: l.palette.text.value
                        }
                    } : {},
                    ...$_(200, !1)
                },
                children: [v.jsx(C, {
                    mt: "3px",
                    children: v.jsx(bk, {
                        color: t ? l.palette.primary.main : "inherit",
                        size: fLe
                    })
                }), v.jsx(k, {
                    variant: "paragraph3",
                    color: "inherit",
                    children: e
                }), s && v.jsx(C, {
                    mt: "3px",
                    children: v.jsx(gS, {
                        color: o ? "inherit" : l.palette.success.main,
                        size: fLe
                    })
                })]
            })
        }), v.jsx(ae, {
            ...c,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: vLe,
            transformOrigin: SLe,
            children: v.jsx(ee, {
                elevation: 1,
                sx: yLe,
                className: "padre-no-scroll",
                children: v.jsx(r, {
                    ...n,
                    onClose: c.onClose
                })
            })
        })]
    })
}
  , fLe = 14
  , vLe = {
    vertical: "bottom",
    horizontal: "center"
}
  , SLe = {
    vertical: "top",
    horizontal: "center"
}
  , yLe = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , kLe = ({label: e, onClick: t, nextLabel: n, showIcon: r=!0, alignRight: a=!0}) => v.jsx(GC, {
    title: `Switch to ${n}`,
    children: v.jsx(C, {
        component: "span",
        width: "100%",
        sx: ALe,
        children: v.jsxs(C, {
            onClick: t,
            display: "flex",
            alignItems: "center",
            justifyContent: a ? "flex-end" : "flex-start",
            width: "100%",
            gap: .25,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "inherit",
                children: e
            }), r && v.jsx(C, {
                mt: .25,
                children: v.jsx(gS, {
                    animateColor: !0,
                    color: "inherit",
                    size: CLe
                })
            })]
        })
    })
})
  , CLe = 14
  , ALe = {
    color: "text.label",
    ...$_(200, !1),
    cursor: "pointer"
}
  , wLe = ({onClick: e}) => v.jsx(C, {
    onClick: e,
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    width: "100%",
    sx: TLe,
    children: v.jsx(Ny, {
        animateColor: !0,
        color: "inherit",
        size: jLe
    })
})
  , jLe = 14
  , TLe = e => ({
    cursor: "pointer",
    color: e.palette.text.label,
    "&:hover": {
        color: e.palette.text.value
    }
})
  , ILe = y.memo(( ({label: e, onClick: t, showOldest: n}) => v.jsx(C, {
    component: "span",
    width: "100%",
    sx: MLe,
    children: v.jsxs(C, {
        onClick: t,
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        width: "100%",
        gap: .25,
        color: "text.label",
        sx: NLe,
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "inherit",
            children: e
        }), v.jsx(C, {
            display: "flex",
            children: n ? v.jsx(JS, {
                animateColor: !0,
                color: "inherit",
                size: ELe
            }) : v.jsx(ey, {
                animateColor: !0,
                color: "inherit",
                size: ELe
            })
        })]
    })
})))
  , ELe = 16
  , MLe = {
    cursor: "pointer"
}
  , NLe = $_(200, !1)
  , PLe = y.memo(( ({tableGap: e, tablePadding: t, isShort: n, isPanel: r, gridTemplateColumns: a, isColumnVisible: s, tradesTargetMode: o, toggleTradesTargetMode: l, tradesPanelTotalMode: i, setTradesPanelTotalMode: d, minimumUsdValue: u, setMinimumUsdValue: p, focusedTraders: h, chain: m, openSettings: g, showOldest: x, toggleShowOldest: b}) => {
    const {t: f} = we()
      , S = y.useMemo(( () => Cwe(n, r, s)), [s, r, n])
      , k = y.useMemo(( () => n => ({
        borderBottom: `1px solid ${n.palette.background.borderMain}`,
        px: t,
        height: OLe,
        minHeight: OLe,
        gap: e,
        background: n.palette.background.secondary
    })), [e, t])
      , A = y.useCallback((e => {
        const t = LLe(m, e, r, f);
        return "timestamp" === e ? v.jsx(ILe, {
            label: t,
            onClick: b,
            showOldest: x
        }, e) : "priceInUsd" === e ? v.jsx(kLe, {
            label: o === rwe.MARKET_CAP ? "MCap" : "Price" + (r ? "" : o === rwe.QUOTE ? !c.isNil(m) && GD(m) ? ` ${GD(m)}` : "" : " $"),
            onClick: l,
            nextLabel: o === rwe.MARKET_CAP ? "price in USD " : o === rwe.USD ? "price in native" : "market cap",
            alignRight: !r
        }, e) : "amountInUsd" === e ? v.jsx(bLe, {
            label: t,
            hasActiveFilter: null !== u,
            filtersProps: {
                minimumUsdValue: u,
                setMinimumUsdValue: p,
                ...r ? {
                    currency: i,
                    setCurrency: d
                } : {},
                onClose: c.noop,
                chain: m ?? void 0
            },
            FiltersComponent: gLe,
            alignRight: !r,
            showCurrencySwitchIcon: r,
            grayOut: i !== rwe.USD
        }, e) : "maker" === e ? v.jsx(bLe, {
            label: t,
            hasActiveFilter: null !== h,
            filtersProps: {
                chain: m,
                onClose: c.noop
            },
            FiltersComponent: xLe,
            alignRight: !r,
            showCurrencySwitchIcon: !1,
            grayOut: i !== rwe.USD
        }, e) : "txnHash" === e ? v.jsx(wLe, {
            onClick: g
        }, e) : v.jsx(RLe, {
            label: t,
            justifyContent: "side" === e || "timestamp" === e ? "flex-start" : "flex-end"
        }, e)
    }
    ), [m, h, r, u, g, p, x, b, l, d, i, o, f]);
    return v.jsx(C, {
        position: "sticky",
        top: 0,
        zIndex: 3,
        display: "grid",
        gridTemplateColumns: a,
        alignItems: "center",
        sx: k,
        children: S.map(A)
    })
}
))
  , OLe = 34
  , LLe = (e, t, n, r) => {
    switch (t) {
    case "timestamp":
        return r("Age");
    case "tipInNativeUi":
        return r("Tip & Prio");
    case "side":
        return r("Side");
    case "priceInUsd":
    case "txnHash":
    default:
        return "";
    case "amountBase":
        return r("Amount");
    case "amountInUsd":
        return r(n ? "Total" : "Total USD");
    case "amountInNative":
        return r("Total {{label}}", {
            label: c.isNil(e) ? "" : GD(e)
        });
    case "maker":
        return r("Maker")
    }
}
  , RLe = y.memo(( ({label: e, justifyContent: t="flex-end"}) => v.jsx(k, {
    variant: "paragraph3",
    color: "text.label",
    display: "flex",
    alignItems: "center",
    justifyContent: t,
    noWrap: !0,
    children: e
})))
  , DLe = ({tradeData: e, isNumericalValue: t=!1}) => {
    const n = D();
    return void 0 === e ? {
        color: n.palette.text.value,
        variant: t ? "monospace2" : "paragraph2"
    } : {
        color: e.side === xc.BUY ? n.palette.positive[500] : n.palette.negative[500],
        variant: t ? "monospace2" : "paragraph2"
    }
}
  , BLe = y.memo(( ({isPanel: e, tradeData: t}) => {
    const n = DLe({
        tradeData: t
    })
      , r = t.chain && AA(t.txnHash, t.chain);
    return v.jsx(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: e ? "flex-end" : "flex-start",
        children: v.jsx(H, {
            to: r ?? "#",
            target: "_blank",
            component: Hn,
            sx: _Le,
            children: v.jsx(xE, {
                ts: (null == t ? void 0 : t.timestamp) || null,
                isShort: !0,
                ...n,
                color: "text.placeholder",
                sx: ULe
            })
        })
    })
}
))
  , _Le = {
    textDecoration: "none"
}
  , ULe = {
    cursor: "pointer"
}
  , WLe = y.memo(( ({tradeData: e, isShort: t, tradesTargetMode: n, isPanel: r=!1}) => {
    const a = DLe({
        tradeData: e,
        isNumericalValue: !0
    })
      , s = vde()
      , o = Ade()
      , l = e && null !== s && null !== o ? Number(e.priceInUsd) * Number(s) / 10 ** o : null;
    if (!e || !n || n === rwe.MARKET_CAP && null === l)
        return v.jsx(CQ, {});
    const i = n === rwe.QUOTE
      , c = n === rwe.MARKET_CAP;
    return v.jsx(k, {
        ...a,
        color: "inherit",
        justifyContent: r ? "flex-start" : "flex-end",
        display: "flex",
        children: c ? null === l || Number.isNaN(l) ? Ud : LI(l, {
            collapseExponent: !0,
            symbol: "",
            ...l > 1e3 ? {
                desiredDigits: 4
            } : {
                maxPrecision: 2,
                minPrecision: 1
            }
        }) : i && !e.priceInNative ? Ud : EI(Number(i ? e.priceInNative : e.priceInUsd), {
            precision: r || t ? 3 : i ? 4 : 3
        })
    })
}
))
  , FLe = y.memo(( ({tradeData: e}) => {
    const t = DLe({
        tradeData: e,
        isNumericalValue: !0
    });
    return v.jsx(k, {
        ...t,
        color: "inherit",
        justifyContent: "flex-end",
        display: "flex",
        children: e.amountBase ? OI(e.amountBase, {
            collapseExponent: !0,
            symbol: "",
            padSymbol: !0,
            precision: e.amountBase >= 1e3 || e.amountBase < 1 ? 2 : 1
        }) : Ud
    })
}
))
  , VLe = y.memo(( ({tradeData: e}) => v.jsx(H_, {
    tradeSide: null == e ? void 0 : e.side
})))
  , HLe = y.memo(( ({tradeData: e, liveMakerEntry: t}) => {
    const n = D();
    return y.useMemo(( () => !!(null == t ? void 0 : t.activationTimestamp) && t.activationTimestamp > i().unix() + 10800), [null == t ? void 0 : t.activationTimestamp]) && e ? v.jsx(GC, {
        title: e.chain ? `Address had 0 ${GD(e.chain)} until last couple of hours.` : "",
        children: v.jsx(C, {
            component: "span",
            display: "inline-flex",
            children: v.jsx(Mf, {
                size: qLe,
                color: n.palette.originalGreen.main
            })
        })
    }) : null
}
))
  , zLe = y.memo(( ({tradeData: e, isShort: t, isPanel: n, groups: r, showMakerTradingApp: a, showMakerCount: s, showExplorer: o, tableAddressMode: l}) => {
    var i, c;
    const {t: d} = we()
      , u = D()
      , {openModal: p} = r6()
      , h = Ade()
      , {originalStaticMarketInfo: g} = Qce()
      , x = DLe({
        tradeData: e
    })
      , b = bve((t => {
        var n;
        return e ? (null == (n = t.wrapped) ? void 0 : n.queue.get(e.maker)) ?? null : null
    }
    ), ze)
      , f = Zwe(e.chain, e.maker)
      , A = Owe((e => e.onTooltipOpen))
      , w = Owe((e => e.onTooltipClose))
      , j = kve((t => !!((null == e ? void 0 : e.maker) && t.wrapped && t.wrapped.get(e.maker))))
      , T = e.customWalletName ?? (null == f ? void 0 : f.name) ?? null
      , I = !e.customWalletEmoji && f ? Jwe(null == f ? void 0 : f.walletAddress) : null
      , E = Sve((t => t.snipers.has(e.maker)))
      , M = y.useRef(b);
    M.current = b ?? M.current;
    const N = y.useCallback(( () => {
        e && p(e.maker)
    }
    ), [p, e])
      , P = y.useMemo(( () => ({
        ...$_(200, !1),
        maxWidth: n ? GLe : $Le,
        overflow: "clip",
        whiteSpace: "nowrap"
    })), [n]);
    if (!e || m.isNil(h) || !g)
        return v.jsx(CQ, {});
    const O = e.markers && e.markers.includes(Gp.MEV_TXN)
      , L = e.markers && e.markers.includes(Gp.BUNDLER) || (null == (i = M.current) ? void 0 : i.isBundler)
      , R = e.side === xc.BUY && (null == (c = M.current) ? void 0 : c.holdingSince) && M.current.holdingSince === e.timestamp
      , B = s ? v.jsx(C, {
        height: 19,
        children: v.jsx(Gwe, {
            minWidth: 22,
            label: !M.current || null === M.current.buyTxns && null === M.current.sellTxns ? Ud : LI((M.current.buyTxns ?? 0) + (M.current.sellTxns ?? 0), {
                collapseExponent: !0,
                maxPrecision: 0,
                minPrecision: 0,
                symbol: ""
            })
        })
    }) : null;
    return v.jsxs(S, {
        direction: n ? "row-reverse" : "row",
        gap: .5,
        alignItems: "center",
        justifyContent: "flex-end",
        children: [e.customWalletEmoji ? v.jsx(C, {
            component: "span",
            display: "inline-flex",
            children: v.jsx(ZT, {
                emoji: e.customWalletEmoji
            })
        }) : r.length > 0 ? r.map((e => v.jsx(GC, {
            title: e.name,
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(ZT, {
                    emoji: e.emoji
                })
            })
        }, e.groupId))) : I ? v.jsx(Te, {
            src: I,
            sx: eje
        }) : null, O && v.jsx(GC, {
            title: d("MEV Transaction"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(nr, {
                    sx: KLe,
                    color: "error"
                })
            })
        }), e.isCopyTrade && v.jsx(GC, {
            title: d("Automated copied trade"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(YS, {
                    size: qLe,
                    color: u.palette.purple[500]
                })
            })
        }), j && v.jsx(GC, {
            title: d("Top holder"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(CS, {
                    size: qLe,
                    color: u.palette.blue[500]
                })
            })
        }), e.isPool && v.jsx(GC, {
            title: d("Liquidity pool"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(GS, {
                    size: qLe,
                    color: u.palette.lavender[500]
                })
            })
        }), e.isMayhem && v.jsx(C, {
            component: "span",
            display: "inline-flex",
            mt: "1px",
            children: v.jsx(TC, {
                size: qLe
            })
        }), L && v.jsx(GC, {
            title: d("Bundler"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(Uv, {
                    size: qLe,
                    color: u.palette.error.main
                })
            })
        }), e.isToken && v.jsx(z, {
            title: d("Token contract"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(TS, {
                    size: qLe,
                    color: u.palette.text.primary
                })
            })
        }), E && !e.isDeployer && !e.isPool && v.jsx(GC, {
            title: d("Sniper"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(ES, {
                    size: qLe,
                    color: u.palette.error.main
                })
            })
        }), !ke(e.tradingApp) && !n && a && v.jsx(Ywe, {
            tradingApp: e.tradingApp
        }), e.isDeployer && v.jsx(GC, {
            title: d("Dev"),
            children: v.jsx(C, {
                component: "span",
                display: "inline-flex",
                children: v.jsx(Vv, {
                    size: qLe,
                    color: u.palette.primary.main
                })
            })
        }), v.jsx(HLe, {
            tradeData: e,
            liveMakerEntry: M.current
        }), R && v.jsx(GC, {
            title: d("First trade"),
            children: v.jsx(C, {
                position: "relative",
                component: "span",
                display: "inline-flex",
                width: XLe,
                height: qLe,
                children: v.jsx(C, {
                    display: "flex",
                    position: "absolute",
                    sx: n ? QLe : ZLe,
                    children: v.jsx(Bv, {
                        size: XLe
                    })
                })
            })
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "center",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(GC, {
                enterDelay: 250,
                enterNextDelay: 250,
                disableInteractive: !1,
                onOpen: A,
                onClose: w,
                title: v.jsx(e2, {
                    chain: g.chain,
                    decimals: h,
                    deployedAt: g.baseToken.deployedAt,
                    quoteTokenAddress: g.quoteToken.address,
                    symbol: g.baseToken.symbol,
                    walletAddress: e.maker,
                    tokenAddress: g.baseToken.address
                }),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .5,
                        onClick: N,
                        sx: YLe,
                        children: v.jsx(k, {
                            ...x,
                            fontWeight: r.length || e.isMayhem || e.isUserTxn || e.isPool || f ? wu.SEMIBOLD : wu.REGULAR,
                            sx: P,
                            color: e.isMayhem ? u.palette.success.main : e.isPool ? u.palette.lavender[500] : r.length || e.isUserTxn ? u.palette.gold[500] : f ? u.palette.text.primary : "inherit",
                            children: e.isMayhem ? n ? "MAY" : "MAYHEM" : e.isPool ? "LIQ POOL" : e.isUserTxn ? "YOU" : T || (t || n ? e.maker.slice(n ? -3 : -4) : t2(e.maker, l))
                        })
                    })
                })
            }), !n && s && B, !n && o && v.jsx(S, {
                direction: "row",
                alignItems: "center",
                children: v.jsx(tU, {
                    link: e.chain ? AA(e.txnHash, e.chain) : null,
                    hideBackground: !0,
                    noPadding: !0,
                    children: v.jsx(tE, {
                        chain: e.chain
                    })
                })
            })]
        })]
    })
}
))
  , $Le = 80
  , GLe = 32
  , qLe = 14
  , KLe = {
    fontSize: qLe
}
  , YLe = {
    "&:hover": {
        cursor: "pointer"
    }
}
  , XLe = 10
  , QLe = {
    top: -3,
    left: -1
}
  , ZLe = {
    top: -3,
    left: 0
}
  , JLe = y.memo(( ({tradeData: e, isNative: t=!1, isPanel: n, showBar: r=!0}) => {
    const a = D()
      , {colorSkin: s} = Vb()
      , o = DLe({
        tradeData: e,
        isNumericalValue: !0
    })
      , l = y.useMemo(( () => {
        if (!e)
            return {};
        const t = n ? tRe : eRe
          , r = nRe(Number(e.amountInUsd), t)
          , o = E1(e.side, a, s);
        return {
            position: "absolute",
            right: n ? void 0 : t - r - 6,
            left: n ? -10 : void 0,
            top: n ? -3 : -7,
            bottom: n ? -3 : -7,
            width: `${r}px`,
            zIndex: 1,
            background: M1(o)
        }
    }
    ), [s, n, a, e])
      , i = t ? e.amountInNative : (d = e.amountInUsd,
    Number(d));
    var d;
    return v.jsxs(S, {
        direction: "row",
        position: "relative",
        justifyContent: n ? "flex-start" : "flex-end",
        display: "flex",
        children: [r && v.jsx(C, {
            sx: l
        }), v.jsx(k, {
            ...o,
            zIndex: 2,
            children: t && (c.isNil(i) || isNaN(i)) ? Ud : OI(i, {
                collapseExponent: i >= 1e4,
                symbol: "",
                padSymbol: !0,
                precision: n && i >= 1e3 ? 1 : n && i >= 1e4 || i >= 1e4 || !t ? 2 : n ? 3 : 4
            })
        })]
    })
}
))
  , eRe = 102
  , tRe = 74
  , nRe = (e, t) => Math.max(1, Number(Math.min(Math.abs(e) / (1e3 / t), t).toFixed(0)))
  , rRe = y.memo(( ({tradeData: e}) => v.jsx(S, {
    justifyContent: "center",
    alignItems: "flex-end",
    mr: "-5px",
    children: v.jsx(qwe, {
        maker: e.maker,
        isInTrades: !0
    })
})))
  , aRe = y.memo(( ({tradeData: e}) => {
    const t = DLe({
        tradeData: e,
        isNumericalValue: !0
    })
      , n = y.useMemo(( () => e ? (e.tipInNativeUi || 0) + (e.prioSurchargeInNativeUi || 0) : null), [e]);
    return v.jsx(k, {
        ...t,
        display: "flex",
        justifyContent: "flex-end",
        children: null === n ? Ud : oRe(n) ? sRe(n) : null
    })
}
))
  , sRe = e => e.toFixed(3)
  , oRe = e => parseFloat(sRe(e)) > 0
  , lRe = y.memo(( ({tableGap: e, tablePadding: t, isShort: n, isPanel: r, gridTemplateColumns: a, isColumnVisible: s, rowHeight: o, groups: l, tradesTargetMode: i, tradesPanelTotalMode: c, showMakerCount: d, showMakerTradingApp: u, showExplorer: p, tableAddressMode: h, zebra: m, ...g}) => {
    const x = y.useMemo(( () => Cwe(n, r, s)), [r, n, s])
      , {colorSkin: b} = Vb()
      , f = y.useMemo(( () => n => ({
        px: t,
        gap: e,
        ...m ? {
            "&:nth-of-type(odd)": {
                backgroundColor: b === rg.INDIGO ? tY : n.palette.background.secondary
            }
        } : {}
    })), [e, t, m, b])
      , S = y.useCallback((e => {
        switch (e) {
        case "timestamp":
            return v.jsx(BLe, {
                tradeData: g,
                isPanel: r
            }, e);
        case "tipInNativeUi":
            return v.jsx(aRe, {
                tradeData: g
            }, e);
        case "side":
            return v.jsx(VLe, {
                tradeData: g
            }, e);
        case "priceInUsd":
            return v.jsx(WLe, {
                tradeData: g,
                tradesTargetMode: i,
                isShort: n || !1,
                isPanel: r
            }, e);
        case "amountBase":
            return v.jsx(FLe, {
                tradeData: g
            }, e);
        case "amountInUsd":
            return v.jsx(JLe, {
                tradeData: g,
                isPanel: r,
                isNative: r && c === rwe.QUOTE
            }, e);
        case "amountInNative":
            return v.jsx(JLe, {
                isNative: !0,
                tradeData: g,
                showBar: !x.includes("amountInUsd")
            }, e);
        case "maker":
            return v.jsx(zLe, {
                tradeData: g,
                isShort: n,
                isPanel: r,
                groups: l,
                showMakerCount: d,
                showMakerTradingApp: u,
                showExplorer: p,
                tableAddressMode: h
            }, e);
        case "txnHash":
            return v.jsx(rRe, {
                tradeData: g
            }, e);
        default:
            return v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: e.slice(0, 3)
            }, e)
        }
    }
    ), [g, i, n, r, c, x, l, d, u, h, p]);
    return v.jsx(C, {
        display: "grid",
        gridTemplateColumns: a,
        alignItems: "center",
        height: o,
        minHeight: o,
        sx: f,
        children: x.map(S)
    })
}
), ( (e, t) => {
    for (const n in e)
        if ("groups" !== n && e[n] !== t[n])
            return !1;
    if (e.groups.length !== t.groups.length)
        return !1;
    for (let n = 0; n < e.groups.length; n++) {
        const r = e.groups[n]
          , a = t.groups[n];
        if (r.name !== a.name || r.emoji !== a.emoji || r.groupId !== a.groupId)
            return !1
    }
    return !0
}
))
  , iRe = y.memo(( ({rowData: e, isLoading: t, isShort: n, isPanel: r, chain: a, showOldest: s, toggleShowOldest: o, containerRef: l}) => {
    const {t: i} = we()
      , d = bw()
      , u = Uwe()
      , p = Wwe()
      , h = Owe((e => e.setMinimumUsdValue))
      , {focusTraders: m, focusedTraders: g, areTrackedGroupsFocused: x, focusTrackedGroups: b, tradesLocation: f, panelFocusTraders: C, panelFocusedTraders: A, panelAreTrackedGroupsFocused: w, panelFocusTrackedGroups: j} = jwe()
      , T = y.useCallback((e => {
        f === XAe.PANEL && d ? C(e) : m(e)
    }
    ), [m, C, f, d])
      , I = y.useMemo(( () => f === XAe.PANEL && d ? A : g), [g, A, f, d])
      , E = y.useMemo(( () => f === XAe.PANEL && d ? w : x), [f, d, w, x])
      , M = y.useCallback((e => {
        f === XAe.PANEL && d ? j(e) : b(e)
    }
    ), [f, d, j, b])
      , N = Owe((e => e.pauseOnHover))
      , P = Owe((e => e.setPauseOnHover))
      , [O,L] = Mx("padreV2-tradesAddressMode", iZ.END)
      , D = y.useRef(0);
    y.useEffect(( () => {
        if (!R || !l)
            return;
        const e = l.current
          , t = () => {
            0 === (null == e ? void 0 : e.scrollTop) && 0 !== D.current && u(!1),
            D.current = (null == e ? void 0 : e.scrollTop) ?? 0
        }
        ;
        return null == e || e.addEventListener("scroll", t),
        () => {
            null == e || e.removeEventListener("scroll", t)
        }
    }
    ), [l, u]);
    const [B,_] = Mx("padreV2-tradesPriceCurrencyV2", rwe.MARKET_CAP)
      , U = y.useCallback(( () => {
        _((e => e === rwe.MARKET_CAP ? rwe.USD : e === rwe.USD ? rwe.QUOTE : rwe.MARKET_CAP))
    }
    ), [_])
      , [W,F] = Mx("padreV2-tradesPanelTotalCurrency", dwe)
      , V = y.useMemo(( () => uwe.has(W) ? W : dwe), [W])
      , {hiddenColumnsKeys: H, isModalOpen: z, openModal: $, closeModal: G, setHiddenColumnsKeys: q} = EZ(IZ("Trades"))
      , K = y.useMemo(( () => (e => e ? 24 : 34)(r)), [r])
      , Y = y.useMemo(( () => n ? owe : swe), [n])
      , X = y.useMemo(( () => new Set(Y)), [Y])
      , Q = y.useMemo(( () => new Set(H)), [H])
      , Z = y.useCallback((e => !X.has(e) || !Q.has(e)), [X, Q])
      , [J,ee] = Mx("padreV2-tradesCustomFlags", xwe)
      , [te,ne,re] = y.useMemo(( () => [!!J[hwe], !!J[mwe], !!J[gwe]]), [J])
      , [ae,se] = y.useMemo(( () => n ? [1.5, 1.75] : r ? [1.25, 1.25] : [1.75, 2]), [r, n])
      , [oe,le] = y.useMemo(( () => {
        if (r)
            return ["70px 72px minmax(70px, 1fr) 36px", 315 - 2 * se * 8];
        const e = n ? cwe : lwe.filter(Z)
          , {templates: t, width: a} = c.reduce(e, ( (e, t) => {
            const [r,a] = ( (e, t, n, r) => {
                switch (e) {
                case "timestamp":
                    return [t ? "47px" : "minmax(47px, 60px)", 47];
                case "tipInNativeUi":
                    return ["64px", 64];
                case "side":
                    return ["48px", 48];
                case "priceInUsd":
                    return ["minmax(84px, 0.5fr)", 84];
                case "amountBase":
                    return ["minmax(70px, 0.5fr)", 70];
                case "amountInUsd":
                    return ["102px", 102];
                case "amountInNative":
                    return ["minmax(85px, 0.5fr)", 85];
                case "maker":
                    {
                        const e = t ? 110 : 190
                          , a = t ? e : e - (16 + (n ? 0 : 24) + (r ? 0 : 16));
                        return [`minmax(${a}px, 1fr)`, a]
                    }
                case "txnHash":
                    return ["16px", 16];
                default:
                    return ["0px", 0]
                }
            }
            )(t, n, ne, re);
            return e.templates.push(r ?? "0px"),
            e.width += a,
            e
        }
        ), {
            templates: [],
            width: 0
        })
          , s = a + 8 * (2 * se + ae * (e.length - 1));
        return [t.join(" "), s]
    }
    ), [Z, r, n, ae, se, ne, re])
      , ie = y.useMemo(( () => !!(null == I ? void 0 : I.length) || (!!E || null !== p)), [null == I ? void 0 : I.length, E, p])
      , ce = y.useCallback(( () => {
        h(null),
        T(null),
        M(!1)
    }
    ), [T, h, M])
      , de = y.useMemo(( () => v.jsx(PLe, {
        tableGap: ae,
        tablePadding: se,
        isShort: n,
        isPanel: r,
        gridTemplateColumns: oe,
        chain: a,
        isColumnVisible: Z,
        tradesTargetMode: B,
        toggleTradesTargetMode: U,
        tradesPanelTotalMode: V,
        setTradesPanelTotalMode: F,
        minimumUsdValue: p,
        setMinimumUsdValue: h,
        focusedTraders: I,
        openSettings: $,
        showOldest: s,
        toggleShowOldest: o
    })), [a, I, oe, Z, V, r, n, p, $, h, s, ae, se, o, F, U, B])
      , ue = y.useMemo(( () => ({
        overflow: "scroll",
        height: r ? "100%" : "calc(100% - 4px)"
    })), [r]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(S, {
            sx: ue,
            className: "padre-no-scroll",
            position: "relative",
            ref: l,
            children: v.jsxs(S, {
                width: le,
                minWidth: "100%",
                height: t || !e.length ? "100%" : void 0,
                children: [de, v.jsx(S, {
                    className: pwe,
                    height: t || !e.length ? "100%" : void 0,
                    children: t ? null : e.length ? e.map((e => {
                        const t = cRe(e);
                        return v.jsx(lRe, {
                            tableGap: ae,
                            tablePadding: se,
                            isShort: n,
                            isPanel: r,
                            gridTemplateColumns: oe,
                            isColumnVisible: Z,
                            rowHeight: K,
                            tradesTargetMode: B,
                            tradesPanelTotalMode: V,
                            showMakerCount: ne,
                            showMakerTradingApp: te,
                            showExplorer: re,
                            tableAddressMode: O,
                            zebra: !r,
                            ...e
                        }, t)
                    }
                    )) : v.jsx(S, {
                        alignItems: "center",
                        justifyContent: "center",
                        width: "100%",
                        flexGrow: 1,
                        minHeight: d ? void 0 : 100,
                        children: ie ? v.jsx(s1, {
                            resetFilters: ce
                        }) : v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.label",
                            children: "No data to show"
                        })
                    })
                })]
            })
        }), !r && v.jsx(jZ, {
            customizableColumnsKeys: Y,
            hiddenColumnsKeys: H,
            isModalOpen: z,
            closeModal: G,
            setHiddenColumnsKeys: q,
            keysLabelsLookup: awe,
            label: i("Customize trades"),
            customFlagsConfig: bwe,
            customFlags: J,
            setCustomFlags: ee,
            extraFlagColumns: fwe,
            tableAddressMode: O,
            setTableAddressMode: L,
            pauseOnHover: N,
            setPauseOnHover: P
        })]
    })
}
))
  , cRe = e => `${e.txnHash}-${e.tradeIndex}-${e.priceInUsd}-${e.maker}`
  , dRe = []
  , uRe = ({chain: e, devAddress: t, isPanel: n=!1}) => {
    const r = bw()
      , {originalStaticMarketInfo: a} = Qce()
      , s = dde(a)
      , o = fde()
      , {selectedWalletsAddresses: l} = Gde()
      , {walletGroups: i, customWalletNames: d, customWalletEmojis: u} = rf()
      , p = y.useRef(null)
      , h = _we()
      , m = Owe((e => e.trades))
      , g = Owe((e => e.isLoading))
      , x = Uwe()
      , b = Owe((e => e.showOldest))
      , f = Owe((e => e.toggleShowOldest))
      , {focusedTraders: k, areTrackedGroupsFocused: C, focusedWalletGroupAddresses: A, tradesLocation: w, panelFocusedTraders: j, panelAreTrackedGroupsFocused: T, panelFocusedWalletGroupAddresses: I, allTrackedGroupIds: E} = jwe()
      , M = y.useMemo(( () => w === XAe.PANEL && r ? j : k), [k, j, w, r])
      , N = y.useMemo(( () => w === XAe.PANEL && r ? T : C), [w, r, T, C])
      , P = y.useMemo(( () => w === XAe.PANEL && r ? I : A), [A, I, w, r])
      , O = y.useMemo(( () => N ? nwe.GROUP : M && c.isEqual([...l].sort(), [...M].sort()) ? nwe.MY : nwe.MARKET), [N, M, l])
      , L = UD((e => e.wallets))
      , R = y.useMemo(( () => L ? new Set(L.map((e => ng(e.publicAddress)))) : null), [L])
      , D = Wwe()
      , B = Fwe()
      , _ = ( (e, t, n, r, a, s) => {
        const [o,l] = y.useState(null)
          , i = QAe();
        return y.useEffect(( () => {
            let o = !1;
            return (async () => {
                try {
                    if (o || !n || !e && !t)
                        return;
                    const c = i && (null == a ? void 0 : a.length) ? dh(a) : null
                      , d = await bm.getHistoryV6(n, (null == r ? void 0 : r.length) ? YA(r) : null, (null == t ? void 0 : t.startTs) ?? null, (null == t ? void 0 : t.endTs) ?? null, null, c, s, e ? "1" : null);
                    if (o)
                        return;
                    l({
                        marketId: n,
                        trades: d.trades
                    })
                } catch (fNe) {
                    if (o)
                        return
                }
            }
            )(),
            () => {
                o = !0
            }
        }
        ), [e, t, r, n, s, a, i]),
        n === (null == o ? void 0 : o.marketId) ? o.trades : dRe
    }
    )(b, B, s, M, N ? E : null, D)
      , U = b || B ? _ : m
      , W = y.useMemo(( () => _.map((e => e.maker))), [_]);
    fve(e, (null == a ? void 0 : a.baseToken.address) ?? null, W);
    const F = y.useMemo(( () => U.map((e => e.maker))), [U])
      , H = pX(F, e)
      , [z,$] = y.useMemo(( () => U ? [vwe(U, M, N, e, (null == a ? void 0 : a.quoteToken.symbol) || null, (null == a ? void 0 : a.baseToken.symbol) || null, L || [], H, (null == a ? void 0 : a.baseToken.deployer) ? ng(a.baseToken.deployer) : null, (null == a ? void 0 : a.baseToken.address) ? ng(a.baseToken.address) : null, $we(o || null), i, d, u), g] : [[], g]), [U, M, N, e, a, L, H, o, i, d, u, g])
      , G = y.useMemo(( () => {
        switch (O) {
        case nwe.MY:
            return z.filter((e => null == R ? void 0 : R.has(ng(e.maker))));
        case nwe.GROUP:
            return z.filter((e => null == P ? void 0 : P.has(e.maker)));
        case nwe.MARKET:
            return z
        }
    }
    ), [z, O, R, P])
      , q = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        x(!1)
    }
    ), [x])
      , K = y.useCallback(( () => {
        x(!0)
    }
    ), [x])
      , Y = y.useCallback(( () => {
        x(!1)
    }
    ), [x]);
    return pM({
        target: p,
        onInteractionStart: K,
        onInteractionStop: Y,
        child: `.${pwe}`
    }),
    v.jsxs(S, {
        overflow: "scroll",
        className: "padre-no-scroll",
        "data-testid": "token-section-trades",
        mx: r ? void 0 : -2,
        sx: n ? {
            pointerEvents: "auto"
        } : {},
        minHeight: r ? n ? "calc(100% - 35px)" : "100%" : void 0,
        maxHeight: r ? void 0 : "100%",
        children: [!r && v.jsxs(S, {
            gap: .5,
            children: [v.jsx(hLe, {}), v.jsx(mLe, {
                devAddress: t,
                tableMode: oAe.TRADES,
                tradesLocation: XAe.MARKET_ACTIVITY
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                px: 2,
                pb: 1,
                children: [v.jsx(H9, {
                    isLive: h && !b
                }), v.jsx(Q, {
                    in: !h,
                    children: v.jsx(V, {
                        variant: "tertiary",
                        onClick: q,
                        size: "xsmall",
                        children: "Resume"
                    })
                })]
            })]
        }), v.jsx(iRe, {
            rowData: G ?? pRe,
            isLoading: $,
            isShort: !r,
            isPanel: n,
            chain: e,
            showOldest: b,
            toggleShowOldest: f,
            containerRef: p
        })]
    })
}
  , pRe = []
  , hRe = sAe.TRADES
  , mRe = sAe.OPEN
  , gRe = [sAe.OPEN, sAe.POSITIONS, sAe.HISTORY, sAe.TOP_TRADERS]
  , xRe = [sAe.OPEN, sAe.POSITIONS, sAe.HOLDERS, sAe.TOP_TRADERS, sAe.DEV_TOKENS]
  , bRe = [Pd.SOLANA]
  , fRe = y.memo(( ({devAddress: e, tableMode: t, tradesLocation: n, areOtherTokensVisible: r, toggleOtherTokensVisible: a, ordersTabMode: s, setOrdersTabMode: o, openOrdersCount: l}) => {
    const {t: i} = we()
      , {areCancelledHidden: c, toggleCancelledHidden: d} = _de()
      , u = _we()
      , p = y.useCallback(( (e, t) => {
        o(t)
    }
    ), [o])
      , h = y.useMemo(( () => [{
        value: iAe.OPEN,
        label: "Open" + (null === l ? "" : ` (${l})`)
    }, {
        value: iAe.HISTORY,
        label: i("Historical")
    }]), [l, i]);
    return v.jsxs(S, {
        direction: "row",
        gap: vRe,
        px: 2,
        py: .5,
        minHeight: 37,
        alignItems: "center",
        justifyContent: t === oAe.HOLDERS || t === oAe.TOP_TRADERS ? "flex-end" : "space-between",
        sx: SRe,
        className: "padre-no-scroll",
        children: [t === oAe.ORDERS && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .75,
            children: [v.jsx(S, {
                direction: "row",
                alignItems: "center",
                minWidth: 2 * kRe + 2,
                children: v.jsx(IH, {
                    size: "xxsmall",
                    value: s,
                    onChange: p,
                    items: h,
                    minItemWidth: kRe
                })
            }), !R && v.jsx(z, {
                title: `Shows at most ${s === iAe.HISTORY ? 200 : 1e3} most recently updated orders`,
                children: v.jsx(C, {
                    component: "span",
                    display: "flex",
                    sx: yRe,
                    children: v.jsx(QS, {
                        size: 14
                    })
                })
            })]
        }), [oAe.ORDERS, oAe.TRADES].includes(t) && v.jsxs(S, {
            direction: "row",
            gap: vRe,
            children: [t === oAe.ORDERS && s === iAe.HISTORY && v.jsx(WR, {
                label: "Hide cancelled",
                isChecked: c,
                onClick: d
            }), t === oAe.ORDERS && v.jsx(WR, {
                label: "Hide other tokens",
                isChecked: !r,
                onClick: a
            }), t === oAe.TRADES && v.jsx(H9, {
                isLive: u
            })]
        }), v.jsx(mLe, {
            devAddress: e,
            tableMode: t,
            tradesLocation: n
        })]
    })
}
))
  , vRe = {
    xs: .5,
    md: 1,
    lg: 2
}
  , SRe = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    overflowX: "scroll",
    overflowY: "hidden"
})
  , yRe = {
    "&:hover": {
        cursor: "help"
    }
}
  , kRe = 80
  , CRe = y.memo(( ({value: e, label: t, count: n, warningTooltip: r}) => {
    const a = D()
      , s = y.useMemo(( () => "string" == typeof t ? v.jsx(k, {
        variant: "inherit",
        color: "inherit",
        children: t ?? e
    }) : t), [t, e]);
    return v.jsx(GC, {
        title: r ?? "",
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [s, r && v.jsx(wk, {
                color: a.palette.error.main,
                size: 14
            }), void 0 !== n && v.jsxs(k, {
                variant: "inherit",
                color: "inherit",
                children: ["(", n, ")"]
            })]
        })
    })
}
))
  , ARe = (e, t) => `${e}-${t}`
  , wRe = e => c.reduce(e, ( (e, t) => {
    const {chain: n} = t.def
      , r = {
        chain: n,
        tokenAddress: t.def.tradeParams.pair.baseCurrency
    }
      , a = ARe(r.chain, r.tokenAddress)
      , s = {
        chain: n,
        tokenAddress: t.def.tradeParams.pair.quoteCurrency
    }
      , o = ARe(s.chain, s.tokenAddress);
    return e[a] || (e[a] = r),
    e[o] || (e[o] = s),
    e
}
), {})
  , jRe = 1732921200
  , TRe = (e, t, r, a, s, o) => {
    const l = !!o && o < jRe;
    return [...e || s !== XAe.MARKET_ACTIVITY ? [] : [{
        value: sAe.TRADES,
        label: n.t("Trades")
    }], {
        value: sAe.POSITIONS,
        label: n.t("Positions")
    }, {
        value: sAe.OPEN,
        label: n.t("Orders")
    }, ...e ? [] : [{
        value: sAe.HOLDERS,
        label: n.t("Holders"),
        count: e || null === t || l ? void 0 : t,
        tooltip: l ? n.t("For older coins, holders data won't be accurate") : void 0
    }], {
        value: sAe.TOP_TRADERS,
        label: n.t("Top Traders"),
        tooltip: l ? n.t("For older coins, top traders data won't be accurate") : void 0
    }, ...a && bRe.includes(a) && !e ? [{
        value: sAe.DEV_TOKENS,
        label: n.t("Dev Tokens"),
        count: null === r ? void 0 : r
    }] : []]
}
  , IRe = e => {
    switch (e) {
    case sAe.TRADES:
    case sAe.POSITIONS:
        return 85;
    case sAe.HOLDERS:
        return 130;
    case sAe.OPEN:
        return 85;
    default:
        return 120
    }
}
  , ERe = pg((e => e), (e => ({
    minWidth: IRe(e),
    px: {
        xs: 2.75,
        md: 2
    }
})), 20)
  , MRe = y.memo(( ({chain: e, baseDeployedAt: t, handleModeChange: n, marketActivityMode: r, tradesLocation: a}) => {
    const s = bw()
      , o = Sde()
      , l = Ive()
      , i = y.useMemo(( () => l && !o && 50 === l ? null : null !== l && (null === o || o <= 50 || l <= 40) ? l : o), [o, l])
      , c = QZ();
    return v.jsx(ot, {
        variant: "scrollable",
        value: (s ? xRe : gRe).includes(r) ? r : s ? hRe : mRe,
        onChange: n,
        sx: NRe,
        children: TRe(!s, i, c.tokensCreated, e, a, t).map(( ({label: e, value: t, count: n, tooltip: r}) => v.jsx(lt, {
            sx: ERe(t),
            value: t,
            label: v.jsx(CRe, {
                label: e,
                value: t,
                count: n,
                warningTooltip: r
            }, t)
        }, t)))
    })
}
))
  , NRe = {
    borderBottom: 0,
    pl: {
        xs: 0,
        md: .25
    },
    "& .MuiTabs-scrollButtons": {
        width: 24
    }
}
  , PRe = y.memo(( ({chain: e, toggleTradesLocation: t, tradesLocation: r, setMarketActivityMode: a}) => {
    const s = PR()
      , o = y.useRef(null)
      , l = y.useRef(null)
      , i = bw()
      , {toggleTradingWidget: c, isTradingWidgetOpen: d, toggleBubblemapWidget: u, isBubblemapWidgetOpen: p} = ESe()
      , h = y.useCallback(( () => {
        r === XAe.MARKET_ACTIVITY && a(sAe.OPEN),
        t(),
        r === XAe.PANEL && a(hRe)
    }
    ), [a, t, r])
      , m = y.useMemo(( () => e => ({
        minWidth: 105,
        width: 105,
        pr: .5,
        pl: .25,
        gap: .5,
        borderRadius: "16px",
        color: d ? e.palette.success.contrastText : e.palette.success.main,
        borderColor: `${e.palette.success.main}80`,
        transition: "none",
        backgroundColor: d ? e.palette.success.main : "transparent",
        "&:hover": {
            borderColor: `${e.palette.success.main}80`,
            backgroundColor: d ? e.palette.success.main : e.palette.background.secondary
        },
        "&:focus": {
            borderColor: `${e.palette.success.main}80`,
            backgroundColor: d ? e.palette.success.main : "transparent"
        }
    })), [d])
      , g = y.useCallback(( () => {
        var e;
        const t = null == (e = o.current) ? void 0 : e.getBoundingClientRect();
        c({
            x: (null == t ? void 0 : t.left) ?? 0,
            y: (null == t ? void 0 : t.top) ?? 0
        })
    }
    ), [c])
      , x = y.useCallback(( () => {
        var e;
        const t = null == (e = l.current) ? void 0 : e.getBoundingClientRect();
        u({
            x: (null == t ? void 0 : t.left) ?? 0,
            y: (null == t ? void 0 : t.top) ?? 0
        })
    }
    ), [u])
      , b = y.useMemo(( () => e => ({
        p: 0,
        color: p ? e.palette.green[500] : e.palette.text.label,
        borderColor: "transparent",
        background: "transparent",
        "&:hover": {
            borderColor: "transparent",
            background: e.palette.background.secondary
        },
        "&:focus": {
            borderColor: "transparent",
            background: "transparent"
        }
    })), [p]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        children: [!s && i && e && rAe.includes(e) && v.jsxs(V, {
            ref: o,
            variant: "tertiary",
            color: "success",
            size: "xxsmall",
            onClick: g,
            sx: m,
            children: [v.jsx(ay, {
                color: "inherit"
            }), v.jsx(k, {
                color: "inherit",
                variant: "paragraph3",
                children: n.t("Instant trade")
            })]
        }), !s && i && v.jsx(V, {
            ref: l,
            variant: "tertiary",
            size: "xxsmall",
            onClick: x,
            sx: b,
            children: v.jsx(RS, {
                color: "inherit"
            })
        }), i && v.jsx(V, {
            onClick: h,
            variant: "tertiary",
            size: "xxsmall",
            sx: LRe,
            children: r === XAe.MARKET_ACTIVITY ? v.jsx(_f, {
                size: ORe
            }) : v.jsx(Uf, {
                size: ORe
            })
        })]
    })
}
))
  , ORe = 22
  , LRe = e => ({
    mr: .5,
    minWidth: 28,
    width: 28,
    p: 0,
    background: "transparent",
    borderColor: "transparent",
    "&:hover, &:focus": {
        borderColor: "transparent",
        background: e.palette.background.secondary
    },
    "&:focus": {
        borderColor: "transparent",
        background: "transparent"
    }
})
  , RRe = {
    p: 2
}
  , DRe = 200
  , BRe = 230
  , _Re = 3
  , URe = 31
  , WRe = (e, t, n, r, a, s, o, l) => t && l && e ? c.reduce(l, ( (l, i) => {
    const {walletName: d, walletId: u, walletType: p, publicAddress: h} = i
      , m = ng(h)
      , g = t[m]
      , {totalBalanceInUsd: x, totalPnl: b, unrealizedPnl: f} = ( (e, t, n, r, a, s, o) => e ? c.reduce(Object.values(e), ( (e, l) => Hfe(l.chain) ? e : t ? (!r && t[kX(l.tokenAddress, l.chain)] || n && 1 > (l.currentValueInUsdUi ?? 0) || !a && l.isLikelyScam || s && !o.has(tDe(ng(l.tokenAddress), l.chain)) || (e.totalBalanceInUsd += l.currentValueInUsdUi || 0,
    e.totalPnl += null !== l.currentValueInUsdUi && null !== l.totalSoldInUsdUi && null !== l.totalInvestedInUsdUi ? l.currentValueInUsdUi + l.totalSoldInUsdUi - l.totalInvestedInUsdUi : 0,
    e.unrealizedPnl += l.unrealizedPnlInUsdUi || 0),
    e) : e), {
        totalBalanceInUsd: 0,
        totalPnl: 0,
        unrealizedPnl: 0
    }) : {
        totalBalanceInUsd: 0,
        totalPnl: 0,
        unrealizedPnl: 0
    })(g ? g.perTokenId : null, e, n, r, a, s, o);
    return l[m] = {
        address: m,
        name: d,
        walletId: u,
        totalBalanceInUsd: x,
        totalPnl: b,
        unrealizedPnl: f,
        walletTypes: [p]
    },
    l
}
), {}) : null
  , FRe = {
    displayData: null,
    openPositionsCount: null,
    metaStats: null
}
  , VRe = ({value: e, unrealizedPnl: t, currentCost: n, totalInvested: r, totalSold: a}) => {
    const s = null !== r && null !== a ? a + (e ?? 0) - r : null;
    return {
        pnlPercentage: null !== t && n ? t / n * 100 : null,
        totalPnl: s,
        totalPnlPercentage: null !== s && r ? 100 * s / r : null
    }
}
  , HRe = (e, t) => null === e && null === t ? null : null !== e && null !== t ? e + t : e ?? t ?? null
  , zRe = (e, t, n, r) => r === Gh.TXN_TIME ? e : null !== t && null !== n ? t * n : null
  , $Re = (e, t, n, r, a, s, o, l, i, d, u, p, h) => {
    if (!e || !t)
        return FRe;
    const m = c.reduce(e, ( (e, t) => (e[ng(t.address)] = t,
    e)), {})
      , g = c.reduce(Object.keys(m), ( (e, n) => {
        var r;
        const a = null == (r = t[n]) ? void 0 : r.perTokenId;
        return a ? (e.push(...Object.values(a)),
        e) : e
    }
    ), [])
      , [x,b,f] = c.reduce(g, ( (e, t) => {
        var l;
        if (Hfe(t.chain))
            return e;
        if (null === t.tokenInfo || null === t.balance || null === t.isLikelyClosed)
            return e;
        const c = h === qh.MARKET_VALUE ? null : vSe(t, null, null)
          , g = ( (e, t) => {
            const n = e.currentValueInUsdUi && e.currentValueInNativeUi ? e.currentValueInUsdUi / e.currentValueInNativeUi : null;
            return null !== t && n ? t * n : null === e.currentValueInUsdUi ? null : null !== e.liqInUsd ? Math.min(e.liqInUsd, e.currentValueInUsdUi) : e.currentValueInUsdUi
        }
        )(t, c)
          , x = ( (e, t, n) => {
            const r = e.currentValueInUsdUi && n ? n / e.currentValueInUsdUi : null;
            return t || (r && e.currentValueInNativeUi ? e.currentValueInNativeUi * r : e.currentValueInNativeUi)
        }
        )(t, c, g);
        if (null === g)
            return e;
        if (r && d && g < 1)
            return e;
        if (d && "0" === t.balance)
            return e;
        if (!s && t.isLikelyScam)
            return e;
        const b = ng(t.tokenAddress);
        if (o && !i.has(tDe(b, t.chain)))
            return e;
        if (!a && n[kX(b, t.chain)])
            return e;
        if (t.isLikelyClosed || r && !(g >= 1) || "0" === t.balance || e[1]++,
        d && t.isLikelyClosed || !d && !t.isLikelyClosed)
            return e;
        if (!d && tu(t.tokenAddress, t.chain))
            return e;
        const {tokenInfo: f, balance: v, currentCostInUsdUi: S, totalInvestedInUsdUi: y, totalInvestedInNativeUi: k, currentCostInNativeUi: C, avgBuyPriceInUsdUi: A, markPriceInUsdUi: w, markPriceInNativeUi: j, unrealizedPnlInUsdUi: T, unrealizedPnlInNativeUi: I, totalSoldInUsdUi: E, totalSoldInNativeUi: M, wasExternallyTraded: N, holdTimeInSeconds: P, lastActivityTs: O, chain: L, walletAddress: R} = t
          , D = (null == (l = m[R]) ? void 0 : l.name) ?? ""
          , B = v ? Number(new sB({
            decimals: f.decimals
        },BigInt(v)).toExact()) : null
          , {pnlPercentage: _, totalPnl: U, totalPnlPercentage: W} = VRe({
            value: g,
            unrealizedPnl: T,
            currentCost: S,
            totalInvested: y,
            totalSold: E
        })
          , {pnlPercentage: F, totalPnl: V, totalPnlPercentage: H} = VRe({
            value: x,
            unrealizedPnl: I,
            currentCost: C,
            totalInvested: k,
            totalSold: M
        })
          , z = p[L] ?? null
          , $ = zRe(U, V, z, u);
        return t.isLikelyClosed && $ && ($ > 0 ? (e[2].totalWins = (e[2].totalWins || 0) + 1,
        e[2].totalWinsInUsd = (e[2].totalWinsInUsd || 0) + $,
        (null === e[2].topWinInUsd || $ > e[2].topWinInUsd) && (e[2].topWinInUsd = $),
        null !== t.holdTimeInSeconds && e[2].winHoldsInSeconds.push(t.holdTimeInSeconds)) : $ < 0 && (e[2].totalLosses = (e[2].totalLosses || 0) + 1,
        e[2].totalLossesInUsd = (e[2].totalLossesInUsd || 0) + $,
        (null === e[2].topLossInUsd || Math.abs($) > e[2].topLossInUsd) && (e[2].topLossInUsd = Math.abs($)),
        null !== t.holdTimeInSeconds && e[2].lossHoldsInSeconds.push(t.holdTimeInSeconds))),
        e[0].push({
            tokenAddress: b,
            tokenSymbol: f.symbol ?? null,
            tokenName: f.name ?? null,
            chain: L,
            walletName: D,
            walletAddress: R,
            valueUsd: zRe(g, x, z, u),
            costUsd: zRe(S, C, z, u),
            soldUsd: zRe(E, M, z, u),
            unrealizedPnlUsd: zRe(T, I, z, u),
            pnlPercentageUsd: u === Gh.CURRENT ? F : _,
            investedUsd: zRe(y, k, z, u),
            totalPnlUsd: $,
            totalPnlPercentageUsd: u === Gh.CURRENT ? H : W,
            valueNative: x,
            costNative: C,
            soldNative: M,
            unrealizedPnlNative: I,
            pnlPercentageNative: F,
            investedNative: k,
            totalPnlNative: V,
            totalPnlPercentageNative: H,
            wasExternallyTraded: N,
            avgPurchasePriceInUsd: A,
            priceInUsd: w,
            priceInNative: j,
            holdingAmount: B,
            holdTime: P,
            lastActivityTs: O
        }),
        e
    }
    ), [[], 0, {
        totalWins: null,
        totalLosses: null,
        topWinInUsd: null,
        topLossInUsd: null,
        winHoldsInSeconds: [],
        lossHoldsInSeconds: [],
        totalWinsInUsd: null,
        totalLossesInUsd: null
    }])
      , {totalWins: v, totalLosses: S, topWinInUsd: y, topLossInUsd: k, winHoldsInSeconds: C, lossHoldsInSeconds: A, totalWinsInUsd: w, totalLossesInUsd: j} = f
      , T = {
        totalWins: v,
        totalLosses: S,
        topWinInUsd: y,
        topLossInUsd: k,
        winRate: (v || 0) + (S || 0) > 0 ? (v || 0) / ((v || 0) + (S || 0)) : null,
        avgWinHoldInSeconds: C.length ? c.mean(C) : null,
        avgLossHoldInSeconds: A.length ? c.mean(A) : null,
        avgWinInUsd: null !== w && null !== v && v > 0 ? w / v : null,
        avgLossInUsd: null !== j && null !== S && S > 0 ? j / S : null
    };
    return {
        displayData: l ? Object.values(c.reduce(x, ( (e, t) => {
            const n = `${t.tokenAddress}-${t.chain}`
              , r = e[n];
            if (!r)
                return e[n] = t,
                e;
            const a = HRe(t.valueUsd, r.valueUsd)
              , s = HRe(t.costUsd, r.costUsd)
              , o = HRe(t.soldUsd, r.soldUsd)
              , l = HRe(t.unrealizedPnlUsd, r.unrealizedPnlUsd)
              , i = HRe(t.investedUsd, r.investedUsd)
              , {pnlPercentage: c, totalPnl: d, totalPnlPercentage: u} = VRe({
                value: a,
                unrealizedPnl: l,
                currentCost: s,
                totalInvested: i,
                totalSold: o
            })
              , p = HRe(t.valueNative, r.valueNative)
              , h = HRe(t.costNative, r.costNative)
              , m = HRe(t.soldNative, r.soldNative)
              , g = HRe(t.unrealizedPnlNative, r.unrealizedPnlNative)
              , x = HRe(t.investedNative, r.investedNative)
              , {pnlPercentage: b, totalPnl: f, totalPnlPercentage: v} = VRe({
                value: p,
                unrealizedPnl: g,
                currentCost: h,
                totalInvested: x,
                totalSold: m
            })
              , S = HRe(t.holdingAmount, r.holdingAmount);
            return e[n] = {
                ...t,
                walletAddress: null,
                walletName: null,
                valueUsd: a,
                costUsd: s,
                soldUsd: o,
                unrealizedPnlUsd: l,
                pnlPercentageUsd: c,
                investedUsd: i,
                totalPnlUsd: d,
                totalPnlPercentageUsd: u,
                valueNative: p,
                costNative: h,
                soldNative: m,
                unrealizedPnlNative: g,
                pnlPercentageNative: b,
                investedNative: x,
                totalPnlNative: f,
                totalPnlPercentageNative: v,
                wasExternallyTraded: t.wasExternallyTraded || r.wasExternallyTraded || !1,
                holdingAmount: S,
                holdTime: null !== t.holdTime && null !== r.holdTime ? Math.max(t.holdTime, r.holdTime) : t.holdTime ?? r.holdTime ?? null,
                lastActivityTs: null !== t.lastActivityTs && null !== r.lastActivityTs ? Math.max(t.lastActivityTs, r.lastActivityTs) : t.lastActivityTs ?? r.lastActivityTs ?? null
            },
            e
        }
        ), {})) : x,
        openPositionsCount: b,
        metaStats: T
    }
}
  , GRe = (e, t, n, r) => {
    const a = t ? 80 : 160;
    return [{
        value: rge.OVERVIEW,
        label: e("Overview"),
        tabMinWidth: a
    }, {
        value: rge.OPEN_POSITIONS,
        label: `${e(t ? "Open" : "Open positions")}${null === n ? "" : ` (${n})`}`,
        tabMinWidth: a
    }, {
        value: rge.CLOSED_POSITIONS,
        label: e(t ? "Closed" : "Closed positions"),
        tabMinWidth: a
    }, {
        value: rge.TRADES,
        label: e("Trades"),
        tabMinWidth: a
    }, {
        value: rge.ORDERS,
        label: `${e(t ? "Orders" : "Open orders")}${null === r ? "" : ` (${r})`}`,
        tabMinWidth: a
    }]
}
  , qRe = (e, t) => {
    const n = e.filter((e => e.currentStateData.status === sc.FILLED));
    return fAe(n, t, iAe.HISTORY, null, new Set)
}
  , KRe = e => `${eg(e.chain)}-${e.address}`
  , YRe = (e, t, r, a, s, o, l, d, u) => {
    var p, h, m;
    const {filteredPositions: g, totalValue: x} = c.reduce(Object.values(e), ( (e, n) => {
        if (Hfe(n.chain))
            return e;
        const r = ng(n.tokenAddress)
          , i = n.currentValueInUsdUi;
        return a && (i || 0) < 1 || null === n.tokenInfo || !o && n.isLikelyScam || l && !d.has(tDe(r, n.chain)) || !s && t[kX(r, n.chain)] || (e.filteredPositions.push({
            ...n,
            tokenAddress: r
        }),
        e.totalValue += i || 0),
        e
    }
    ), {
        filteredPositions: [],
        totalValue: 0
    })
      , b = i().subtract(31, "days").unix()
      , f = XRe(u, b)
      , v = ZRe(QRe(u, b))
      , {cumulativeData: S, pieAssetsData: y} = c.reduce(g, ( (e, t) => {
        var r;
        const a = x ? (t.currentValueInUsdUi || 0) / x * 100 : 0;
        if (a >= JRe) {
            const n = {
                address: t.tokenAddress,
                chain: t.chain,
                symbol: (null == (r = t.tokenInfo) ? void 0 : r.symbol) || "",
                percentageValue: a,
                valueInUsd: t.currentValueInUsdUi || 0,
                isCumulative: !1
            };
            e.pieAssetsData[KRe(n)] = n
        } else
            e.cumulativeData = e.cumulativeData ? {
                ...e.cumulativeData,
                percentageValue: e.cumulativeData.percentageValue + a,
                valueInUsd: e.cumulativeData.valueInUsd + (t.currentValueInUsdUi || 0)
            } : {
                address: "OTHER_ASSETS",
                chain: t.chain,
                symbol: n.t("Other assets"),
                percentageValue: a,
                valueInUsd: t.currentValueInUsdUi || 0,
                isCumulative: !0
            };
        return e
    }
    ), {
        cumulativeData: null,
        pieAssetsData: {}
    });
    return {
        pieData: {
            ...y,
            ...S ? {
                [KRe(S)]: S
            } : {}
        },
        pieTotalValue: x,
        pieTotalAssets: g.length,
        selectedPieDailyStats: r ? (null == (p = e[r]) ? void 0 : p.dailyStats) ?? null : null,
        selectedPieSymbol: r ? (null == (m = null == (h = e[r]) ? void 0 : h.tokenInfo) ? void 0 : m.symbol) ?? null : null,
        aggregatedCumulativePnl: v,
        aggregatedDailyPnl: f
    }
}
  , XRe = (e, t) => {
    const n = {};
    return e.forEach((e => {
        if (e.ts < t)
            return;
        const r = e.totalSoldUsd - e.totalBoughtUsd;
        n[e.ts] = (n[e.ts] || 0) + r
    }
    )),
    n
}
  , QRe = (e, t) => {
    const n = XRe(e, t)
      , r = m.sortBy(Object.keys(n), (e => Number(e)))
      , a = {};
    let s = 0;
    return r.forEach((e => {
        s += n[e],
        a[e] = s
    }
    )),
    a
}
  , ZRe = e => {
    const t = m.minBy(Object.keys(e), (e => Number(e)));
    return t && (e[String(Number(t) - 86400)] = 0),
    e
}
  , JRe = 1
  , eDe = (e, t, n) => {
    const r = e.filter((e => [sc.WAITING, sc.EXECUTING].includes(e.currentStateData.status)));
    return fAe(r, t, iAe.OPEN, null, n)
}
  , tDe = (e, t) => `${e}-${t}`
  , nDe = e => c.reduce(e, ( (e, t) => (Object.values(t.perTokenId ?? {}).map((t => {
    t.wasAirdropped || e.add(tDe(ng(t.tokenAddress), t.chain))
}
)),
e)), new Set)
  , rDe = e => e.length ? c.reduce(e, ( (e, t) => (e.totalBalanceInUsd += t.totalBalanceInUsd,
e.totalPnl += t.totalPnl,
e.unrealizedPnl += t.unrealizedPnl,
t.walletTypes.length && !e.walletTypes.includes(t.walletTypes[0]) && (e.walletTypes = [...e.walletTypes, ...t.walletTypes]),
e)), {
    address: "multi",
    name: e.length > 1 ? n.t("{{count}} Wallets Selected", {
        count: e.length
    }) : e[0].name,
    walletId: "multi",
    totalBalanceInUsd: 0,
    totalPnl: 0,
    unrealizedPnl: 0,
    walletTypes: []
}) : null
  , aDe = []
  , sDe = []
  , oDe = y.memo(( ({chain: e, aggregatePositions: t, showScams: n, excludeDust: r, showHidden: a, onlyPurchasedTokens: s}) => {
    const {hiddenPairs: o} = SX()
      , l = Wce()
      , i = pK()
      , d = y.useCallback(( () => {
        i({
            message: uu.nativeMarketClick,
            type: "default"
        }, "portfolio-native-market-click")
    }
    ), [i])
      , u = bw()
      , p = y.useMemo(( () => dge({
        isDesktop: u,
        isOpen: !0,
        onNativeMarketRowClick: d,
        currencyMode: uZ.NATIVE
    })), [u, d])
      , h = y.useCallback((e => {
        ST({
            query: bg(e.chain, e.tokenAddress),
            withDeepCacheWarm: !1
        })
    }
    ), [])
      , m = y.useMemo(( () => oZ("portfolioOpenPositionsV6", u)), [u])
      , g = y.useMemo(( () => s && l ? nDe(l) : new Set), [s, l])
      , {wallets: x} = UD((e => e))
      , b = y.useMemo(( () => x && e ? x.filter((t => !t.isHidden && t.walletType === ED(e))) : aDe), [x, e])
      , f = y.useMemo(( () => b ? b.map((e => e.publicAddress)) : sDe), [b])
      , S = y.useMemo(( () => WRe(o, l, r, a, n, s, g, b)), [o, l, b, r, a, n, s, g])
      , k = y.useMemo(( () => {
        if (!f.length || !S)
            return null;
        const e = c.reduce(f, ( (e, t) => (S[t] && e.push(S[t]),
        e)), []);
        return e.length ? e : null
    }
    ), [S, f])
      , {settings: C} = rf()
      , A = VV(Pd.SOLANA)
      , w = VV(Pd.ETH_MAINNET)
      , j = VV(Pd.BASE)
      , T = VV(Pd.BSC)
      , I = y.useMemo(( () => ({
        [Pd.SOLANA]: A,
        [Pd.ETH_MAINNET]: w,
        [Pd.BASE]: j,
        [Pd.BSC]: T
    })), [j, w, A, T])
      , {displayData: E} = y.useMemo(( () => k && o ? $Re(k, l, o, r, a, n, s, t, g, !0, (null == C ? void 0 : C.markPriceMode) ?? Gh.CURRENT, I, (null == C ? void 0 : C.remainingBasis) ?? qh.MARKET_VALUE) : FRe), [k, o, l, r, a, n, s, t, g, null == C ? void 0 : C.markPriceMode, null == C ? void 0 : C.remainingBasis, I]);
    return v.jsx(yQ, {
        rowData: E,
        isLoading: !1,
        columnDefs: p,
        getRowUniqueId: Sge,
        onRowHover: h,
        ...m
    })
}
))
  , lDe = ({protocol: e, chain: t, baseAddress: n, quoteAddress: r, quoteSymbol: a, tradesLocation: s, devAddress: o, baseDeployedAt: l, toggleTradesLocation: i}) => {
    const c = bw()
      , {showModal: d} = gU()
      , [u,p] = Mx(c ? "padreV2-desktopMarketActivityV2" : "padreV2-mobileMarketActivityV2", c ? hRe : mRe)
      , [h,m] = Mx("padreV2-ordersTableMode", iAe.OPEN);
    y.useEffect(( () => {
        (c ? [...xRe, ...s === XAe.MARKET_ACTIVITY ? [sAe.TRADES] : []] : gRe).includes(u) || p(c ? s === XAe.MARKET_ACTIVITY ? hRe : sAe.OPEN : mRe)
    }
    ), [s, u, c, e, p]);
    const {focusedWalletGroupAddresses: g, focusedWalletGroupAddressesLoading: x} = jwe()
      , [b,f] = Mx("padreV2-marketActivityOtherTokensVisible", !1)
      , k = y.useCallback(( () => {
        f((e => !e))
    }
    ), [f])
      , C = y.useCallback(( (e, t) => {
        p(t)
    }
    ), [p])
      , A = y.useCallback(( () => {
        s !== XAe.PANEL && p(sAe.TRADES)
    }
    ), [p, s])
      , {openOrders: w, areCancelledHidden: j} = _de()
      , T = (null == e ? void 0 : e.type) && ooe.includes(e.type) ? qc : r
      , I = Ode(j ? "history" : "history_full", null, t, b ? null : n, b ? null : T, {
        skip: h !== iAe.HISTORY
    })
      , E = Ode("open", null, t, null, null, {
        skip: !b || h !== iAe.OPEN
    })
      , M = y.useMemo(( () => b ? E : w), [b, E, w])
      , N = y.useMemo(( () => {
        if (!(null == I ? void 0 : I.wrapper) && !(null == M ? void 0 : M.wrapper))
            return null;
        const e = wRe([...Array.from((null == I ? void 0 : I.wrapper.lookup.values()) ?? []), ...Array.from((null == M ? void 0 : M.wrapper.lookup.values()) ?? [])]);
        return Object.values(e)
    }
    ), [null == I ? void 0 : I.wrapper, null == M ? void 0 : M.wrapper])
      , P = r_(N)
      , O = y.useCallback((e => {
        e && d(e.orderId, e.type, e.side, e.orderListId)
    }
    ), [d])
      , [L,R] = y.useMemo(( () => h === iAe.OPEN ? [fAe(Array.from((null == M ? void 0 : M.wrapper.lookup.values()) ?? []), P || [], h, (null == e ? void 0 : e.type) ?? null, new Set), null === M] : h === iAe.HISTORY ? [fAe(Array.from((null == I ? void 0 : I.wrapper.lookup.values()) ?? []), P || [], h, (null == e ? void 0 : e.type) ?? null, new Set), null === I] : [null, !0]), [M, I, h, null == e ? void 0 : e.type, P])
      , D = y.useMemo(( () => {
        return (e = M) ? {
            open: e.wrapper.lookup.size
        } : null;
        var e
    }
    ), [M])
      , B = NA(D, !0)
      , _ = y.useMemo(( () => ( (e, t) => {
        switch (e) {
        case sAe.HISTORY:
        case sAe.OPEN:
            return oAe.ORDERS;
        case sAe.TRADES:
            return oAe.TRADES;
        case sAe.HOLDERS:
            return oAe.HOLDERS;
        case sAe.POSITIONS:
            return oAe.POSITIONS;
        case sAe.TOP_TRADERS:
            return oAe.TOP_TRADERS;
        case sAe.SNIPES:
            return oAe.ORDERS;
        case sAe.DEV_TOKENS:
            return oAe.DEV_TOKENS;
        default:
            return t ? oAe.TRADES : oAe.ORDERS
        }
    }
    )(u, c)), [u, c])
      , U = y.useMemo(( () => (null == D ? void 0 : D.open) ?? (null == B ? void 0 : B.open) ?? null), [null == D ? void 0 : D.open, null == B ? void 0 : B.open])
      , [W,F] = Mx("padreV2-ordersTableTotalMode", lAe.USD)
      , V = y.useCallback(( () => {
        F((e => e === lAe.USD ? lAe.QUOTE : lAe.USD))
    }
    ), [F])
      , H = y.useMemo(( () => c ? _Ae(W, V, !0, a) : DAe), [c, a, W, V])
      , z = y.useMemo(( () => c ? _Ae(W, V, !1, a) : BAe), [c, a, W, V]);
    return v.jsxs(S, {
        "data-testid": "token-section-orders",
        height: "100%",
        mt: cDe,
        mx: dDe,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            justifyContent: "space-between",
            alignItems: "center",
            sx: uDe,
            children: [v.jsx(MRe, {
                baseDeployedAt: l,
                marketActivityMode: u,
                chain: t,
                tradesLocation: s,
                handleModeChange: C
            }), v.jsx(PRe, {
                chain: t,
                setMarketActivityMode: p,
                tradesLocation: s,
                toggleTradesLocation: i
            })]
        }), v.jsx(fRe, {
            devAddress: o,
            tableMode: _,
            tradesLocation: s,
            areOtherTokensVisible: b,
            toggleOtherTokensVisible: k,
            ordersTabMode: h,
            setOrdersTabMode: m,
            openOrdersCount: U
        }), v.jsxs(S, {
            flex: "1 1 100px",
            height: "100%",
            children: [_ === oAe.ORDERS && h === iAe.OPEN && v.jsx(yQ, {
                rowData: L,
                isLoading: R || _ !== oAe.ORDERS,
                columnDefs: H,
                getRowUniqueId: iDe,
                onRowClick: O
            }), _ === oAe.ORDERS && h === iAe.HISTORY && v.jsx(yQ, {
                rowData: L,
                isLoading: R || _ !== oAe.ORDERS,
                columnDefs: z,
                getRowUniqueId: iDe,
                onRowClick: O
            }), _ === oAe.POSITIONS && v.jsx(oDe, {
                chain: t,
                aggregatePositions: !0,
                showScams: !1,
                excludeDust: !0,
                showHidden: !1,
                onlyPurchasedTokens: !0
            }), _ === oAe.TRADES && v.jsx(uRe, {
                chain: t,
                devAddress: null
            }), _ === oAe.HOLDERS && v.jsx(Fje, {
                focusedWalletGroupAddresses: g,
                focusedWalletGroupAddressesLoading: x,
                onFilterCallback: A
            }), _ === oAe.TOP_TRADERS && v.jsx(Wje, {
                focusedWalletGroupAddresses: g,
                focusedWalletGroupAddressesLoading: x,
                isQuote: !(!n || !t) && tu(ng(n), t),
                onFilterCallback: A
            }), _ === oAe.DEV_TOKENS && v.jsx(cJ, {
                chain: t,
                devAddress: o,
                isVisible: !0
            })]
        })]
    })
}
  , iDe = e => e.orderId
  , cDe = {
    xs: -.75,
    md: 0
}
  , dDe = {
    xs: -1.5,
    md: 0
}
  , uDe = e => ({
    pr: {
        xs: .5,
        md: 0
    },
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , pDe = y.memo(( ({address: e, Icon: t, shortcut: n, tooltipTitle: r, devFundTxn: a, chain: s, nameDisplay: o}) => {
    const l = bw()
      , {t: i} = we()
      , c = y.useCallback((t => {
        t.stopPropagation(),
        t.preventDefault(),
        s && e && window.open(jA(e, s) ?? "#", "_blank", "noopener,noreferrer")
    }
    ), [e, s]);
    return v.jsxs(S, {
        sx: hDe,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .25,
            justifyContent: "space-between",
            pr: 1,
            children: [v.jsx(cA, {
                address: e,
                tooltipTitle: r,
                hideIcon: !0,
                containerSx: mDe,
                customLabelComponent: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    children: [v.jsx(t, {
                        size: 14
                    }), v.jsx(k, {
                        variant: "inherit",
                        color: "text.label",
                        minWidth: 24,
                        children: n
                    }), o ?? v.jsx(k, {
                        variant: "inherit",
                        color: "text.value",
                        minWidth: 24,
                        maxWidth: l ? SDe : yDe,
                        overflow: "clip",
                        children: oA(e, {
                            firstPartLength: 19,
                            finalPartLength: 4
                        })
                    })]
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [s && v.jsx(C, {
                    component: "a",
                    href: jA(e, s) ?? "",
                    onClick: c,
                    target: "_blank",
                    sx: CDe,
                    children: v.jsx(tE, {
                        chain: Pd.SOLANA,
                        forceMonochromatic: !0,
                        defaultColor: "inherit",
                        size: kDe
                    })
                }), v.jsx(kle, {
                    address: e,
                    iconSize: kDe
                })]
            })]
        }), a && v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            px: 1,
            pb: .5,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .5,
                children: [v.jsx(GC, {
                    title: i("View funding wallet"),
                    children: v.jsx(C, {
                        component: "span",
                        children: v.jsxs(V, {
                            component: "a",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            href: jA(a.fromAddress, Pd.SOLANA) ?? "#",
                            size: "xxsmall",
                            variant: "tertiary",
                            sx: bDe,
                            children: [a.exchange ? v.jsx(f5, {
                                exchange: a.exchange,
                                size: gDe
                            }) : v.jsx(tE, {
                                chain: Pd.SOLANA
                            }), v.jsx(k, {
                                variant: "inherit",
                                color: "inherit",
                                sx: fDe,
                                children: oA(a.fromAddress)
                            })]
                        })
                    })
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    children: [v.jsx(k, {
                        variant: "paragraph2",
                        color: "text.value",
                        children: UI(a.solAmount.toFixed(3))
                    }), v.jsx(dk, {
                        size: xDe
                    })]
                })]
            }), v.jsx(GC, {
                title: i("View funding transaction"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsxs(V, {
                        component: "a",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        href: AA(a.txnHash, Pd.SOLANA) ?? "#",
                        size: "xxsmall",
                        variant: "tertiary",
                        sx: vDe,
                        children: [v.jsx(Fk, {
                            size: gDe,
                            color: "inherit"
                        }), v.jsx(mE, {
                            ts: a.timestamp,
                            isShort: !0,
                            variant: "paragraph2"
                        })]
                    })
                })
            })]
        })]
    })
}
))
  , hDe = e => ({
    border: `1px solid ${e.palette.background.borderMain}`,
    borderRadius: "4px"
})
  , mDe = e => ({
    height: 32,
    width: "100%",
    justifyContent: "flex-start",
    px: 1,
    "&:hover": {
        background: e.palette.background.buttonHover
    }
})
  , gDe = 14
  , xDe = 12
  , bDe = {
    pr: .5,
    pl: .25,
    ml: -.5,
    gap: .5,
    height: 24,
    background: "transparent"
}
  , fDe = {
    mt: .25
}
  , vDe = {
    px: .5,
    gap: .5,
    mr: -.5,
    height: 24,
    background: "transparent"
}
  , SDe = 205
  , yDe = 215
  , kDe = 16
  , CDe = {
    display: "inline-flex",
    direction: "row",
    alignItems: "center",
    justifyContent: "center",
    height: kDe,
    cursor: "pointer",
    textDecoration: "none",
    color: "text.label",
    transition: "200ms color ease-in-out",
    "&:hover": {
        color: "text.value"
    }
}
  , ADe = y.memo(( ({title: e, valueFormatted: t, color: n="success.main", Icon: r, onClick: a}) => {
    const s = y.useMemo(( () => e => ({
        display: "flex",
        flexDirection: "column",
        border: `1px solid ${e.palette.background.borderMain}`,
        borderRadius: 1,
        gap: .75,
        py: 1,
        px: .25,
        ...a ? {
            "&:hover": {
                cursor: "pointer",
                background: e.palette.background.buttonDefault
            }
        } : {}
    })), [a]);
    return v.jsxs(C, {
        alignItems: "center",
        height: wDe,
        sx: s,
        onClick: a,
        children: [v.jsx(S, {
            height: jDe,
            children: "string" == typeof t ? v.jsxs(S, {
                direction: "row",
                gap: .5,
                alignItems: "center",
                color: n,
                children: [r && v.jsx(r, {
                    size: TDe,
                    color: "inherit"
                }), v.jsx(k, {
                    variant: "paragraph2",
                    color: "inherit",
                    fontSize: 14,
                    noWrap: !0,
                    children: t
                })]
            }) : t
        }), v.jsx(k, {
            textAlign: "center",
            variant: "paragraph2",
            color: "text.label",
            fontSize: 12,
            noWrap: !0,
            lineHeight: 1.1,
            children: e
        })]
    })
}
))
  , wDe = 55
  , jDe = 16
  , TDe = 14
  , IDe = e => null === e ? "text.value" : e ? "success.main" : "error.main"
  , EDe = ({value: e, direction: t, warningThreshold: n, errorThreshold: r, defaultSuccess: a=!1}) => {
    if (null === e)
        return "text.value";
    switch (t) {
    case "asc":
        return void 0 !== r && e >= r ? "error.main" : void 0 !== n && e >= n ? "warning.main" : a ? "success.main" : "text.value";
    case "desc":
        return void 0 !== n && e <= n ? "warning.main" : void 0 !== r && e <= r ? "error.main" : a ? "success.main" : "text.value"
    }
}
  , MDe = e => e ? "Yes" : "No"
  , NDe = [ud, zd, Vd, Qd, $d, Gd, qd, Kd, Yd, Xd, ..._1]
  , PDe = y.memo(( () => {
    const {t: e} = we()
      , t = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.deployerHoldingPcnt) ?? null
    }
    ))
      , n = y.useMemo(( () => EDe({
        value: t,
        direction: "asc",
        warningThreshold: 20,
        errorThreshold: 50
    })), [t])
      , r = y.useMemo(( () => null !== t ? jI(t, {
        omitSign: !0,
        precision: 0 === t || t >= 100 || t < .01 ? 0 : t >= 10 ? 1 : 2
    }) : Ud), [t]);
    return v.jsx(ADe, {
        title: e("Dev holding"),
        valueFormatted: r,
        Icon: Vv,
        color: "text.value" === n ? "success.main" : n
    })
}
))
  , ODe = y.memo(( ({unableToSell: e}) => {
    const {t: t} = we();
    return v.jsx(ADe, {
        title: t("Can't Sell"),
        valueFormatted: e ? e.count.toString() : Ud,
        Icon: Uy,
        color: e ? e.count > 0 ? "error.main" : "success.main" : "text.value"
    })
}
))
  , LDe = y.memo(( ({title: e, tax: t}) => {
    const n = y.useMemo(( () => cTe(t, !0)), [t]);
    return v.jsx(ADe, {
        title: e,
        valueFormatted: null === t ? Ud : `${t}%`,
        color: n
    })
}
))
  , RDe = y.memo(( ({marketAddress: e, chain: t, approxLastBoostTs: n, totalAmount: r}) => {
    const {t: a} = we()
      , s = D()
      , o = y.useMemo(( () => r > 0 ? s.palette.gold[500] : s.palette.text.value), [s.palette.gold, s.palette.text.value, r])
      , l = OI(r, {
        collapseExponent: !0,
        symbol: "",
        precision: r >= 1e3 ? 1 : 0
    })
      , i = y.useMemo(( () => TA(t, e)), [t, e])
      , c = y.useCallback(( () => {
        i && window.open(i, "_blank", "noopener,noreferrer")
    }
    ), [i])
      , d = y.useMemo(( () => r ? v.jsxs(S, {
        gap: .5,
        alignItems: "center",
        direction: "row",
        children: [v.jsxs(S, {
            direction: "row",
            gap: .25,
            alignItems: "center",
            color: o,
            height: DDe,
            children: [v.jsx(ay, {
                size: BDe,
                color: "inherit"
            }), v.jsx(k, {
                color: "inherit",
                variant: "paragraph2",
                height: DDe,
                children: l
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: _De
        }), v.jsx(mE, {
            variant: "paragraph2",
            color: "text.label",
            ts: n ?? null,
            isShort: !0,
            height: DDe
        })]
    }) : l), [n, o, r, l]);
    return v.jsx(ADe, {
        title: a("Dex Boost"),
        valueFormatted: d,
        Icon: OS,
        onClick: i ? c : void 0,
        color: o
    })
}
))
  , DDe = 14
  , BDe = DDe
  , _De = {
    my: .25
}
  , UDe = y.memo(( ({isFreshHoldingsExact: e, freshWalletsPercentage: t}) => {
    const {t: n} = we()
      , r = null === t ? Ud : `${e ? "" : "> "}${jI(t, {
        omitSign: !0,
        precision: 0 === t || t >= 100 ? 0 : t >= 10 ? 1 : 0
    })}`;
    return v.jsx(ADe, {
        title: n("Fresh holding"),
        valueFormatted: r,
        Icon: Mf
    })
}
))
  , WDe = y.memo(( ({value: e, title: t, reverseColor: n=!1}) => v.jsx(ADe, {
    title: t,
    valueFormatted: null === e ? Ud : MDe(e),
    color: IDe(n ? !e : e)
})))
  , FDe = y.memo(( ({top10HoldingsPercentageSum: e}) => {
    const {t: t} = we()
      , n = y.useMemo(( () => EDe({
        value: e,
        direction: "asc",
        warningThreshold: 10,
        errorThreshold: 40
    })), [e])
      , r = null !== e ? jI(e, {
        omitSign: !0,
        precision: 0 === e || e >= 100 ? 0 : e >= 10 ? 1 : 0
    }) : null;
    return v.jsx(ADe, {
        title: t("Top 10 H."),
        valueFormatted: r ?? Ud,
        Icon: CS,
        color: "text.value" === n ? "success.main" : n
    })
}
))
  , VDe = y.memo(( ({insidersHoldingPcnt: e}) => {
    const {t: t} = we()
      , n = y.useMemo(( () => EDe({
        value: e,
        direction: "asc",
        warningThreshold: 5,
        errorThreshold: 10,
        defaultSuccess: !0
    })), [e])
      , r = jI(e, {
        omitSign: !0,
        precision: 0 === e || e >= 100 ? 0 : e >= 10 ? 1 : 0
    });
    return v.jsx(ADe, {
        title: t("Insiders H."),
        valueFormatted: r,
        Icon: _v,
        color: n
    })
}
));
y.memo(( ({sol: e}) => {
    const {t: t} = we()
      , n = NI(e, {
        symbol: "",
        removeTrailingZerosPrecision: e >= 100 ? 0 : 1
    });
    return v.jsx(ADe, {
        title: t("Fresh total"),
        valueFormatted: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .25,
            color: "success.main",
            children: [v.jsx(k, {
                variant: "paragraph2",
                color: "inherit",
                fontSize: 14,
                noWrap: !0,
                children: n
            }), v.jsx(dk, {
                size: 15,
                color: "inherit"
            })]
        })
    })
}
));
const HDe = y.memo(( ({count: e}) => {
    const {t: t} = we()
      , n = NI(e, {
        symbol: "",
        precision: 0
    });
    return v.jsx(ADe, {
        title: t("Fresh buys"),
        valueFormatted: n,
        Icon: Mf
    })
}
))
  , zDe = y.memo(( ({totalSupply: e, bundlesHoldingPcntCurrent: t, totalBundlesCount: n, totalSolSpentInBundles: r, totalTokenBoughtInBundles: a}) => {
    const {t: s} = we()
      , o = y.useMemo(( () => EDe({
        value: t ?? 0,
        direction: "asc",
        warningThreshold: 5,
        errorThreshold: 10,
        defaultSuccess: !0
    })), [t])
      , l = y.useMemo(( () => null === t ? Ud : jI(t, {
        omitSign: !0,
        precision: 0 === t || t >= 100 ? 0 : t >= 10 ? 1 : 0
    })), [t])
      , i = y.useMemo(( () => v.jsxs(S, {
        minWidth: 150,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: s("Total bundles")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: null !== n ? n.toFixed(0) : Ud
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: s("Bundled SOL")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .25,
                    children: [v.jsx(dk, {}), null === r ? Ud : OI(r, {
                        collapseExponent: !0,
                        symbol: ""
                    })]
                })
            })]
        }), v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: s("Bundled token")
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                children: null !== a && e ? jI(a / e * 100, {
                    omitSign: !0
                }) : Ud
            })]
        })]
    })), [s, n, r, a, e])
      , c = null !== t ? v.jsx(GC, {
        title: i,
        disableInteractive: !1,
        children: v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            sx: GDe,
            children: [v.jsx(Uv, {
                size: $De
            }), v.jsx(k, {
                variant: "paragraph2",
                color: "inherit",
                children: l
            })]
        })
    }) : Ud;
    return v.jsx(ADe, {
        title: s("Bundles H."),
        valueFormatted: c,
        Icon: Uv,
        color: o
    })
}
))
  , $De = 12
  , GDe = {
    gap: .5,
    "&:hover": {
        cursor: "help"
    }
}
  , qDe = y.memo(( ({clogPcnt: e}) => {
    const {t: t} = we();
    return v.jsx(ADe, {
        title: t("Clog"),
        valueFormatted: null === e ? Ud : `${e.toFixed(2)}%`,
        color: (n = e,
        null === n ? "text.value" : n >= 1 ? "warning.main" : "text.value")
    });
    var n
}
))
  , KDe = y.memo(( ({totalBurnedLiqudity: e}) => {
    const {t: t} = we()
      , n = null === e ? Ud : `${e.toFixed(e >= 100 ? 0 : e >= 10 ? 1 : 2)}%`;
    return v.jsx(ADe, {
        title: t("Locked Liq."),
        valueFormatted: n,
        Icon: Wf,
        color: (r = e,
        null === r ? "text.value" : r >= 95 ? "success.main" : r >= 50 ? "text.value" : r > 10 ? "warning.main" : "error.main")
    });
    var r
}
))
  , YDe = y.memo(( ({amount: e, decimals: t, symbol: n, title: r}) => {
    const a = e && !m.isNil(t) ? LI(Number(new sB({
        decimals: t
    },BigInt(e ?? "0")).toExact()), {
        collapseExponent: !0,
        symbol: iu(n, 12),
        desiredDigits: 2
    }) : Ud;
    return v.jsx(ADe, {
        title: r,
        valueFormatted: a
    })
}
))
  , XDe = y.memo(( ({burnedLiqudity: e}) => {
    const {t: t} = we();
    return v.jsx(ADe, {
        title: t("Burned Liq."),
        valueFormatted: null === e ? Ud : `${e.toFixed(e >= 10 ? 0 : 1)}%`,
        Icon: NS
    })
}
))
  , QDe = y.memo(( ({percentValue: e, totalCount: t}) => {
    const {t: n} = we()
      , r = D()
      , a = e >= JDe ? r.palette.error.main : r.palette.success.main
      , s = v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .75,
        children: [v.jsx(k, {
            variant: "paragraph2",
            color: a,
            children: jI(e, {
                precision: 0,
                omitSign: !0
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            orientation: "vertical",
            sx: ZDe
        }), v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: t
        })]
    });
    return v.jsx(ADe, {
        title: n("Snipers"),
        valueFormatted: s,
        Icon: ES,
        color: a
    })
}
))
  , ZDe = {
    my: .25
}
  , JDe = 5
  , eBe = y.memo(( () => {
    var e;
    const {t: t} = we()
      , n = bw()
      , {originalMarketId: r, originalStaticMarketInfo: a} = Qce()
      , {data: s} = Hwe(r, Tve((null == a ? void 0 : a.baseToken.address) ?? null), null)
      , o = PA({
        refreshRate: 52312,
        immediateRunAfterPageBecomesVisible: !0
    })
      , l = dde(a)
      , i = y.useMemo(( () => {
        if (!l)
            return null;
        return mg(l).marketAddress
    }
    ), [l])
      , d = (null == a ? void 0 : a.chain) ?? null
      , u = (null == a ? void 0 : a.baseToken.deployer) ?? null
      , p = (null == a ? void 0 : a.baseToken.address) ?? null
      , [h,m] = Mx("padreV2-dataSecurityExpandedV2", !0)
      , g = y.useCallback(( () => m((e => !e))), [m])
      , x = y.useMemo(( () => e => ({
        minHeight: 44,
        maxHeight: 44,
        borderBottom: `1px solid ${h ? e.palette.background.borderMain : "transparent"}`,
        transition: "border-color 0.3s ease"
    })), [h])
      , b = yde()
      , f = vde()
      , C = fde()
      , A = wde()
      , w = jde()
      , j = Zce((e => {
        var t, n, r;
        return (null == (t = e.marketStats) ? void 0 : t.baseTokenTaxes) ? (null == (r = null == (n = e.marketStats) ? void 0 : n.baseTokenTaxes) ? void 0 : r.transferPercent) ?? null : null
    }
    ))
      , T = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.baseTokenAudit) ?? null
    }
    ), c.isEqual)
      , I = Zce((e => {
        var t;
        return (null == (t = e.marketStats) ? void 0 : t.clogPcnt) ?? null
    }
    ))
      , {data: E} = Hwe(r, Tde(), null)
      , {isFreshHoldingsExact: M, freshWalletsPercentage: N, top10HoldingsPercentageSum: P} = y.useMemo(( () => {
        if (!a || !f || !i)
            return {
                freshWalletsPercentage: null,
                top10HoldingsPercentageSum: null,
                isFreshHoldingsExact: !0
            };
        const e = ( (e, t, n, r, a, s, o) => {
            if (!n || !r)
                return {
                    top10HoldingsPercentageSum: null,
                    freshWalletsPercentage: null,
                    isFreshHoldingsExact: !0
                };
            const l = ng(e)
              , i = ng(a)
              , d = n.queue.getTopN(50).filter((e => {
                const t = ng(e.walletAddress);
                return t !== l && t !== i && !s.has(t) && !NDe.includes(t)
            }
            ))
              , u = Number(new sB({
                decimals: t
            },BigInt(r ?? "0")).toExact())
              , p = d.map((e => {
                const n = Number(new sB({
                    decimals: t
                },BigInt(e.amountString ?? "0")).toNumber().toFixed(0));
                return isNaN(u) || 0 === u ? 0 : n / u * 100
            }
            )).sort(( (e, t) => t - e)).slice(0, 10)
              , h = Math.min(c.sum(p), 100)
              , m = n.queue.getTopN(50).map((e => {
                const n = Number(new sB({
                    decimals: t
                },BigInt(e.amountString ?? "0")).toNumber().toFixed(0));
                return isNaN(u) || 0 === u ? 0 : n / u * 100
            }
            ))
              , g = Math.min(c.sum(m), 100);
            return {
                top10HoldingsPercentageSum: h,
                freshWalletsPercentage: c.reduce(d, ( (e, n) => {
                    if (!n.activationTimestamp)
                        return e;
                    if (!(Math.max(o - n.activationTimestamp, 0) < 10800))
                        return e;
                    const r = Number(new sB({
                        decimals: t
                    },BigInt(n.amountString ?? "0")).toNumber().toFixed(0));
                    return e + (isNaN(u) || 0 === u ? 0 : r / u * 100)
                }
                ), 0),
                isFreshHoldingsExact: g >= 99 || n.queue.length < 50
            }
        }
        )(a.baseToken.address, a.baseToken.decimals, s, f, i, new Set(C ?? []), o.unix());
        return e
    }
    ), [f, C, o, i, a, s])
      , O = Zce((e => e.marketStats && e.marketStats.liquidityLock ? Math.min(100, (e.marketStats.liquidityLock.lockedPcnt || 0) + (e.marketStats.burnedLiquidityPcnt || 0)) : null))
      , L = Mde()
      , R = y.useMemo(( () => v.jsx(Wn, {
        expandIcon: rBe,
        sx: x,
        children: v.jsx(k, {
            variant: "paragraph1",
            color: "text.value",
            children: t("Token Data & Security")
        })
    })), [x, t]);
    return v.jsx(S, {
        mr: n ? -1.75 : -1,
        ml: n ? -2 : -1,
        children: v.jsxs(Un, {
            disableGutters: !0,
            onChange: g,
            expanded: h,
            square: !0,
            sx: aBe,
            children: [R, v.jsx(Fn, {
                sx: nBe,
                children: v.jsxs(S, {
                    pb: 2,
                    children: [v.jsxs(S, {
                        display: "grid",
                        gridTemplateColumns: "repeat(3, 1fr)",
                        gap: 2,
                        p: 2,
                        overflow: "clip",
                        children: [v.jsx(FDe, {
                            top10HoldingsPercentageSum: P
                        }), v.jsx(PDe, {}), d === Pd.SOLANA && E && v.jsx(QDe, {
                            percentValue: E.snipersHoldingPcnt,
                            totalCount: E.totalSnipers
                        }), void 0 !== (null == E ? void 0 : E.insidersHoldingPcnt) && v.jsx(VDe, {
                            insidersHoldingPcnt: E.insidersHoldingPcnt
                        }), v.jsx(zDe, {
                            totalSupply: (null == E ? void 0 : E.totalSupply) ?? null,
                            bundlesHoldingPcntCurrent: (null == (e = null == E ? void 0 : E.bundlesHoldingPcnt) ? void 0 : e.current) ?? null,
                            totalBundlesCount: (null == E ? void 0 : E.totalBundlesCount) ?? null,
                            totalSolSpentInBundles: (null == E ? void 0 : E.totalSolSpentInBundles) ?? null,
                            totalTokenBoughtInBundles: (null == E ? void 0 : E.totalTokenBoughtInBundles) ?? null
                        }), T && T.chain !== Pd.SOLANA && v.jsxs(v.Fragment, {
                            children: [v.jsx(ODe, {
                                unableToSell: T.unableToSell
                            }), v.jsx(LDe, {
                                title: t("Buy Tax"),
                                tax: A ? Number(A) : null
                            }), v.jsx(LDe, {
                                title: t("Sell Tax"),
                                tax: w ? Number(w) : null
                            }), v.jsx(LDe, {
                                title: t("Transfer Tax"),
                                tax: j ? Number(j) : null
                            }), v.jsx(qDe, {
                                clogPcnt: I ?? null
                            }), v.jsx(KDe, {
                                totalBurnedLiqudity: O
                            }), v.jsx(WDe, {
                                value: T.isOpenSource,
                                title: t("Open Source")
                            }), v.jsx(WDe, {
                                value: T.isOwnerRenounced,
                                title: t("Renounced")
                            }), a && v.jsxs(v.Fragment, {
                                children: [v.jsx(YDe, {
                                    amount: T.maxBuyTokenRawAmount,
                                    decimals: a.baseToken.decimals,
                                    symbol: a.baseToken.symbol,
                                    title: t("Max buy")
                                }), v.jsx(YDe, {
                                    amount: T.maxSellTokenRawAmount,
                                    decimals: a.baseToken.decimals,
                                    symbol: a.baseToken.symbol,
                                    title: t("Max sell")
                                })]
                            })]
                        }), (null == T ? void 0 : T.chain) === Pd.SOLANA && 100 === L && v.jsx(XDe, {
                            burnedLiqudity: L
                        }), a && d === Pd.SOLANA && i && b && v.jsx(RDe, {
                            marketAddress: i,
                            chain: b.chain,
                            approxLastBoostTs: b.approxLastBoostTs,
                            totalAmount: b.totalAmount
                        }), (null == E ? void 0 : E.freshWalletBuys) && v.jsx(HDe, {
                            count: E.freshWalletBuys.count
                        }), d === Pd.SOLANA && v.jsx(UDe, {
                            isFreshHoldingsExact: M,
                            freshWalletsPercentage: N
                        }), (null == T ? void 0 : T.chain) === Pd.SOLANA && v.jsx(WDe, {
                            value: T.isMintAuthorityEnabled,
                            title: t("Mint Auth."),
                            reverseColor: !0
                        }), (null == T ? void 0 : T.chain) === Pd.SOLANA && v.jsx(WDe, {
                            value: T.isFreezeAuthorityEnabled,
                            title: t("Freeze Auth."),
                            reverseColor: !0
                        })]
                    }), v.jsx(tBe, {
                        chain: d,
                        displayedCreatorAddress: (null == E ? void 0 : E.displayedCreatorAddress) ?? null,
                        contractAddress: p,
                        deployer: u ?? (null == T ? void 0 : T.deployerAddress) ?? null,
                        devFundTxn: (null == E ? void 0 : E.devFundTxn) ?? null
                    })]
                })
            })]
        })
    })
}
))
  , tBe = y.memo(( ({chain: e, contractAddress: t, deployer: n, displayedCreatorAddress: r, devFundTxn: a}) => {
    const {t: s} = we()
      , {customWalletNames: o, customWalletEmojis: l} = rf()
      , i = y.useMemo(( () => {
        if (!n)
            return;
        const e = o[n] ?? null
          , t = l[n] ?? null;
        return e || t ? v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(ZT, {
                emoji: t ?? rI,
                size: 14
            }), v.jsx(k, {
                variant: "inherit",
                color: "warning.main",
                fontWeight: 600,
                minWidth: 24,
                noWrap: !0,
                children: e ? e.slice(0, 30) : oA(n, {
                    firstPartLength: 22,
                    finalPartLength: 4
                })
            })]
        }) : void 0
    }
    ), [l, o, n]);
    return v.jsxs(S, {
        px: 2,
        gap: 2,
        width: "100%",
        children: [t && v.jsx(pDe, {
            address: t,
            Icon: gk,
            shortcut: "CA:",
            tooltipTitle: s("Copy contract address"),
            devFundTxn: null,
            chain: e
        }), r && e === Pd.SOLANA && v.jsx(pDe, {
            address: r,
            Icon: vf,
            shortcut: "CR:",
            tooltipTitle: s("Copy creator address"),
            devFundTxn: null,
            chain: e
        }), n && v.jsx(pDe, {
            address: n,
            Icon: Vv,
            shortcut: "DA:",
            tooltipTitle: s("Copy dev address"),
            devFundTxn: a,
            nameDisplay: i,
            chain: e
        })]
    })
}
))
  , nBe = {
    p: 0
}
  , rBe = v.jsx(Sy, {
    size: 16
})
  , aBe = e => ({
    backgroundColor: "transparent",
    boxShadow: "none",
    borderRadius: 0,
    border: "none",
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:before": {
        display: "none"
    }
})
  , sBe = y.memo(( () => {
    const {t: e} = we()
      , t = bw()
      , n = kde()
      , [r,a] = Mx("padreV2-dexBannedExpanded", !1)
      , s = y.useCallback(( () => a((e => !e))), [a]);
    return (null == n ? void 0 : n.dexBannerUrl) ? v.jsx(S, {
        mr: t ? -1.75 : -1,
        ml: t ? -2 : -1,
        children: v.jsxs(Un, {
            disableGutters: !0,
            onChange: s,
            expanded: r,
            square: !0,
            sx: iBe,
            children: [v.jsx(Wn, {
                expandIcon: lBe,
                sx: cBe,
                children: v.jsx(S, {
                    width: "100%",
                    direction: "row",
                    alignItems: "center",
                    children: v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        children: e("Token Banner")
                    })
                })
            }), v.jsx(Fn, {
                sx: oBe,
                children: v.jsx(S, {
                    px: 2,
                    pb: 2,
                    children: v.jsx(uE, {
                        bannerUrl: n.dexBannerUrl
                    })
                })
            })]
        })
    }) : null
}
))
  , oBe = {
    p: 0
}
  , lBe = v.jsx(Sy, {
    size: 16
})
  , iBe = e => ({
    backgroundColor: "transparent",
    boxShadow: "none",
    borderRadius: 0,
    border: "none",
    borderTop: "none",
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    "&:before": {
        display: "none"
    }
})
  , cBe = {
    minHeight: 44,
    maxHeight: 44
}
  , dBe = y.memo(( ({pricePercentChange: e}) => {
    const t = D()
      , {colorSkin: n} = Vb()
      , [r,a,s] = y.useMemo(( () => {
        if (null === e)
            return [null, null, null];
        const t = Number(e.toFixed(1));
        return [jI(t, {
            precision: 1,
            collapseExponent: t > 1e5
        }), t > 0, t < 0]
    }
    ), [e]);
    return v.jsx(k, {
        variant: "paragraph3",
        color: r === mBe ? "text.value" : a ? n === rg.PURPLE ? t.palette.primary[300] : t.palette.positive[500] : s ? t.palette.negative[500] : "text.value",
        minWidth: hBe,
        display: "flex",
        justifyContent: "center",
        children: null === r ? v.jsx(Ie, {
            width: uBe,
            height: pBe
        }) : v.jsx(S, {
            direction: "row",
            gap: .5,
            alignItems: "center",
            ml: r === mBe ? .5 : 0,
            children: r
        })
    })
}
))
  , uBe = 32
  , pBe = 12
  , hBe = 46
  , mBe = "0.0"
  , gBe = y.memo(( ({header: e, value: t, showSolanaIcon: n, showBscIcon: r, valueTypographyOverides: a}) => v.jsxs(S, {
    gap: .5,
    py: .75,
    textAlign: "center",
    children: [v.jsx(k, {
        variant: "paragraph3",
        color: "text.label",
        whiteSpace: "nowrap",
        position: "relative",
        zIndex: 1,
        ...Nu,
        children: e
    }), "string" == typeof t ? v.jsxs(k, {
        variant: "paragraph3",
        color: "text.value",
        whiteSpace: "nowrap",
        ...Nu,
        sx: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: xBe
        },
        ...a,
        children: [t, n && v.jsx(dk, {
            size: xBe
        }), r && v.jsx(C, {
            display: "flex",
            mt: "-1px",
            children: v.jsx(ak, {
                size: xBe
            })
        })]
    }) : t]
})))
  , xBe = 14
  , bBe = ["m5", "h1", "h6", "h24"]
  , fBe = {
    m5: "5M",
    h1: "1H",
    h6: "6H",
    h24: "24H"
}
  , vBe = (e, t) => {
    const n = e => {
        return n = t,
        r = e,
        c.isNil(n) || c.isNil(r) || 0 === r ? 0 : (n - r) / r * 100;
        var n, r
    }
    ;
    return {
        m5: n(e.m5.lastPriceUsd),
        h1: n(e.h1.lastPriceUsd),
        h6: n(e.h6.lastPriceUsd),
        h24: n(e.h24.lastPriceUsd)
    }
}
  , SBe = bBe.map((e => ({
    value: e,
    label: fBe[e]
})));
const yBe = y.memo(( ({timespan: e, handleTimestampChange: t, handleRepeatClick: n, volumeInUsd: r, netVol: a, buys: s, sells: o, buysVolume: l, sellsVolume: i, priceInUsdChangePercent: c, isCollapsed: d}) => {
    const {t: u} = we()
      , p = y.useMemo(( () => jBe(d)), [d])
      , h = y.useMemo(( () => e => ({
        borderTop: `1px solid ${e.palette.background.borderMain}`,
        mx: -2
    })), [])
      , m = y.useCallback((e => {
        const t = e.nativeEvent.composedPath()
          , r = t.indexOf(e.currentTarget);
        for (let a = 0; a < r; a++) {
            const e = t[a];
            if (e instanceof HTMLElement && "true" === e.getAttribute("aria-selected")) {
                n();
                break
            }
        }
    }
    ), [n]);
    return v.jsxs(S, {
        "data-testid": "token-section-overview",
        sx: h,
        children: [v.jsx(ee, {
            elevation: 1,
            sx: ABe,
            children: v.jsx(ot, {
                value: !d && e,
                onChange: t,
                onClick: m,
                TabIndicatorProps: TBe,
                sx: wBe,
                children: SBe.map((e => v.jsx(lt, {
                    sx: p,
                    label: v.jsxs(S, {
                        gap: .25,
                        ...Nu,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: e.label
                        }), v.jsx(dBe, {
                            pricePercentChange: null !== c ? c[e.value] : null
                        })]
                    }),
                    value: e.value
                }, e.value)))
            })
        }), !d && (null === s || null === o || null === r ? v.jsx(S, {
            children: v.jsx(Ie, {
                variant: "rectangular",
                sx: IBe,
                height: CBe
            })
        }) : v.jsxs(S, {
            direction: "column",
            width: "100%",
            pt: .5,
            children: [v.jsxs(S, {
                gap: 2,
                direction: "row",
                minWidth: kBe,
                justifyContent: "space-evenly",
                children: [v.jsx(gBe, {
                    header: u("Volume"),
                    value: OI(r, {
                        collapseExponent: !0
                    })
                }), v.jsx(gBe, {
                    header: u("Buys"),
                    value: v.jsxs(S, {
                        height: 14,
                        alignItems: "center",
                        direction: "row",
                        gap: "1px",
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "success.main",
                            children: s > 1e3 ? LI(s, {
                                collapseExponent: !0,
                                symbol: "",
                                desiredDigits: 3
                            }) : s
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: "/"
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: "success.main",
                            children: null === l ? Ud : LI(l, {
                                collapseExponent: !0,
                                symbol: "$",
                                symbolPosition: yI.START,
                                padSymbol: !1,
                                desiredDigits: 3
                            })
                        })]
                    })
                }), v.jsx(gBe, {
                    header: u("Sells"),
                    value: v.jsxs(S, {
                        height: 14,
                        alignItems: "center",
                        direction: "row",
                        gap: "1px",
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "error.main",
                            children: o > 1e3 ? LI(o, {
                                collapseExponent: !0,
                                symbol: "",
                                desiredDigits: 3
                            }) : o
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            children: "/"
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: "error.main",
                            children: null === i ? Ud : LI(i, {
                                collapseExponent: !0,
                                symbol: "$",
                                symbolPosition: yI.START,
                                padSymbol: !1,
                                desiredDigits: 3
                            })
                        })]
                    })
                }), v.jsx(gBe, {
                    header: u("Net Vol."),
                    value: v.jsx(RZ, {
                        value: a ?? 0,
                        formattedDisplay: null !== a ? `${0 === a ? "" : a > 0 ? "+" : "-"}${LI(Math.abs(a), {
                            collapseExponent: !0,
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            symbol: "$",
                            desiredDigits: 3
                        })}` : Ud
                    })
                })]
            }), v.jsx(S, {
                px: 1,
                flexGrow: 1,
                children: v.jsx(woe, {
                    leftWeight: {
                        value: Number(l)
                    },
                    rightWeight: {
                        value: Number(i)
                    },
                    barHeight: "2px"
                })
            })]
        }))]
    })
}
), ( (e, t) => c.isEqual(e, t)))
  , kBe = 80
  , CBe = 66
  , ABe = {
    borderInline: 0,
    borderBottom: 0,
    boxShadow: 0
}
  , wBe = {
    minHeight: 0,
    border: "none"
}
  , jBe = e => t => ({
    minHeight: e ? 40 : 41,
    borderLeft: `1px solid ${t.palette.background.borderMain}`,
    borderRight: `1px solid ${t.palette.background.borderMain}`,
    borderRadius: 0,
    borderBottom: e ? "none" : `1px solid ${t.palette.background.borderMain}`,
    borderTop: "none",
    flex: "1 0 0",
    minWidth: 0,
    maxWidth: "none",
    py: .5,
    backgroundColor: t.palette.background.primary,
    "&:not(:last-of-type)": {
        borderRight: "none"
    },
    "&:first-of-type": {
        borderLeft: "none"
    },
    "&:last-of-type": {
        borderRight: "none"
    },
    "&.Mui-selected": {
        backgroundColor: t.palette.background.buttonDefault
    },
    "&:hover": {
        backgroundColor: t.palette.background.buttonDefault,
        borderRadius: 0
    }
})
  , TBe = {
    sx: {
        height: 0
    }
}
  , IBe = {
    borderRadius: 0
}
  , EBe = y.memo(( ({symbol: e, name: t, tokenAddress: n, createdAt: r, chain: a, launchpad: s, launchpadAux: o, liquidityInUsd: l, vol1hInUsd: i, fdvUsd: d, isMigration: u, protocol: p}) => {
    const {t: h} = we()
      , m = yT()
      , g = y.useMemo(( () => v$(p.type, c.isNil(s) ? null : s, c.isNil(o) ? null : o, a, u)), [a, u, s, o, p.type])
      , x = y.useCallback((e => {
        if (0 === e.button && !e.metaKey && !e.ctrlKey)
            return e.preventDefault(),
            e.stopPropagation(),
            m({
                chain: a,
                tokenAddress: n,
                tradePageOrigin: nT.SIMILAR_TOKENS
            }),
            !1
    }
    ), [m, a, n])
      , [b,f] = JC(!1, OBe)
      , [A,w] = JC(!1, OBe)
      , j = y.useCallback((t => {
        t.stopPropagation(),
        QC && (ZC(e),
        f(!0))
    }
    ), [e, f])
      , T = y.useCallback((e => {
        e.stopPropagation(),
        QC && (ZC(n),
        w(!0))
    }
    ), [n, w])
      , {marketCapThresholds: I} = bA()
      , {marketCapColor: E} = Xoe(null === d || isNaN(Number(d)) ? 0 : Number(d), 1, I);
    return v.jsxs(C, {
        display: "flex",
        onClick: x,
        sx: NBe,
        gap: 1.25,
        children: [v.jsx(C, {
            display: "flex",
            height: MBe,
            children: v.jsx(b_, {
                size: MBe,
                url: IE(a, n),
                name: t,
                chain: a,
                padreAvatarUrl: null,
                protocolInfo: g,
                hideBorder: !0,
                showLens: !0
            })
        }), v.jsxs(S, {
            gap: .5,
            width: "100%",
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                children: [v.jsxs(S, {
                    direction: "row",
                    gap: .5,
                    alignItems: "center",
                    maxWidth: 165,
                    children: [v.jsx(GC, {
                        title: b ? v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            ...Nu,
                            children: [h("Copied"), v.jsx(G, {
                                sx: LBe,
                                color: "success"
                            })]
                        }) : t,
                        children: v.jsx(k, {
                            variant: "h2",
                            height: 16,
                            color: "text.value",
                            ...Nu,
                            noWrap: !0,
                            fontWeight: 500,
                            onClick: j,
                            sx: RBe,
                            children: e
                        })
                    }), v.jsx(GC, {
                        title: A ? v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .5,
                            ...Nu,
                            children: ["Copied", v.jsx(G, {
                                sx: LBe,
                                color: "success"
                            })]
                        }) : `Copy ${oA(n)}`,
                        children: v.jsx(k, {
                            variant: "h2",
                            height: 16,
                            color: "text.label",
                            ...Nu,
                            fontWeight: 400,
                            onClick: T,
                            noWrap: !0,
                            sx: DBe,
                            children: t
                        })
                    })]
                }), v.jsx(GC, {
                    title: h("Liquidity"),
                    children: v.jsxs(S, {
                        direction: "row",
                        alignItems: "center",
                        gap: .25,
                        children: [v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.value",
                            children: isNaN(Number(l)) ? Ud : LI(Number(l), {
                                collapseExponent: !0,
                                maxPrecision: 0,
                                minPrecision: 0,
                                symbol: "$",
                                padSymbol: !1,
                                symbolPosition: yI.START
                            })
                        }), v.jsx(k, {
                            variant: "paragraph1",
                            color: "text.label",
                            minWidth: PBe,
                            textAlign: "right",
                            children: "Liq"
                        })]
                    })
                })]
            }), v.jsxs(S, {
                gap: .75,
                width: "100%",
                children: [v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "flex-end",
                    children: v.jsx(GC, {
                        title: h("1H Volume"),
                        children: v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .25,
                            children: [v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.value",
                                children: isNaN(Number(i)) ? Ud : LI(Number(i), {
                                    collapseExponent: !0,
                                    maxPrecision: 0,
                                    minPrecision: 0,
                                    symbol: "$",
                                    padSymbol: !1,
                                    symbolPosition: yI.START
                                })
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                minWidth: PBe,
                                textAlign: "right",
                                children: "Vol"
                            })]
                        })
                    })
                }), v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    children: [v.jsx(mE, {
                        variant: "paragraph1",
                        ts: r,
                        isShort: !0
                    }), v.jsx(GC, {
                        title: h("Market Cap"),
                        children: v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            gap: .25,
                            children: [v.jsx(k, {
                                variant: "paragraph1",
                                color: E ?? "text.value",
                                children: !d || isNaN(Number(d)) ? Ud : LI(Number(d), {
                                    collapseExponent: !0,
                                    maxPrecision: 0,
                                    minPrecision: 0,
                                    symbol: "$",
                                    padSymbol: !1,
                                    symbolPosition: yI.START
                                })
                            }), v.jsx(k, {
                                variant: "paragraph1",
                                color: "text.label",
                                minWidth: PBe,
                                textAlign: "right",
                                children: "MC"
                            })]
                        })
                    })]
                })]
            })]
        })]
    })
}
))
  , MBe = 50
  , NBe = e => ({
    borderRadius: 1,
    p: 1,
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:hover": {
        background: e.palette.background.buttonDefault,
        cursor: "pointer"
    }
})
  , PBe = 22
  , OBe = 6e3
  , LBe = {
    fontSize: "1.5em"
}
  , RBe = {
    flexGrow: 0
}
  , DBe = {
    flex: 1
}
  , BBe = (e, t, n) => `${e}-${t}-${n}`
  , _Be = 5
  , UBe = async (e, t, n) => {
    const r = new Promise(( (e, t) => setTimeout(( () => t([])), WBe)))
      , a = q$(n)
      , s = lm.searchSimilarTokens({
        chain: e,
        tokenAddress: t,
        sortBy: a
    });
    try {
        return (await Promise.race([s, r])).hits
    } catch (fNe) {
        return []
    }
}
  , WBe = 1e4
  , FBe = y.memo(( ({sortMode: e, tokenSymbol: t, tokenAddress: n, chain: r, dataNeeded: a}) => {
    const {t: s} = we()
      , o = ( (e, t, n, r, a) => {
        const [s,o] = y.useState({});
        return y.useEffect(( () => {
            if (!a)
                return;
            const t = BBe(n, r, e);
            if (void 0 !== s[t])
                return;
            const l = ng(n);
            (async () => {
                try {
                    const a = (await UBe(r, n, e)).filter((e => ng(e.tokenAddress) !== l && !!e.createdAt)).slice(0, _Be);
                    o((e => ({
                        ...e,
                        [t]: {
                            status: ox.READY,
                            data: a
                        }
                    })))
                } catch (fNe) {
                    o((e => ({
                        ...e,
                        [t]: {
                            status: ox.ERROR
                        }
                    })))
                }
            }
            )()
        }
        ), [r, s, e, n, t, a]),
        y.useMemo(( () => {
            const t = BBe(n, r, e);
            return void 0 === s[t] ? {
                status: ox.LOADING
            } : s[t]
        }
        ), [r, s, e, n])
    }
    )(e, t, n, r, a);
    return o.status === ox.LOADING || o.status === ox.INITIAL ? v.jsx(S, {
        height: VBe,
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(Km, {})
    }) : o.status === ox.ERROR ? v.jsx(S, {
        height: VBe,
        alignItems: "center",
        justifyContent: "center",
        children: v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: s("Error upon loading similar tokens")
        })
    }) : v.jsx(S, {
        gap: 1.25,
        children: o.data.length ? o.data.map((e => v.jsx(EBe, {
            ...e
        }, e.tokenAddress))) : v.jsx(S, {
            height: VBe,
            alignItems: "center",
            justifyContent: "center",
            children: v.jsx(k, {
                variant: "paragraph3",
                color: "text.label",
                children: s("No similar tokens have been found")
            })
        })
    })
}
))
  , VBe = 300
  , HBe = y.memo(( () => {
    const {t: e} = we()
      , t = bw()
      , {originalStaticMarketInfo: n} = Qce()
      , [r,a] = Mx("padreV2-similarTokensExpanded", !1)
      , s = y.useCallback(( () => a((e => !e))), [a])
      , [o,l] = Mx("padreV2-similarTokensSortMode", hz.VOLUME)
      , i = y.useCallback((e => {
        e.stopPropagation(),
        l((e => e === hz.MARKET_CAP ? hz.VOLUME : e === hz.VOLUME ? hz.LIQUIDITY : hz.MARKET_CAP))
    }
    ), [l])
      , c = y.useMemo(( () => e => ({
        backgroundColor: "transparent",
        boxShadow: "none",
        borderRadius: 0,
        border: "none",
        borderTop: "none",
        borderBottom: r ? "none" : `1px solid ${e.palette.background.borderMain}`,
        "&:before": {
            display: "none"
        }
    })), [r])
      , [d,u] = y.useState(!1)
      , p = y.useCallback(( () => {
        u(!0)
    }
    ), [])
      , h = y.useMemo(( () => r || d), [r, d]);
    return n ? v.jsx(S, {
        mr: t ? -1.75 : -1,
        ml: t ? -2 : -1,
        children: v.jsxs(Un, {
            disableGutters: !0,
            onChange: s,
            expanded: r,
            square: !0,
            sx: c,
            onMouseEnter: p,
            children: [v.jsx(Wn, {
                expandIcon: $Be,
                sx: GBe,
                children: v.jsxs(S, {
                    width: "100%",
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    gap: 1,
                    pr: 2.5,
                    children: [v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.value",
                        children: e("Similar Tokens")
                    }), v.jsx(GC, {
                        title: `Sort by ${KBe[o]}`,
                        children: v.jsx(C, {
                            component: "span",
                            display: "flex",
                            children: v.jsx(V, {
                                variant: "tertiary",
                                size: "xxsmall",
                                onClick: i,
                                sx: YBe,
                                children: v.jsxs(S, {
                                    direction: "row",
                                    justifyContent: "flex-end",
                                    alignItems: "center",
                                    gap: .5,
                                    children: [v.jsx(k, {
                                        variant: "paragraph3",
                                        color: "inherit",
                                        children: qBe[o]
                                    }), v.jsx(oy, {})]
                                })
                            })
                        })
                    })]
                })
            }), v.jsx(Fn, {
                sx: zBe,
                children: v.jsx(S, {
                    px: 2,
                    pb: 2,
                    children: v.jsx(FBe, {
                        sortMode: o,
                        tokenSymbol: n.baseToken.symbol,
                        tokenAddress: n.baseToken.address,
                        chain: n.chain,
                        dataNeeded: h
                    })
                })
            })]
        })
    }) : null
}
))
  , zBe = {
    p: 0
}
  , $Be = v.jsx(Sy, {
    size: 16
})
  , GBe = {
    minHeight: 44,
    maxHeight: 44
}
  , qBe = {
    [hz.MARKET_CAP]: "MC",
    [hz.VOLUME]: "VOL",
    [hz.LIQUIDITY]: "LIQ",
    [hz.BEST_MATCH]: "BEST"
}
  , KBe = {
    [hz.MARKET_CAP]: "Market Cap",
    [hz.VOLUME]: "1H Volume",
    [hz.LIQUIDITY]: "Liquidity",
    [hz.BEST_MATCH]: "Best match"
}
  , YBe = {
    height: 26,
    py: 0,
    px: .5,
    mr: .5,
    minWidth: 54,
    display: "flex",
    justifyContent: "flex-end"
}
  , XBe = y.memo(( ({marketId: e}) => {
    const {data: t} = Hwe(e, (e => {
        var t;
        const n = (null == (t = VK().user) ? void 0 : t.uid) ?? null
          , r = y.useCallback((t => n && e ? mm.subscribeMigrationAwareMarketStats(e, t) : {
            unsubscribe: () => {}
        }), [e, n])
          , a = yx(r, {
            debounceDuration: 200
        });
        return e && a ? "init" === a.type ? a.snapshot : a.update : null
    }
    )(e), null)
      , [n,r] = Mx("padreV2-overviewCollapsed", !0)
      , [a,s] = Mx("padreV2-overviewTimespan-v3", "m5");
    y.useEffect(( () => {
        bBe.includes(a) || s("m5")
    }
    ), [a, s]);
    y.useRef(a).current = a;
    const o = y.useCallback(( (e, t) => {
        r(!1),
        s(t)
    }
    ), [r, s])
      , l = y.useCallback(( () => {
        r((e => !e))
    }
    ), [r])
      , [i,c,d,u,p,h] = y.useMemo(( () => {
        if (!t)
            return [null, null, null, null, null, null];
        const e = ( (e, t) => {
            switch (t) {
            case "m5":
                return e.m5;
            case "h1":
                return e.h1;
            case "h6":
                return e.h6;
            case "h24":
                return e.h24
            }
        }
        )(t, a);
        return [e.buyVolumeUsd + e.sellVolumeUsd, e.buyVolumeUsd - e.sellVolumeUsd, e.buyCount, e.sellCount, e.buyVolumeUsd, e.sellVolumeUsd]
    }
    ), [t, a])
      , m = ode()
      , g = y.useMemo(( () => t && null !== m ? vBe(t, m) : null), [m, t]);
    return v.jsxs(S, {
        children: [v.jsx(yBe, {
            timespan: a,
            isCollapsed: n,
            handleTimestampChange: o,
            handleRepeatClick: l,
            volumeInUsd: i,
            netVol: c,
            buys: d,
            sells: u,
            buysVolume: p,
            sellsVolume: h,
            priceInUsdChangePercent: g
        }), v.jsxs(S, {
            children: [v.jsx(eBe, {}), v.jsx(sBe, {}), v.jsx(HBe, {})]
        })]
    })
}
));
var QBe = (e => (e.DATA = "overview",
e.ORDERS = "orders",
e.CHART = "chart",
e.TRADES = "trades",
e.HOLDERS = "holders",
e.TOP_TRADERS = "topTraders",
e.BUBBLES = "bubbles",
e))(QBe || {});
const ZBe = y.memo(( ({label: e, count: t, showWarning: n}) => {
    const r = D();
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: .25,
        children: [v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            children: e
        }), n && v.jsx(wk, {
            size: 14,
            color: r.palette.error.main
        }), void 0 !== t && v.jsx(k, {
            variant: "monospace2",
            color: "inherit",
            children: `(${LI(t, {
                collapseExponent: !0,
                symbol: "",
                maxPrecision: t > 1e3 ? 2 : 0,
                minPrecision: t > 1e3 ? 2 : 0
            })})`
        })]
    })
}
))
  , JBe = QBe.CHART
  , e_e = y.memo(( ({originalStaticMarketInfo: e, originalMarketId: t}) => {
    const {isLandscape: n} = OR()
      , [r,a] = y.useState(JBe)
      , s = y.useCallback(( (e, t) => {
        a(t)
    }
    ), [])
      , o = hde(e)
      , l = o ? vg(o) : t
      , i = y.useCallback(( () => {
        a(QBe.TRADES)
    }
    ), [])
      , {focusedWalletGroupAddresses: d, focusedWalletGroupAddressesLoading: u} = jwe()
      , p = y.useMemo(( () => [{
        name: QBe.DATA,
        content: v.jsx(XBe, {
            marketId: l
        })
    }, {
        name: QBe.ORDERS,
        content: v.jsx(lDe, {
            protocol: (null == o ? void 0 : o.protocol) ?? null,
            chain: (null == o ? void 0 : o.chain) ?? null,
            baseAddress: (null == o ? void 0 : o.baseToken.address) ?? null,
            quoteAddress: (null == o ? void 0 : o.quoteToken.address) ?? null,
            quoteSymbol: null == o ? void 0 : o.quoteToken.symbol,
            tradesLocation: XAe.MARKET_ACTIVITY,
            devAddress: (null == o ? void 0 : o.baseToken.deployer) ?? null,
            toggleTradesLocation: c.noop,
            baseDeployedAt: (null == o ? void 0 : o.baseToken.deployedAt) ?? null
        })
    }, {
        name: QBe.CHART,
        content: v.jsx(C, {
            mx: -1,
            height: "100%",
            children: v.jsx(dLe, {})
        })
    }, {
        name: QBe.TRADES,
        content: v.jsx(uRe, {
            chain: null === o ? null : o.chain,
            devAddress: (null == o ? void 0 : o.baseToken.deployer) ?? null
        })
    }, {
        name: QBe.HOLDERS,
        content: v.jsxs(C, {
            mx: -1,
            height: "100%",
            children: [v.jsx(S, {
                ml: -1,
                mb: .5,
                children: v.jsx(mLe, {
                    devAddress: (null == o ? void 0 : o.baseToken.deployer) ?? null,
                    tableMode: oAe.HOLDERS,
                    tradesLocation: XAe.MARKET_ACTIVITY
                })
            }), v.jsx(Uje, {
                focusedWalletGroupAddresses: d,
                focusedWalletGroupAddressesLoading: u,
                onFilterCallback: i
            })]
        })
    }, {
        name: QBe.BUBBLES,
        content: v.jsx(C, {
            display: "flex",
            ml: -2,
            mt: -1,
            children: v.jsx(QCe, {
                chain: (null == o ? void 0 : o.chain) ?? null,
                contractAddress: (null == o ? void 0 : o.baseToken.address) ?? null
            })
        })
    }, {
        name: QBe.TOP_TRADERS,
        content: v.jsxs(C, {
            mx: -1,
            height: "100%",
            children: [v.jsx(S, {
                ml: -1,
                mb: .5,
                children: v.jsx(mLe, {
                    devAddress: (null == o ? void 0 : o.baseToken.deployer) ?? null,
                    tableMode: oAe.TOP_TRADERS,
                    tradesLocation: XAe.MARKET_ACTIVITY
                })
            }), v.jsx(Wje, {
                focusedWalletGroupAddresses: d,
                focusedWalletGroupAddressesLoading: u,
                isQuote: !!o && tu(ng(o.baseToken.address), o.chain),
                onFilterCallback: i
            })]
        })
    }]), [l, o, i, d, u])
      , h = Sde()
      , m = Ive()
      , g = y.useMemo(( () => null !== m && (null === h || h <= 50 || m <= 40) ? m : h), [h, m])
      , x = y.useMemo(( () => ( (e, t) => {
        const n = !!t && t < jRe;
        return [{
            name: QBe.CHART,
            label: "Chart"
        }, {
            name: QBe.DATA,
            label: "Data"
        }, {
            name: QBe.ORDERS,
            label: "Orders"
        }, {
            name: QBe.TRADES,
            label: "Trades"
        }, {
            name: QBe.HOLDERS,
            label: "Holders",
            count: n ? void 0 : e ?? void 0,
            showWarning: n
        }, {
            name: QBe.BUBBLES,
            label: "Bubbles"
        }, {
            name: QBe.TOP_TRADERS,
            label: "Traders",
            showWarning: n
        }]
    }
    )(g, (null == o ? void 0 : o.baseToken.deployedAt) ?? null)), [g, null == o ? void 0 : o.baseToken.deployedAt])
      , [b,f] = Mx("padreV2-mobileInstantTradeMode", !0)
      , k = y.useCallback(( () => {
        f((e => !e))
    }
    ), [f]);
    return v.jsx(S, {
        "data-testid": "market-page-layout-mobile",
        flexGrow: 1,
        overflow: n ? "auto" : "hidden",
        className: n ? "padre-no-scroll" : void 0,
        position: "relative",
        maxWidth: "100vw",
        children: l ? v.jsxs(v.Fragment, {
            children: [!o && v.jsx(C, {
                sx: {
                    position: "absolute",
                    inset: 0,
                    zIndex: t_e,
                    backgroundColor: "background.default"
                },
                children: v.jsx(Km, {})
            }), v.jsxs(S, {
                flexGrow: 1,
                pt: .25,
                children: [v.jsx(vt, {
                    children: v.jsxs(S, {
                        gap: n ? 2.5 : 0,
                        direction: n ? "row" : "column",
                        justifyContent: n ? "space-between" : void 0,
                        alignItems: n ? "center" : "flex-start",
                        pb: .75,
                        children: [v.jsx(rTe, {
                            marketInfo: o
                        }), v.jsx(Ee, {
                            orientation: "horizontal",
                            flexItem: !0,
                            sx: {
                                mx: -2,
                                mb: n ? 0 : .75,
                                mt: n ? 0 : .25
                            }
                        }), v.jsx(qTe, {
                            sx: {
                                alignItems: n ? "center" : void 0
                            }
                        })]
                    })
                }), v.jsx(S, {
                    width: "100%",
                    children: v.jsx(ot, {
                        value: r,
                        onChange: s,
                        sx: r_e,
                        variant: "scrollable",
                        children: x.map(( ({name: e, label: t, count: n, showWarning: r}) => v.jsx(lt, {
                            label: v.jsx(ZBe, {
                                label: t,
                                count: n,
                                showWarning: r
                            }, e),
                            sx: s_e(e),
                            value: e
                        }, e)))
                    })
                }), v.jsx(S, {
                    flex: "1 1 1px",
                    overflow: "hidden",
                    position: "relative",
                    minHeight: n ? n_e : void 0,
                    mx: -1,
                    children: p.map(( ({content: e, name: t}) => t !== r ? null : v.jsx(C, {
                        flexGrow: 1,
                        sx: {
                            overflowY: "auto",
                            overflowX: "hidden"
                        },
                        pt: t === QBe.CHART ? 0 : 1,
                        children: v.jsx(vt, {
                            sx: {
                                height: "100%"
                            },
                            children: e
                        })
                    }, t)))
                }), o && v.jsx(S, {
                    py: 1,
                    borderTop: e => `1px solid ${e.palette.divider}`,
                    mx: -.75,
                    children: v.jsx(vt, {
                        children: v.jsxs(S, {
                            children: [v.jsx($Se, {
                                marketInfo: o
                            }), b ? v.jsx(AIe, {
                                toggleInstantMode: k
                            }) : v.jsx(aMe, {
                                marketId: l,
                                marketInfo: o,
                                toggleInstantMode: k
                            })]
                        })
                    })
                })]
            })]
        }) : v.jsx(Km, {})
    })
}
))
  , t_e = 10
  , n_e = 250
  , r_e = e => ({
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    pl: {
        xs: 0,
        md: .25
    },
    "& .MuiTabs-scrollButtons": {
        width: 24
    }
})
  , a_e = e => e === QBe.HOLDERS ? 100 : e === QBe.TOP_TRADERS ? 70 : 60
  , s_e = pg((e => e), (e => ({
    minWidth: a_e(e),
    px: {
        xs: 2.75,
        md: 2
    }
})), 20)
  , o_e = y.memo(( ({isCollapsed: e, toggleCollpased: t}) => {
    const n = y.useMemo(( () => ({
        position: "absolute",
        left: e ? -i_e : -i_e / 2 - 1,
        top: "50%",
        transform: "translateY(-50%)",
        width: i_e,
        height: c_e,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1
    })), [e])
      , r = y.useMemo(( () => t => ({
        width: "100%",
        height: "100%",
        minWidth: 0,
        p: 0,
        color: "white",
        borderRadius: e ? "4px 0 0 4px" : "4px",
        "&:focus": {
            backgroundColor: t.palette.background.buttonDefault,
            borderColor: t.palette.background.borderMain,
            "&:hover": {
                backgroundColor: t.palette.background.buttonHover,
                borderColor: t.palette.background.borderActive
            }
        }
    })), [e]);
    return v.jsx(C, {
        sx: n,
        children: v.jsx(V, {
            variant: "tertiary",
            onClick: t,
            sx: r,
            children: e ? v.jsx(ky, {
                size: l_e,
                color: "inherit"
            }) : v.jsx(Cy, {
                size: l_e,
                color: "inherit"
            })
        })
    })
}
))
  , l_e = 12
  , i_e = 15
  , c_e = 34
  , d_e = y.memo(( () => {
    const {walletGroups: e} = rf()
      , {compatibleWalletsAddresses: t} = Gde()
      , n = y.useMemo(( () => t.map((e => ng(e.publicAddress)))), [t])
      , {t: r} = we()
      , {originalStaticMarketInfo: a} = Qce()
      , s = hde(a)
      , o = y.useMemo(( () => (null == s ? void 0 : s.baseToken.deployer) ?? null), [null == s ? void 0 : s.baseToken.deployer])
      , {panelFocusedTraders: l, panelFocusTraders: i, panelAreTrackedGroupsFocused: d, panelFocusTrackedGroups: u} = jwe()
      , p = y.useCallback(( () => {
        i(null)
    }
    ), [i])
      , h = y.useCallback(( () => {
        p(),
        u(!d)
    }
    ), [p, u, d])
      , m = y.useCallback(( () => {
        u(!1),
        o && (1 === (null == l ? void 0 : l.length) && l[0] === ng(o) ? p() : i([ng(o)]))
    }
    ), [u, o, l, p, i])
      , g = y.useCallback(( () => {
        u(!1),
        p()
    }
    ), [u, p])
      , x = y.useMemo(( () => !(!(null == l ? void 0 : l.length) || !n.length) && c.isEqual([...l].sort(), [...n].sort())), [l, n])
      , b = y.useCallback(( () => {
        n.length && (l && c.isEqual([...l].sort(), [...n].sort()) ? p() : i(n))
    }
    ), [n, l, p, i])
      , f = NA(n, !0);
    return y.useEffect(( () => {
        l && !c.isEqual(n, f) && c.isEqual([...l].sort(), [...f].sort()) && i(n)
    }
    ), [i, l, f, n]),
    v.jsxs(S, {
        direction: "row",
        width: "100%",
        className: "padre-no-scroll",
        sx: u_e,
        alignItems: "center",
        children: [v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            noWrap: !0,
            minWidth: 35,
            children: `${r("Filter")}:`
        }), v.jsxs(S, {
            direction: "row",
            gap: .5,
            children: [v.jsx(hLe, {
                isPanel: !0
            }), v.jsx(uLe, {
                isSelected: null === l && !d && !x,
                label: r("All"),
                onClick: g
            }), n && v.jsx(uLe, {
                isSelected: x,
                label: r("Mine"),
                onClick: b
            }), !!o && v.jsx(uLe, {
                isSelected: !!o && 1 === (null == l ? void 0 : l.length) && l[0] === ng(o),
                label: r("Dev"),
                onClick: m
            }), !!(null == e ? void 0 : e.length) && v.jsx(uLe, {
                isSelected: d,
                label: r("Tracked"),
                onClick: h
            })]
        })]
    })
}
))
  , u_e = e => ({
    width: "100%",
    height: 34,
    minHeight: 34,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    overflowX: "scroll",
    overflowY: "hidden",
    pr: .75,
    pl: 1.5,
    gap: 1
})
  , p_e = y.memo(( ({isCollapsed: e, toggleCollpased: t, orderWidgetHidden: n}) => {
    const {originalStaticMarketInfo: r} = Qce()
      , a = _we();
    return v.jsxs(S, {
        height: "100%",
        position: "relative",
        pr: n ? .25 : 0,
        width: e ? 0 : n ? 350 : 315,
        children: [v.jsx(d_e, {}), v.jsx(uRe, {
            chain: (null == r ? void 0 : r.chain) ?? null,
            isPanel: !0,
            devAddress: null
        }), !a && v.jsx(S, {
            position: "absolute",
            bottom: 0,
            left: 0,
            width: "100%",
            height: 24,
            sx: m_e,
            children: v.jsx(k, {
                sx: h_e,
                variant: "paragraph3",
                color: "warning.main",
                children: "Feed is paused"
            })
        }), v.jsx(o_e, {
            isCollapsed: e,
            toggleCollpased: t
        })]
    })
}
))
  , h_e = {
    pointerEvents: "none"
}
  , m_e = e => ({
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    backgroundColor: e.palette.background.secondary,
    justifyContent: "center",
    alignItems: "center",
    pointerEvents: "none",
    opacity: .85,
    zIndex: 3
})
  , g_e = 350
  , x_e = y.memo(( ({originalStaticMarketInfo: e, originalMarketId: t, chainId: n}) => {
    const r = D()
      , [a,s] = Mx("padreV2-marketPageOrderWidgetHidden", !1)
      , o = y.useCallback(( () => {
        s((e => !e))
    }
    ), [s])
      , [l,i] = Mx("padreV2-marketPasgeTradesPanelCollapsed", !1)
      , c = y.useCallback(( () => {
        i((e => !e))
    }
    ), [i])
      , {tradesLocation: d, setTradesLocation: u} = jwe()
      , p = y.useCallback(( () => {
        i(!1),
        u((e => e === XAe.MARKET_ACTIVITY ? XAe.PANEL : XAe.MARKET_ACTIVITY))
    }
    ), [i, u])
      , h = lxe()
      , m = hde(e)
      , g = m ? vg(m) : t
      , x = y.useMemo(( () => m ?? Dve(n)), [m, n])
      , b = y.useMemo(( () => v.jsx(Ee, {
        orientation: "vertical",
        flexItem: !0
    })), [])
      , f = y.useMemo(( () => [{
        minSize: 210,
        size: 500,
        isHandleReversed: !0,
        content: v.jsxs(S, {
            height: "100%",
            flexGrow: 1,
            divider: v.jsx(Ee, {
                flexItem: !0
            }),
            children: [v.jsxs(S, {
                pl: 2,
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                children: [v.jsxs(S, {
                    flexGrow: 1,
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    py: .5,
                    pr: 1.5,
                    overflow: "scroll",
                    className: "padre-no-scroll",
                    children: [v.jsxs(S, {
                        flexGrow: 1,
                        direction: "row",
                        alignItems: "center",
                        gap: 1,
                        children: [v.jsx(rTe, {
                            marketInfo: m
                        }), v.jsx(qTe, {})]
                    }), v.jsx(GC, {
                        title: rr(a ? "Normal chart view" : "Wide chart view"),
                        children: v.jsx(C, {
                            display: "flex",
                            children: v.jsx(F, {
                                onClick: o,
                                children: a ? v.jsx(_f, {
                                    size: b_e,
                                    color: r.palette.text.value
                                }) : v.jsx(Uf, {
                                    size: b_e,
                                    color: r.palette.text.value
                                })
                            })
                        })
                    })]
                }), a && v.jsx(KSe, {
                    marketInfo: m
                })]
            }), v.jsxs(S, {
                direction: "row",
                divider: v.jsx(Ee, {
                    orientation: "vertical",
                    flexItem: !0
                }),
                flex: 1,
                height: "100%",
                overflow: "scroll",
                className: "padre-no-scroll",
                children: [v.jsx(C, {
                    flex: "1 1 1px",
                    children: v.jsx(dLe, {})
                }), d === XAe.PANEL && v.jsx(p_e, {
                    isCollapsed: l,
                    toggleCollpased: c,
                    orderWidgetHidden: a
                })]
            })]
        })
    }, {
        minSize: 200,
        content: v.jsxs(S, {
            direction: "row",
            flexGrow: 1,
            height: "100%",
            maxHeight: "100%",
            divider: b,
            children: [v.jsx(S, {
                flex: "1 1 1px",
                width: 0,
                children: m ? v.jsx(lDe, {
                    protocol: (null == m ? void 0 : m.protocol) || null,
                    chain: (null == m ? void 0 : m.chain) || null,
                    baseAddress: (null == m ? void 0 : m.baseToken.address) ?? null,
                    quoteAddress: (null == m ? void 0 : m.quoteToken.address) ?? null,
                    quoteSymbol: null == m ? void 0 : m.quoteToken.symbol,
                    tradesLocation: d,
                    devAddress: (null == m ? void 0 : m.baseToken.deployer) ?? null,
                    toggleTradesLocation: p,
                    baseDeployedAt: (null == m ? void 0 : m.baseToken.deployedAt) ?? null
                }) : null
            }), a && v.jsxs(S, {
                overflow: "scroll",
                className: "padre-no-scroll",
                pt: 2,
                gap: 2,
                flex: "0 0 350px",
                maxWidth: g_e,
                children: [v.jsx(vt, {
                    children: v.jsx(QEe, {
                        marketId: g ?? "",
                        marketInfo: x,
                        hidePositionBox: !0
                    })
                }), v.jsx(S, {
                    mt: -2,
                    height: "100%",
                    minHeight: 200,
                    children: v.jsx(C, {
                        p: 2,
                        children: v.jsx(XBe, {
                            marketId: g
                        })
                    })
                })]
            })]
        })
    }]), [m, a, o, d, l, c, b, p, g, x, r.palette.text.value]);
    return v.jsxs(S, {
        minHeight: 1420,
        "data-testid": "market-page-layout-desktop",
        height: "100%",
        direction: "row",
        flexGrow: 1,
        divider: b,
        ...ar ? {
            maxHeight: `calc(100vh - ${h}px)`
        } : {},
        children: [v.jsx(S, {
            flex: "1 1 1px",
            width: 0,
            children: v.jsx(S, {
                position: "relative",
                flexGrow: 1,
                children: v.jsx(Ube, {
                    vertical: !0,
                    storageKey: "padreV2-marketPageMainPaneSizes",
                    panes: f
                })
            })
        }), !a && v.jsxs(S, {
            overflow: "scroll",
            className: "padre-no-scroll",
            pt: 1,
            gap: 2,
            flex: "0 0 350px",
            maxWidth: g_e,
            children: [v.jsx(vt, {
                children: v.jsx(QEe, {
                    marketId: g ?? "",
                    marketInfo: x
                })
            }), v.jsx(S, {
                mt: -2,
                height: "100%",
                minHeight: 200,
                children: v.jsx(C, {
                    p: 2,
                    children: v.jsx(XBe, {
                        marketId: g
                    })
                })
            })]
        })]
    })
}
))
  , b_e = 16
  , f_e = {
    tokensCreated: null,
    tokensBonded: null,
    highestMcap: null,
    mostRecent: null
}
  , v_e = ({children: e}) => {
    const {originalStaticMarketInfo: t} = Qce()
      , n = Ede(t)
      , [r,a] = y.useState(null);
    return y.useEffect(( () => {
        (null == t ? void 0 : t.chain) && n && (async () => {
            try {
                const e = await wm.getDevStats(t.chain, n);
                a({
                    tokensCreated: e.tokensCreated,
                    tokensBonded: e.tokensBonded,
                    highestMcap: e.highestMcap,
                    mostRecent: e.mostRecent
                })
            } catch (W$e) {}
        }
        )()
    }
    ), [null == t ? void 0 : t.chain, n]),
    v.jsx(XZ.Provider, {
        value: r ?? f_e,
        children: e
    })
}
  , S_e = y.memo(( () => {
    const {originalStaticMarketInfo: e, originalMarketId: t, addressError: n, chainId: r} = Qce()
      , {saveInHistory: a, history: s} = fz()
      , [o,l] = y.useState(!1)
      , i = NA(t);
    y.useEffect(( () => {
        i !== t && l(!1)
    }
    ), [t, i, l]);
    const {setLastViewedChain: c} = _H();
    y.useEffect(( () => {
        (null == e ? void 0 : e.chain) && TD(e.chain) && c(e.chain)
    }
    ), [null == e ? void 0 : e.chain, c]),
    y.useEffect(( () => {
        o || t && e && (l(!0),
        a({
            marketId: t,
            baseAddress: e.baseToken.address,
            quoteAddress: e.quoteToken.address,
            baseSymbol: e.baseToken.symbol,
            quoteSymbol: e.quoteToken.symbol,
            chain: e.chain,
            protocol: e.protocol.type,
            baseName: e.baseToken.name
        }))
    }
    ), [a, t, e, s, l, o]);
    const d = bw()
      , u = y.useMemo(( () => d ? x_e : e_e), [d])
      , p = y.useMemo(( () => e ? {
        address: e.baseToken.address,
        symbol: e.baseToken.symbol,
        decimals: e.baseToken.decimals
    } : null), [e])
      , h = y.useMemo(( () => loe(e)), [e])
      , m = y.useMemo(( () => h ? {
        address: h.address,
        symbol: h.symbol,
        decimals: h.decimals
    } : null), [h])
      , g = t ? mg(t) : null;
    return n && (ru(ng((null == g ? void 0 : g.marketAddress) ?? "")) || ng((null == g ? void 0 : g.marketAddress) ?? "") === Fd) ? v.jsx(Rve, {
        chain: (null == g ? void 0 : g.chain) ?? Pd.ETH_MAINNET
    }) : n ? v.jsx(Lve, {}) : r ? v.jsx(Bke, {
        children: v.jsx($de, {
            chainId: (null == e ? void 0 : e.chain) || null,
            baseCurrencyProperties: p,
            quoteCurrencyForExecutionProperties: m,
            children: v.jsx(JSe, {
                chain: r,
                children: v.jsx(Yde, {
                    children: v.jsx(s_, {
                        children: v.jsx(VAe, {
                            children: v.jsx(Bwe, {
                                children: v.jsx(Dwe, {
                                    originalMarketId: t,
                                    originalMarketInfo: e,
                                    children: v.jsx(v_e, {
                                        children: v.jsx(jSe, {
                                            children: v.jsx(aAe, {
                                                children: v.jsx(u, {
                                                    originalStaticMarketInfo: e,
                                                    originalMarketId: t,
                                                    chainId: r
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    }) : v.jsx(Lve, {})
}
))
  , y_e = y.memo(( () => v.jsx(qce, {
    children: v.jsx(sde, {
        children: v.jsx(Gke, {
            children: v.jsx(jve, {
                children: v.jsx(Ove, {
                    children: v.jsx(Bde, {
                        children: v.jsx(S_e, {})
                    })
                })
            })
        })
    })
})))
  , k_e = y.memo(( () => {
    const {history: e} = fz()
      , t = y.useMemo(( () => e.length ? e[0].marketId : fg(Pd.SOLANA, Hd, null)), [e]);
    return v.jsx(sr, {
        to: `${tT.TRADE}${uT(t)}`
    })
}
))
  , C_e = e => Promise.resolve({
    default: s6
})
  , A_e = y.lazy(( () => l(( () => import("./PortfolioPageContent-Dx_ktPlj.js")), __vite__mapDeps([5, 1, 2, 6, 3, 4])).catch(C_e)))
  , w_e = y.memo(( () => v.jsx(y.Suspense, {
    fallback: null,
    children: v.jsx(A_e, {})
})))
  , j_e = e => Promise.resolve({
    default: s6
})
  , T_e = y.lazy(( () => l(( () => import("./RewardsPageContent-Caflerbq.js")), __vite__mapDeps([7, 1, 2, 6, 3, 4])).catch(j_e)))
  , I_e = () => v.jsx(y.Suspense, {
    fallback: null,
    children: v.jsx(T_e, {})
})
  , E_e = "Email is already in use"
  , M_e = "Invalid email or password"
  , N_e = "Too many requests. Please wait before retrying."
  , P_e = "Account already exists for that credential. Please choose a different credential or delete the other account."
  , O_e = "Something went wrong.";
var L_e = (e => (e.CREDENTIAL_EXISITS = "auth/credential-already-in-use",
e.EMAIL_EXISTS = "auth/email-already-in-use",
e.INVALID_CREDENTIALS = "auth/invalid-credential",
e.TOO_MANY_ATTEMPTS = "auth/too-many-requests",
e))(L_e || {});
const R_e = y.memo(( ({agreedTos: e, isTosErrorVisible: t, toggleTosCheckbox: n, isInCreateMode: r, showCheckbox: a=!1}) => {
    const {t: s} = we()
      , o = D();
    return v.jsxs(S, {
        mt: 1,
        alignItems: "center",
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            children: [a && v.jsx(_e, {
                "data-testid": "tos-agreement-checkbox",
                checked: e,
                onChange: n,
                size: "small",
                style: {
                    color: e ? o.palette.primary.main : t ? o.palette.error.main : o.palette.text.secondary
                }
            }), v.jsxs(k, {
                textAlign: "center",
                variant: "paragraph1",
                color: a ? "text.value" : "text.label",
                children: [s(a ? "I agree to the" : "By signing in you agree to"), " ", v.jsx($C, {
                    label: s("Terms of Service"),
                    href: _C,
                    nofollow: !1,
                    variant: "paragraph1",
                    color: o.palette.primary.main
                }), " ", v.jsx("br", {}), "and", " ", v.jsx($C, {
                    label: s("Privacy Policy"),
                    href: DC,
                    nofollow: !1,
                    variant: "paragraph1",
                    color: o.palette.primary.main
                })]
            })]
        }), a && v.jsx(S, {
            height: 16,
            children: t && v.jsx(k, {
                variant: "paragraph1",
                color: "negative.main",
                children: s(r ? "You need to accept our terms to create an account" : "You need to accept our terms to log in")
            })
        })]
    })
}
))
  , D_e = y.memo(( ({buttonLabel: e, isInCreateMode: t}) => {
    const {t: n} = we()
      , r = D()
      , {values: a, errors: s, touched: o, handleBlur: l, handleChange: i, status: d, isSubmitting: u} = Tn()
      , [p,h] = y.useState(!1)
      , m = y.useCallback(( () => {
        h((e => !e))
    }
    ), []);
    return v.jsx(Rn, {
        children: v.jsxs(S, {
            gap: 1,
            mb: -1,
            children: [v.jsx(je, {
                "data-testid": "email-input",
                name: "email",
                placeholder: n("Email"),
                value: a.email,
                onChange: i,
                onBlur: l,
                error: o.email && !!s.email,
                startAdornment: v.jsx(We, {
                    position: "start",
                    children: v.jsx(jk, {})
                }),
                inputProps: {
                    [vu]: "false"
                },
                sx: __e,
                size: "xlarge"
            }), v.jsx(je, {
                "data-testid": "password-input",
                name: "password",
                placeholder: p ? n("Password") : "       ",
                value: a.password,
                onChange: i,
                onBlur: l,
                type: p ? "text" : "password",
                error: o.password && !!s.password,
                endAdornment: v.jsx(We, {
                    position: "end",
                    children: v.jsx(F, {
                        sx: U_e,
                        onClick: m,
                        tabIndex: -1,
                        children: p ? v.jsx(Ek, {}) : v.jsx(Tk, {})
                    })
                }),
                inputProps: {
                    [vu]: "false"
                },
                sx: __e,
                size: "xlarge"
            }), !t && v.jsx(R_e, {
                agreedTos: !0,
                isTosErrorVisible: !1,
                toggleTosCheckbox: c.noop,
                isInCreateMode: t
            }), v.jsx(V, {
                type: "submit",
                variant: "primary",
                disabled: u,
                sx: B_e,
                children: e
            }), v.jsx(S, {
                minHeight: 24,
                mt: -1,
                justifyContent: "center",
                textAlign: "center",
                children: v.jsx(rt, {
                    in: !!d || !(!o.password || !s.password) || !(!o.email || !s.email),
                    children: v.jsx(k, {
                        variant: "bodyLarge",
                        color: r.palette.error.main,
                        children: s.email ?? s.password ?? d
                    })
                })
            })]
        })
    })
}
))
  , B_e = {
    mt: 2,
    borderRadius: 5,
    width: 100,
    alignSelf: "center",
    color: "#000000",
    boxShadow: "0 0 30px 0px #86EFAC66"
}
  , __e = e => ({
    background: "black",
    borderRadius: 20,
    border: `1px solid ${e.palette.background.borderMain}`,
    "& .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&:hover .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    [`&.${Ot.error}`]: {
        [`.${Ot.input}, .${Ot.input}::placeholder`]: {
            color: e.palette.text.value
        }
    }
})
  , U_e = {
    p: 0
}
  , W_e = y.memo(( ({buttonLabel: e, onSubmit: t, agreedTos: n, showTosError: r, isInCreateMode: a, formikRef: s}) => {
    const o = y.useCallback((async (e, {setSubmitting: a, setStatus: s}) => {
        if (n) {
            a(!0);
            try {
                const n = await t(e);
                n.success || s((e => {
                    switch (e) {
                    case L_e.EMAIL_EXISTS:
                        return E_e;
                    case L_e.INVALID_CREDENTIALS:
                        return M_e;
                    case L_e.TOO_MANY_ATTEMPTS:
                        return N_e;
                    case L_e.CREDENTIAL_EXISITS:
                        return P_e;
                    default:
                        return O_e
                    }
                }
                )(n.message))
            } catch (fNe) {} finally {
                a(!1)
            }
        } else
            r()
    }
    ), [t, n, r]);
    return v.jsx(Ln, {
        initialValues: V_e,
        validationSchema: F_e,
        onSubmit: o,
        innerRef: s,
        children: v.jsx(D_e, {
            buttonLabel: e,
            isInCreateMode: a
        })
    })
}
))
  , F_e = Qe().shape({
    email: qe().email("Please provide correct email").required("Email is required"),
    password: qe().min(8, "Password must be at least 8 characters").required("Password is required")
})
  , V_e = {
    email: "",
    password: ""
}
  , H_e = () => {
    const {refCode: e, isLoading: t} = ( () => {
        const [e,t] = y.useState(!0)
          , [n,r] = xe()
          , a = Cbe(n.get(Sbe));
        return y.useEffect(( () => {
            a && Abe(a),
            r((e => (e.delete(Sbe),
            e))),
            t(!1)
        }
        ), [a, r]),
        {
            refCode: Cbe(localStorage.getItem(ybe) || localStorage.getItem(kbe)),
            setRefCode: Abe,
            isLoading: e
        }
    }
    )()
      , {migrationCode: n, isLoading: r} = ( () => {
        const [e,t] = y.useState(!0)
          , [n,r] = xe()
          , a = n.get(wbe);
        return y.useEffect(( () => {
            a && Tbe(a),
            r((e => (e.delete(wbe),
            e))),
            t(!1)
        }
        ), [a, r]),
        {
            migrationCode: localStorage.getItem(jbe),
            removeV1MigrationCode: Ibe,
            isLoading: e
        }
    }
    )()
      , [a,s] = y.useState({
        status: ox.INITIAL
    });
    y.useEffect(( () => {
        let e = !1;
        if (r || t)
            s({
                status: ox.LOADING
            });
        else {
            if (n)
                return (async () => {
                    try {
                        const {kolName: t} = await Sm.decodeV1Migration(n);
                        if (e)
                            return;
                        s({
                            status: ox.READY,
                            data: {
                                refCode: t,
                                migrationCode: n
                            }
                        })
                    } catch (fNe) {
                        if (e)
                            return;
                        s({
                            status: ox.ERROR
                        })
                    }
                }
                )(),
                () => {
                    e = !0
                }
                ;
            s({
                status: ox.READY,
                data: {
                    refCode: null,
                    migrationCode: n
                }
            })
        }
    }
    ), [r, t, n]);
    return y.useMemo(( () => a.status !== ox.READY ? a : null === a.data.refCode && e ? {
        status: ox.READY,
        data: {
            refCode: e,
            migrationCode: null
        }
    } : a), [a, e])
}
  , z_e = or(k, {
    shouldForwardProp: e => !["startColor", "endColor", "angle"].includes(e)
})(( ({startColor: e="#FAFAFA", endColor: t="rgba(250, 250, 250, 0.4)", angle: n=91}) => ({
    display: "inline-block",
    background: `linear-gradient(${n}deg, ${e} 0.16%, ${t} 100%)`,
    WebkitBackgroundClip: "text",
    backgroundClip: "text",
    color: "transparent"
})))
  , $_e = ({isSpinning: e=!0, size: t=G_e, color: n, Icon: r=_S, spinDuration: a=q_e}) => v.jsx(C, {
    sx: {
        display: "flex",
        alignItems: "center",
        animation: e ? `spin ${a}ms linear infinite` : "none",
        "@keyframes spin": {
            "0%": {
                transform: "rotate(360deg)"
            },
            "100%": {
                transform: "rotate(0deg)"
            }
        }
    },
    children: v.jsx(r, {
        size: t,
        color: n
    })
})
  , G_e = 16
  , q_e = 2e3
  , K_e = y.memo(( ({iconComponent: e, testid: t, onClick: n, disabled: r}) => v.jsx(F, {
    "data-testid": t,
    sx: Y_e,
    onClick: n,
    disabled: r,
    children: e
})))
  , Y_e = {
    width: 70,
    height: 70,
    p: 0,
    background: "#171717"
}
  , X_e = 24
  , Q_e = () => {
    const {signInWithOtp: e} = VK()
      , [t,n] = y.useState(!1)
      , [r,a] = y.useState(!1)
      , s = pK()
      , l = y.useRef(null)
      , i = y.useRef(null)
      , c = y.useCallback(( () => {
        n(!0)
    }
    ), [n])
      , d = y.useCallback(( () => {
        n(!1)
    }
    ), [n])
      , u = y.useCallback((async t => {
        a(!0);
        try {
            await e(t)
        } catch (W$e) {
            s({
                snackName: pu.unableToScanQrCode,
                message: uu.tryAgainLater,
                type: "error"
            }, "unable-to-scan-qr-code")
        } finally {
            a(!1)
        }
    }
    ), [s, a, e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(K_e, {
            iconComponent: v.jsx(KS, {
                size: X_e
            }),
            onClick: c,
            disabled: r
        }), v.jsx(Sw, {
            open: t,
            onClose: d,
            children: v.jsxs(S, {
                gap: 4,
                children: [v.jsx(k, {
                    variant: "h1",
                    children: "Scan QR code"
                }), v.jsx(S, {
                    gap: 2.5,
                    children: v.jsx("video", {
                        ref: e => {
                            e ? (l.current = e,
                            i.current = new lr(e,(e => {
                                const t = e.data.slice(-36);
                                u(t).catch((e => {
                                    o(e)
                                }
                                )),
                                i.current && (i.current.destroy(),
                                i.current = null),
                                d()
                            }
                            ),{
                                onDecodeError() {}
                            }),
                            i.current.start().catch((e => {
                                var t;
                                null == (t = i.current) || t.destroy(),
                                i.current = null
                            }
                            ))) : (i.current && (i.current.destroy(),
                            i.current = null),
                            l.current = null)
                        }
                    })
                })]
            })
        })]
    })
}
  , Z_e = ({agreedTos: e, isTosErrorVisible: t, toggleTosCheckbox: n, isInCreateMode: r, signInWithTelegram: a}) => {
    const s = H_e()
      , {authorize: o, isAuthorizing: l, setIsAuthorizing: i} = Cue()
      , [c,d] = y.useState(!1)
      , u = y.useCallback(( () => {
        o((async e => {
            if (!e)
                return void i(!1);
            if (s.status !== ox.READY)
                return;
            const {refCode: t, migrationCode: n} = s.data;
            await a({
                tgAuthData: e,
                kolName: t,
                ...n ? {
                    v1MigrationCode: n
                } : {}
            }),
            i(!1),
            d(!1)
        }
        ))
    }
    ), [o, s, i, a])
      , p = y.useCallback(( () => d(!1)), [])
      , h = y.useCallback(( () => {
        const e = "padre_tg_bot";
        s.status === ox.READY && s.data.refCode ? window.open(`https://t.me/${e}?start=%2Fsign%20${s.data.refCode}`, "_blank") : window.open(`https://t.me/${e}?start=%2Fsign%20padre`, "_blank")
    }
    ), [s]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(K_e, {
            iconComponent: v.jsx(Ly, {
                color: "#57A3E0",
                size: 22
            }),
            onClick: h,
            disabled: l || s.status !== ox.READY
        }), v.jsx(Sw, {
            open: c,
            onClose: p,
            children: v.jsxs(S, {
                gap: 4,
                children: [v.jsx(k, {
                    variant: "h1",
                    children: "Agree to ToS"
                }), v.jsxs(S, {
                    gap: 2.5,
                    children: [v.jsxs(V, {
                        disabled: !e || l || s.status !== ox.READY,
                        onClick: u,
                        variant: "tertiary",
                        size: "large",
                        sx: {
                            gap: 1
                        },
                        children: [v.jsx(Ry, {}), J_e]
                    }), v.jsx(R_e, {
                        agreedTos: e,
                        isTosErrorVisible: t,
                        toggleTosCheckbox: n,
                        isInCreateMode: r,
                        showCheckbox: !0
                    })]
                })]
            })
        })]
    })
}
  , J_e = "Continue with Telegram"
  , eUe = y.memo(( ({signInWithStandardProvider: e, signInWithPassword: t, signInWithMetaMask: n, signInWithPhantom: r, isInitiallyInCreateMode: a, signInWithTelegram: s}) => {
    const o = D()
      , l = bw()
      , {t: i} = we()
      , c = H_e()
      , d = y.useRef(null)
      , [u,p] = dx("padreV2-agreedTos1StorageKey", !1)
      , [h,m] = y.useState(a)
      , [g,x] = y.useState(!1)
      , [b,f] = y.useState(!1)
      , [A,w] = y.useState(!1)
      , j = y.useCallback(( () => {
        x(!1),
        c.status === ox.READY && m((e => !e))
    }
    ), [c])
      , T = y.useCallback(( () => {
        x(!1),
        p((e => !e))
    }
    ), [p])
      , I = y.useMemo(( () => i(h ? "Already have an account?" : "Don't have an account?")), [h, i])
      , E = y.useCallback(( () => {
        x(!0)
    }
    ), [])
      , M = y.useCallback(( () => {
        g && x(!1),
        e(TK.GOOGLE)
    }
    ), [g, e])
      , N = y.useCallback(( () => {
        c.status === ox.READY && (g && x(!1),
        f(!0),
        n({
            migrationCode: c.data.migrationCode,
            refCode: c.data.refCode
        }).finally(( () => {
            f(!1)
        }
        )))
    }
    ), [g, c, n])
      , P = y.useCallback(( () => {
        c.status === ox.READY && (g && x(!1),
        w(!0),
        r({
            migrationCode: c.data.migrationCode,
            refCode: c.data.refCode
        }).finally(( () => {
            w(!1)
        }
        )))
    }
    ), [g, c, r])
      , O = y.useCallback((async e => {
        if (h)
            throw new Error("Signing up with password is not supported");
        return x(!1),
        t(e)
    }
    ), [h, t]);
    return v.jsxs(S, {
        gap: 5,
        maxWidth: nUe,
        children: [v.jsxs(S, {
            gap: 3,
            children: [v.jsxs(C, {
                sx: rUe,
                children: [l && v.jsx(k, {
                    fontFamily: Cu.REGULAR,
                    fontSize: 38,
                    lineHeight: "48px",
                    letterSpacing: "-0.5px",
                    fontWeight: 600,
                    color: "#86EFAC",
                    sx: aUe,
                    children: i(h ? "Start Winning" : "Log In")
                }), v.jsx(k, {
                    fontFamily: Cu.REGULAR,
                    fontSize: 38,
                    lineHeight: "48px",
                    letterSpacing: "-0.5px",
                    fontWeight: 600,
                    color: "#86EFAC",
                    zIndex: 1,
                    children: i(h ? "Start Winning" : "Log In")
                })]
            }), v.jsxs(z_e, {
                fontSize: 19,
                fontWeight: 600,
                letterSpacing: "-0.5px",
                textAlign: "center",
                noWrap: !0,
                lineHeight: "24px",
                children: [i("Up to 35% cashback."), l ? " " : v.jsx("br", {}), i("Fastest execution. Full control.")]
            })]
        }), v.jsxs(S, {
            gap: 5,
            px: 2.5,
            width: l ? "100%" : "min(420px, 100vw)",
            children: [h && c.status === ox.READY && !!c.data.refCode && v.jsxs(C, {
                display: "flex",
                alignItems: "center",
                width: "100%",
                gap: 1,
                px: l ? 4 : 1,
                children: [v.jsx(C, {
                    sx: sUe
                }), v.jsxs(k, {
                    color: "#9D9EA2",
                    variant: "paragraph3",
                    fontFamily: Cu.REGULAR,
                    children: [i("You're joining with code:"), " ", v.jsx("span", {
                        style: {
                            fontWeight: 800,
                            color: o.palette.primary.main
                        },
                        children: c.data.refCode
                    })]
                }), v.jsx(C, {
                    sx: oUe
                })]
            }), v.jsxs(S, {
                gap: 2,
                children: [v.jsxs(S, {
                    gap: 2,
                    children: [v.jsx(k, {
                        fontSize: 15,
                        alignSelf: "center",
                        variant: "paragraph1",
                        color: "text.label",
                        children: i("Continue with")
                    }), v.jsxs(S, {
                        gap: 2,
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "center",
                        children: [v.jsx(Z_e, {
                            signInWithTelegram: s,
                            agreedTos: u,
                            isTosErrorVisible: g,
                            toggleTosCheckbox: T,
                            isInCreateMode: h
                        }), v.jsx(K_e, {
                            iconComponent: b ? v.jsx($_e, {
                                size: X_e
                            }) : v.jsx(BS, {
                                size: 22
                            }),
                            testid: "meta-mask-login-button",
                            onClick: N
                        }), v.jsx(K_e, {
                            iconComponent: A ? v.jsx($_e, {
                                size: X_e
                            }) : v.jsx(DS, {
                                size: 30
                            }),
                            testid: "phantom-login-button",
                            onClick: P
                        }), (!R || h) && v.jsx(K_e, {
                            iconComponent: v.jsx(Vy, {
                                size: X_e
                            }),
                            testid: "gmail-login-button",
                            onClick: M
                        })]
                    }), R && !h && v.jsxs(S, {
                        gap: 2,
                        direction: "row",
                        alignItems: "center",
                        justifyContent: "center",
                        children: [v.jsx(K_e, {
                            iconComponent: v.jsx(Vy, {
                                size: X_e
                            }),
                            testid: "gmail-login-button",
                            onClick: M
                        }), v.jsx(Q_e, {})]
                    })]
                }), v.jsxs(S, {
                    gap: 2,
                    px: l ? 4 : 2,
                    children: [!h && v.jsx(k, {
                        textAlign: "center",
                        variant: "paragraph1",
                        color: "text.label",
                        fontSize: 15,
                        children: i("or")
                    }), !h && v.jsx(W_e, {
                        onSubmit: O,
                        buttonLabel: i(h ? "Sign up" : "Log in"),
                        agreedTos: !0,
                        showTosError: E,
                        formikRef: d,
                        isInCreateMode: h
                    })]
                }), v.jsxs(S, {
                    gap: 1.5,
                    children: [v.jsxs(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        sx: lUe,
                        children: [I, v.jsx(C, {
                            onClick: j,
                            sx: tUe,
                            children: i(h ? "Log in" : "Create account")
                        })]
                    }), h && v.jsx(R_e, {
                        agreedTos: u,
                        isTosErrorVisible: g,
                        toggleTosCheckbox: T,
                        isInCreateMode: h
                    })]
                })]
            })]
        })]
    })
}
))
  , tUe = e => ({
    cursor: "pointer",
    color: e.palette.primary.main,
    fontWeight: wu.SEMIBOLD
})
  , nUe = 450
  , rUe = {
    position: "relative",
    display: "inline-block",
    alignSelf: "center"
}
  , aUe = {
    filter: "blur(18px)",
    zIndex: 0,
    position: "absolute",
    top: 0,
    left: 0
}
  , sUe = {
    flex: 1,
    height: "1px",
    background: "linear-gradient(to right, #FFFFFF00, #999999FF)"
}
  , oUe = {
    flex: 1,
    height: "1px",
    background: "linear-gradient(to left, #FFFFFF00, #999999FF)"
}
  , lUe = {
    gap: 1,
    display: "flex",
    alignSelf: "center",
    mt: 1
}
  , iUe = y.memo(( ({isInitiallyInCreateMode: e}) => {
    const {signInWithStandardProvider: t, signInWithTelegram: n, signInWithPassword: r, signInWithMetaMask: a, signInWithPhantom: s, signInWithOtp: o, loading: l, user: i} = VK()
      , [c] = xe()
      , d = pK()
      , u = y.useMemo(( () => c.get("otp")), [c]);
    return y.useEffect(( () => {
        !u || l || (null == i ? void 0 : i.uid) || o(u).catch((e => {
            d({
                message: uu.tryAgainLater,
                snackName: pu.loginFail,
                type: "error"
            }, "sign-with-otp-failed")
        }
        ))
    }
    ), [d, u, l, o, null == i ? void 0 : i.uid]),
    v.jsxs(C, {
        "data-testid": "sign-in-content",
        width: "100%",
        display: "flex",
        justifyContent: "center",
        children: [v.jsx(eUe, {
            signInWithStandardProvider: t,
            signInWithTelegram: n,
            signInWithPassword: r,
            signInWithMetaMask: a,
            signInWithPhantom: s,
            isInitiallyInCreateMode: e
        }), v.jsx(C, {
            sx: cUe,
            children: v.jsx(Lxe, {})
        })]
    })
}
))
  , cUe = {
    position: "fixed",
    right: 12,
    bottom: 8,
    zIndex: 10
}
  , dUe = y.memo(( () => {
    const {isReturningUser: e} = IK();
    return v.jsx(vK, {
        children: v.jsx(iUe, {
            isInitiallyInCreateMode: !e
        })
    })
}
))
  , uUe = ({onClick: e, label: t}) => v.jsx(V, {
    variant: "tertiary",
    sx: pUe,
    onClick: e,
    children: t
})
  , pUe = {
    border: "none",
    p: 0,
    color: "inherit",
    backgroundColor: "transparent",
    "&:hover": {
        color: "text.main",
        backgroundColor: "transparent"
    },
    "&:focus": {
        backgroundColor: "transparent"
    }
}
  , hUe = y.memo(( ({onClick: e, label: t}) => {
    const {t: n} = we();
    return v.jsx(S, {
        direction: "row",
        alignItems: "baseline",
        justifyContent: "center",
        color: "text.value",
        children: v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "baseline",
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "inherit",
                children: n("or")
            }), v.jsx(uUe, {
                onClick: e,
                label: t
            })]
        })
    })
}
))
  , mUe = y.memo(( () => {
    const {t: e} = we()
      , t = cT()
      , {initSignOut: n} = VK()
      , r = y.useCallback(( () => {
        n(t)
    }
    ), [n, t]);
    return v.jsx(hUe, {
        onClick: r,
        label: e("Sign out")
    })
}
))
  , gUe = ({hasError: e, onRetry: t}) => {
    const {t: n} = we();
    return v.jsxs(v.Fragment, {
        children: [v.jsx(k, {
            variant: "h1",
            fontSize: 20,
            color: "primary.main",
            children: n("Creating your wallets")
        }), v.jsx(S, {
            gap: 3,
            children: e ? v.jsxs(v.Fragment, {
                children: [v.jsx(VEe, {
                    severity: "error",
                    sx: {
                        px: 2
                    },
                    title: n("Something went wrong. Please retry."),
                    children: v.jsxs(k, {
                        variant: "bodyLarge",
                        children: [n("If this problem persists, please open a support ticket in our"), " ", v.jsx($C, {
                            label: n("Discord"),
                            href: LC
                        })]
                    })
                }), v.jsxs(S, {
                    gap: 1,
                    children: [v.jsx(V, {
                        fullWidth: !0,
                        size: "large",
                        onClick: t,
                        children: n("Retry")
                    }), v.jsx(mUe, {})]
                })]
            }) : v.jsxs(v.Fragment, {
                children: [v.jsx(k, {
                    variant: "bodyLarge",
                    textAlign: "center",
                    children: n("Please do not close this page.")
                }), v.jsx(Km, {}), v.jsx(k, {
                    variant: "bodyLarge",
                    color: "text.meta",
                    textAlign: "center",
                    children: n("This usually takes around 5 seconds")
                })]
            })
        })]
    })
}
  , xUe = ({children: e, TypographyProps: t={}, ...n}) => v.jsxs(S, {
    direction: "row",
    justifyContent: "space-between",
    alignItems: "center",
    flexGrow: 1,
    ...n,
    children: [v.jsx(k, {
        variant: "labelLarge",
        ...t,
        children: e
    }), v.jsx(C, {
        sx: e => ({
            mr: -.5,
            display: "flex",
            color: "text.value",
            opacity: 0,
            transition: `opacity ${e.transitions.duration.shortest}`,
            [`.${Pt.root}.${Pt.selected} &`]: {
                opacity: 1
            }
        }),
        children: v.jsx(xy, {})
    })]
})
  , bUe = y.memo(( ({chain: e, labelTypographyVariant: t="labelRegular", iconSize: n=fUe, amount: r}) => v.jsxs(S, {
    direction: "row",
    gap: 1,
    alignItems: "center",
    component: "span",
    children: [v.jsx(Sz, {
        chain: e,
        size: n
    }), v.jsx(k, {
        variant: t,
        lineHeight: `${n}px`,
        pt: ".15em",
        ...Nu,
        children: `${ID(e)}${void 0 !== r ? ` (${r})` : ""}`
    })]
})))
  , fUe = 20
  , vUe = ({chain: e, iconSize: t, amount: n, usdValue: r}) => v.jsxs(S, {
    direction: "row",
    alignItems: "center",
    width: "100%",
    gap: 1,
    justifyContent: "space-between",
    children: [v.jsx(bUe, {
        chain: e,
        iconSize: t,
        amount: null === n ? void 0 : n
    }), v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        gap: 1.5,
        mr: .5,
        children: [v.jsx(k, {
            variant: "labelRegular",
            color: r ? "text.value" : "text.label",
            sx: {
                mt: "3px"
            },
            children: null === r ? Ud : LI(r, {
                symbol: "$",
                padSymbol: !1,
                symbolPosition: yI.START,
                maxPrecision: 2
            })
        }), v.jsx(Ee, {
            orientation: "vertical",
            flexItem: !0,
            sx: e => ({
                borderColor: e.palette.background.borderSecondary
            })
        })]
    })]
})
  , SUe = ({chain: e, walletsData: t, setChain: n, iconSize: r=kUe, minWidth: a=yUe}) => {
    const s = y.useCallback((e => {
        n(e.target.value)
    }
    ), [n]);
    return v.jsx(it, {
        size: "medium",
        value: e,
        displayEmpty: !0,
        onChange: s,
        sx: {
            minWidth: a
        },
        renderValue: () => {
            var n;
            return v.jsx(vUe, {
                chain: e,
                iconSize: r,
                amount: t[e] && (null == (n = t[e]) ? void 0 : n.length) || null,
                usdValue: t[e] ? c.sumBy(t[e], (e => e.usdAmount || 0)) : null
            })
        }
        ,
        children: wD.map((e => {
            const n = t[e]
              , a = n ? n.length : null
              , s = n ? c.sumBy(n, (e => e.usdAmount || 0)) : null;
            return v.jsx(te, {
                value: e,
                "data-testid": `wallet-type-select-${e}`,
                dense: !0,
                children: v.jsx(xUe, {
                    TypographyProps: {
                        sx: {
                            width: "100%",
                            mr: .5,
                            ml: -.25
                        }
                    },
                    children: v.jsx(vUe, {
                        chain: e,
                        iconSize: r,
                        amount: a,
                        usdValue: s
                    })
                })
            }, e)
        }
        ))
    })
}
  , yUe = 160
  , kUe = 16
  , CUe = y.memo(( ({walletType: e, ...t}) => {
    const n = (e => {
        switch (e) {
        case pc.ETH:
            return jD;
        case pc.SOL:
            return [Pd.SOLANA]
        }
    }
    )(e);
    return v.jsx(S, {
        direction: "row",
        gap: 2,
        alignItems: "center",
        component: "span",
        children: n.map(( (e, n) => v.jsx(bUe, {
            ...t,
            chain: e
        }, n)))
    })
}
))
  , AUe = ({walletType: e, setWalletType: t, labelTypographyVariant: n, iconSize: r, ...a}) => {
    const s = y.useCallback((e => {
        t(e.target.value)
    }
    ), [t]);
    return v.jsx(it, {
        ...a,
        value: e,
        displayEmpty: !0,
        onChange: s,
        renderValue: () => v.jsx(k, {
            color: "text.label",
            children: v.jsx(CUe, {
                walletType: e,
                labelTypographyVariant: n,
                iconSize: r
            })
        }),
        sx: wUe,
        children: mc.map((e => v.jsx(te, {
            value: e,
            "data-testid": `wallet-type-select-${e}`,
            dense: !0,
            children: v.jsx(xUe, {
                minHeight: bu.LARGE,
                children: v.jsx(CUe, {
                    walletType: e,
                    labelTypographyVariant: n,
                    iconSize: r
                })
            })
        }, e)))
    })
}
  , wUe = e => ({
    minWidth: 160,
    backgroundColor: e.palette.background.default,
    borderRadius: "8px",
    "& .MuiSelect-select": {
        backgroundColor: e.palette.background.default,
        padding: 1.25
    }
})
  , jUe = () => {
    const [e,t] = y.useState(!1)
      , n = y.useCallback(( () => {
        t(!1)
    }
    ), [])
      , r = y.useCallback(( () => {
        t(!0)
    }
    ), []);
    return y.useMemo(( () => ({
        isOpen: e,
        close: n,
        open: r
    })), [e, n, r])
}
  , TUe = ({isLoading: e=!1, disabled: t, children: n, ...r}) => v.jsx(V, {
    startIcon: v.jsx(rt, {
        orientation: "horizontal",
        unmountOnExit: !0,
        in: e,
        children: v.jsx(J, {
            "data-testid": "onboarding-button-loader",
            size: 16
        })
    }),
    disabled: e || t,
    sx: {
        translate: "no",
        ...r.sx
    },
    ...r,
    className: "notranslate",
    children: v.jsxs(S, {
        direction: "row",
        children: [v.jsx(k, {
            variant: "inherit",
            color: "inherit",
            noWrap: !0,
            children: n
        }), e && v.jsx(D5, {})]
    })
})
  , IUe = () => {
    const {user: e} = VK()
      , {apiStamper: t} = YT()
      , {credentialIds: n, solSubOrgId: r, solEndUserId: a} = UD((e => e))
      , s = pK()
      , l = (null == e ? void 0 : e.uid) ?? null;
    return async () => {
        if (r && a && l && t)
            try {
                const e = await (async (e, t, n) => await FT(e.credentialIds, !1, null).stampCreateApiKeys({
                    type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
                    organizationId: e.solSubOrgId,
                    timestampMs: String(+(await kg())),
                    parameters: {
                        userId: n,
                        apiKeys: [{
                            apiKeyName: "Velvet sol migration",
                            publicKey: t,
                            curveType: "API_KEY_CURVE_P256"
                        }]
                    }
                }))({
                    credentialIds: n,
                    solSubOrgId: r,
                    uid: l
                }, t.apiPublicKey, a);
                await Em.runVelvetSolMigration(l, {
                    request: e
                })
            } catch (fNe) {
                o(fNe, {
                    extra: {
                        name: "VelvetContextProvider.runVelvetMigration"
                    }
                }),
                s({
                    message: uu.unknownError,
                    snackName: pu.somethingWentWrong,
                    type: "error"
                }, "velvet-migration-error")
            }
    }
}
  , EUe = y.memo(( ({iframeContainerRef: e}) => {
    var t;
    const {values: {name: n, walletType: r}, errors: a, touched: s, setTouched: l, setFieldValue: i, handleChange: c, handleBlur: d} = Tn();
    y.useEffect(( () => {
        (async () => {
            try {
                await Promise.all([l({
                    name: !1
                }), i("name", "")])
            } catch (fNe) {
                o(fNe)
            }
        }
        )()
    }
    ), [l, i]);
    const u = y.useRef(null)
      , [p,h] = y.useState((null == (t = u.current) ? void 0 : t.clientWidth) ?? 0)
      , m = y.useCallback(( () => {
        var e;
        h((null == (e = u.current) ? void 0 : e.clientWidth) || 0)
    }
    ), [])
      , g = y.useMemo(( () => M(m, 50)), [m]);
    y.useEffect(( () => (g(),
    window.addEventListener("resize", g),
    () => window.removeEventListener("resize", g))), [g]);
    const x = y.useMemo(( () => p / (PUe + 2 * NUe)), [p])
      , b = y.useMemo(( () => `\niframe {\n    border: none;\n    width: ${Math.round(p / x)}px;\n    transform: scale(${x});\n    transform-origin: top left;\n    position: absolute;\n}\n`), [x, p]);
    return v.jsxs(S, {
        gap: 3,
        children: [v.jsx(AUe, {
            disabled: !0,
            size: "xlarge",
            walletType: r,
            setWalletType: O,
            labelTypographyVariant: "labelLarge"
        }), v.jsxs(S, {
            children: [v.jsx(je, {
                name: "name",
                value: n,
                onChange: c,
                onBlur: d,
                size: "xlarge",
                error: s.name && !!a.name,
                startAdornment: v.jsx(We, {
                    position: "start",
                    children: v.jsx(k, {
                        htmlFor: "import-wallet-name-input",
                        ...MUe,
                        children: "Name"
                    })
                }),
                inputProps: {
                    ...Su,
                    id: "import-wallet-name-input",
                    style: {
                        textAlign: "right"
                    }
                }
            }), v.jsx(k, {
                variant: "bodyRegular",
                color: "error",
                sx: {
                    "&:empty::before": {
                        content: "''",
                        display: "inline-block"
                    }
                },
                mt: 1,
                children: s.name && a.name || ""
            })]
        }), v.jsxs(S, {
            gap: 1.5,
            mt: -2.5,
            children: [v.jsx(k, {
                variant: "labelLarge",
                color: "text.label",
                children: "Enter your private key string"
            }), v.jsx(S, {
                ref: u,
                sx: e => ({
                    border: `1px solid ${e.palette.background.borderStandard}`,
                    backgroundColor: "white",
                    borderRadius: 1,
                    overflow: "hidden",
                    height: x * OUe + 2 * NUe,
                    position: "relative"
                }),
                children: v.jsx(C, {
                    ref: e,
                    children: v.jsx("style", {
                        children: b
                    })
                })
            })]
        })]
    })
}
))
  , MUe = {
    variant: "labelLarge",
    color: "text.label",
    component: "label"
}
  , NUe = 10
  , PUe = 300
  , OUe = 110
  , LUe = y.memo(( ({close: e, walletType: t, iframeContainerRef: n, processIframeInput: r, isProcessing: a, inject: s}) => {
    const {t: o} = we()
      , l = pK()
      , i = y.useCallback(( (e, t, n) => {
        const r = "string" == typeof e ? e : "";
        r == hc.INVALID_NAME ? n("name", "Name has to be unique") : r === hc.ALREADY_IMPORTED ? t("This wallet is already imported") : r.includes("no target key found") ? t("Private browsing can interfere with imports. You can import your wallet in standard browsing mode, then switch to private mode for trading.") : r.includes("invalid hex string") || r.includes("cannot base58-decode") ? t(o("Invalid private key")) : t(o("Unable to import private key"))
    }
    ), [o])
      , d = y.useCallback((async ({name: t, walletType: n}, {setStatus: a, setFieldError: o, validateForm: d}) => {
        Ve("ImportWalletForm.onSubmit", {
            extra: {
                name: t,
                walletType: n
            }
        }),
        a(null);
        try {
            const u = await r({
                name: t,
                walletType: n
            });
            if (!u.success)
                return i(u.error, a, o),
                void (await s());
            const p = await d();
            if (!c.isEmpty(p))
                return;
            l({
                message: uu.walletImportSuccess,
                snackName: pu.importSuccess,
                type: "success"
            }, "import-wallet-success"),
            e()
        } catch (fNe) {
            i(fNe, a, o)
        }
    }
    ), [e, l, s, r, i]);
    return v.jsx(Ln, {
        initialValues: {
            name: "",
            walletType: t
        },
        validationSchema: RUe,
        onSubmit: d,
        enableReinitialize: !0,
        children: ({status: t, values: {name: r}, isSubmitting: s}) => v.jsx(Rn, {
            children: v.jsxs(S, {
                gap: 2,
                children: [v.jsx(EUe, {
                    iframeContainerRef: n
                }), v.jsx(rt, {
                    in: !!t,
                    children: v.jsx(VEe, {
                        severity: "error",
                        title: o("Unable to import private key"),
                        children: t
                    })
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 2,
                    children: [v.jsx(V, {
                        fullWidth: !0,
                        onClick: e,
                        variant: "tertiary",
                        children: o("Close")
                    }), v.jsx(z, {
                        title: r ? "" : o("Name of the wallet is required"),
                        children: v.jsx(C, {
                            component: "span",
                            width: "100%",
                            children: v.jsx(TUe, {
                                fullWidth: !0,
                                "data-testid": "wallet-import-submit-button",
                                type: "submit",
                                variant: "primary",
                                isLoading: a || s,
                                disabled: !r || a || s,
                                children: o("Import")
                            })
                        })
                    })]
                })]
            })
        })
    })
}
))
  , RUe = Qe().shape({
    name: qe().required("Wallet name is required. Please fill the input."),
    walletType: qe().required()
})
  , DUe = () => {
    const [e,t] = y.useState(!1)
      , {t: n} = we()
      , r = y.useCallback(( () => {
        t((e => !e))
    }
    ), []);
    return v.jsxs(Un, {
        disableGutters: !0,
        expanded: e,
        onChange: r,
        sx: e => ({
            ...Xhe(e),
            backgroundColor: e.palette.background.tertiary
        }),
        children: [v.jsx(Wn, {
            sx: {
                px: BUe
            },
            expandIcon: v.jsx(Sy, {
                size: _Ue
            }),
            children: v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                children: [v.jsx(QS, {}), v.jsx(k, {
                    variant: "labelLarge",
                    color: "text.label",
                    children: n("How to find your Private Key?")
                })]
            })
        }), v.jsx(Fn, {
            sx: {
                pt: 0,
                pb: BUe,
                px: BUe
            },
            children: v.jsx(k, {
                variant: "bodyLarge",
                color: "text.primary",
                children: v.jsx(ir, {
                    i18nKey: "Private key instructions",
                    components: {
                        phantomLink: v.jsx($C, {
                            href: "https://help.phantom.app/hc/en-us/articles/28355165637011-Displaying-and-Exporting-Your-Private-Key",
                            label: "Phantom"
                        }),
                        metamaskLink: v.jsx($C, {
                            href: "https://support.metamask.io/managing-my-wallet/secret-recovery-phrase-and-private-keys/how-to-export-an-accounts-private-key/",
                            label: "MetaMask"
                        })
                    }
                })
            })
        })]
    })
}
  , BUe = 2
  , _Ue = 18
  , UUe = e => {
    switch (e) {
    case pc.ETH:
        return {
            curve: "CURVE_SECP256K1",
            pathFormat: "PATH_FORMAT_BIP32",
            path: "m/44'/60'/0'/0/0",
            addressFormat: "ADDRESS_FORMAT_ETHEREUM"
        };
    case pc.SOL:
        return {
            curve: "CURVE_ED25519",
            pathFormat: "PATH_FORMAT_BIP32",
            path: "m/44'/501'/0'/0/0",
            addressFormat: "ADDRESS_FORMAT_SOLANA"
        };
    default:
        throw new Error(`Unsupported wallet type: ${e}`)
    }
}
  , WUe = y.memo(( ({onClose: e, credentialIds: t, initialWalletType: n, allImportIds: r}) => {
    var a;
    const {t: s} = we()
      , l = (null == (a = VK().user) ? void 0 : a.uid) ?? null
      , {trackStartedWalletImport: i} = hf()
      , [c,d] = y.useState(n)
      , [u,p] = y.useState(!1)
      , h = y.useRef(null)
      , m = y.useMemo(( () => {
        const e = ( ({walletType: e, allImportIds: {ethEndUserId: t, ethSubOrgId: n, solEndUserId: r, solSubOrgId: a}}) => e === pc.SOL && r && a ? {
            subOrgId: a,
            endUserId: r
        } : e === pc.ETH && t && n ? {
            subOrgId: n,
            endUserId: t
        } : null)({
            walletType: c,
            allImportIds: r
        });
        return e ?? {
            subOrgId: null,
            endUserId: null
        }
    }
    ), [c, r])
      , {initialize: g, isInitializing: x, process: b, isProcessing: f, inject: k} = ( ({uid: e, subOrgId: t, endUserId: n, credentialIds: r, containerRef: a}) => {
        const s = y.useRef(null)
          , l = pK()
          , [i,c] = y.useState(!1)
          , [d,u] = y.useState(!1)
          , p = y.useRef(null)
          , h = YT()
          , m = y.useCallback((async () => {
            var i;
            const d = {
                success: !1
            };
            if (!e)
                return d;
            if (!t || !n)
                return d;
            if (h.isContextLoading)
                return d;
            c(!0),
            s.current || (s.current = new cr({
                iframeUrl: "https://import.turnkey.com",
                iframeContainer: a.current,
                iframeElementId: `turnkey-import-iframe-${n}`
            }));
            try {
                s.current.publicKey() || await s.current.init();
                const e = null == (i = (await FT(r, !!h.hasApiAuthenticator, h.apiStamper).initImportPrivateKey({
                    type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY",
                    timestampMs: String(+(await kg())),
                    organizationId: t,
                    parameters: {
                        userId: n
                    }
                })).activity.result.initImportPrivateKeyResult) ? void 0 : i.importBundle;
                if (!e)
                    throw new Error("unexpected error importing wallet");
                if (p.current = e,
                !(await s.current.injectImportBundle(e, t, n)))
                    throw new Error("unexpected error while injecting import bundle");
                d.success = !0
            } catch (fNe) {
                o(fNe),
                l({
                    message: uu.walletImportFailed,
                    snackName: pu.importFailed,
                    type: "error"
                }, "import-wallet-error")
            } finally {
                c(!1)
            }
            return d
        }
        ), [e, t, n, a, r, l, h])
          , g = y.useCallback((async () => {
            if (!s.current || !t || !n)
                return;
            const e = p.current;
            if (!e)
                throw new Error("unexpected error importing wallet");
            if (!(await s.current.injectImportBundle(e, t, n)))
                throw new Error("unexpected error while injecting import bundle")
        }
        ), [t, n])
          , x = y.useCallback((async ({name: a, walletType: o}) => {
            if (!e)
                return {
                    success: !1,
                    error: "Missing uid"
                };
            if (!t || !n)
                return {
                    success: !1,
                    error: "Missing id"
                };
            if (!a)
                return {
                    success: !1,
                    error: "Missing name"
                };
            if (h.isContextLoading)
                return {
                    success: !1,
                    error: "Velvet loading"
                };
            u(!0);
            try {
                if (!s.current)
                    throw new Error("Stamper missing");
                const l = await s.current.extractKeyEncryptedBundle(o === pc.SOL ? dr.Solana : dr.Hexadecimal)
                  , i = UUe(o)
                  , c = await FT(r.length > 0 ? r : null, !!h.hasApiAuthenticator, h.apiStamper).stampImportPrivateKey({
                    type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY",
                    timestampMs: String(+(await kg())),
                    organizationId: t,
                    parameters: {
                        encryptedBundle: l,
                        userId: n,
                        addressFormats: [i.addressFormat],
                        curve: i.curve,
                        privateKeyName: a
                    }
                });
                return await am.finalizeWalletImportv2({
                    uid: e,
                    signedRequest: c,
                    walletType: o
                })
            } catch (W$e) {
                return {
                    success: !1,
                    error: W$e
                }
            } finally {
                u(!1)
            }
        }
        ), [r, n, t, e, h]);
        return y.useMemo(( () => ({
            initialize: m,
            isInitializing: i,
            isProcessing: d,
            process: x,
            inject: g
        })), [m, i, d, x, g])
    }
    )({
        ...m,
        uid: l,
        credentialIds: t,
        containerRef: h
    })
      , C = IUe()
      , A = UD((e => e.requiresVelvetSolanaMigration))
      , w = y.useCallback((async () => {
        if (i(),
        c === pc.SOL && A)
            return void (await C());
        (await g()).success && p(!0)
    }
    ), [g, i, c, A, C]);
    return v.jsxs(S, {
        mt: -1,
        children: [v.jsx(S, {
            mb: 3,
            children: v.jsx(DUe, {})
        }), v.jsx(rt, {
            in: !u,
            children: v.jsxs(S, {
                gap: 3,
                children: [v.jsx(AUe, {
                    size: "xlarge",
                    walletType: c,
                    setWalletType: d,
                    labelTypographyVariant: "labelLarge"
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 2,
                    children: [v.jsx(V, {
                        fullWidth: !0,
                        onClick: e,
                        variant: "tertiary",
                        children: s("Close")
                    }), v.jsx(TUe, {
                        fullWidth: !0,
                        onClick: w,
                        variant: "primary",
                        isLoading: x,
                        disabled: !m.subOrgId || !m.endUserId,
                        children: s("Start importing")
                    })]
                })]
            })
        }), v.jsx(rt, {
            in: u,
            children: v.jsx(LUe, {
                close: e,
                walletType: c,
                iframeContainerRef: h,
                processIframeInput: b,
                isProcessing: f,
                inject: k
            })
        })]
    })
}
))
  , FUe = {
    openCreateForm: O,
    openEditForm: O,
    openImportForm: O,
    isImportAvailablePerType: {
        [pc.ETH]: !1,
        [pc.SOL]: !1
    }
}
  , VUe = y.createContext(FUe);
function HUe(e) {
    return e.split(/[\s:_"-]+/).map((e => function(e) {
        try {
            if (e.length >= 40 && e.length <= 100 && function(e) {
                return /^[1-9A-HJ-NP-Za-km-z]+$/.test(e)
            }(e))
                return 64 === It.decode(e).length
        } catch (fNe) {
            return !1
        }
        return !1
    }(e) || function(e) {
        if (e.length > 60 && e.length < 70)
            return /^[0-9a-fA-F]{64}$/.test(e);
        return !1
    }(e) ? "***POTENTIAL_PRIVATE_KEY***" : e)).join(" ").trim().slice(0, 10)
}
VUe.displayName = "WalletManagementContext";
const zUe = ({wallet: e, credentialIds: t, ...n}) => {
    const r = D()
      , a = y.useRef(null)
      , s = y.useRef(null)
      , [l,i] = y.useState(!1)
      , [c,d] = y.useState(null)
      , [u,p] = y.useState(!1)
      , h = YT()
      , m = UD((e => e.requiresVelvetSolanaMigration))
      , g = IUe()
      , x = y.useCallback((async (e, n) => {
        if (Ve("getWalletExportBundle", {
            extra: {
                publicKey: e,
                wallet: n,
                credentialIds: t,
                hasApiAuthenticator: !!h.hasApiAuthenticator,
                hasApiStamper: !!h.apiStamper,
                requiresVelvetSolanaMigration: m
            }
        }),
        !h.isContextLoading) {
            if (n.walletType !== pc.SOL || !m)
                return mX(t, h, e, n);
            await g()
        }
    }
    ), [t, h, m, g])
      , b = y.useCallback((async (e, n) => (Ve("getWalletExportBundle", {
        extra: {
            publicKey: e,
            wallet: n,
            credentialIds: t,
            hasApiAuthenticator: !!h.hasApiAuthenticator,
            hasApiStamper: !!h.apiStamper
        }
    }),
    gX(t, h, e, n))), [t, h])
      , f = y.useCallback((async () => {
        p(!0),
        a.current || (a.current = new cr({
            iframeUrl: "https://export.turnkey.com",
            iframeContainer: s.current,
            iframeElementId: `turnkey-iframe-${e.publicAddress}`
        }));
        try {
            const t = a.current.publicKey() ?? await a.current.init()
              , n = await (e.isImported ? b(t, e) : x(t, e));
            if (!n)
                throw new Error("unexpected error exporting wallet");
            if (!0 !== await a.current.injectKeyExportBundle(n, e.subOrgId, e.walletType === pc.SOL ? dr.Solana : dr.Hexadecimal))
                throw new Error("unexpected error while injecting export bundle");
            i(!0)
        } catch (fNe) {
            o(`Export wallet failed: ${HUe(String(fNe))}`),
            d("Wallet export failed")
        } finally {
            p(!1)
        }
    }
    ), [e, b, x])
      , C = y.useCallback(( () => {
        var e;
        i(!1),
        null == (e = a.current) || e.clear(),
        a.current = null
    }
    ), []);
    return v.jsxs(S, {
        gap: 2,
        ...n,
        children: [l ? v.jsx(V, {
            "data-testid": "export-wallet-button-hide",
            variant: "primary",
            onClick: C,
            startIcon: v.jsx(ur, {
                fontSize: "small",
                color: "inherit"
            }),
            children: "Hide private key"
        }) : v.jsx(V, {
            "data-testid": "export-wallet-button",
            variant: "primary",
            onClick: f,
            disabled: l,
            startIcon: v.jsx(pr, {
                fontSize: "small",
                color: "inherit"
            }),
            children: "Show private key"
        }), v.jsxs(S, {
            height: $Ue,
            overflow: "hidden",
            gap: 2,
            position: "relative",
            children: [u && v.jsx(hr, {
                color: "primary",
                "data-testid": "export-wallet-progress",
                sx: {
                    width: "100%"
                }
            }), c && v.jsx(k, {
                variant: "bodyLarge",
                color: r.palette.error.main,
                children: c
            }), v.jsx(S, {
                ref: s,
                display: l ? void 0 : "none",
                flexGrow: 1,
                alignSelf: "center",
                width: "100%",
                maxWidth: GUe,
                children: v.jsx("style", {
                    children: qUe
                })
            })]
        })]
    })
}
  , $Ue = 80
  , GUe = 420
  , qUe = `\niframe {\n    border: none;\n    max-height: ${$Ue}px;\n    overflow: auto;\n}\n`
  , KUe = ({isOpen: e, walletToEdit: t}) => {
    const {values: {name: n, walletType: r}, errors: a, touched: s, setTouched: o, setFieldValue: l, setSubmitting: i, handleChange: c, handleBlur: d} = Tn();
    y.useEffect(( () => {
        (async () => {
            e || (await o({
                name: !1
            }),
            await l("name", ""))
        }
        )()
    }
    ), [e, i, o, l]);
    const u = y.useCallback((async e => {
        await l("walletType", e)
    }
    ), [l]);
    return v.jsxs(S, {
        gap: 1,
        children: [t && v.jsx(je, {
            disabled: !0,
            name: "address",
            startAdornment: v.jsx(We, {
                position: "start",
                children: v.jsx(k, {
                    htmlFor: "address-input",
                    ...YUe,
                    children: "Wallet address"
                })
            }),
            inputProps: {
                ...Su,
                id: "address-input"
            },
            sx: e => ({
                "& .MuiOutlinedInput-input": {
                    ...e.typography.monoLarge,
                    textAlign: "right",
                    fontWeight: 500
                },
                "&.Mui-disabled .MuiOutlinedInput-input": {
                    color: "text.label",
                    WebkitTextFillColor: "currentColor"
                }
            }),
            endAdornment: QC && v.jsx(We, {
                position: "end",
                children: v.jsx(cA, {
                    address: t.publicAddress,
                    labelSx: {
                        color: "text.secondary"
                    }
                })
            })
        }), v.jsx(AUe, {
            size: "xlarge",
            walletType: r,
            setWalletType: u,
            disabled: !!t,
            labelTypographyVariant: "labelLarge"
        }), v.jsx(je, {
            size: "xlarge",
            name: "name",
            value: n,
            onChange: c,
            onBlur: d,
            error: s.name && !!a.name,
            startAdornment: v.jsx(We, {
                position: "start",
                children: v.jsx(k, {
                    htmlFor: "wallet-name-input",
                    ...YUe,
                    children: "Name"
                })
            }),
            inputProps: {
                ...Su,
                id: "wallet-name-input",
                style: {
                    textAlign: "right",
                    fontWeight: 500
                }
            }
        }), v.jsx(k, {
            variant: "bodySmall",
            color: "error",
            sx: {
                "&:empty::before": {
                    content: "''",
                    display: "inline-block"
                }
            },
            children: s.name && a.name || ""
        })]
    })
}
  , YUe = {
    variant: "labelLarge",
    color: "text.label",
    component: "label"
}
  , XUe = ({isSuborgAvailableByWalletType: e, isEdit: t, onCloseClick: n}) => {
    const {values: {name: r, walletType: a}, errors: {name: s}, isSubmitting: o, isValid: l, submitForm: i, dirty: c} = Tn()
      , d = y.useMemo(( () => e[a]), [e, a]);
    return v.jsxs(S, {
        direction: "row",
        gap: 2,
        children: [v.jsx(V, {
            fullWidth: !0,
            onClick: n,
            variant: "tertiary",
            children: "Close"
        }), v.jsx(z, {
            title: t && !c ? "No changes to save" : r ? d ? `Trading ${a} not enabled` : "" : "Name of the wallet is required",
            children: v.jsx(C, {
                component: "span",
                width: "100%",
                children: v.jsx(V, {
                    fullWidth: !0,
                    "data-testid": "wallet-management-submit-button",
                    type: "submit",
                    onClick: i,
                    color: s ? "error" : "primary",
                    variant: "primary",
                    disabled: !r || o || !d || !l || t && !c,
                    children: v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        alignItems: "center",
                        children: [o && v.jsx(J, {
                            size: QUe
                        }), t ? "Save" : "Create", o && v.jsx(C, {
                            width: QUe
                        })]
                    })
                })
            })
        })]
    })
}
  , QUe = 16
  , ZUe = y.memo(( ({isOpen: e, walletToEdit: t, onClose: n, defaultWalletType: r, ethSubOrgId: a, solSubOrgId: s, credentialIds: o}) => {
    const {user: l} = VK()
      , i = pK()
      , c = YT()
      , d = IUe()
      , u = UD((e => e.requiresVelvetSolanaMigration))
      , p = y.useCallback((async e => {
        if ((null == l ? void 0 : l.uid) && t)
            try {
                await am.renameWallet({
                    uid: l.uid,
                    walletId: t.walletId,
                    walletType: t.walletType,
                    newName: e
                }),
                i({
                    message: pu.updateSuccess,
                    type: "success"
                }, "wallet-update-success")
            } catch (fNe) {
                i({
                    message: pu.updateFailed,
                    type: "error"
                }, "wallet-update-fail")
            }
    }
    ), [null == l ? void 0 : l.uid, t, i])
      , h = y.useCallback((async ({walletName: e, walletType: t}) => {
        if (!c.isContextLoading && (null == l ? void 0 : l.uid) && (0 !== o.length || c.hasApiAuthenticator))
            try {
                if (t === pc.SOL && u)
                    return void (await d());
                await (async ({walletType: e, walletName: t, ethSubOrgId: n, solSubOrgId: r, credentialIds: a, hasApiAuthenticator: s, apiStamper: o}) => {
                    let l;
                    const i = UUe(e);
                    switch (e) {
                    case pc.ETH:
                        l = n;
                        break;
                    case pc.SOL:
                        l = r
                    }
                    if (!l)
                        throw new Error(`Missing subOrgId for wallet type: ${e}`);
                    const c = await FT(a, s, o).stampCreateWallet({
                        type: "ACTIVITY_TYPE_CREATE_WALLET",
                        timestampMs: String(+(await kg())),
                        organizationId: l,
                        parameters: {
                            walletName: t,
                            accounts: [i]
                        }
                    });
                    return await am.createWallet({
                        signedRequest: c
                    })
                }
                )({
                    walletType: t,
                    walletName: e,
                    ethSubOrgId: a,
                    solSubOrgId: s,
                    credentialIds: o,
                    hasApiAuthenticator: !!c.hasApiAuthenticator,
                    apiStamper: c.apiStamper
                }),
                i({
                    message: pu.createSuccess,
                    type: "success"
                }, "wallet-create-success")
            } catch (fNe) {
                i({
                    message: pu.createFailed,
                    type: "error"
                }, "wallet-create-fail")
            }
    }
    ), [null == l ? void 0 : l.uid, i, a, s, o, c, u, d])
      , m = y.useCallback((async (e, {setSubmitting: r, setErrors: a}) => {
        if (r(!0),
        0 !== o.length || c.hasApiAuthenticator)
            try {
                t ? await p(e.name) : await h({
                    walletName: e.name,
                    walletType: e.walletType
                }),
                null == n || n()
            } catch (fNe) {
                a({
                    name: "Something went wrong"
                })
            } finally {
                r(!1)
            }
    }
    ), [n, o, t, p, h, c])
      , g = y.useMemo(( () => ({
        [pc.ETH]: !!a,
        [pc.SOL]: !!s
    })), [a, s]);
    return v.jsx(Ln, {
        initialValues: eWe(r, null == t ? void 0 : t.walletName),
        validationSchema: JUe,
        onSubmit: m,
        children: v.jsxs(v.Fragment, {
            children: [v.jsxs(S, {
                gap: 2,
                children: [v.jsx(KUe, {
                    isOpen: e,
                    walletToEdit: t
                }), t && (o.length > 0 || c.apiStamper) && v.jsxs(v.Fragment, {
                    children: [v.jsx(Ee, {
                        sx: {
                            mb: 2
                        }
                    }), v.jsx(zUe, {
                        wallet: t,
                        credentialIds: o
                    })]
                })]
            }), v.jsx(XUe, {
                isEdit: !!t,
                isSuborgAvailableByWalletType: g,
                onCloseClick: n
            })]
        })
    })
}
))
  , JUe = Qe().shape({
    name: qe().required(qD)
})
  , eWe = (e, t="") => ({
    name: t,
    walletType: e
})
  , tWe = y.memo(( ({children: e}) => {
    const {t: t} = we()
      , {ethSubOrgId: n, solSubOrgId: r, credentialIds: a, ethEndUserId: s, solEndUserId: o} = UD((e => e))
      , l = YT()
      , i = y.useMemo(( () => ({
        ethEndUserId: s,
        ethSubOrgId: n,
        solEndUserId: o,
        solSubOrgId: r
    })), [s, n, o, r])
      , c = y.useMemo(( () => ({
        [pc.ETH]: !(!s || !n),
        [pc.SOL]: !(!o || !r)
    })), [s, n, o, r])
      , {isOpen: d, close: u, open: p} = jUe()
      , {isOpen: h, close: m, open: g} = jUe()
      , {isOpen: x, close: b, open: f} = jUe()
      , [S,k] = y.useState(pc.ETH)
      , [C,A] = y.useState(null)
      , w = y.useCallback((e => {
        k(e),
        A(null),
        p()
    }
    ), [p])
      , j = y.useCallback((e => {
        k(e.walletType),
        A(e),
        g()
    }
    ), [g])
      , T = y.useCallback((e => {
        c[e] && (k(e),
        A(null),
        f())
    }
    ), [f, c])
      , I = y.useMemo(( () => ({
        openCreateForm: w,
        openEditForm: j,
        openImportForm: T,
        isImportAvailablePerType: c
    })), [w, j, T, c]);
    return v.jsxs(VUe.Provider, {
        value: I,
        children: [e, v.jsx(U5, {
            title: t("Manage wallet"),
            open: g,
            close: m,
            isOpen: h,
            modalLayoutProps: {
                maxDesktopHeight: 565
            },
            children: v.jsx(ZUe, {
                isOpen: h,
                walletToEdit: C,
                onClose: m,
                defaultWalletType: S,
                ethSubOrgId: n,
                solSubOrgId: r,
                credentialIds: a
            })
        }), v.jsx(U5, {
            title: t("Create wallet"),
            open: p,
            close: u,
            isOpen: d,
            modalLayoutProps: {
                maxDesktopHeight: 340
            },
            children: v.jsx(ZUe, {
                isOpen: d,
                walletToEdit: null,
                onClose: u,
                defaultWalletType: S,
                ethSubOrgId: n,
                solSubOrgId: r,
                credentialIds: a
            })
        }), v.jsx(U5, {
            title: t("Import wallet"),
            subtitle: t("Import an existing wallet with your private key. Only you should know your private key."),
            open: f,
            close: b,
            isOpen: x,
            showCloseButton: !0,
            modalLayoutProps: {
                maxDesktopHeight: 750
            },
            children: (a.length > 0 || l.apiStamper) && v.jsx(WUe, {
                onClose: b,
                initialWalletType: S,
                credentialIds: a,
                allImportIds: i
            })
        })]
    })
}
))
  , nWe = () => y.useContext(VUe)
  , rWe = y.memo(( ({walletType: e=pc.ETH}) => {
    const {t: t} = we()
      , {openImportForm: n} = nWe()
      , r = y.useCallback(( () => {
        n(e)
    }
    ), [e, n]);
    return v.jsx(hUe, {
        onClick: r,
        label: t("Import wallet")
    })
}
))
  , aWe = ({isAcking: e, finishOnboarding: t}) => {
    const {t: n} = we()
      , {wallets: r, hiddenWallets: a} = UD((e => e))
      , {openNewSession: s, isSessionActive: o, isUnlocking: l} = $K()
      , {apiStamper: i} = YT()
      , [c,d] = y.useState(pc.SOL)
      , u = y.useMemo(( () => r ? r.find(( ({walletType: e}) => e === c)) : null), [r, c]);
    y.useEffect(( () => {
        !o && !l && i && (r && r.length > 0 || a && a.length > 0) && s(!0).catch((e => {}
        ))
    }
    ), [o, l, i, r, s, a]);
    const {setLastSelectedWalletsPerChain: p} = OD();
    return y.useEffect(( () => {
        if (!r)
            return;
        const e = r.filter(( ({walletType: e}) => e === pc.SOL))
          , t = r.filter(( ({walletType: e}) => e === pc.ETH))
          , n = e.filter(( ({isImported: e}) => e))
          , a = t.filter(( ({isImported: e}) => e))
          , s = n.length ? n.map(( ({publicAddress: e}) => ng(e))).slice(0, gc(pc.SOL)) : e.length ? [ng(e[0].publicAddress)] : null
          , o = a.length ? a.map(( ({publicAddress: e}) => ng(e))).slice(0, gc(pc.ETH)) : t.length ? [ng(t[0].publicAddress)] : null;
        p((e => ({
            ...e,
            ...null === s ? {} : {
                [Pd.SOLANA]: s
            },
            ...null === o ? {} : {
                [Pd.ETH_MAINNET]: o,
                [Pd.BASE]: o,
                [Pd.BSC]: o
            }
        })))
    }
    ), [p, r]),
    v.jsxs(v.Fragment, {
        children: [v.jsx(k, {
            variant: "h1",
            fontSize: 20,
            color: "primary.main",
            children: n("Wallets ready. Select chain below")
        }), v.jsxs(S, {
            gap: 1.5,
            alignSelf: "stretch",
            minWidth: {
                sm: oWe
            },
            children: [v.jsx(AUe, {
                fullWidth: !0,
                size: "xlarge",
                walletType: c,
                setWalletType: d,
                labelTypographyVariant: "labelLarge"
            }), u && v.jsxs(v.Fragment, {
                children: [v.jsxs(S, {
                    py: 2,
                    gap: 2,
                    alignItems: "center",
                    borderRadius: 1,
                    border: e => `1px solid ${e.palette.background.borderSubtle}`,
                    children: [v.jsx(k, {
                        variant: "labelLarge",
                        children: n("Top up your wallet")
                    }), v.jsx(C, {
                        sx: {
                            background: "white"
                        },
                        p: 1,
                        children: v.jsx(Vn, {
                            size: sWe,
                            value: u.publicAddress,
                            viewBox: `0 0 ${sWe} ${sWe}`
                        })
                    })]
                }), v.jsx(S, {
                    alignSelf: "center",
                    children: v.jsx(cA, {
                        address: u.publicAddress,
                        customName: u.publicAddress,
                        maxWidth: "none",
                        labelVariant: "monoLarge",
                        containerSx: {
                            height: bu.XLARGE,
                            backgroundColor: "background.tertiary"
                        },
                        labelSx: {
                            whiteSpace: {
                                xs: "wrap",
                                sm: "nowrap"
                            },
                            overflow: {
                                xs: "initial",
                                sm: "hidden"
                            },
                            textOverflow: {
                                xs: "initial",
                                sm: "ellipsis"
                            },
                            wordBreak: {
                                xs: "break-all",
                                sm: "none"
                            }
                        }
                    })
                })]
            })]
        }), v.jsxs(S, {
            gap: 1,
            width: "100%",
            children: [v.jsx(S, {
                gap: 1,
                width: "100%",
                alignItems: "center",
                children: v.jsx(V, {
                    size: "large",
                    disabled: e,
                    onClick: t,
                    sx: lWe,
                    children: n("Start trading")
                })
            }), v.jsx(rWe, {})]
        })]
    })
}
  , sWe = 140
  , oWe = 300
  , lWe = {
    mt: 2,
    borderRadius: 5,
    width: 175,
    alignSelf: "center",
    color: "#000000",
    boxShadow: "0 0 30px 0px #86EFAC66"
}
  , iWe = y.memo(( ({id: e, isChecked: t, onChange: n, hasError: r, label: a, checkboxProps: s={}, typographyProps: o={}, ...l}) => {
    const i = y.useCallback((e => {
        n(e.target.checked)
    }
    ), [n]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        ...l,
        children: [v.jsx(_e, {
            id: e,
            ...s,
            checked: t,
            onChange: i,
            size: "large",
            sx: e => ({
                color: t ? e.palette.primary.main : r ? e.palette.error.main : e.palette.text.secondary
            })
        }), v.jsx(k, {
            component: "label",
            htmlFor: e,
            variant: "labelLarge",
            color: !t && r ? "error.main" : "text.label",
            sx: {
                cursor: "pointer"
            },
            ...o,
            children: a
        })]
    })
}
))
  , cWe = y.memo(( ({isAcknowledged: e, toggleIsAcknowledged: t, isAcknowledgedErrorVisible: n, showAcknowledgedError: r, onContinueClick: a}) => {
    const {t: s} = we()
      , o = y.useMemo(( () => ({
        borderRadius: 5,
        width: 150,
        alignSelf: "center",
        color: "#000000",
        boxShadow: e ? "0 0 30px 0px #86EFAC66" : "none"
    })), [e]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(k, {
            variant: "h1",
            fontSize: 20,
            color: "primary.main",
            children: s("Password ready")
        }), v.jsxs(S, {
            gap: 3,
            alignSelf: "stretch",
            children: [v.jsx(VEe, {
                severity: "warning",
                py: 2,
                mb: 0,
                bgcolor: "background.default",
                children: v.jsx(S, {
                    gap: 1,
                    children: v.jsx(k, {
                        variant: "bodyLarge",
                        children: v.jsxs(ir, {
                            i18nKey: "Password importance message",
                            components: {
                                br: v.jsx("br", {})
                            },
                            children: ["This password is the only way to use your wallets via the Terminal app. If you lose your password, it cannot be recovered.", v.jsx("br", {}), v.jsx("br", {}), "We recommend exporting your private keys to mitigate the risk of permanently losing access to your funds."]
                        })
                    })
                })
            }), v.jsx(iWe, {
                id: "private-keys-export-acknowledgement-checkbox",
                label: s("I will export and safely store my private keys before depositing funds"),
                onChange: t,
                isChecked: e,
                hasError: n && !e,
                checkboxProps: {
                    "data-testid": "private-keys-export-acknowledgement-checkbox"
                }
            })]
        }), v.jsxs(S, {
            gap: 1,
            width: "100%",
            children: [v.jsx(S, {
                gap: 1,
                width: "100%",
                children: v.jsx(C, {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    width: "100%",
                    onClick: e ? void 0 : r,
                    children: v.jsx(V, {
                        "data-testid": "button-password-importance-ack",
                        disabled: !e,
                        onClick: e ? a : void 0,
                        sx: o,
                        variant: "primary",
                        children: s("Continue")
                    })
                })
            }), v.jsx(mUe, {})]
        })]
    })
}
))
  , dWe = () => {
    const e = bw()
      , {user: t, initSignOut: n} = VK()
      , {ackWallets: r} = UD((e => e))
      , {apiStamper: a} = YT()
      , s = null == a ? void 0 : a.apiPublicKey
      , [l,i] = y.useState("NEEDS_INIT")
      , c = y.useCallback(( () => {
        (null == t ? void 0 : t.uid) && (i("IS_ACKING"),
        r(t.uid).catch((e => {}
        )))
    }
    ), [r, t])
      , [d,u] = y.useState(!1)
      , p = y.useCallback(( () => {
        u((e => !e))
    }
    ), [])
      , [h,m] = y.useState(!1)
      , g = y.useCallback(( () => {
        m(!0)
    }
    ), [])
      , [x,b] = y.useState(!1)
      , f = y.useCallback(( () => {
        (null == t ? void 0 : t.uid) && s && (i("IS_INITIALIZING"),
        (async () => {
            b(!1);
            try {
                await DD(s),
                i("NEEDS_ACK")
            } catch (W$e) {
                o(W$e),
                b(!0),
                i("NEEDS_INIT")
            }
        }
        )())
    }
    ), [null == t ? void 0 : t.uid, s])
      , k = cT()
      , C = y.useMemo(( () => {
        switch (l) {
        case "NEEDS_INIT":
            return v.jsx(cWe, {
                isAcknowledged: d,
                isAcknowledgedErrorVisible: h,
                toggleIsAcknowledged: p,
                showAcknowledgedError: g,
                onContinueClick: f
            });
        case "IS_INITIALIZING":
            return v.jsx(gUe, {
                hasError: x,
                onRetry: f
            });
        case "IS_ACKING":
        case "NEEDS_ACK":
            return v.jsx(aWe, {
                finishOnboarding: c,
                isAcking: "IS_ACKING" === l
            });
        default:
            {
                const e = () => {
                    n(k)
                }
                ;
                return v.jsxs(S, {
                    children: ["Unknown step ", v.jsx(V, {
                        onClick: e,
                        children: "sign out"
                    })]
                })
            }
        }
    }
    ), [l, d, p, h, g, n, k, f, x, c]);
    return v.jsx(vK, {
        children: v.jsx(S, {
            width: "100%",
            maxWidth: 460,
            minWidth: e ? 460 : 150,
            minHeight: 500,
            alignItems: "center",
            justifyContent: "IS_INITIALIZING" === l || "NEEDS_INIT" === l ? "center" : "flex-start",
            sx: uWe,
            children: C
        })
    })
}
  , uWe = {
    px: {
        xs: 2,
        sm: 3,
        md: 4
    },
    gap: 3,
    borderRadius: 2
}
  , pWe = "ma_of"
  , hWe = "padreV2-marketingOffer"
  , mWe = e => {
    localStorage.setItem(hWe, e)
}
  , gWe = ({isInCreateMode: e, overwriteLabel: t, onSnoozeMigration: n}) => {
    const {t: r} = we()
      , a = D()
      , {submitForm: s, errors: o, isSubmitting: l, values: i} = Tn()
      , [c,d] = y.useState(!1)
      , u = y.useCallback(( () => {
        d((e => !e))
    }
    ), [])
      , [p,h] = y.useState(!1)
      , m = y.useCallback(( () => {
        h((e => !e))
    }
    ), [])
      , g = "" === i.password || l || !!o.password || e && !!o.repeatPassword
      , x = y.useMemo(( () => ({
        borderRadius: 5,
        width: t ? 275 : e ? 165 : 125,
        alignSelf: "center",
        color: "#000000",
        boxShadow: g ? "none" : "0 0 30px 0px #86EFAC66"
    })), [g, e, t]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(Zn, {
            name: "password",
            children: ({field: t, form: {touched: n, errors: a}}) => v.jsxs(S, {
                gap: 1,
                minWidth: 275,
                children: [v.jsx(je, {
                    ...t,
                    "data-testid": "velvet-password-input",
                    placeholder: r("Password"),
                    type: c ? "text" : "password",
                    error: n.password && !!a.password,
                    endAdornment: v.jsx(We, {
                        position: "end",
                        children: v.jsx(F, {
                            sx: bWe,
                            onClick: u,
                            tabIndex: -1,
                            children: c ? v.jsx(Ek, {}) : v.jsx(Tk, {})
                        })
                    }),
                    inputProps: {
                        [vu]: "false"
                    },
                    sx: xWe,
                    size: "xlarge"
                }), v.jsx(C, {
                    height: e ? void 0 : 16,
                    justifyContent: "center",
                    display: "flex",
                    children: v.jsx(mr, {
                        name: "password",
                        children: e => v.jsx(k, {
                            color: "negative.main",
                            variant: "paragraph3",
                            children: e
                        })
                    })
                })]
            })
        }), e && v.jsx(Zn, {
            name: "repeatPassword",
            children: ({field: e, form: {touched: t, errors: n}}) => v.jsxs(S, {
                gap: 1,
                children: [v.jsx(je, {
                    ...e,
                    "data-testid": "repeat-velvet-password-input",
                    placeholder: r("Repeat password"),
                    type: p ? "text" : "password",
                    error: t.repeatPassword && !!n.repeatPassword,
                    endAdornment: v.jsx(We, {
                        position: "end",
                        tabIndex: -1,
                        children: v.jsx(F, {
                            sx: bWe,
                            onClick: m,
                            tabIndex: -1,
                            children: p ? v.jsx(Ek, {}) : v.jsx(Tk, {})
                        })
                    }),
                    inputProps: {
                        [vu]: "false"
                    },
                    sx: xWe,
                    size: "xlarge"
                }), v.jsx(C, {
                    height: 16,
                    justifyContent: "center",
                    display: "flex",
                    children: v.jsx(mr, {
                        name: "repeatPassword",
                        children: e => v.jsx(k, {
                            color: "negative.main",
                            variant: "paragraph3",
                            children: e
                        })
                    })
                })]
            })
        }), v.jsx(V, {
            fullWidth: !0,
            variant: "primary",
            disabled: g,
            type: "submit",
            onClick: s,
            sx: x,
            endIcon: v.jsx(rt, {
                orientation: "horizontal",
                unmountOnExit: !0,
                in: l,
                sx: fWe,
                children: v.jsx(J, {
                    size: 16
                })
            }),
            children: t || r(e ? "Set up password" : "Login")
        }), n && v.jsxs(k, {
            variant: "bodyLarge",
            color: a.palette.text.meta,
            sx: {
                display: "flex",
                alignSelf: "center",
                gap: 1
            },
            children: [r("Not ready to set up password yet?"), " ", v.jsx(C, {
                onClick: n,
                sx: {
                    cursor: "pointer",
                    color: a.palette.primary.main,
                    fontWeight: wu.SEMIBOLD
                },
                children: r("Snooze for 24 hours")
            })]
        })]
    })
}
  , xWe = e => ({
    background: "black",
    borderRadius: 20,
    border: `1px solid ${e.palette.background.borderMain}`,
    "& .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&:hover .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
        border: "none"
    },
    [`&.${Ot.error}`]: {
        [`.${Ot.input}, .${Ot.input}::placeholder`]: {
            color: e.palette.text.value
        }
    }
})
  , bWe = {
    p: 0
}
  , fWe = {
    minWidth: 16
}
  , vWe = () => {
    const {t: e} = we()
      , {trackCreatedPassword: t} = hf()
      , {marketingOffer: n} = ( () => {
        const [e,t] = y.useState(!0)
          , [n,r] = xe()
          , a = n.get(pWe);
        return y.useEffect(( () => {
            a && mWe(a),
            r((e => (e.delete(pWe),
            e))),
            t(!1)
        }
        ), [a, r]),
        {
            marketingOffer: localStorage.getItem(hWe),
            isLoading: e
        }
    }
    )()
      , {claimMarketingOffer: r} = VK()
      , a = YT()
      , s = y.useMemo(( () => a.isContextLoading ? null : !a.hasApiAuthenticator), [a])
      , o = y.useCallback((async (e, {setSubmitting: o, resetForm: l}) => {
        if (null !== s) {
            o(!0);
            try {
                if (s) {
                    const s = n ? r(n) : Promise.resolve();
                    await a.createAuthenticator(e.password),
                    t(),
                    await s
                } else
                    await a.providePassword(e.password);
                l()
            } catch (fNe) {
                o(!1),
                l()
            }
        }
    }
    ), [s, a, t, r, n])
      , l = y.useMemo(( () => Qe().shape({
        password: qe().min(8, e("Password is at least 8 characters long")).required(e("Please enter password"))
    })), [e])
      , i = y.useMemo(( () => Qe().shape({
        password: qe().min(8, e("Password is at least 8 characters long")).required(e("Please enter password")),
        repeatPassword: qe().oneOf([gr("password")], "Passwords must match").required("Please repeat password")
    })), [e]);
    return null === s ? v.jsx(vK, {
        children: v.jsx(Km, {})
    }) : v.jsx(vK, {
        children: v.jsxs(S, {
            gap: 1.5,
            minHeight: 500,
            minWidth: 350,
            alignItems: "center",
            justifyContent: "center",
            children: [v.jsx(k, {
                variant: "h1",
                fontSize: 20,
                textAlign: "center",
                mb: 2.5,
                color: "primary.main",
                children: e(s ? "Create your password" : "Provide your password")
            }), v.jsx(Ln, {
                initialValues: SWe,
                validationSchema: s ? i : l,
                onSubmit: o,
                validateOnMount: !0,
                children: v.jsx(Rn, {
                    children: v.jsx(gWe, {
                        isInCreateMode: s
                    })
                })
            }), v.jsx(mUe, {})]
        })
    })
}
  , SWe = {
    password: "",
    repeatPassword: ""
}
  , yWe = y.memo(( ({velvetContext: e}) => {
    const t = UD((e => e)).state !== BD.INITIALIZING
      , n = !e.isContextLoading;
    return t && n ? e.hasApiAuthenticator && e.apiStamper ? (o("Unexpected state in VelvetHandler. This means programming error.", {
        extra: {
            hasApiAuthenticator: e.hasApiAuthenticator,
            hasApiStamper: !!e.apiStamper
        }
    }),
    v.jsx(pve, {})) : v.jsx(vWe, {}) : v.jsx(vK, {
        children: v.jsx(Km, {})
    })
}
))
  , kWe = y.memo(( () => {
    const {value: e} = (e => {
        const t = me()
          , {pathname: n, hash: r, search: a} = he()
          , s = y.useMemo(( () => new URLSearchParams(a)), [a])
          , o = s.get(e)
          , l = y.useCallback((a => {
            s.set(e, a),
            t({
                pathname: n,
                hash: r,
                search: `?${ge(s)}`
            }, {
                replace: !0
            })
        }
        ), [e, t, s, n, r])
          , i = y.useCallback(( () => {
            s.delete(e),
            t({
                pathname: n,
                hash: r,
                search: `?${ge(s)}`
            }, {
                replace: !0
            })
        }
        ), [e, t, s, n, r]);
        return y.useMemo(( () => ({
            value: o,
            set: l,
            clear: i
        })), [o, l, i])
    }
    )(lT)
      , t = y.useMemo(( () => e || iT), [e])
      , n = vbe()
      , r = YT();
    return (e => {
        const {user: t, loading: n, assignToKol: r, refreshUser: a, referredByInfo: s} = VK()
          , o = H_e()
          , [l,i] = y.useState(!1)
          , c = e === fbe.HANDLE_INITIALIZE_USER || e === fbe.SETUP_VELVET;
        y.useEffect(( () => {
            let e = !1;
            if (!c)
                return;
            if (n || !t || !s || o.status === ox.LOADING || o.status === ox.INITIAL)
                return;
            if (s && (s.referredByKol || s.isReferredByUser))
                return;
            if (l)
                return;
            if (o.status === ox.ERROR)
                return;
            const {refCode: d, migrationCode: u} = o.data;
            if (d)
                return (async () => {
                    if (u)
                        try {
                            const t = await r(d, u);
                            if (e)
                                return;
                            if (!t)
                                throw new Error("Failed to verify referral")
                        } catch (fNe) {
                            if (e)
                                return
                        } finally {
                            e || i(!0)
                        }
                    else
                        try {
                            const n = await em.getRefCodeType(d);
                            if (!n)
                                throw new Error("Ref code is invalid");
                            const s = "kol" === n.type ? await r(d) : await tm.assignToRefCode({
                                refCode: d,
                                uid: t.uid
                            });
                            if (await a(),
                            e)
                                return;
                            if (!s)
                                throw new Error("Failed to verify referral")
                        } catch (fNe) {
                            if (e)
                                return
                        } finally {
                            e || i(!0)
                        }
                }
                )(),
                () => {
                    e = !0
                }
                ;
            i(!0)
        }
        ), [t, o, r, l, n, a, c, s])
    }
    )(n),
    n === fbe.REFRESH_PAGE ? v.jsx(pve, {}) : n === fbe.LOADING ? v.jsx(vK, {
        children: v.jsx(S, {
            alignItems: "center",
            justifyContent: "center",
            sx: CWe,
            children: v.jsx(Km, {})
        })
    }) : n === fbe.SIGN_IN ? v.jsx(dUe, {}) : n === fbe.SETUP_VELVET ? v.jsx(yWe, {
        velvetContext: r
    }) : n === fbe.HANDLE_INITIALIZE_USER ? v.jsx(dWe, {}) : v.jsx(T$e, {
        path: t
    })
}
))
  , CWe = {
    minHeight: 500,
    minWidth: {
        xs: 150,
        md: 450
    }
}
  , AWe = y.memo(( ({children: e}) => {
    const t = y.useMemo(( () => rX(wWe, Bb, Bb, Ub)), []);
    return v.jsx(xr, {
        theme: t,
        children: e
    })
}
))
  , wWe = rg.TERMINAL
  , jWe = y.memo(( ({label: e, onClick: t, isSelected: n}) => {
    const r = y.useMemo(( () => e => ({
        overflow: "visible",
        textTransform: "none",
        px: 1,
        pt: .75,
        pb: .25,
        fontWeight: 500,
        fontSize: 14,
        color: n ? e.palette.text.main : e.palette.text.label,
        background: "transparent",
        borderColor: "transparent",
        "&:hover, &:focus": {
            background: "transparent",
            color: n ? e.palette.text.main : e.palette.text.value,
            borderColor: "transparent"
        }
    })), [n]);
    return v.jsx(V, {
        variant: "tertiary",
        size: "xxsmall",
        onClick: t,
        sx: r,
        children: e
    })
}
))
  , TWe = y.memo(( ({selectedTab: e, setSelectedTab: t}) => {
    const {t: n} = we()
      , r = y.useCallback(( () => {
        "X_TRACKER" !== e && t("X_TRACKER")
    }
    ), [e, t])
      , a = y.useCallback(( () => {
        "WALLET_TRACKER" !== e && t("WALLET_TRACKER")
    }
    ), [e, t]);
    return v.jsxs(S, {
        direction: "row",
        gap: .75,
        alignItems: "center",
        children: [v.jsx(Xfe, {
            label: n("X Tracker"),
            onClick: r,
            isSelected: "X_TRACKER" === e,
            isBig: !0
        }), v.jsx(Xfe, {
            label: n("Wallet Tracker"),
            onClick: a,
            isSelected: "WALLET_TRACKER" === e,
            isBig: !0
        })]
    })
}
))
  , IWe = y.memo(( ({style: e, onClose: t}) => {
    const {t: n} = we()
      , {subscribeHandle: r} = KA()
      , [a,s] = y.useState("")
      , o = y.useMemo(( () => e => ({
        px: 1.5,
        background: e.palette.background.primary,
        "&:nth-of-type(even)": {
            backgroundColor: e.palette.background.secondary
        }
    })), [])
      , [l,i] = y.useState(!1)
      , c = y.useCallback((async () => {
        try {
            i(!0),
            a && await r(a),
            t()
        } catch (fNe) {} finally {
            i(!1)
        }
    }
    ), [a, t, r])
      , d = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        c())
    }
    ), [c])
      , u = y.useCallback(( ({target: {value: e}}) => {
        const t = e.replace(/[^a-zA-Z0-9_]/g, "");
        s(t.slice(0, 15))
    }
    ), []);
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        justifyContent: "space-between",
        alignItems: "center",
        height: 44,
        sx: o,
        style: e,
        children: [v.jsxs(S, {
            gap: 2,
            alignItems: "center",
            direction: "row",
            children: [v.jsx(C, {
                width: 16
            }), v.jsx(Qn, {
                autoFocus: !0,
                name: "myField",
                value: a,
                onChange: u,
                onKeyDown: d,
                autoComplete: "off",
                placeholder: n("Enter username"),
                sx: NWe,
                startAdornment: EWe,
                inputProps: PWe
            })]
        }), v.jsx(V, {
            disabled: l,
            onClick: c,
            variant: "primary",
            color: "primary",
            sx: OWe,
            children: l ? v.jsx(J, {
                color: "inherit",
                size: MWe
            }) : v.jsx(cS, {
                color: "inherit"
            })
        })]
    })
}
))
  , EWe = v.jsx(We, {
    position: "start",
    sx: {
        ml: 0,
        pl: 0,
        width: 8
    },
    children: v.jsx(k, {
        variant: "paragraph3",
        children: "@"
    })
})
  , MWe = 14
  , NWe = {
    border: "none",
    outline: "none",
    p: 0,
    background: "transparent",
    "& input": {
        p: 0,
        textAlign: "start",
        fontSize: "12px",
        height: "auto"
    }
}
  , PWe = {
    [vu]: "true"
}
  , OWe = {
    p: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 24,
    height: 24,
    minWidth: 24
}
  , LWe = y.memo(( ({accountId: e, handle: t, isTracked: n, style: r, type: a}) => {
    const s = D()
      , {subscribeUser: o, unsubscribeUser: l} = KA()
      , i = y.useMemo(( () => e => ({
        px: 1.5,
        background: e.palette.background.primary,
        "&:nth-of-type(even)": {
            backgroundColor: e.palette.background.secondary
        }
    })), [])
      , [c,d] = y.useState(!1)
      , [u,p] = y.useState(null);
    y.useEffect(( () => {
        p(null)
    }
    ), [n]);
    const h = y.useCallback((async () => {
        try {
            d(!0);
            const t = await (n ? l(e) : o(e));
            p(t)
        } catch (fNe) {} finally {
            d(!1)
        }
    }
    ), [e, n, o, l])
      , m = y.useMemo(( () => a === Bh.UNAVAILABLE ? (e => `https://x.com/intent/user?user_id=${e}`)(e) : SI(t, VA.TWITTER)), [t, a, e]);
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        justifyContent: "space-between",
        alignItems: "center",
        height: 44,
        sx: i,
        style: r,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 2,
            children: [v.jsx(UWe, {
                type: a,
                isTracked: n
            }), v.jsx(C, {
                component: "a",
                href: m,
                target: "_blank",
                rel: "noopener nofollow",
                sx: _We,
                children: v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    overflow: "hidden",
                    textOverflow: "hidden",
                    minWidth: 0,
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: !n || a !== Bh.POPULAR && a !== Bh.CUSTOM ? "text.label" : "text.value",
                        noWrap: !0,
                        sx: DWe,
                        children: a === Bh.UNAVAILABLE ? `Unavailable ${oA(e, {
                            firstPartLength: 3,
                            finalPartLength: 3
                        })}` : `@${t}`
                    })
                })
            })]
        }), v.jsx(V, {
            disabled: c,
            onClick: h,
            variant: "tertiary",
            sx: BWe,
            children: c ? v.jsx(J, {
                color: "inherit",
                size: RWe
            }) : u ?? n ? v.jsx(wS, {
                color: s.palette.error.main
            }) : v.jsx(XS, {
                size: 20
            })
        })]
    })
}
))
  , RWe = 14
  , DWe = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    flexShrink: 1,
    maxWidth: "100%",
    "&:hover": {
        textDecoration: "underline"
    }
}
  , BWe = {
    p: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 24,
    height: 24,
    minWidth: 24,
    border: "none",
    background: "none"
}
  , _We = {
    textDecoration: "none"
}
  , UWe = y.memo(( ({type: e, isTracked: t}) => {
    const n = D()
      , r = y.useMemo(( () => WWe[e]), [e]);
    return v.jsx(GC, {
        title: FWe[e],
        children: v.jsx(C, {
            display: "flex",
            width: 16,
            sx: VWe,
            children: v.jsx(r, {
                color: e === Bh.CUSTOM_OVER_LIMIT ? n.palette.error.main : t ? n.palette.text.value : n.palette.text.label
            })
        })
    })
}
))
  , WWe = {
    [Bh.POPULAR]: ty,
    [Bh.CUSTOM]: $S,
    [Bh.CUSTOM_OVER_LIMIT]: QS,
    [Bh.UNAVAILABLE]: kS
}
  , FWe = {
    [Bh.POPULAR]: "Popular handle  not included in the limit",
    [Bh.CUSTOM]: "Custom handle",
    [Bh.CUSTOM_OVER_LIMIT]: "This handle wont be shown in the feed  it exceeds the limit for custom handles",
    [Bh.UNAVAILABLE]: "Handle unavailable"
}
  , VWe = {
    "&:hover": {
        cursor: "help"
    }
}
  , HWe = y.memo(( ({watchedAccountToDisplay: e, isInAddHandleMode: t, closeAddHandleMode: n}) => {
    const {trackedAccounts: r} = KA()
      , a = y.useMemo(( () => r ? new Set(r.map((e => e.accountId))) : new Set), [r]);
    return v.jsx(mt, {
        children: ({height: r, width: s}) => v.jsx(gt, {
            className: "padre-no-scroll",
            height: r,
            width: s,
            rowHeight: 44,
            rowCount: e.length + (t ? 1 : 0),
            itemData: e,
            rowRenderer: ({index: r, style: s}) => {
                const o = t && 0 === r ? null : e[r - (t ? 1 : 0)];
                if (!o)
                    return v.jsx(IWe, {
                        style: s,
                        onClose: n
                    }, "add-handle-row");
                const l = a.has(o.accountId);
                return v.jsx(LWe, {
                    ...o,
                    isTracked: l,
                    style: s
                }, o.handle)
            }
            ,
            overscanRowCount: 3,
            cellRangeRenderer: Ete
        })
    })
}
));
var zWe = (e => (e.ALL = "ALL",
e.MINE = "MINE",
e))(zWe || {});
const $We = y.memo(( ({search: e, accountMode: t, isInAddHandleMode: n, closeAddHandleMode: r}) => {
    const {allWatchedAccounts: a, trackedAccounts: s} = KA()
      , o = y.useMemo(( () => t === zWe.ALL ? a : s), [t, a, s])
      , l = y.useMemo(( () => o ? ( (e, t) => {
        if (!t)
            return e;
        const n = t.toLowerCase();
        return c.reduce(e, ( (e, t) => (n && !lj(t.handle.toLowerCase(), n) || e.push(t),
        e)), [])
    }
    )(o, e) : null), [o, e]);
    return (null == l ? void 0 : l.length) || t === zWe.MINE && n ? v.jsx(S, {
        sx: GWe,
        children: v.jsx(HWe, {
            watchedAccountToDisplay: l ?? [],
            isInAddHandleMode: n && t === zWe.MINE,
            closeAddHandleMode: r
        })
    }) : v.jsx(S, {
        height: "100%",
        alignItems: "center",
        justifyContent: "center",
        children: l ? t !== zWe.MINE || l.length ? v.jsx(Km, {}) : v.jsx(k, {
            variant: "paragraph3",
            color: "text.label",
            children: "You don't have tracked accounts"
        }) : v.jsx(Km, {})
    })
}
))
  , GWe = {
    height: "100%"
}
  , qWe = y.memo(( ({onExport: e, onRemoveAll: t}) => {
    const n = D()
      , {t: r} = we()
      , {trackedAccounts: a} = KA()
      , {buttonProps: s, popoverProps: o} = Fw({
        id: "tracked-handles-context-menu-button"
    })
      , l = y.useCallback(( () => {
        e(),
        o.onClose()
    }
    ), [e, o])
      , i = y.useCallback(( () => {
        t(),
        o.onClose()
    }
    ), [t, o]);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(F, {
            ...s,
            sx: YWe,
            children: v.jsx(SS, {
                size: KWe
            })
        }), v.jsx(ae, {
            ...o,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: XWe,
            transformOrigin: QWe,
            children: v.jsx(ee, {
                elevation: 1,
                sx: ZWe,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    children: [v.jsx(JWe, {
                        label: r("Export"),
                        onClick: l,
                        Icon: tk,
                        disabled: !(null == a ? void 0 : a.length)
                    }), v.jsx(JWe, {
                        label: r("Remove all"),
                        onClick: i,
                        Icon: wS,
                        disabled: !(null == a ? void 0 : a.length),
                        color: n.palette.error.main
                    })]
                })
            })
        })]
    })
}
))
  , KWe = 18
  , YWe = {
    p: .5
}
  , XWe = {
    vertical: "bottom",
    horizontal: "center"
}
  , QWe = {
    vertical: "top",
    horizontal: "center"
}
  , ZWe = e => ({
    background: e.palette.background.secondary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , JWe = y.memo(( ({label: e, onClick: t, Icon: n, color: r, disabled: a=!1}) => {
    const s = D();
    return v.jsx(te, {
        disabled: a,
        onClick: t,
        sx: eFe,
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 2,
            my: .25,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: a ? "text.label" : r ?? "text.value",
                children: e
            }), v.jsx(n, {
                color: a ? s.palette.text.label : r
            })]
        })
    })
}
))
  , eFe = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    ":last-child": {
        borderBottom: "none"
    }
})
  , tFe = y.memo(( ({inputText: e, setInputText: t}) => {
    const n = y.useCallback((e => {
        t(e.target.value)
    }
    ), [t]);
    return v.jsx(je, {
        multiline: !0,
        value: e,
        onChange: n,
        minRows: 8,
        maxRows: 8,
        size: "xsmall",
        placeholder: aFe,
        fullWidth: !0,
        sx: nFe,
        inputProps: rFe
    })
}
))
  , nFe = {
    height: 144,
    pr: .25,
    pl: 1,
    pt: 2.25,
    borderRadius: 2
}
  , rFe = {
    style: {
        fontWeight: 400,
        fontSize: 12,
        lineHeight: "17px"
    },
    className: "padre-decorative-scroll",
    inputMode: "text"
}
  , aFe = "Exported tracked accounts"
  , sFe = y.memo(( ({isOpen: e, onClose: t}) => {
    const {t: n} = we()
      , [r,a] = y.useState("")
      , [s,o] = y.useState(!1)
      , [l,i] = y.useState(!1)
      , d = y.useCallback((e => {
        a(e),
        o(!1)
    }
    ), [])
      , {multiUpdate: u, allWatchedAccounts: p} = KA()
      , h = y.useCallback((async () => {
        const e = (e => {
            let t;
            try {
                t = JSON.parse(e)
            } catch {
                return null
            }
            if (!Array.isArray(t))
                return null;
            const n = t
              , r = c.reduce(n, ( (e, t) => (t.id ? e[t.id] = {
                id: t.id
            } : t.h && (e[t.h] = {
                handle: t.h
            }),
            e)), {})
              , a = Object.values(r);
            if (!a.length)
                return null;
            const s = []
              , o = [];
            for (const l of a)
                "id"in l ? s.push(l.id) : o.push(l.handle);
            return {
                ids: s,
                handles: o
            }
        }
        )(r);
        if (e)
            try {
                i(!0),
                await u({
                    idsAdds: e.ids,
                    handlesAdds: e.handles,
                    idsDeletes: []
                })
            } catch (fNe) {
                i(!1)
            } finally {
                t()
            }
        else
            o(!0)
    }
    ), [r, t, u])
      , m = y.useCallback((async () => {
        if (p && p.length)
            try {
                i(!0),
                await u({
                    idsAdds: p.map((e => e.accountId)),
                    handlesAdds: [],
                    idsDeletes: []
                })
            } catch (fNe) {
                i(!1)
            } finally {
                t()
            }
    }
    ), [p, u, t]);
    return v.jsx(Sw, {
        className: "no-drag",
        open: e,
        stackSx: cFe,
        onClose: t,
        desktopWidth: oFe,
        minDesktopWidth: oFe,
        children: v.jsxs(S, {
            height: "100%",
            gap: 2,
            justifyContent: "space-between",
            children: [v.jsxs(S, {
                gap: 1,
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [v.jsx(k, {
                        variant: "h2",
                        children: n("Import Tracked Accounts")
                    }), v.jsx(F, {
                        onClick: t,
                        sx: iFe,
                        children: v.jsx(kS, {})
                    })]
                }), v.jsx(Ee, {
                    flexItem: !0,
                    sx: dFe
                }), v.jsx(V, {
                    fullWidth: !0,
                    onClick: m,
                    disabled: l,
                    sx: pFe,
                    children: v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        children: n("Import all popular")
                    })
                }), v.jsx(Ee, {
                    flexItem: !0,
                    sx: uFe,
                    children: v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: n("or")
                    })
                }), v.jsx(tFe, {
                    inputText: r,
                    setInputText: d
                })]
            }), v.jsx(k, {
                variant: "paragraph3",
                color: "error.main",
                sx: lFe,
                children: s ? n("Invalid format") : ""
            }), v.jsx(GC, {
                title: r ? "" : n("Input is empty"),
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        fullWidth: !0,
                        onClick: h,
                        disabled: !r || l,
                        sx: pFe,
                        children: v.jsx(k, {
                            variant: "inherit",
                            color: "inherit",
                            children: n("Import")
                        })
                    })
                })
            })]
        })
    })
}
))
  , oFe = 325
  , lFe = {
    ml: .25,
    mb: -1,
    mt: -1.5,
    height: 15
}
  , iFe = {
    p: .25,
    mr: -.25
}
  , cFe = {
    p: 2,
    zIndex: qw
}
  , dFe = {
    mx: -2
}
  , uFe = e => ({
    "::before": {
        borderColor: e.palette.background.borderMain
    },
    "::after": {
        borderColor: e.palette.background.borderMain
    }
})
  , pFe = {
    borderRadius: "24px"
}
  , hFe = y.memo(( ({isOpen: e, onClose: t, onRemoveAllClicked: n}) => {
    const {t: r} = we()
      , [a,s] = y.useState(!1)
      , o = y.useCallback(( () => {
        n(),
        s(!0)
    }
    ), [n]);
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsx(k, {
                variant: "h1",
                color: "text.value",
                textAlign: "center",
                children: r("Confirm removing all tracked handles")
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                children: [v.jsx(V, {
                    onClick: t,
                    fullWidth: !0,
                    variant: "tertiary",
                    children: r("Cancel")
                }), v.jsx(V, {
                    onClick: o,
                    fullWidth: !0,
                    color: "error",
                    variant: "secondary",
                    disabled: a,
                    children: a ? v.jsx(J, {
                        size: 16,
                        color: "inherit"
                    }) : r("Remove handles")
                })]
            })]
        })
    })
}
))
  , mFe = y.memo(( () => {
    const {t: e} = we()
      , t = xw()
      , [n,r] = y.useState("")
      , a = pK()
      , [s,o] = y.useState(!1)
      , l = y.useCallback(( () => {
        o(!0)
    }
    ), [])
      , i = y.useCallback(( () => {
        o(!1)
    }
    ), [])
      , {trackedAccounts: c, removeAll: d} = KA()
      , [u,p] = y.useState("")
      , h = y.useMemo(( () => xt((e => {
        p(e)
    }
    ), xFe)), []);
    y.useEffect(( () => {
        h(n)
    }
    ), [n, h]);
    const [m,g] = Mx("padreV2-trackedAccountsMode", zWe.MINE)
      , x = y.useCallback(( (e, t) => {
        g(t)
    }
    ), [g])
      , [b,f] = y.useState(!1)
      , k = y.useCallback(( () => {
        if (m === zWe.ALL)
            return f(!0),
            void g(zWe.MINE);
        f((e => !e))
    }
    ), [m, g])
      , C = y.useCallback(( () => {
        f(!1)
    }
    ), [])
      , A = y.useCallback(( () => {
        (null == c ? void 0 : c.length) && (QC ? (ZC(JSON.stringify(c.map((e => ({
            id: e.accountId,
            h: e.handle
        }))))),
        a({
            message: uu.clipboardExportTrackedAccountsSuccess,
            type: "success"
        }, "clipboard-export-success")) : a({
            message: uu.clipboardEnableAccess,
            snackName: pu.clipboardUnavailable,
            type: "error"
        }, "clipboard-unavailable"))
    }
    ), [a, c])
      , [w,j] = y.useState(!1)
      , T = y.useCallback(( () => {
        j(!0)
    }
    ), [])
      , I = y.useCallback(( () => {
        j(!1)
    }
    ), [])
      , E = y.useCallback((async () => {
        try {
            await d()
        } catch (fNe) {} finally {
            I()
        }
    }
    ), [I, d])
      , M = y.useMemo(( () => [{
        value: zWe.MINE,
        label: e("My list")
    }, {
        value: zWe.ALL,
        label: e("Popular")
    }]), [e]);
    return v.jsxs(S, {
        height: "100%",
        children: [v.jsxs(S, {
            px: 1,
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            gap: 1,
            height: 30,
            children: [t && v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                flex: 1,
                minWidth: 125,
                children: v.jsx(IH, {
                    size: "xxsmall",
                    value: m,
                    onChange: x,
                    items: M,
                    maxItemWidth: bFe
                })
            }), v.jsxs(S, {
                gap: 1,
                direction: "row",
                alignItems: "center",
                width: "100%",
                maxWidth: 500,
                children: [t && v.jsx(oQ, {
                    search: n,
                    setSearch: r
                }), t && v.jsx(qWe, {
                    onExport: A,
                    onRemoveAll: T
                }), v.jsx(V, {
                    variant: "tertiary",
                    size: "xxsmall",
                    sx: fFe,
                    onClick: l,
                    children: e("Import")
                }), !t && v.jsx(qWe, {
                    onExport: A,
                    onRemoveAll: T
                }), t && v.jsx(V, {
                    variant: "primary",
                    size: "xxsmall",
                    sx: vFe,
                    onClick: k,
                    children: e("Add handle")
                })]
            }), !t && v.jsx(V, {
                variant: "primary",
                size: "xxsmall",
                sx: vFe,
                onClick: k,
                children: e("Add handle")
            })]
        }), !t && v.jsxs(S, {
            direction: "row",
            pt: 1,
            px: 1,
            gap: 1,
            children: [v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                flex: 1,
                minWidth: 125,
                children: v.jsx(IH, {
                    size: "xxsmall",
                    value: m,
                    onChange: x,
                    items: M,
                    maxItemWidth: bFe
                })
            }), v.jsx(oQ, {
                search: n,
                setSearch: r
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: gFe
        }), v.jsx($We, {
            search: u,
            accountMode: m,
            isInAddHandleMode: b,
            closeAddHandleMode: C
        }), s && v.jsx(sFe, {
            isOpen: !0,
            onClose: i
        }), w && v.jsx(hFe, {
            isOpen: !0,
            onClose: I,
            onRemoveAllClicked: E
        })]
    })
}
))
  , gFe = {
    mt: 1
}
  , xFe = 150
  , bFe = 60
  , fFe = {
    p: 0,
    minWidth: 60,
    borderRadius: "16px",
    borderColor: "transparent",
    "&:hover, &:focus": {
        borderColor: "transparent"
    }
}
  , vFe = {
    p: 0,
    minWidth: 86,
    borderRadius: "16px",
    fontWeight: 600
}
  , SFe = y.memo(( () => {
    const {tweetsFilters: e, setTweetsFilters: t} = KA()
      , [n,r] = y.useState(!0)
      , a = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation(),
        r(!0)
    }
    ), [r]);
    return v.jsxs(S, {
        height: "100%",
        children: [v.jsxs(S, {
            px: 1,
            direction: "row",
            alignItems: "center",
            justifyContent: "flex-end",
            gap: 1,
            minHeight: 30,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1,
                children: [R && v.jsx(Q, {
                    in: !n,
                    children: v.jsx(V, {
                        variant: "tertiary",
                        onClick: a,
                        size: "xxsmall",
                        children: "Resume"
                    })
                }), v.jsx(H9, {
                    isLive: n,
                    compact: !0
                })]
            }), v.jsx(vI, {}), v.jsx(lee, {
                isFeed: !0,
                currentFilters: e,
                setFilters: t
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: yFe
        }), v.jsx(S, {
            height: "calc(100% - 94px)",
            overflow: "auto",
            className: "padre-decorative-scroll",
            children: v.jsx(JP, {
                isLive: n,
                setIsLive: r
            })
        })]
    })
}
))
  , yFe = {
    mt: 1
};
var kFe = (e => (e.TRACKED_ACCOUNT = "TRACKED_ACCOUNT",
e.FEED = "FEED",
e))(kFe || {})
  , CFe = (e => (e.MANAGER = "MANAGER",
e.LIVE_TRADES = "LIVE_TRADES",
e))(CFe || {});
const AFe = y.memo(( () => {
    const {t: e} = we()
      , t = D()
      , n = xw()
      , {alertsEnabled: r, toggleAlertsEnabled: a, soundEffectEnabled: s, setSoundEffectEnabled: o, selectedSoundEffect: l, setSelectedSoundEffect: i, notificationsVolume: c, setNotificationsDuration: d, notificationsDuration: u, setNotificationsVolume: p} = uI()
      , [h,m] = Mx("padreV2-trackerXTab", kFe.FEED)
      , g = y.useCallback(( (e, t) => {
        m(t)
    }
    ), [m])
      , [x,b] = Mx("padreV2-trackerWalletsTab", CFe.MANAGER)
      , f = y.useCallback(( (e, t) => {
        b(t)
    }
    ), [b])
      , k = y.useCallback(( () => {
        b(CFe.MANAGER)
    }
    ), [b])
      , A = y.useCallback(( () => {
        b(CFe.LIVE_TRADES)
    }
    ), [b])
      , w = y.useCallback(( () => {
        m(kFe.FEED)
    }
    ), [m])
      , j = y.useCallback(( () => {
        m(kFe.TRACKED_ACCOUNT)
    }
    ), [m])
      , {lastViewedMobileTrackerTab: T, setLastViewedMobileTrackerTab: I} = _H();
    return v.jsxs(S, {
        height: "100%",
        children: [!n && v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(S, {
                sx: MFe,
                justifyContent: "center",
                children: v.jsx(TWe, {
                    selectedTab: T,
                    setSelectedTab: I
                })
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.25,
                mr: 2,
                children: [(n || "WALLET_TRACKER" === T) && r && v.jsx(C, {
                    component: "span",
                    children: v.jsx(pI, {
                        soundEffectEnabled: s,
                        selectedSoundEffect: l,
                        notificationsVolume: c,
                        setNotificationsVolume: p,
                        notificationsDuration: u,
                        setNotificationsDuration: d,
                        isInFloatingWidget: !1,
                        usePopper: !1
                    })
                }), (n || "WALLET_TRACKER" === T) && r && v.jsx(C, {
                    component: "span",
                    children: v.jsx(ej, {
                        idKey: "notifications",
                        soundEffectEnabled: s,
                        setSoundEffectEnabled: o,
                        selectedSoundEffect: l,
                        setSelectedSoundEffect: i,
                        usePopper: !1,
                        volume: c,
                        disableBackground: !0
                    })
                }), (n || "WALLET_TRACKER" === T) && v.jsx(V, {
                    ...LFe,
                    onClick: a,
                    children: r ? v.jsx(jy, {
                        size: OFe,
                        color: t.palette.primary.main
                    }) : v.jsx(Ey, {
                        size: OFe
                    })
                })]
            })]
        }), !n && ("X_TRACKER" === T ? v.jsxs(ot, {
            value: h,
            onChange: g,
            sx: NFe,
            variant: "scrollable",
            children: [v.jsx(lt, {
                label: e("Tracked Accounts"),
                value: kFe.TRACKED_ACCOUNT
            }), v.jsx(lt, {
                label: e("X Feed"),
                value: kFe.FEED
            })]
        }) : v.jsxs(ot, {
            value: x,
            onChange: f,
            sx: NFe,
            variant: "scrollable",
            children: [v.jsx(lt, {
                label: e("Wallet Manager"),
                value: CFe.MANAGER
            }), v.jsx(lt, {
                label: e("Live Trades"),
                value: CFe.LIVE_TRADES
            })]
        })), n ? v.jsx(S, {
            direction: "row",
            height: "100%",
            children: v.jsx(Ube, {
                storageKey: "padreV2-trackerSplitPanes",
                panes: [{
                    minSize: PFe,
                    size: window.innerWidth / 2,
                    content: v.jsxs(S, {
                        gap: 1,
                        height: "100%",
                        children: [v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            sx: jFe,
                            children: [v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 2,
                                children: [v.jsx(jWe, {
                                    label: e("Wallet Manager"),
                                    onClick: k,
                                    isSelected: x === CFe.MANAGER
                                }), v.jsx(jWe, {
                                    label: e("Live Trades"),
                                    onClick: A,
                                    isSelected: x === CFe.LIVE_TRADES
                                })]
                            }), v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: n ? 1.5 : 1,
                                mr: 2,
                                children: [r && v.jsx(C, {
                                    component: "span",
                                    children: v.jsx(pI, {
                                        soundEffectEnabled: s,
                                        selectedSoundEffect: l,
                                        notificationsVolume: c,
                                        setNotificationsVolume: p,
                                        notificationsDuration: u,
                                        setNotificationsDuration: d,
                                        isInFloatingWidget: !0
                                    })
                                }), r && v.jsx(C, {
                                    component: "span",
                                    children: v.jsx(ej, {
                                        idKey: "notifications",
                                        soundEffectEnabled: s,
                                        setSoundEffectEnabled: o,
                                        selectedSoundEffect: l,
                                        setSelectedSoundEffect: i,
                                        usePopper: !0,
                                        volume: c,
                                        disableBackground: !0
                                    })
                                }), v.jsx(GC, {
                                    title: e(r ? "Disable notification" : "Enable notifications"),
                                    children: v.jsx(C, {
                                        component: "span",
                                        children: v.jsx(V, {
                                            ...LFe,
                                            onClick: a,
                                            children: r ? v.jsx(jy, {
                                                size: OFe,
                                                color: t.palette.primary.main
                                            }) : v.jsx(Ey, {
                                                size: OFe
                                            })
                                        })
                                    })
                                })]
                            })]
                        }), x === CFe.MANAGER ? v.jsx(S, {
                            height: "calc(100vh - 136px)",
                            children: v.jsx(w9, {
                                isInTracker: !0
                            })
                        }) : v.jsx(g2, {
                            isInTracker: !0
                        })]
                    })
                }, {
                    minSize: PFe,
                    size: window.innerWidth / 2,
                    content: v.jsxs(S, {
                        flex: 1,
                        gap: 1,
                        height: `calc(100% - ${wFe + 2 * EFe * 8}px)`,
                        children: [v.jsxs(S, {
                            direction: "row",
                            alignItems: "center",
                            sx: jFe,
                            children: [v.jsx(jWe, {
                                label: e("Tracked Accounts"),
                                onClick: j,
                                isSelected: h === kFe.TRACKED_ACCOUNT
                            }), v.jsx(jWe, {
                                label: e("X Feed"),
                                onClick: w,
                                isSelected: h === kFe.FEED
                            })]
                        }), h === kFe.TRACKED_ACCOUNT ? v.jsx(mFe, {}) : v.jsx(SFe, {})]
                    })
                }]
            })
        }) : v.jsx(S, {
            pt: 1.5,
            height: `calc(100% - ${TFe + IFe}px)`,
            children: "X_TRACKER" === T ? h === kFe.TRACKED_ACCOUNT ? v.jsx(mFe, {}) : v.jsx(SFe, {}) : x === CFe.MANAGER ? v.jsx(S, {
                height: "100%",
                children: v.jsx(w9, {
                    isInTracker: !0
                })
            }) : v.jsx(g2, {
                isInTracker: !0
            })
        })]
    })
}
))
  , wFe = 48
  , jFe = e => ({
    pl: 1.5,
    gap: 2,
    height: wFe,
    minHeight: wFe,
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , TFe = 40
  , IFe = 28
  , EFe = .5
  , MFe = {
    minHeight: TFe,
    px: {
        xs: 2,
        sm: 2.5
    },
    gap: EFe
}
  , NFe = e => ({
    borderTop: `1px solid ${e.palette.background.borderMain}`,
    pl: {
        xs: 0,
        md: .25
    },
    "& .MuiTabs-scrollButtons": {
        width: 24
    }
})
  , PFe = 400
  , OFe = 18
  , LFe = {
    variant: "tertiary",
    size: "xxsmall",
    sx: {
        p: 0,
        height: 24,
        width: 24,
        minWidth: 24,
        background: "transparent",
        borderColor: "transparent",
        "&:hover, &:focus": {
            borderColor: "transparent"
        }
    }
}
  , RFe = y.memo(( () => v.jsx(vt, {
    sx: BFe,
    style: DFe,
    maxWidth: !1,
    children: v.jsx(S, {
        height: "100%",
        className: "padre-no-scroll",
        children: v.jsx(AFe, {})
    })
})))
  , DFe = {
    padding: 0
}
  , BFe = {
    height: "calc(100% - 2px)",
    width: "100%",
    overflow: "hidden"
}
  , _Fe = y.memo(( ({onRemove: e, address: t, isLast: n}) => {
    const r = bw()
      , a = D()
      , s = y.useMemo(( () => e => ({
        borderBottom: n ? "none" : `1px solid ${e.palette.background.borderMain}`,
        pr: {
            xs: 1,
            md: 2
        },
        pl: {
            xs: .5,
            md: 1.5
        },
        height: Nte - (n ? 0 : 1)
    })), [n]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: s,
        children: [v.jsx(cA, {
            address: t,
            maxWidth: r ? 345 : 270,
            customName: t,
            labelVariant: "paragraph3"
        }), v.jsx(F, {
            onClick: e,
            sx: UFe,
            children: v.jsx(wS, {
                color: a.palette.error.main
            })
        })]
    })
}
))
  , UFe = {
    p: .25
}
  , WFe = y.memo(( () => {
    var e;
    const {t: t} = we()
      , n = pK()
      , {removeFromDevBlacklist: r, addToDevBlacklist: a, clearBlacklist: s, settings: o} = rf()
      , l = y.useMemo(( () => {
        var e;
        return (null == (e = null == o ? void 0 : o.devBlacklist) ? void 0 : e.length) ?? 0
    }
    ), [null == (e = null == o ? void 0 : o.devBlacklist) ? void 0 : e.length])
      , [i,c] = y.useState("")
      , d = y.useCallback((async ({target: {value: e}}) => {
        c(e)
    }
    ), [c])
      , u = y.useMemo(( () => {
        if (!i)
            return t("Dev address is empty");
        if (!su.test(i) && !au.test(i))
            return t("Invalid address");
        const e = ng(i);
        return (null == o ? void 0 : o.devBlacklist) && o.devBlacklist.some((t => ng(t) === e)) ? t("This address is already blacklisted") : (null == o ? void 0 : o.devBlacklist) && o.devBlacklist.length >= Mte ? t("Reached blacklisted addresses limit") : ""
    }
    ), [i, null == o ? void 0 : o.devBlacklist, t])
      , p = y.useCallback(( () => {
        if (u)
            return;
        const e = ng(i);
        lu.has(e) ? n({
            message: uu.devProtectedBlacklist,
            type: "warning"
        }, "dev-blacklist-protected-error") : (a(e),
        c(""))
    }
    ), [a, n, u, i])
      , h = y.useCallback((async () => {
        await s(),
        n({
            message: pu.devBlacklistDeletedSuccess,
            type: "success"
        }, "clear-dev-blacklist-success")
    }
    ), [s, n]);
    return v.jsxs(S, {
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            pb: 1.5,
            children: [v.jsx(bt, {
                autoComplete: "off",
                value: i,
                onChange: d,
                variant: "outlined",
                placeholder: t("Dev address"),
                fullWidth: !0,
                autoFocus: !0,
                sx: {
                    input: {
                        "&.MuiOutlinedInput-input": {
                            fontWeight: 500
                        },
                        "&::placeholder": {
                            opacity: 1
                        }
                    }
                },
                InputProps: {
                    sx: {
                        height: 32,
                        pr: .5
                    }
                }
            }), v.jsx(GC, {
                title: u,
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        disabled: !!u,
                        onClick: p,
                        variant: "tertiary",
                        size: "xsmall",
                        children: t("Add")
                    })
                })
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: FFe
        }), v.jsx(S, {
            height: VFe,
            mx: -2,
            children: v.jsx(mt, {
                children: ({height: e, width: t}) => v.jsx(gt, {
                    className: "padre-no-scroll",
                    height: e,
                    width: t,
                    rowHeight: Nte,
                    rowCount: ((null == o ? void 0 : o.devBlacklist) ?? []).length,
                    itemData: (null == o ? void 0 : o.devBlacklist) ?? [],
                    rowRenderer: ({index: e, style: t}) => {
                        const n = ((null == o ? void 0 : o.devBlacklist) ?? [])[e];
                        return v.jsx("div", {
                            style: t,
                            children: v.jsx(_Fe, {
                                onRemove: () => {
                                    r(n)
                                }
                                ,
                                address: n,
                                isLast: e === ((null == o ? void 0 : o.devBlacklist) ?? []).length - 1
                            })
                        }, n)
                    }
                    ,
                    overscanRowCount: 2
                })
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: FFe
        }), v.jsxs(S, {
            direction: "row",
            gap: 1.5,
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: l >= Mte ? "warning.main" : "text.label",
                children: `${l}/200 ${t("addresses")}`
            }), v.jsx(V, {
                onClick: h,
                size: "xxsmall",
                variant: "secondary",
                color: "error",
                children: t("Delete all")
            })]
        })]
    })
}
))
  , FFe = {
    mx: -2,
    mb: 1.5
}
  , VFe = 405
  , HFe = y.memo(( ({onRemove: e, handle: t, isLast: n}) => {
    const r = D()
      , a = y.useMemo(( () => e => ({
        borderBottom: n ? "none" : `1px solid ${e.palette.background.borderMain}`,
        pr: {
            xs: 1,
            md: 2
        },
        pl: {
            xs: .5,
            md: 1.5
        },
        height: Nte - (n ? 0 : 1)
    })), [n])
      , s = y.useMemo(( () => `https://twitter.com/${t}`), [t]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: a,
        children: [v.jsx(C, {
            display: "flex",
            component: "a",
            href: s,
            target: "_blank",
            rel: "noopener nofollow",
            sx: $Fe,
            children: v.jsx(k, {
                sx: GFe,
                variant: "paragraph1",
                color: FI,
                noWrap: !0,
                children: `@${t}`
            })
        }), v.jsx(F, {
            onClick: e,
            sx: zFe,
            children: v.jsx(wS, {
                color: r.palette.error.main
            })
        })]
    })
}
))
  , zFe = {
    p: .25
}
  , $Fe = {
    textDecoration: "none"
}
  , GFe = {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minWidth: 0,
    minHeight: 16,
    flexShrink: 1,
    "&:hover": {
        textDecoration: "underline"
    }
}
  , qFe = y.memo(( () => {
    var e;
    const {t: t} = we()
      , n = pK()
      , {addToHandlesBlacklist: r, removeFromHandlesBlacklist: a, clearHandlesBalcklist: s, settings: o} = rf()
      , l = y.useMemo(( () => {
        var e;
        return (null == (e = null == o ? void 0 : o.handlesBlacklist) ? void 0 : e.length) ?? 0
    }
    ), [null == (e = null == o ? void 0 : o.handlesBlacklist) ? void 0 : e.length])
      , [i,c] = y.useState("")
      , d = y.useCallback((async ({target: {value: e}}) => {
        const t = e.replace(/[^A-Za-z0-9_]/g, "");
        c(t.slice(0, XFe))
    }
    ), [c])
      , u = y.useMemo(( () => {
        if (!i)
            return t("Handle is empty");
        const e = i.toLowerCase();
        return (null == o ? void 0 : o.handlesBlacklist) && o.handlesBlacklist.some((t => t.toLowerCase() === e)) ? t("This handle is already blacklisted") : (null == o ? void 0 : o.handlesBlacklist) && o.handlesBlacklist.length >= Mte ? t("Reached blacklisted handles limit") : ""
    }
    ), [i, null == o ? void 0 : o.handlesBlacklist, t])
      , p = y.useCallback(( () => {
        u || (r(i),
        c(""))
    }
    ), [r, u, i])
      , h = y.useCallback((async () => {
        await s(),
        n({
            message: pu.handlesBlacklistDeletedSuccess,
            type: "success"
        }, "clear-handles-blacklist-success")
    }
    ), [s, n]);
    return v.jsxs(S, {
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            gap: 1,
            pb: 1.5,
            children: [v.jsx(bt, {
                autoComplete: "off",
                value: i,
                onChange: d,
                variant: "outlined",
                placeholder: t("Handle"),
                fullWidth: !0,
                autoFocus: !0,
                sx: ZFe,
                InputProps: QFe
            }), v.jsx(GC, {
                title: u,
                children: v.jsx(C, {
                    component: "span",
                    children: v.jsx(V, {
                        disabled: !!u,
                        onClick: p,
                        variant: "tertiary",
                        size: "xsmall",
                        children: t("Add")
                    })
                })
            })]
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: KFe
        }), v.jsx(S, {
            height: YFe,
            mx: -2,
            children: v.jsx(mt, {
                children: ({height: e, width: t}) => v.jsx(gt, {
                    className: "padre-no-scroll",
                    height: e,
                    width: t,
                    rowHeight: Nte,
                    rowCount: ((null == o ? void 0 : o.handlesBlacklist) ?? []).length,
                    itemData: (null == o ? void 0 : o.handlesBlacklist) ?? [],
                    rowRenderer: ({index: e, style: t}) => {
                        const n = ((null == o ? void 0 : o.handlesBlacklist) ?? [])[e];
                        return v.jsx("div", {
                            style: t,
                            children: v.jsx(HFe, {
                                onRemove: () => {
                                    a(n)
                                }
                                ,
                                handle: n,
                                isLast: e === ((null == o ? void 0 : o.handlesBlacklist) ?? []).length - 1
                            })
                        }, n)
                    }
                    ,
                    overscanRowCount: 2
                })
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: KFe
        }), v.jsxs(S, {
            direction: "row",
            gap: 1.5,
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: l >= 200 ? "warning.main" : "text.label",
                children: `${l}/200 ${t("handles")}`
            }), v.jsx(V, {
                onClick: h,
                size: "xxsmall",
                variant: "secondary",
                color: "error",
                children: t("Delete all")
            })]
        })]
    })
}
))
  , KFe = {
    mx: -2,
    mb: 1.5
}
  , YFe = 405
  , XFe = 15
  , QFe = {
    startAdornment: v.jsx(We, {
        position: "start",
        children: v.jsx(k, {
            color: "text.value",
            variant: "h2",
            children: "@"
        })
    }),
    sx: {
        height: 32,
        pr: .5
    }
}
  , ZFe = {
    input: {
        "&.MuiOutlinedInput-input": {
            fontWeight: 500
        },
        "&::placeholder": {
            opacity: 1
        }
    }
}
  , JFe = y.memo(( ({onRemove: e, address: t, chain: n, isLast: r}) => {
    const a = bw()
      , s = D()
      , o = y.useMemo(( () => e => ({
        borderBottom: r ? "none" : `1px solid ${e.palette.background.borderMain}`,
        pr: {
            xs: 1,
            md: 2
        },
        pl: {
            xs: .5,
            md: 1.5
        },
        height: Nte - (r ? 0 : 1)
    })), [r]);
    return v.jsxs(S, {
        direction: "row",
        alignItems: "center",
        justifyContent: "space-between",
        sx: o,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: .5,
            children: [v.jsx(Sz, {
                chain: n
            }), v.jsx(cA, {
                address: t,
                maxWidth: a ? 345 : 270,
                customName: t,
                labelVariant: "paragraph3"
            })]
        }), v.jsx(F, {
            onClick: e,
            sx: eVe,
            children: v.jsx(wS, {
                color: s.palette.error.main
            })
        })]
    })
}
))
  , eVe = {
    p: .25
}
  , tVe = y.memo(( () => {
    const {t: e} = we()
      , {showPair: t, hiddenPairs: n, clearAll: r} = SX()
      , a = y.useMemo(( () => n ? c.reduce(Object.entries(n), ( (e, [t,n]) => {
        if (!n)
            return e;
        const {tokenAddress: r, chain: a} = CX(t);
        return e.push({
            address: r,
            chain: a
        }),
        e
    }
    ), []) : []), [n]);
    return v.jsxs(S, {
        children: [v.jsx(S, {
            height: nVe,
            mx: -2,
            children: v.jsx(mt, {
                children: ({height: e, width: n}) => v.jsx(gt, {
                    className: "padre-no-scroll",
                    height: e,
                    width: n,
                    rowHeight: Nte,
                    rowCount: a.length,
                    itemData: a,
                    rowRenderer: ({index: e, style: n}) => {
                        const r = a[a.length - 1 - e];
                        return v.jsx("div", {
                            style: n,
                            children: v.jsx(JFe, {
                                onRemove: () => {
                                    t(r.address, r.chain)
                                }
                                ,
                                address: r.address,
                                chain: r.chain,
                                isLast: e === a.length - 1
                            })
                        }, `${r.address}-${r.chain}`)
                    }
                    ,
                    overscanRowCount: 2
                })
            })
        }), v.jsx(Ee, {
            flexItem: !0,
            sx: rVe
        }), v.jsxs(S, {
            direction: "row",
            gap: 1.5,
            alignItems: "center",
            justifyContent: "space-between",
            children: [v.jsx(k, {
                variant: "paragraph3",
                color: a.length >= yX ? "warning.main" : "text.label",
                children: `${a.length}/1000 ${e("addresses")}`
            }), v.jsx(V, {
                onClick: r,
                size: "xxsmall",
                variant: "secondary",
                color: "error",
                children: e("Delete all")
            })]
        })]
    })
}
))
  , nVe = 462
  , rVe = {
    mx: -2,
    mb: 1.5
};
var aVe = (e => (e.DEV_BLACKLIST = "DEV_BLACKLIST",
e.HIDDEN_TOKENS = "HIDDEN_TOKENS",
e.HANDLES_BLACKLIST = "HANDLES_BLACKLIST",
e))(aVe || {});
const sVe = y.memo(( ({onClose: e}) => {
    const {t: t} = we()
      , [n,r] = Mx("padreV2-blocklistsSelectedTab", aVe.DEV_BLACKLIST)
      , a = y.useCallback(( (e, t) => {
        r(t)
    }
    ), [r]);
    return v.jsxs(S, {
        gap: 1.5,
        children: [v.jsxs(S, {
            direction: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "h2",
                children: t("Blacklists")
            }), v.jsx(F, {
                onClick: e,
                sx: oVe,
                children: v.jsx(kS, {})
            })]
        }), v.jsxs(ot, {
            value: n,
            onChange: a,
            children: [v.jsx(lt, {
                label: t("Dev Blacklist"),
                value: aVe.DEV_BLACKLIST
            }), v.jsx(lt, {
                label: t("Hidden Tokens"),
                value: aVe.HIDDEN_TOKENS
            }), v.jsx(lt, {
                label: t("Handles Blacklist"),
                value: aVe.HANDLES_BLACKLIST
            })]
        }), n === aVe.DEV_BLACKLIST && v.jsx(WFe, {}), n === aVe.HIDDEN_TOKENS && v.jsx(tVe, {}), n === aVe.HANDLES_BLACKLIST && v.jsx(qFe, {})]
    })
}
))
  , oVe = {
    p: .5
}
  , lVe = y.memo(( ({isOpen: e, onClose: t}) => v.jsx(Sw, {
    open: e,
    onClose: t,
    stackSx: cVe,
    maxDesktopWidth: iVe,
    children: v.jsx(sVe, {
        onClose: t
    })
})))
  , iVe = 360
  , cVe = {
    p: 2,
    pb: 1.5
}
  , dVe = y.memo(( () => {
    const {t: e} = we()
      , [t,n] = y.useState(!1)
      , r = y.useCallback(( () => {
        n(!0)
    }
    ), [])
      , a = y.useCallback(( () => {
        n(!1)
    }
    ), []);
    return v.jsxs(v.Fragment, {
        children: [v.jsx(GC, {
            title: e("Blacklists"),
            children: v.jsx(C, {
                component: "span",
                children: v.jsx(V, {
                    className: "no-drag",
                    variant: "tertiary",
                    size: "xxsmall",
                    onClick: r,
                    sx: uVe,
                    children: v.jsx(C, {
                        display: "flex",
                        children: v.jsx(VS, {
                            color: "inherit"
                        })
                    })
                })
            })
        }), v.jsx(lVe, {
            isOpen: t,
            onClose: a
        })]
    })
}
))
  , uVe = e => ({
    zIndex: 2,
    transition: "none",
    py: 0,
    px: .5,
    minWidth: 28,
    border: e.palette.primary.main,
    backgroundColor: e.palette.background.buttonDefault,
    "&:focus": {
        border: "none",
        backgroundColor: e.palette.background.buttonDefault
    },
    "&:hover": {
        border: "none",
        backgroundColor: e.palette.background.buttonHover
    }
})
  , pVe = y.memo(( ({isCollapsed: e, toggleCollapse: t}) => v.jsx(V, {
    variant: "tertiary",
    size: "xxsmall",
    onClick: t,
    sx: hVe,
    children: v.jsx(C, {
        display: "flex",
        children: e ? v.jsx(Ny, {}) : v.jsx(JS, {})
    })
})))
  , hVe = e => ({
    zIndex: 2,
    transition: "none",
    py: 0,
    px: .5,
    minWidth: 28,
    borderRadius: "50%",
    backgroundColor: "transparent",
    border: `1px solid ${e.palette.background.borderMain}`,
    "&:focus": {
        backgroundColor: "transparent",
        border: `1px solid ${e.palette.background.borderMain}`
    },
    "&:hover": {
        backgroundColor: "transparent",
        border: `1px solid ${e.palette.background.borderMain}`
    }
})
  , mVe = y.memo(( () => {
    const {t: e} = we()
      , t = bw()
      , {setLastViewedChain: n} = _H()
      , {trenchesChain: r, spacingMode: a, hiddenColumns: s, resetHiddenColumns: o} = xne();
    y.useEffect(( () => {
        n(r)
    }
    ), [n, r]);
    const {visibleSections: l} = Cne()
      , [i,c] = dx("padreV2-trenchesMobileTab", Zh.NEW)
      , d = y.useCallback(( (e, t) => {
        c(t)
    }
    ), [c])
      , [u,p] = Mx("padreV2-trenchesMobileCollapsed", !1)
      , h = y.useCallback(( () => {
        p((e => !e))
    }
    ), [p])
      , m = y.useMemo(( () => t && a === HX.SPACED), [t, a])
      , [g,x,b,f,A] = y.useMemo(( () => {
        const [e,t,n] = [!s.includes(Zh.NEW), !s.includes(Zh.ALMOST_BONDED), !s.includes(Zh.RECENTLY_BONDED)];
        return [e, t, n, [e, t, n].filter(Boolean).length, !e && !t && !n]
    }
    ), [s]);
    return v.jsx(vt, {
        maxWidth: "none",
        sx: gVe,
        children: v.jsxs(S, {
            sx: xVe,
            children: [(t || !u) && v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                sx: vVe,
                children: [v.jsxs(S, {
                    sx: fVe,
                    direction: "row",
                    alignItems: "center",
                    flexGrow: t ? 0 : void 0,
                    children: [t && v.jsx(Uie, {
                        large: !0
                    }), t && l.has(vne.VIBING) && r === Pd.SOLANA && v.jsx(Bie, {
                        chain: r
                    }), !t && v.jsx(Uie, {
                        compact: !0
                    })]
                }), v.jsxs(S, {
                    sx: bVe,
                    direction: "row",
                    alignItems: "center",
                    justifyContent: t ? "flex-start" : "flex-end",
                    flexShrink: 0,
                    children: [i === Zh.ALMOST_BONDED && !t && v.jsx(Mse, {}), v.jsx(oae, {}), v.jsx(gae, {}), v.jsx(dVe, {}), !t && !u && v.jsx(pVe, {
                        isCollapsed: u,
                        toggleCollapse: h
                    })]
                })]
            }), !t && v.jsxs(S, {
                direction: "row",
                width: "100%",
                flexGrow: 1,
                gap: .5,
                alignItems: "center",
                mt: !t && u ? -.5 : 0,
                children: [v.jsx(S, {
                    flexGrow: 1,
                    children: v.jsxs(ot, {
                        value: i,
                        onChange: d,
                        children: [v.jsx(lt, {
                            label: e("New"),
                            value: Zh.NEW
                        }), v.jsx(lt, {
                            label: e("Soon"),
                            value: Zh.ALMOST_BONDED
                        }), v.jsx(lt, {
                            label: e("Recent"),
                            value: Zh.RECENTLY_BONDED
                        })]
                    })
                }), !t && u && v.jsx(pVe, {
                    isCollapsed: u,
                    toggleCollapse: h
                })]
            }), v.jsxs(S, {
                direction: "row",
                justifyContent: "center",
                sx: SVe,
                children: [t && A && v.jsx(S, {
                    alignItems: "center",
                    width: "100%",
                    justifyContent: "center",
                    children: v.jsxs(S, {
                        gap: .75,
                        children: [v.jsx(k, {
                            textAlign: "center",
                            variant: "paragraph1",
                            color: "text.label",
                            children: e("All columns are hidden")
                        }), v.jsxs(V, {
                            variant: "tertiary",
                            sx: yVe,
                            onClick: o,
                            className: "no-drag",
                            children: [e("Show all columns"), v.jsx(C, {
                                display: "flex",
                                mt: "-1px",
                                children: v.jsx(Tk, {
                                    color: "inherit",
                                    size: 14
                                })
                            })]
                        })]
                    })
                }), (t && g || !t && i === Zh.NEW) && v.jsx(cH, {
                    contextId: "trenchesNew",
                    children: v.jsx(XJ, {
                        contextId: "trenchesNew",
                        children: v.jsx(tie, {
                            isSpaced: m,
                            trenchMode: Zh.NEW,
                            order: 0,
                            visibleColumnsCount: f,
                            isFirstColumn: !0,
                            isLastColumn: !x && !b
                        })
                    })
                }), (t && x || !t && i === Zh.ALMOST_BONDED) && v.jsx(cH, {
                    contextId: "trenchesAlmostBonded",
                    children: v.jsx(XJ, {
                        contextId: "trenchesAlmostBonded",
                        children: v.jsx(tie, {
                            isSpaced: m,
                            trenchMode: Zh.ALMOST_BONDED,
                            order: t ? g ? 1 : 0 : 1,
                            visibleColumnsCount: f,
                            isFirstColumn: !g,
                            isLastColumn: !b
                        })
                    })
                }), (t && b || !t && i === Zh.RECENTLY_BONDED) && v.jsx(cH, {
                    contextId: "trenchesRecentlyBonded",
                    children: v.jsx(XJ, {
                        contextId: "trenchesRecentlyBonded",
                        children: v.jsx(tie, {
                            isSpaced: m,
                            trenchMode: Zh.RECENTLY_BONDED,
                            order: t ? g && x ? 2 : g || x ? 1 : 0 : 2,
                            visibleColumnsCount: f,
                            isFirstColumn: !g && !x,
                            isLastColumn: !0
                        })
                    })
                })]
            })]
        })
    })
}))
, gVe = {
    flexGrow: 1,
    height: "100%",
    pt: 2
}
  , xVe = {
    gap: {
        xs: .25,
        md: 2
    },
    px: {
        xs: 1,
        md: 0
    },
    mx: -2,
    height: "100%",
    mt: {
        xs: -1,
        md: 0
    }
}
  , bVe = {
    gap: {
        xs: .75,
        md: 1.5
    }
}
  , fVe = {
    gap: {
        xs: .5,
        md: 1
    },
    flexGrow: 1,
    overflow: "hidden",
    minHeight: 30
}
  , vVe = {
    pl: {
        md: 1.5
    },
    pr: {
        md: 2
    },
    gap: {
        xs: .75,
        md: 2
    },
    width: "100%"
}
  , SVe = {
    px: {
        md: 1
    },
    width: "100%",
    height: "100%"
}
  , yVe = {
    border: "none",
    display: "flex",
    alignItems: "center",
    p: 0,
    height: 16,
    gap: .5,
    color: "primary.main",
    backgroundColor: "transparent",
    "&:hover": {
        backgroundColor: "transparent"
    },
    "&:focus": {
        backgroundColor: "transparent"
    }
}
  , kVe = y.memo(( () => Ax() ? v.jsx(mVe, {}) : null))
  , CVe = y.memo(( ({tokenAddress: e, tokenType: t, marketId: n, tokenSymbol: r, quoteAddress: a}) => {
    const s = pK()
      , o = y.useMemo(( () => mg(n).marketAddress), [n])
      , {insufficientBalance: l, buttonDisplayValue: i, includeExitStrategies: d, selectedPreset: u, buttonValue: p} = uH()
      , {performBuy: h, hasAnyWallet: m, selectedWalletsAddresses: g} = AD();
    k$(n);
    const {settings: x} = rf()
      , [b,f] = JC(!1, 200, !1)
      , [S,A] = y.useState(!1)
      , [w,j] = y.useState(!1)
      , T = w && !S
      , I = y.useCallback(( () => {
        j(!0)
    }
    ), [j])
      , E = y.useCallback(( () => {
        j(!1)
    }
    ), [j])
      , {exitStrategies: M} = KR();
    y.useEffect(( () => {
        if (!T || !g.length)
            return;
        const t = () => {
            c.forEach([...g].sort(), (t => {
                toe({
                    chain: Pd.SOLANA,
                    baseToken: e,
                    poolAddress: o,
                    quoteToken: qc,
                    walletAddress: t
                })
            }
            ))
        }
        ;
        t();
        const n = setInterval(( () => {
            t()
        }
        ), 5e3);
        return () => {
            clearInterval(n)
        }
    }
    ), [T, g, e, o]);
    const N = y.useCallback((e => {
        "Enter" === e.key && (e.preventDefault(),
        e.stopPropagation())
    }
    ), [])
      , P = y.useMemo(( () => S ? "Buying" : `${(i ?? 0) > 1 ? LI(i ?? 0, {
        collapseExponent: (i ?? 0) > 1e6,
        symbol: "",
        padSymbol: !0,
        symbolPosition: yI.END,
        noTrailingZeros: !1,
        maxPrecision: 3
    }) : i ?? 0}`), [i, S])
      , O = y.useCallback((async o => {
        np.info("Pump live buy button clicked", {
            buttonValue: p,
            tokenAddress: e
        }),
        o.stopPropagation(),
        o.preventDefault();
        const c = {
            originWidget: Dp.PUMP_LIVE,
            selectedWalletsAmount: g.length,
            buttonValue: p,
            buttonDisplayValue: i,
            insufficientBalance: l,
            marketId: n
        };
        if (b || S)
            np.warn("Order hasn't been sent - loading", {
                orderInfo: c,
                isPerformingTrade: S,
                isDisabled: b
            });
        else {
            if (!g.length || !1 === m)
                return np.warn("Order hasn't been sent - no wallet selected", {
                    orderInfo: c
                }),
                void s({
                    message: uu.quickBuyNoWalletsSelected,
                    type: "warning"
                }, "no-wallets-error");
            if (!p || !i)
                return np.warn("Order hasn't been sent - missing button value", {
                    orderInfo: c
                }),
                void s({
                    message: uu.quickBuyIsZero,
                    type: "warning"
                }, "no-amount-error");
            if (l)
                return np.warn("Order hasn't been sent - insufficient balance", {
                    orderInfo: c
                }),
                void s({
                    message: uu.insufficientBalance,
                    type: "warning"
                }, "no-balance-error");
            A(!0),
            ((null == x ? void 0 : x.preventDoubleClick) ?? y$) && f(!0);
            try {
                await h({
                    value: p,
                    baseCurrency: e,
                    baseTokenType: t,
                    poolQuoteCurrency: a,
                    quoteForExecutionCurrency: qc,
                    baseSymbol: r,
                    quoteSymbol: "SOL",
                    marketId: n,
                    padreAvatarUrl: null,
                    presetName: u,
                    originWidget: Dp.PUMP_LIVE,
                    exitStrategies: d && M.length ? M : null
                })
            } catch (fNe) {
                np.error("Order hasn't been sent - exception thrown during processing order", {
                    e: fNe,
                    orderInfo: c
                })
            } finally {
                A(!1)
            }
        }
    }
    ), [b, S, g.length, m, p, i, l, null == x ? void 0 : x.preventDoubleClick, s, f, h, e, t, a, r, n, u, d, M]);
    return v.jsx(GC, {
        title: 0 === g.length ? "No wallet selected" : l ? "Insufficient balance" : !1 === m ? "You don't have compatible wallets" : "",
        children: v.jsx(C, {
            component: "span",
            display: "flex",
            justifyContent: "flex-end",
            children: v.jsx(V, {
                tabIndex: -1,
                onKeyDown: N,
                variant: "secondary",
                size: "xsmall",
                color: "success",
                sx: wVe,
                fullWidth: !1,
                onClick: O,
                onMouseOver: I,
                onMouseOut: E,
                startIcon: S ? null : v.jsx(ay, {
                    color: "inherit",
                    size: 14
                }),
                endIcon: S ? v.jsx(J, {
                    color: "inherit",
                    size: AVe
                }) : null,
                children: v.jsx(k, {
                    noWrap: !0,
                    variant: "h2",
                    color: "inherit",
                    children: P
                })
            })
        })
    })
}
))
  , AVe = 16
  , wVe = e => {
    const t = e.palette.primary.main;
    return {
        zIndex: 10,
        color: An(t, "#fff") > 4.5 ? "#ffffff" : "#111111",
        transition: "none",
        borderRadius: 5,
        px: 2,
        minWidth: jVe,
        maxWidth: TVe,
        height: IVe,
        backgroundColor: t,
        borderColor: Me(t, .08),
        "&:hover": {
            borderColor: Me(t, .08),
            backgroundColor: Me(t, .15)
        },
        "&:focus": {
            borderColor: Me(t, .08),
            backgroundColor: Me(t, .15)
        },
        "&:disabled": {
            backgroundColor: e.palette.background.disabled,
            borderColor: e.palette.background.disabled,
            color: e.palette.text.label
        },
        "& .MuiButton-startIcon": {
            marginRight: "4px"
        }
    }
}
  , jVe = 80
  , TVe = 120
  , IVe = 28
  , EVe = y.memo(( ({pumpFunUrl: e, websiteUrl: t, twitterUrl: n, telegramUrl: r, interactiveTooltipCallback: a}) => {
    const [s,o] = y.useMemo(( () => {
        if (!n)
            return [null, !1];
        const [e,t] = fR(n);
        if (!e)
            return [null, !1];
        return [t ? v.jsx(FO, {
            id: e
        }) : v.jsx(AO, {
            id: e,
            reuses: null
        }), t]
    }
    ), [n])
      , l = y.useMemo(( () => xR(t)), [t])
      , i = y.useMemo(( () => t ? mR(t) ? null : v.jsx(SE, {
        url: t
    }) : null), [t])
      , {tweetId: c, tweetUrl: d} = y.useMemo(( () => {
        const e = uR(n ?? "");
        if (e)
            return {
                tweetId: e,
                tweetUrl: n ?? ""
            };
        const r = uR(t ?? "");
        return r ? {
            tweetId: r,
            tweetUrl: t ?? ""
        } : {
            tweetId: null,
            tweetUrl: null
        }
    }
    ), [n, t]);
    return v.jsxs(S, {
        direction: "row",
        gap: .5,
        children: [v.jsx(aE, {
            Icon: aS,
            link: e,
            preventDefault: !0,
            useHref: !0,
            iconSize: MVe,
            circularBackground: !0
        }), n && s && v.jsx(aE, {
            Icon: o ? Wk : $S,
            color: FI,
            link: n,
            preventDefault: !0,
            useHref: !0,
            showTooltip: !0,
            iconSize: MVe,
            tooltipTitle: s,
            noTooltipBackground: !0,
            controlledOnMobile: !0,
            circularBackground: !0,
            interactiveTooltipCallback: a
        }), c && d && !s && v.jsx(aE, {
            Icon: qy,
            link: d,
            preventDefault: !0,
            useHref: !0,
            tooltipTitle: v.jsx(ZL, {
                id: c
            }),
            noTooltipBackground: !0,
            iconSize: MVe,
            showTooltip: !0,
            interactiveTooltipCallback: a,
            controlledOnMobile: !0
        }), n && !(c && d) && !s && v.jsx(aE, {
            Icon: Mk,
            link: n,
            preventDefault: !0,
            useHref: !0,
            iconSize: MVe,
            tooltipTitle: void 0,
            circularBackground: !0
        }), t && v.jsx(aE, {
            Icon: l,
            link: t,
            preventDefault: !0,
            useHref: !0,
            tooltipTitle: i ?? void 0,
            noTooltipBackground: !!i,
            iconSize: MVe,
            showTooltip: !0,
            controlledOnMobile: !!i,
            circularBackground: !0,
            interactiveTooltipCallback: i ? a : void 0
        }), r && v.jsx(aE, {
            Icon: Ly,
            link: r,
            preventDefault: !0,
            useHref: !0,
            iconSize: MVe,
            circularBackground: !0
        })]
    })
}
))
  , MVe = 14
  , NVe = "https://prod-livestream-thumbnails-841162682567.s3.us-east-1.amazonaws.com/default.png"
  , PVe = e => `${e.tokenAddress}-${e.createdAt}`
  , OVe = y.memo(( ({interactiveTooltipCallback: e, ...t}) => {
    const {title: n, desc: r, backgroundUrl: a, avatarUrl: s, padreAvatarUrl: o, createdAt: l, repliesCount: i, fdvUsd: c, tokenAddress: d, tokenType: u, marketId: p, tokenSymbol: h, quoteAddress: m, quoteSymbol: g, pumpFunUrl: x, websiteUrl: b, twitterUrl: f, telegramUrl: A} = t
      , w = D()
      , j = xw()
      , T = bw()
      , I = fw()
      , E = vw()
      , M = y.useMemo(( () => E ? 150 : I ? 220 : T ? 200 : j ? 210 : 190), [I, T, j, E])
      , {marketCapThresholds: N} = bA()
      , P = y.useMemo(( () => IA(c ?? 0, N, w.palette.text.value)), [c, N, w.palette.text.value])
      , O = y.useMemo(( () => ({
        position: "absolute",
        inset: 0,
        backgroundImage: `url(${a})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
        filter: "blur(12px)",
        transform: "scale(1.15)",
        opacity: 0,
        transition: "opacity 160ms ease-in-out",
        pointerEvents: "none",
        maskImage: `linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,1) calc(100% - ${WVe}px), rgba(0,0,0,0) 100%)`,
        WebkitMaskImage: `linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,1) calc(100% - ${WVe}px), rgba(0,0,0,0) 100%)`
    })), [a])
      , L = pT()
      , R = y.useMemo(( () => QE(p, nT.PUMP_LIVE)), [p])
      , B = y.useCallback((e => {
        if (e.metaKey || e.ctrlKey)
            return void (R && window.open(R, "_blank"));
        if (e.preventDefault(),
        !p)
            return;
        const n = (e => {
            const t = Jse(Pd.SOLANA, e.quoteAddress) ?? noe;
            return {
                chain: Pd.SOLANA,
                marketAddress: e.marketAddress,
                protocol: e.protocol,
                createdAt: e.createdAt,
                baseToken: {
                    chain: Pd.SOLANA,
                    address: e.tokenAddress,
                    symbol: e.tokenSymbol,
                    name: e.title,
                    decimals: e.decimals ?? 6,
                    deployedAt: e.createdAt,
                    deployedAtBlock: null,
                    deployer: e.devAddress,
                    tokenType: e.tokenType
                },
                quoteToken: t,
                launchpad: e.launchpad,
                launchpadAux: e.launchpadAux,
                preMigrationMarketId: e.preMigrationMarketId,
                realQuoteToken: e.realQuoteToken ?? null
            }
        }
        )(t);
        n && mT.set(p, n),
        L({
            marketId: p,
            tradePageOrigin: nT.PUMP_LIVE
        })
    }
    ), [p, L, R, t])
      , _ = y.useCallback((e => {
        e.preventDefault(),
        e.stopPropagation();
        let t = e.target
          , n = null;
        for (; t && t !== e.currentTarget; ) {
            if ("A" === t.tagName && t.hasAttribute("reflink")) {
                n = t.getAttribute("reflink");
                break
            }
            if (t.hasAttribute("aria-label")) {
                const e = t.getAttribute("aria-label");
                if ((null == e ? void 0 : e.startsWith("http://")) || (null == e ? void 0 : e.startsWith("https://"))) {
                    n = e;
                    break
                }
            }
            t = t.parentElement
        }
        return n ? window.open(n, "_blank") : window.open(R, "_blank"),
        !1
    }
    ), [R])
      , U = y.useCallback((e => {
        Mn && 1 === e.button && e.preventDefault()
    }
    ), []);
    return v.jsxs(C, {
        sx: qVe,
        component: "span",
        onClick: B,
        onAuxClick: _,
        onContextMenu: Mn ? Uw : _,
        onMouseDown: U,
        children: [v.jsx(C, {
            className: _Ve,
            sx: KVe
        }), v.jsx(C, {
            className: BVe,
            sx: O
        }), v.jsx(C, {
            sx: LVe,
            className: UVe,
            children: v.jsx(C, {
                sx: RVe,
                children: v.jsx(C, {
                    component: "img",
                    src: a,
                    alt: n,
                    sx: FVe
                })
            })
        }), v.jsxs(S, {
            sx: DVe,
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .75,
                    minWidth: 0,
                    children: [v.jsx(b_, {
                        url: o || s,
                        name: n,
                        chain: Pd.SOLANA,
                        padreAvatarUrl: o || null,
                        protocolInfo: null,
                        borderRadius: "6px",
                        size: GVe,
                        showLens: !0,
                        miniLens: !0
                    }), v.jsx(wG, {
                        typographyOverrides: $Ve,
                        address: d,
                        customName: n,
                        maxWidth: M,
                        hideIcon: !0,
                        hoverPrimaryColor: !0,
                        forceStopPropagation: !0,
                        forcePreventDefault: !0
                    })]
                }), null != c && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    flexShrink: 0,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        noWrap: !0,
                        children: "MC"
                    }), v.jsx(k, {
                        variant: "h2",
                        color: P,
                        noWrap: !0,
                        children: LI(c, {
                            collapseExponent: !0,
                            desiredDigits: 3,
                            symbol: "$",
                            padSymbol: !1,
                            symbolPosition: yI.START
                        })
                    })]
                })]
            }), v.jsx(k, {
                variant: "paragraph1",
                color: "text.label",
                sx: VVe,
                fontWeight: zVe,
                lineHeight: 1.3,
                children: r
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: .75,
                children: [null != i && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    height: HVe,
                    children: [v.jsx(kC, {
                        size: 14
                    }), v.jsx(k, {
                        variant: "paragraph1",
                        color: "text.label",
                        noWrap: !0,
                        height: HVe,
                        fontWeight: zVe,
                        children: i
                    })]
                }), v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    height: HVe,
                    fontWeight: zVe,
                    children: hM
                }), null != l && v.jsx(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: .5,
                    height: HVe,
                    children: v.jsx(mE, {
                        variant: "paragraph1",
                        color: "text.label",
                        ts: l,
                        noWrap: !0,
                        suffixAdornment: " ago",
                        height: HVe,
                        fontWeight: zVe
                    })
                })]
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 1,
                children: [v.jsx(EVe, {
                    pumpFunUrl: x,
                    websiteUrl: b,
                    twitterUrl: f,
                    telegramUrl: A,
                    interactiveTooltipCallback: e
                }), v.jsx(CVe, {
                    tokenAddress: d,
                    tokenType: u,
                    marketId: p,
                    tokenSymbol: h,
                    quoteAddress: m,
                    quoteSymbol: g
                })]
            })]
        })]
    })
}
), ( (e, t) => e.fdvUsd === t.fdvUsd && c.isEqual(e, t)))
  , LVe = {
    px: 1.5,
    pt: 1.5,
    pb: 1,
    transition: "transform 200ms ease-in-out"
}
  , RVe = {
    position: "relative",
    width: "100%",
    aspectRatio: "16 / 9",
    overflow: "hidden",
    borderRadius: 1
}
  , DVe = {
    position: "relative",
    zIndex: 1,
    px: 1.5,
    pb: 3,
    gap: 1.5
}
  , BVe = "pump-blur-bg"
  , _Ve = "pump-static-bg"
  , UVe = "pump-full-bg"
  , WVe = 250
  , FVe = {
    width: "100%",
    height: "100%",
    objectFit: "cover"
}
  , VVe = {
    overflow: "hidden",
    textOverflow: "ellipsis",
    display: "-webkit-box",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical",
    minHeight: 34
}
  , HVe = 15
  , zVe = 400
  , $Ve = {
    variant: "h2",
    noWrap: !0,
    mt: .25
}
  , GVe = 22
  , qVe = e => ({
    display: "flex",
    flexDirection: "column",
    position: "relative",
    background: e.palette.background.secondary,
    borderRadius: 2,
    gap: 1,
    overflow: "hidden",
    "&:hover": {
        cursor: "pointer",
        [`.${UVe}`]: {
            transform: "scale(1.01)"
        }
    },
    [`&:hover .${BVe}`]: {
        opacity: .25
    },
    [`&:hover .${_Ve}`]: {
        opacity: 0
    }
})
  , KVe = e => ({
    position: "absolute",
    inset: 0,
    background: `linear-gradient(to bottom, ${e.palette.background.buttonActive} 0%, transparent 100%)`,
    pointerEvents: "none",
    transition: "opacity 160ms ease-in-out"
})
  , YVe = e => {
    const {data: t} = mte(e);
    return y.useMemo(( () => t ? c.reduce(t.orderedDisplayData, ( (e, t) => {
        const n = (e => {
            if (!e.livePf || !e.livePfPreviewAdditions)
                return null;
            const {tokenAddress: t, livePf: n, livePfPreviewAdditions: r, pumpfunAddress: a, meteoraAddress: s, pumpSwapAddress: o, raydiumAddress: l, padreAvatarUrl: i} = e
              , c = s ?? o ?? l ?? a;
            if (!c)
                return null;
            const d = fg(Pd.SOLANA, c, null);
            if (!d)
                return null;
            const u = r.thumbnail ?? NVe
              , p = IE(Pd.SOLANA, t)
              , h = Sp(e)
              , m = Dee(e.twitterUrl)
              , g = e.quoteTokenAddr ?? qc;
            return {
                marketId: d,
                tokenAddress: e.tokenAddress,
                tokenSymbol: e.symbol,
                quoteAddress: g,
                quoteSymbol: "SOL",
                title: e.name,
                desc: r.description ?? "",
                backgroundUrl: u,
                avatarUrl: p,
                padreAvatarUrl: i,
                pumpFunUrl: `https://pump.fun/coin/${t}`,
                websiteUrl: e.projectWebsiteUrl && ou.test(e.projectWebsiteUrl) ? e.projectWebsiteUrl : null,
                twitterUrl: e.twitterUrl && ou.test(e.twitterUrl) ? e.twitterUrl : null,
                telegramUrl: e.telegramUrl && ou.test(e.telegramUrl) ? e.telegramUrl : null,
                createdAt: e.createdAt,
                repliesCount: n.replyCount ?? 0,
                fdvUsd: e.fdvInUsd,
                twitterHandle: m ? m.toLowerCase() : null,
                migrationTime: h,
                marketAddress: c,
                protocol: kp(e),
                decimals: e.decimals,
                devAddress: e.devAddress,
                tokenType: e.tokenType ?? ("heaven" === e.type ? vc.SOLANA_SPL_2022 : vc.SOLANA_SPL),
                realQuoteToken: e.realQuoteToken,
                preMigrationMarketId: ioe({
                    chain: Pd.SOLANA,
                    fourMemeAddress: null,
                    pancakeSwapAddress: null,
                    ...e
                }),
                launchpad: e.type,
                launchpadAux: e.launchpadAux
            }
        }
        )(t);
        return n && e.push(n),
        e
    }
    ), []) : null), [t])
}
  , XVe = y.memo(( ({gazeType: e, isPaused: t, setIsTooltipOpen: n, setIsHovering: r}) => {
    const a = xw()
      , s = YVe(e)
      , o = lxe()
      , l = ube()
      , i = y.useMemo(( () => `calc(100vh - ${eHe + o + l + (a ? QVe : ZVe)}px)`), [l, o, a])
      , {setLivePumpFilters: c, livePumpFilters: d} = JX()
      , u = y.useCallback((e => {
        c({
            ...XX,
            ...d,
            TICKERS: [e]
        })
    }
    ), [c, d])
      , p = XM((e => e.registerTrenchesNewSearch));
    y.useEffect(( () => {
        const e = p(u);
        return () => {
            e()
        }
    }
    ), [u, p]);
    const h = y.useMemo(( () => ({
        onOpen: () => {
            n(!0)
        }
        ,
        onClose: () => {
            n(!1)
        }
    })), [n])
      , m = y.useCallback(( () => {
        r(!0)
    }
    ), [r])
      , g = y.useCallback(( () => {
        r(!1)
    }
    ), [r])
      , x = y.useCallback(( () => {
        R && r(!0)
    }
    ), [r])
      , b = y.useCallback(( () => {
        R && r(!1)
    }
    ), [r])
      , f = y.useRef(null)
      , C = y.useRef([]);
    pM({
        target: f,
        onInteractionStart: x,
        onInteractionStop: b
    });
    const A = y.useRef(0)
      , w = y.useCallback((e => {
        const t = e.currentTarget.scrollTop;
        0 === t && R && g(),
        A.current = t
    }
    ), [g]);
    y.useEffect(( () => {
        t && C.current.length || (C.current = s || [])
    }
    ), [t, s]);
    const j = y.useCallback((e => {
        const t = e.currentTarget
          , n = e.clientX - t.getBoundingClientRect().left + t.scrollLeft;
        t.scrollWidth - n > nHe ? m() : g()
    }
    ), [m, g])
      , T = y.useCallback(( () => {
        r(!1)
    }
    ), [r])
      , {hideMode: I} = xne()
      , {hiddenPairs: E, hiddenMigratedPairs: M} = SX()
      , {settings: N} = rf()
      , P = y.useMemo(( () => (null == N ? void 0 : N.devBlacklist) ? new Set(N.devBlacklist) : new Set([])), [null == N ? void 0 : N.devBlacklist])
      , O = y.useMemo(( () => (null == N ? void 0 : N.handlesBlacklist) ? new Set(N.handlesBlacklist.map((e => e.toLowerCase()))) : new Set([])), [null == N ? void 0 : N.handlesBlacklist])
      , L = y.useMemo(( () => {
        const e = t && C.current.length ? ( (e, t) => {
            const n = new Map(e.map((e => [PVe(e), e])))
              , r = t.current.map((e => n.get(PVe(e)) || {
                ...e,
                deprecated: !0
            }));
            return t.current = r,
            r
        }
        )(s ?? [], C) : s;
        return I !== sne.SHOW_ALL && (E || P.size || O.size) ? e ? e.filter((e => {
            if (P.has(e.devAddress))
                return !1;
            if (e.twitterHandle && O.has(e.twitterHandle))
                return !1;
            const t = kX(e.tokenAddress, Pd.SOLANA)
              , n = null !== e.migrationTime;
            return I !== sne.HIDE && n ? I !== sne.SHOW_MIGRATED || (!M || !M[t]) : !E || !E[t]
        }
        )) : null : e
    }
    ), [t, s, I, E, P, M, O]);
    return v.jsx(S, {
        height: i,
        children: v.jsx(S, {
            ref: f,
            sx: tHe,
            className: "padre-decorative-scroll",
            onMouseMove: j,
            onMouseLeave: T,
            onScroll: w,
            children: null === L ? v.jsx(S, {
                width: "100%",
                height: "100%",
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(Km, {})
            }) : L.length ? v.jsx(S, {
                sx: JVe,
                children: L.map((e => v.jsx(OVe, {
                    interactiveTooltipCallback: h,
                    ...e
                }, e.marketId)))
            }) : v.jsx(S, {
                width: "100%",
                height: "100%",
                alignItems: "center",
                justifyContent: "center",
                children: v.jsx(k, {
                    variant: "paragraph1",
                    color: "text.label",
                    children: "No data to show"
                })
            })
        })
    })
}
))
  , QVe = 60
  , ZVe = 96
  , JVe = {
    gap: 1.5,
    display: "grid",
    gridTemplateColumns: {
        xs: "repeat(1, minmax(0, 1fr))",
        sm: "repeat(2, minmax(0, 1fr))",
        md: "repeat(3, minmax(0, 1fr))",
        lg: "repeat(4, minmax(0, 1fr))",
        xl: "repeat(5, minmax(0, 1fr))"
    }
}
  , eHe = 12
  , tHe = e => ({
    flex: 1,
    background: e.palette.background.secondary,
    border: `1px solid ${e.palette.background.borderMain}`,
    borderRadius: 2,
    maxWidth: "100%",
    p: 1,
    overflowY: "scroll",
    overflowX: "hidden"
})
  , nHe = 15
  , rHe = y.memo(( ({filterMode: e, chain: t}) => {
    const {t: n} = we()
      , {solFilters: r, setSolFilter: a, bscFilters: s, setBscFilter: o, trendingSolFilters: l, trendingBscFilters: i, setTrendingSolFilters: d, setTrendingBscFilters: u, solDexFilters: p, bscDexFilters: h, setSolDexFilters: m, setBscDexFilters: g, trendingSolNewFilters: x, trendingBscNewFilters: b, setTrendingSolNewFilters: f, setTrendingBscNewFilters: k, livePumpFilters: C, setLivePumpFilters: A} = JX()
      , w = K8(t, l, i)
      , j = K8(t, d, u)
      , T = K8(t, x, b)
      , I = K8(t, f, k)
      , E = K8(t, p, h)
      , M = K8(t, m, g)
      , N = K8(t, r, s)
      , P = K8(t, a, o)
      , O = y.useMemo(( () => {
        switch (e) {
        case "TRENDING":
            return w ? {
                ...XX,
                ...w
            } : XX;
        case "TRENDING_NEW":
            return T ? {
                ...XX,
                ...T
            } : XX;
        case "DEX":
            return E ? {
                ...XX,
                ...E
            } : XX;
        case "LIVE_PUMP":
            return C ? {
                ...XX,
                ...C
            } : XX;
        case Zh.NEW:
        case Zh.ALMOST_BONDED:
        case Zh.RECENTLY_BONDED:
            return N[e] ? {
                ...XX,
                ...N[e]
            } : XX
        }
    }
    ), [e, w, T, E, C, N])
      , L = y.useCallback((t => {
        switch (e) {
        case "TRENDING":
            j(t);
            break;
        case "TRENDING_NEW":
            I(t);
            break;
        case "DEX":
            M(t);
            break;
        case "LIVE_PUMP":
            A(t);
            break;
        case Zh.NEW:
        case Zh.ALMOST_BONDED:
        case Zh.RECENTLY_BONDED:
            P(e, t)
        }
    }
    ), [e, M, P, A, j, I])
      , [R,D] = y.useState(lHe(O) ?? "")
      , B = y.useRef(!1);
    y.useEffect(( () => {
        B.current || D(lHe(O) ?? "")
    }
    ), [O]);
    const _ = y.useRef(O);
    _.current = O;
    const U = y.useCallback((e => {
        L({
            ..._.current,
            [Qh.TICKERS]: e ? [e] : null
        })
    }
    ), [L])
      , W = y.useMemo(( () => {
        const e = c.debounce((e => {
            B.current = !1,
            U(e)
        }
        ), 200);
        return t => {
            B.current = !0,
            e(t)
        }
    }
    ), [U])
      , V = y.useCallback((async e => {
        var t;
        const n = null == (t = e.target.value) ? void 0 : t.toLowerCase();
        D(n),
        W(n)
    }
    ), [W])
      , H = y.useRef(R);
    H.current = R;
    const $ = y.useCallback(( () => {
        U(H.current)
    }
    ), [U])
      , G = y.useCallback((e => {
        "Enter" === e.key && (e.stopPropagation(),
        e.currentTarget.blur())
    }
    ), [])
      , q = y.useCallback(( () => {
        var e;
        D(""),
        U(""),
        null == (e = K.current) || e.blur()
    }
    ), [D, U])
      , K = y.useRef(null);
    return v.jsx(je, {
        ref: K,
        size: "xsmall",
        placeholder: n("Search"),
        inputProps: oHe,
        sx: aHe,
        name: Qh.TICKERS,
        value: R,
        onChange: V,
        onBlur: $,
        onKeyDown: G,
        endAdornment: v.jsx(We, {
            position: "end",
            children: v.jsx(S, {
                direction: "row",
                alignItems: "center",
                gap: 0,
                children: !!R && v.jsx(z, {
                    title: n("Clear"),
                    children: v.jsx(F, {
                        onClick: q,
                        sx: sHe,
                        children: v.jsx(Wy, {})
                    })
                })
            })
        })
    })
}
))
  , aHe = {
    flexGrow: 1,
    borderWidth: 1,
    height: 28,
    maxWidth: 110,
    pr: 0
}
  , sHe = {
    width: 24,
    height: 24,
    p: 0
}
  , oHe = {
    inputMode: "text",
    "data-pseudotype": void 0,
    style: {
        fontWeight: 500
    },
    sx: {
        textAlign: "left",
        pl: 1,
        pr: 0,
        py: 1.5
    }
}
  , lHe = e => {
    if (!e)
        return null;
    const t = e[Qh.TICKERS];
    return t && t.length ? t[0] : null
}
  , iHe = y.memo(( () => {
    const e = xw()
      , {t: t} = we()
      , {trendingMode: n, trendingTimespan: r, trenchesChain: a} = xne()
      , [s,o] = Mx("padreV2-livePumpMode", Cfe)
      , [l,i] = y.useState(!1)
      , [c,d] = y.useState(!1)
      , u = y.useMemo(( () => l || c), [l, c])
      , p = y.useMemo(( () => (e => {
        switch (e) {
        case Yte.VOL_1M:
        case Yte.VOL_5M:
        case Yte.VOL_30M:
        case Yte.VOL_1H:
            return "TRENDING";
        case Yte.DEX:
            return "DEX";
        case Yte.NEW:
            return "TRENDING_NEW";
        case Yte.PUMP_LIVE:
            return "LIVE_PUMP";
        default:
            return "TRENDING"
        }
    }
    )(n)), [n])
      , h = y.useMemo(( () => Afe(n, s)), [n, s])
      , m = y.useCallback(( () => {
        i(!1)
    }
    ), []);
    return v.jsx(cH, {
        contextId: "trending",
        children: v.jsx(XJ, {
            contextId: "trending",
            children: v.jsx(vt, {
                sx: cHe,
                children: v.jsxs(S, {
                    width: "100%",
                    height: "100%",
                    gap: 2,
                    pb: 1,
                    flexWrap: "wrap",
                    children: [v.jsxs(S, {
                        direction: e ? "row" : "column",
                        justifyContent: "space-between",
                        width: "100%",
                        gap: e ? .5 : 1.25,
                        children: [v.jsxs(S, {
                            direction: "row",
                            justifyContent: "space-between",
                            gap: 1,
                            className: "padre-no-scroll",
                            children: [v.jsxs(S, {
                                direction: "row",
                                justifyContent: e ? "space-between" : "flex-start",
                                gap: 1,
                                alignItems: "center",
                                sx: e ? void 0 : uHe,
                                className: "padre-no-scroll",
                                children: [!e && v.jsx(Uie, {
                                    hideLabel: !0
                                }), v.jsx(eve, {
                                    livePumpMode: s,
                                    setLivePumpMode: o
                                }), p && e && v.jsx(Cse, {
                                    filterMode: p,
                                    chain: a
                                }), e && v.jsx(Uie, {
                                    hideLabel: !0
                                }), !R && u && v.jsx(C, {
                                    display: "flex",
                                    ml: .75,
                                    children: v.jsx(H9, {
                                        isLive: !u,
                                        compact: !0
                                    })
                                })]
                            }), p && !e && v.jsx(Cse, {
                                filterMode: p,
                                chain: a
                            })]
                        }), v.jsxs(S, {
                            direction: "row",
                            justifyContent: e ? "flex-end" : "space-between",
                            width: "100%",
                            gap: 1,
                            children: [v.jsxs(S, {
                                direction: "row",
                                gap: 1,
                                children: [e && p && v.jsx(rHe, {
                                    filterMode: p,
                                    chain: a
                                }), a === Pd.BSC && v.jsx(d0, {}), a === Pd.SOLANA && v.jsx(dz, {}), v.jsx(gae, {}), v.jsx(dVe, {}), !e && p && v.jsx(rHe, {
                                    filterMode: p,
                                    chain: a
                                })]
                            }), R && u && v.jsxs(S, {
                                direction: "row",
                                gap: 1,
                                children: [v.jsx(H9, {
                                    isLive: !1,
                                    compact: !0
                                }), v.jsx(V, {
                                    variant: "tertiary",
                                    onClick: m,
                                    size: "xxsmall",
                                    sx: dHe,
                                    children: t("Resume")
                                })]
                            })]
                        })]
                    }), h && n !== Yte.PUMP_LIVE && v.jsx(gfe, {
                        chain: a,
                        trendingMode: n,
                        gazeType: h,
                        trendingTimespan: r,
                        isPaused: u,
                        setIsTooltipOpen: d,
                        setIsHovering: i
                    }), h && n === Yte.PUMP_LIVE && v.jsx(XVe, {
                        gazeType: h,
                        isPaused: u,
                        setIsTooltipOpen: d,
                        setIsHovering: i
                    })]
                })
            })
        })
    })
}
))
  , cHe = {
    pt: 2,
    flexGrow: 1
}
  , dHe = {
    px: 1
}
  , uHe = {
    overflowY: "hidden",
    overflowX: "scroll"
}
  , pHe = y.memo(( () => {
    const {t: e} = we()
      , t = bw()
      , {pathname: n} = he()
      , {setLastViewedPortfolioTab: r} = _H()
      , a = ( () => {
        const e = me()
          , [t] = xe();
        return y.useCallback(( ({navigationOptions: n, keepSearchParams: r}) => {
            e({
                pathname: `${tT.PORTFOLIO}`,
                search: r ? t.toString() : ""
            }, n)
        }
        ), [e, t])
    }
    )()
      , s = dT()
      , o = y.useCallback(( () => {
        n !== tT.PORTFOLIO && (r("PORTFOLIO"),
        a({}))
    }
    ), [a, n, r])
      , l = y.useCallback(( () => {
        n !== tT.WALLETS && (r("WALLETS"),
        s({}))
    }
    ), [s, n, r]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        mt: t && n === tT.PORTFOLIO ? -1 : 0,
        children: [v.jsx(Xfe, {
            label: e("Portfolio"),
            onClick: o,
            isSelected: n === tT.PORTFOLIO,
            isBig: !0
        }), v.jsx(Xfe, {
            label: e("Wallets"),
            onClick: l,
            isSelected: n === tT.WALLETS,
            isBig: !0
        })]
    })
}
))
  , hHe = ({isOpen: e}) => {
    const {values: {name: t, walletType: n, walletAddress: r}, errors: a, touched: s, setTouched: o, setFieldValue: l, setSubmitting: i, handleChange: c, handleBlur: d} = Tn();
    y.useEffect(( () => {
        (async () => {
            e || (await o({
                name: !1
            }),
            await l("name", ""),
            await l("walletAddress", ""))
        }
        )()
    }
    ), [e, i, o, l]);
    const u = y.useCallback((async e => {
        await l("walletType", e)
    }
    ), [l]);
    return v.jsxs(S, {
        gap: 1,
        children: [v.jsx(AUe, {
            size: "xlarge",
            walletType: n,
            setWalletType: u,
            labelTypographyVariant: "labelLarge"
        }), v.jsx(je, {
            size: "xlarge",
            name: "name",
            value: t,
            onChange: c,
            onBlur: d,
            error: s.name && !!a.name,
            startAdornment: v.jsx(We, {
                position: "start",
                children: v.jsx(k, {
                    htmlFor: "add-withdrawal-wallet-name-input",
                    ...mHe,
                    children: "Name"
                })
            }),
            inputProps: {
                ...Su,
                id: "add-withdrawal-wallet-name-input",
                style: {
                    textAlign: "right",
                    fontWeight: 500
                }
            }
        }), v.jsx(k, {
            variant: "bodySmall",
            color: "error",
            sx: {
                "&:empty::before": {
                    content: "''",
                    display: "inline-block"
                }
            },
            children: s.name && a.name || ""
        }), v.jsx(je, {
            size: "xlarge",
            name: "walletAddress",
            value: r,
            onChange: c,
            onBlur: d,
            error: s.walletAddress && !!a.walletAddress,
            startAdornment: v.jsx(We, {
                position: "start",
                children: v.jsx(k, {
                    htmlFor: "add-withdrawal-wallet-wallet-address-input",
                    ...mHe,
                    children: "Address"
                })
            }),
            inputProps: {
                ...Su,
                id: "add-withdrawal-wallet-wallet-address-input",
                style: {
                    textAlign: "right"
                }
            }
        }), v.jsx(k, {
            variant: "bodySmall",
            color: "error",
            sx: {
                "&:empty::before": {
                    content: "''",
                    display: "inline-block"
                }
            },
            children: s.walletAddress && a.walletAddress || ""
        })]
    })
}
  , mHe = {
    variant: "labelLarge",
    color: "text.label",
    component: "label"
}
  , gHe = () => {
    const {t: e} = we()
      , {values: {name: t, walletAddress: n}, errors: {name: r, walletAddress: a}, isSubmitting: s, isValid: o, submitForm: l} = Tn();
    return v.jsx(z, {
        title: n ? t ? a ? "Valid wallet address is required" : "" : "Name of the wallet is required" : "Wallet address is required",
        children: v.jsx(C, {
            component: "span",
            width: "100%",
            children: v.jsx(V, {
                fullWidth: !0,
                "data-testid": "add-withdrawal-wallet-submit-button",
                type: "submit",
                onClick: l,
                color: r || a ? "error" : "primary",
                variant: "primary",
                disabled: !t || !n || s || !o,
                children: v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    alignItems: "center",
                    children: [s && v.jsx(J, {
                        size: xHe
                    }), e("Create"), s && v.jsx(C, {
                        width: xHe
                    })]
                })
            })
        })
    })
}
  , xHe = 16
  , bHe = y.memo(( ({isOpen: e, onClose: t, defaultWalletType: n}) => {
    const {user: r} = VK()
      , a = pK()
      , s = y.useCallback((async ({walletAddress: e, name: t, walletType: n}) => {
        if (r)
            try {
                await am.addWithdrawalWallet({
                    uid: r.uid,
                    walletAddress: e,
                    name: t,
                    type: n
                }),
                a({
                    message: uu.withdrawalWalletAddSuccess,
                    snackName: pu.addSuccess,
                    type: "success"
                }, "withdrawal-wallet-create-success")
            } catch (fNe) {
                a({
                    message: uu.withdrawalWalletAddFail,
                    snackName: pu.addFailed,
                    type: "error"
                }, "withdrawal-wallet-create-failed")
            }
    }
    ), [r, a])
      , o = y.useCallback((async (e, {setSubmitting: n, setErrors: r}) => {
        n(!0);
        try {
            await s(e),
            null == t || t()
        } catch (fNe) {
            r({
                name: "Something went wrong"
            })
        } finally {
            n(!1)
        }
    }
    ), [s, t]);
    return v.jsx(Ln, {
        initialValues: vHe(n),
        validationSchema: fHe,
        onSubmit: o,
        children: v.jsxs(v.Fragment, {
            children: [v.jsx(hHe, {
                isOpen: e
            }), v.jsx(gHe, {})]
        })
    })
}
))
  , fHe = Qe().shape({
    name: qe().required("Wallet name is required"),
    walletAddress: qe().required("Wallet address is required").when("walletType", {
        is: e => e === pc.ETH,
        then: e => e.test({
            message: "Please enter a valid address",
            test: e => au.test(e || "")
        }),
        otherwise: e => e.test({
            message: "Please enter a valid Solana address",
            test: e => su.test(e || "")
        })
    })
})
  , vHe = e => ({
    walletAddress: "",
    name: "",
    walletType: e
})
  , SHe = ({isOpen: e, onClose: t, walletType: n}) => {
    const {t: r} = we();
    return v.jsx(Sw, {
        open: e,
        onClose: t,
        desktopWidth: yHe,
        minDesktopWidth: yHe,
        stackSx: {
            p: 3
        },
        children: v.jsxs(S, {
            gap: 3,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "h3",
                    children: r("Add withdrawal wallet")
                }), v.jsx(F, {
                    onClick: t,
                    sx: {
                        p: .5
                    },
                    children: v.jsx(kS, {})
                })]
            }), v.jsx(bHe, {
                isOpen: e,
                onClose: t,
                defaultWalletType: n
            })]
        })
    })
}
  , yHe = 500
  , kHe = y.memo(( ({transactionState: e, chain: t}) => {
    const n = D()
      , {IconComponent: r, label: a, txnHash: s} = y.useMemo(( () => {
        if (!e)
            return {
                IconComponent: v.jsx(Ck, {}),
                label: ""
            };
        switch (e.status) {
        case HC.DONE:
            return {
                IconComponent: v.jsx(xy, {
                    size: CHe,
                    color: n.palette.success.main
                }),
                label: "Transfer success",
                txnHash: e.txnHash
            };
        case HC.EXECUTING:
        case HC.QUEUED:
            return {
                IconComponent: v.jsx(J, {
                    size: CHe
                }),
                label: "Executing..."
            };
        case HC.FAILED:
            return {
                IconComponent: v.jsx(Ck, {
                    color: n.palette.error.main,
                    size: CHe
                }),
                label: "Transaction has failed"
            };
        case HC.REVERTED:
            return {
                IconComponent: v.jsx(Ck, {
                    color: n.palette.warning.main,
                    size: CHe
                }),
                label: "Transaction has been reverted"
            };
        case HC.TIMED_OUT:
            return {
                IconComponent: v.jsx(Ck, {
                    color: n.palette.error.main,
                    size: CHe
                }),
                label: "Transation has timed out"
            }
        }
    }
    ), [e, n]);
    return e ? v.jsxs(S, {
        width: "100%",
        sx: e => ({
            backgroundColor: e.palette.background.tertiary,
            borderRadius: 1,
            p: 1.5,
            mt: 1
        }),
        children: [v.jsxs(S, {
            direction: "row",
            children: [v.jsx(k, {
                variant: "bodyMediumLarge",
                color: "text.label",
                sx: {
                    width: "100%"
                },
                children: a
            }), v.jsx(S, {}), r]
        }), s && v.jsxs(S, {
            alignItems: "center",
            direction: "row",
            gap: .5,
            children: [v.jsx(k, {
                variant: "bodyMediumRegular",
                color: "text.meta",
                children: "Transaction:"
            }), v.jsx(tU, {
                link: AA(s, t),
                hideBackground: !0,
                children: v.jsx(tE, {
                    chain: t
                })
            })]
        })]
    }) : null
}
))
  , CHe = 16
  , AHe = ({disabled: e}) => {
    const {withdrawalWallets: t} = zHe()
      , {values: {withdrawalWalletAddress: n, walletAddress: r, chain: a}, setFieldValue: s} = Tn()
      , o = y.useCallback((async e => {
        await s("withdrawalWalletAddress", e.target.value)
    }
    ), [s]);
    return v.jsx(it, {
        size: "medium",
        disabled: e,
        value: n,
        displayEmpty: !0,
        onChange: o,
        fullWidth: !0,
        children: (t ? t.filter((e => ng(e.walletAddress) !== ng(r) && e.walletType === ED(a))) : []).map((e => v.jsx(te, {
            value: e.walletAddress,
            dense: !0,
            children: v.jsxs(S, {
                width: "100%",
                direction: "row",
                alignItems: "center",
                justifyContent: "space-between",
                sx: {
                    gap: .5,
                    pr: 2,
                    mt: .25
                },
                children: [v.jsx(k, {
                    variant: "bodyMediumRegular",
                    children: e.name
                }), v.jsx(k, {
                    variant: "bodyMediumRegular",
                    color: "text.meta",
                    children: oA(e.walletAddress)
                })]
            })
        }, `${e.walletAddress}-${e.walletType}`)))
    })
}
  , wHe = (e, t) => {
    const [n,r=""] = e.split(".");
    return `${n}${r.slice(0, t).padEnd(t, "0")}`.replace(/^0+/, "")
}
  , jHe = e => Qe().shape({
    amount: qe().required("Amount is required").test({
        name: "amount-balance-check",
        test: function(t) {
            var n;
            const {chain: r, nativeBalance: a} = this.parent;
            if (!t || !a || "" === a)
                return;
            const s = ( (e, t) => e === Pd.SOLANA ? .001 : null === t ? 2e-4 : 21e3 * (t + (e === Pd.ETH_MAINNET ? 1 : 0)) * 1.125 * 1e-9)(r, (null == (n = null == e ? void 0 : e.perChain[r]) ? void 0 : n.stats.gasUi) ?? null)
              , o = SU(ED(r))
              , l = ( (e, t, n) => wHe((Number(e) + n).toFixed(t), t))(t, o, s)
              , i = eEe(wHe(s.toFixed(o), o), a) > 0;
            return eEe(l, a) > 0 ? this.createError({
                message: `Insufficient balance to cover ${i ? "transfer txn cost" : "total txn cost"} ${GD(r)} ${(s + (i || isNaN(Number(t)) ? 0 : Number(t))).toFixed(r === Pd.BASE ? 7 : 5)}`
            }) : eEe(l, a) <= 0
        }
    }),
    withdrawalWalletAddress: qe().required("Withdrawal wallet address cannot be empty").when("chain", {
        is: e => e !== Pd.SOLANA,
        then: e => e.test({
            message: "Please enter a valid address",
            test: e => au.test(e || "")
        }),
        otherwise: e => e.test({
            message: "Please enter a valid Solana address",
            test: e => su.test(e || "")
        })
    }),
    nativeBalance: qe().required("Native balance is required")
})
  , THe = (e, t) => e ? [HC.DONE, HC.EXECUTING, HC.QUEUED].includes(e.status) : !!t
  , IHe = ({isOpen: e, wallet: t, transactionState: n, transferId: r}) => {
    const {values: {amount: a, chain: s, walletAddress: o}, errors: l, touched: i, setTouched: c, setFieldTouched: d, setFieldValue: u, setSubmitting: p, handleBlur: h} = Tn()
      , m = y.useMemo(( () => s === Pd.SOLANA ? qc : Wd), [s])
      , {tokenBalances: g} = BJ({
        chainId: s,
        walletAddresses: [o],
        tokenAddresses: [m]
    })
      , x = y.useMemo(( () => {
        var e;
        return (null == (e = null == g ? void 0 : g[o]) ? void 0 : e[m]) || null
    }
    ), [g, o, m]);
    y.useEffect(( () => {
        (async () => {
            x ? await u("nativeBalance", x.rawAmount) : await u("nativeBalance", "")
        }
        )()
    }
    ), [x, u]),
    y.useEffect(( () => {
        (async () => {
            e || (await c({
                amount: !1
            }),
            await u("walletAddress", ""),
            await u("name", ""),
            await u("nativeBalance", ""))
        }
        )()
    }
    ), [e, p, c, u]);
    const b = y.useCallback((async e => {
        "ALL_NETWORKS" !== e && await u("chain", e)
    }
    ), [u])
      , f = y.useCallback((async ({target: {value: e}}) => {
        const t = QR(e);
        await u("amount", t),
        await d("amount", !0, !0)
    }
    ), [u, d])
      , C = y.useMemo(( () => THe(n, r)), [n, r])
      , A = y.useCallback((e => {
        try {
            h(e)
        } catch (fNe) {}
    }
    ), [h]);
    return v.jsxs(S, {
        children: [v.jsx(rt, {
            in: !n || n.status !== HC.DONE,
            children: v.jsxs(S, {
                gap: 1,
                children: [v.jsxs(S, {
                    direction: "row",
                    justifyContent: "space-between",
                    gap: 1,
                    alignItems: "end",
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: "From"
                    }), v.jsx(V5, {
                        disabled: C,
                        chain: s,
                        setChain: b,
                        possibleOptions: t.walletType === pc.ETH ? [Pd.ETH_MAINNET, Pd.BASE, Pd.BSC] : [Pd.SOLANA],
                        showNameLabels: !1,
                        disableWrap: !0
                    })]
                }), v.jsxs(S, {
                    width: "100%",
                    direction: "row",
                    alignItems: "center",
                    justifyContent: "space-between",
                    sx: e => ({
                        px: 1,
                        gap: PHe,
                        borderRadius: 1,
                        border: `1px solid ${e.palette.background.borderSubtle}`,
                        overflow: "hidden",
                        minHeight: LHe
                    }),
                    children: [v.jsxs(S, {
                        direction: "row",
                        gap: OHe,
                        maxWidth: `calc(100% - ${NHe + 8 * (OHe + PHe)}px)`,
                        flexGrow: 1,
                        children: [v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            noWrap: !0,
                            children: t.walletName
                        }), v.jsx(k, {
                            variant: "paragraph3",
                            color: "text.label",
                            width: MHe,
                            minWidth: MHe,
                            noWrap: !0,
                            children: oA(t.publicAddress)
                        })]
                    }), v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        textAlign: "end",
                        width: NHe,
                        children: x ? LI(new sB({
                            decimals: SU(ED(s))
                        },BigInt(x.rawAmount)).toExact(), {
                            symbol: GD(s)
                        }) : Ud
                    })]
                }), v.jsxs(S, {
                    gap: 1,
                    width: "100%",
                    children: [v.jsx(je, {
                        size: "xlarge",
                        name: "amount",
                        value: a,
                        onChange: f,
                        onBlur: A,
                        disabled: C,
                        error: i.amount && !!l.amount,
                        startAdornment: v.jsx(We, {
                            position: "start",
                            children: v.jsx(k, {
                                htmlFor: "transfer-amount-input",
                                ...EHe,
                                children: "Amount"
                            })
                        }),
                        inputProps: {
                            ...Su,
                            id: "transfer-amount-input",
                            style: {
                                textAlign: "right",
                                fontWeight: 500
                            }
                        }
                    }), v.jsx(k, {
                        variant: "bodySmall",
                        color: "error",
                        sx: {
                            "&:empty::before": {
                                content: "''",
                                display: "inline-block"
                            }
                        },
                        children: i.amount && l.amount || ""
                    })]
                }), v.jsxs(S, {
                    gap: .5,
                    children: [v.jsx(k, {
                        variant: "paragraph3",
                        color: "text.label",
                        children: "To"
                    }), v.jsx(AHe, {
                        disabled: C
                    })]
                })]
            })
        }), v.jsx(rt, {
            in: !!n,
            children: v.jsx(kHe, {
                transactionState: n,
                chain: s
            })
        })]
    })
}
  , EHe = {
    variant: "paragraph1",
    color: "text.label",
    component: "label"
}
  , MHe = 80
  , NHe = 90
  , PHe = .5
  , OHe = .5
  , LHe = 36
  , RHe = ({disableTransfer: e}) => {
    const {values: {amount: t, withdrawalWalletAddress: n, chain: r}, errors: {amount: a, withdrawalWalletAddress: s}, isSubmitting: o, isValid: l, submitForm: i} = Tn()
      , c = y.useMemo(( () => /^(?!0\d)\d*\.?\d+$/.test(t)), [t])
      , d = !t || 0 === Number(t) || !n || o || !l || e || !c;
    return v.jsx(z, {
        title: n ? t && 0 !== Number(t) ? c ? "" : "Invalid number" : "Amount is required" : "Withdrawal wallet is required",
        children: v.jsx(C, {
            component: "span",
            width: "100%",
            children: v.jsx(V, {
                fullWidth: !0,
                "data-testid": "transfer-submit-button",
                type: "submit",
                onClick: i,
                color: a || s ? "error" : "primary",
                variant: "primary",
                disabled: d,
                sx: {
                    maxWidth: "100%"
                },
                children: v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    alignItems: "center",
                    maxWidth: "100%",
                    children: [o && v.jsx(J, {
                        size: DHe
                    }), v.jsx(k, {
                        variant: "inherit",
                        color: "inherit",
                        noWrap: !0,
                        children: "Transfer" + (d ? "" : ` ${t} ${r === Pd.SOLANA ? "SOL" : "ETH"}`)
                    }), o && v.jsx(C, {
                        width: DHe
                    })]
                })
            })
        })
    })
}
  , DHe = 16
  , BHe = y.memo(( ({isOpen: e, wallet: t, initialChain: n, intialWithdrawalWallet: r}) => {
    const {user: a} = VK()
      , s = pK()
      , {chainStats: o} = FV()
      , [l,i] = y.useState(null)
      , c = (e => {
        const t = y.useCallback((t => e ? Mm.onNativeTransferStateChange(e, t) : {
            unsubscribe: () => {}
        }), [e]);
        return yx(t)
    }
    )(l)
      , d = y.useCallback((async ({walletAddress: e, chain: t, withdrawalWalletAddress: n, amount: r}) => {
        if (a) {
            i(null);
            try {
                if (!n)
                    return;
                const o = ED(t)
                  , l = SU(o)
                  , c = wHe(r, l);
                if (!c || !/^(?!0+$)\d+$/.test(c))
                    return void s({
                        message: uu.transferEnterValidAmount,
                        snackName: pu.transferInvalidAmount,
                        type: "error"
                    }, "transfer-failed-invalid-amount");
                const d = vU()
                  , u = await Mm.makeNativeTransfer(a.uid, {
                    chain: t,
                    idemp: d,
                    rawAmount: c,
                    from: e,
                    to: n
                });
                i(u.nativeTransferId)
            } catch (fNe) {
                s({
                    message: uu.transferFail,
                    snackName: pu.transferFailed,
                    type: "error"
                }, "transfer-failed"),
                i(null)
            }
        }
    }
    ), [a, s])
      , u = y.useCallback((async (e, {setSubmitting: t, setErrors: n, setFieldValue: r, setFieldTouched: a}) => {
        t(!0);
        try {
            await d(e)
        } catch (fNe) {
            n({
                amount: "Something went wrong"
            })
        } finally {
            await r("amount", ""),
            await a("amount", !1, !1),
            t(!1)
        }
    }
    ), [d])
      , p = y.useMemo(( () => jHe(o)), [o]);
    return v.jsx(Ln, {
        initialValues: _He(t, r, n),
        validationSchema: p,
        onSubmit: u,
        children: v.jsx(Rn, {
            children: v.jsxs(S, {
                gap: 1,
                children: [v.jsx(IHe, {
                    isOpen: e,
                    wallet: t,
                    transactionState: c,
                    transferId: l
                }), v.jsx(RHe, {
                    disableTransfer: THe(c, l)
                })]
            })
        })
    })
}
))
  , _He = (e, t, n) => ({
    walletAddress: e.publicAddress,
    chain: n,
    withdrawalWalletAddress: t,
    amount: "",
    nativeBalance: ""
})
  , UHe = ({isOpen: e, onClose: t, wallet: n, initialChain: r}) => {
    const {t: a} = we()
      , {withdrawalWallets: s} = zHe()
      , o = y.useMemo(( () => {
        if (!s || !n)
            return null;
        const e = ng(n.publicAddress)
          , t = s.filter((t => t.walletType === n.walletType && ng(t.walletAddress) !== e));
        return t.length ? t.sort(( (e, t) => t.addedAt - e.addedAt))[0].walletAddress : null
    }
    ), [n, s]);
    return n && o ? v.jsx(Sw, {
        open: e,
        onClose: t,
        desktopWidth: WHe,
        minDesktopWidth: WHe,
        stackSx: {
            p: 3
        },
        children: v.jsxs(S, {
            gap: 3,
            children: [v.jsxs(S, {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [v.jsx(k, {
                    variant: "h2",
                    children: a("Withdraw funds")
                }), v.jsx(F, {
                    onClick: t,
                    sx: FHe,
                    children: v.jsx(kS, {})
                })]
            }), v.jsx(BHe, {
                isOpen: e,
                wallet: n,
                initialChain: r,
                intialWithdrawalWallet: o
            })]
        })
    }) : null
}
  , WHe = 500
  , FHe = {
    p: .5
}
  , VHe = y.createContext({
    withdrawalWallets: null,
    openAddWalletModal: c.noop,
    openWithdrawModal: c.noop
})
  , HHe = ({children: e}) => {
    const {withdrawalWallets: t, state: n} = UD((e => e))
      , [r,a] = y.useState(!1)
      , [s,o] = y.useState(pc.ETH)
      , l = y.useCallback((e => {
        o(e),
        a(!0)
    }
    ), [])
      , i = y.useCallback(( () => {
        a(!1)
    }
    ), [])
      , [c,d] = y.useState(!1)
      , [u,p] = y.useState(null)
      , [h,m] = y.useState(Pd.ETH_MAINNET)
      , g = y.useCallback(( (e, t) => {
        p(e),
        m(t),
        d(!0)
    }
    ), [])
      , x = y.useCallback(( () => {
        d(!1)
    }
    ), [])
      , b = y.useMemo(( () => ({
        withdrawalWallets: n === BD.READY && t || null,
        openAddWalletModal: l,
        openWithdrawModal: g
    })), [t, n, l, g]);
    return v.jsxs(VHe.Provider, {
        value: b,
        children: [e, v.jsx(SHe, {
            isOpen: r,
            onClose: i,
            walletType: s
        }), v.jsx(UHe, {
            isOpen: c,
            onClose: x,
            wallet: u,
            initialChain: h
        })]
    })
}
  , zHe = () => y.useContext(VHe)
  , $He = () => v.jsxs(VEe, {
    severity: "warning",
    children: ["Make sure you export all your private keys and save them securely. Your private keys can be found in", v.jsx($, {
        component: Jn,
        to: tT.WALLETS,
        sx: {
            gap: .5,
            px: .25,
            borderRadius: 1,
            cursor: "pointer",
            alignItems: "center",
            color: "text.meta",
            "&:hover": {
                color: "text.primary",
                transition: "color 200ms ease-in-out"
            }
        },
        children: v.jsx(k, {
            variant: "inherit",
            sx: {
                color: "inherit"
            },
            children: "Wallets"
        })
    })]
})
  , GHe = e => e ? e === pc.SOL ? "Phantom" : "MetaMask" : "Wallet"
  , qHe = ({close: e, isOpen: t, walletType: n, publicAddress: r}) => {
    const {t: a} = we()
      , s = xw()
      , o = bw();
    return v.jsx(U5, {
        title: a("Deposit funds"),
        close: e,
        isOpen: t,
        children: v.jsxs(S, {
            gap: 2,
            alignItems: "center",
            children: [v.jsx(k, {
                variant: "bodyLarge",
                color: "text.meta",
                children: a("Use {{tool}} or another tool of your choice to transfer funds to the address:", {
                    tool: GHe(n)
                })
            }), v.jsx(S, {
                my: {
                    xs: 0,
                    sm: 1
                },
                alignItems: "flex-start",
                children: v.jsx(cA, {
                    address: r,
                    customName: r,
                    maxWidth: "100%",
                    labelVariant: s ? "monoLarge" : "monoRegular",
                    labelSx: {
                        color: "text.primary"
                    }
                })
            }), o && v.jsx(Vn, {
                size: KHe,
                value: r,
                viewBox: `0 0 ${KHe} ${KHe}`
            }), v.jsx(k, {
                variant: "bodyLarge",
                color: "text.meta",
                mb: 2,
                children: a("Please make sure you are sending tokens on intended chain.")
            }), v.jsx($He, {}), v.jsx(V, {
                fullWidth: !0,
                variant: "secondary",
                onClick: e,
                children: a("Close")
            })]
        })
    })
}
  , KHe = 140
  , YHe = ({close: e, isOpen: t, walletType: n, walletToExport: r, credentialIds: a}) => {
    const {t: s} = we();
    return v.jsx(U5, {
        title: s("Export wallet"),
        close: e,
        isOpen: t,
        children: v.jsxs(S, {
            gap: 2,
            children: [v.jsx(k, {
                variant: "bodyLarge",
                color: "text.meta",
                children: s("Export the private key of your wallet and add it to {{tool}} or another tool of your choice", {
                    tool: GHe(n)
                })
            }), r && v.jsx(S, {
                mt: 2,
                children: v.jsx(zUe, {
                    wallet: r,
                    credentialIds: a
                })
            }), v.jsx(V, {
                fullWidth: !0,
                variant: "secondary",
                onClick: e,
                children: s("Close")
            })]
        })
    })
}
  , XHe = {
    disableGutters: !0,
    square: !0,
    sx: e => ({
        "&.MuiAccordion-root": {
            backgroundColor: "transparent"
        },
        borderBottom: `1px solid ${e.palette.background.borderMain}`,
        boxShadow: "none",
        "&:before": {
            display: "none"
        }
    })
}
  , QHe = y.memo(( ({wallet: e}) => {
    const t = D()
      , n = bw()
      , r = Ax()
      , {apiStamper: a, hasApiAuthenticator: s} = YT()
      , [l,i] = y.useState(!1)
      , {ethSubOrgId: c, solSubOrgId: d, credentialIds: u} = UD((e => e))
      , [p,h] = y.useState(!1)
      , [m,g] = y.useState(!1)
      , x = pK()
      , b = y.useCallback((async () => {
        r && (i(!0),
        am.setWalletVisibility({
            isHidden: !1,
            uid: r,
            walletId: e.walletId,
            walletType: e.walletType
        }).then(( () => {
            x({
                message: pu.walletUnarchived,
                type: "success"
            }, "wallet-unarchived")
        }
        )).catch((e => {
            o(e),
            x({
                message: uu.unableToUnarchiveWallet,
                snackName: pu.somethingWentWrong,
                type: "warning"
            }, "unable-to-unarchive-wallet")
        }
        )).finally(( () => {
            i(!1)
        }
        )))
    }
    ), [r, e.walletId, e.walletType, x])
      , C = y.useCallback((async () => {
        if (r && null !== s && c && d)
            if (h(!0),
            e.isImported)
                try {
                    const t = await (async e => {
                        f({
                            message: "stampDeletePrivateKey attempt",
                            data: {
                                subOrgId: e.subOrgId,
                                walletId: e.privateKeyId
                            }
                        });
                        const t = FT(e.credentialIds, e.hasApiAuthenticator, e.apiStamper);
                        return await t.stampDeletePrivateKeys({
                            type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS",
                            organizationId: e.subOrgId,
                            timestampMs: String(+(await kg())),
                            parameters: {
                                privateKeyIds: [e.privateKeyId],
                                deleteWithoutExport: !0
                            }
                        })
                    }
                    )({
                        apiStamper: a,
                        credentialIds: u,
                        subOrgId: e.walletType === pc.ETH ? c : d,
                        hasApiAuthenticator: s,
                        privateKeyId: e.walletId
                    });
                    await am.deletePrivateKey({
                        uid: r,
                        signedRequest: t
                    }),
                    g(!0),
                    x({
                        snackName: pu.walletDeleted,
                        message: null,
                        type: "success"
                    }, "private-key-deleted")
                } catch (W$e) {
                    o(W$e),
                    x({
                        snackName: pu.somethingWentWrong,
                        message: null,
                        type: "error"
                    }, "private-key-deletetion-failed")
                } finally {
                    h(!1)
                }
            else
                try {
                    const t = await (async e => {
                        f({
                            message: "stampDeleteWallet attempt",
                            data: {
                                subOrgId: e.subOrgId,
                                walletId: e.walletId
                            }
                        });
                        const t = FT(e.credentialIds, e.hasApiAuthenticator, e.apiStamper);
                        return await t.stampDeleteWallets({
                            type: "ACTIVITY_TYPE_DELETE_WALLETS",
                            organizationId: e.subOrgId,
                            timestampMs: String(+(await kg())),
                            parameters: {
                                walletIds: [e.walletId],
                                deleteWithoutExport: !0
                            }
                        })
                    }
                    )({
                        apiStamper: a,
                        credentialIds: u,
                        subOrgId: e.walletType === pc.ETH ? c : d,
                        hasApiAuthenticator: s,
                        walletId: e.walletId
                    });
                    await am.deleteWallet({
                        uid: r,
                        signedRequest: t
                    }),
                    g(!0),
                    x({
                        snackName: pu.walletDeleted,
                        message: null,
                        type: "success"
                    }, "wallet-deleted")
                } catch (W$e) {
                    o(W$e),
                    x({
                        snackName: pu.somethingWentWrong,
                        message: null,
                        type: "error"
                    }, "wallet-deletetion-failed")
                } finally {
                    h(!1)
                }
    }
    ), [x, r, e, a, u, c, d, s]);
    return v.jsxs(S, {
        direction: "row",
        gap: 1,
        alignItems: "center",
        justifyContent: "space-between",
        sx: e => ({
            borderBottom: `1px solid ${e.palette.background.borderMain}`,
            height: n ? 80 : 60,
            width: "100%",
            px: 2,
            py: 1
        }),
        children: [v.jsxs(S, {
            gap: .5,
            mb: -.5,
            children: [n && v.jsx(k, {
                variant: "labelLarge",
                color: "text.value",
                noWrap: !0,
                sx: {
                    maxWidth: `calc(50vw - ${nze}px)`
                },
                ...Nu,
                children: e.walletName
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                ml: -1,
                children: [v.jsx(cA, {
                    customName: n ? void 0 : e.walletName,
                    address: e.publicAddress,
                    labelVariant: "labelRegular",
                    maxWidth: "calc(100vw - 244px)",
                    isInTooltip: !0,
                    stopPropagation: !0,
                    omitAriaLabel: !0,
                    containerSx: n ? {
                        py: .75,
                        px: 1
                    } : void 0
                }), n && v.jsx(Ee, {
                    flexItem: !0,
                    orientation: "vertical",
                    sx: {
                        height: tze,
                        alignSelf: "center",
                        ml: -1
                    }
                }), n && v.jsx(Iae, {
                    walletType: e.walletType
                })]
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: 1.5,
            minWidth: {
                md: ZHe
            },
            alignItems: "center",
            justifyContent: "flex-end",
            children: [v.jsx(V, {
                onClick: b,
                disabled: l,
                variant: "tertiary",
                sx: {
                    px: 1.5,
                    height: n ? eze : JHe
                },
                startIcon: v.jsx(Kv, {}),
                children: "Unarchive"
            }), v.jsx(V, {
                onClick: C,
                disabled: l || p || m,
                variant: "tertiary",
                sx: {
                    width: n ? eze : JHe,
                    minWidth: n ? eze : JHe,
                    height: n ? eze : JHe,
                    p: 0
                },
                children: v.jsx(wS, {
                    color: t.palette.error.main
                })
            })]
        })]
    })
}
))
  , ZHe = 90
  , JHe = 30
  , eze = 40
  , tze = 15
  , nze = 185
  , rze = y.memo(( ({walletItems: e}) => {
    const {t: t} = we()
      , n = bw()
      , [r,a] = y.useState(!1);
    y.useEffect(( () => {
        (null == e ? void 0 : e.length) || a(!1)
    }
    ), [e]);
    return v.jsxs(Un, {
        slotProps: {
            transition: {
                unmountOnExit: !0
            }
        },
        expanded: r && !!(null == e ? void 0 : e.length),
        onChange: (e, t) => {
            a(t)
        }
        ,
        ...XHe,
        sx: e => ({
            "&.MuiAccordion-root": {
                backgroundColor: e.palette.background.default
            },
            boxShadow: "none",
            "&:before": {
                display: "none"
            }
        }),
        children: [v.jsx(Wn, {
            sx: e => ({
                borderBottom: r ? `1px solid ${e.palette.background.borderSubtle}` : "1px solid transparent",
                transition: "border-color 0.3s ease",
                height: aze
            }),
            children: v.jsxs(S, {
                justifyContent: "space-between",
                alignItems: "center",
                width: "100%",
                flex: 1,
                direction: "row",
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1.5,
                    children: [v.jsx(k, {
                        variant: "h1",
                        color: "text.main",
                        children: t("Archived wallets")
                    }), v.jsx(Khe, {
                        label: (e || []).length.toString(),
                        grayOut: !0
                    })]
                }), v.jsx(S, {
                    direction: "row",
                    gap: 1.5,
                    children: v.jsx(V, {
                        variant: "tertiary",
                        sx: {
                            width: n ? oze : sze,
                            minWidth: n ? oze : sze,
                            height: n ? oze : sze,
                            p: 0
                        },
                        children: r ? v.jsx(yy, {}) : v.jsx(Sy, {})
                    })
                })]
            })
        }), v.jsx(Fn, {
            sx: e => ({
                backgroundColor: e.palette.background.default,
                p: 0
            }),
            children: v.jsx(S, {
                sx: {
                    overflowY: "scroll",
                    overflowX: "auto"
                },
                className: "padre-no-scroll",
                children: c.sortBy(e || [], (e => e.wallet.walletName)).map(( (e, t) => v.jsx(QHe, {
                    wallet: e.wallet
                }, t)))
            })
        })]
    })
}
))
  , aze = 69
  , sze = 30
  , oze = 40
  , lze = ({chain: e, showValuesInNative: t, usdAmount: n, nativePrice: r}) => null === n ? null : t && e === Pd.SOLANA ? r ? v.jsxs(S, {
    direction: "row",
    gap: .25,
    alignItems: "center",
    children: [v.jsx(Sz, {
        chain: e
    }), v.jsx(k, {
        variant: "paragraph3",
        ...Nu,
        children: LI(n / r, {
            collapseExponent: !0,
            symbol: "",
            desiredDigits: 3
        })
    })]
}) : null : v.jsx(k, {
    variant: "paragraph3",
    ...Nu,
    children: LI(n, {
        collapseExponent: !0,
        symbol: "$",
        symbolPosition: yI.START,
        padSymbol: !1,
        desiredDigits: 3
    })
})
  , ize = y.memo(( ({isDragging: e, walletData: t, showValuesInNative: n, chain: r}) => {
    const a = bw()
      , s = VV(r === Pd.SOLANA ? r : null)
      , o = y.useMemo(( () => lze({
        chain: r,
        showValuesInNative: n,
        usdAmount: t.usdAmount,
        nativePrice: s
    })), [r, s, n, t.usdAmount]);
    return v.jsxs(S, {
        direction: "row",
        width: "100%",
        height: "100%",
        gap: .5,
        alignItems: "center",
        justifyContent: "space-between",
        pr: 1,
        pl: 2,
        children: [v.jsxs(S, {
            direction: "row",
            gap: 1,
            alignItems: "center",
            justifyContent: "space-between",
            width: "100%",
            children: [v.jsxs(S, {
                gap: .5,
                mb: -.5,
                children: [a && v.jsx(k, {
                    variant: "labelLarge",
                    color: "text.value",
                    noWrap: !0,
                    sx: cze,
                    ...Nu,
                    children: t.wallet.walletName
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    alignItems: "center",
                    ml: -1,
                    children: [v.jsx(cA, {
                        customName: a ? void 0 : t.wallet.walletName,
                        address: t.wallet.publicAddress,
                        labelVariant: "labelRegular",
                        maxWidth: "calc(100vw - 244px)",
                        isInTooltip: !0,
                        stopPropagation: !0,
                        omitAriaLabel: !0,
                        containerSx: a ? mze : void 0
                    }), a && v.jsx(Ee, {
                        flexItem: !0,
                        orientation: "vertical",
                        sx: dze
                    }), a && v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        alignItems: "center",
                        children: [(!n || r !== Pd.SOLANA) && v.jsx(C, {
                            display: "flex",
                            mt: .25,
                            children: v.jsx(Iae, {
                                walletType: t.wallet.walletType
                            })
                        }), (!n || r !== Pd.SOLANA) && v.jsx(Ee, {
                            flexItem: !0,
                            orientation: "vertical"
                        }), o ?? v.jsx(Ie, {
                            variant: "rounded",
                            width: 75
                        })]
                    })]
                })]
            }), v.jsx(S, {
                direction: "row",
                gap: 1.5,
                minWidth: uze,
                alignItems: "center",
                justifyContent: "flex-end",
                children: a ? null : o ?? v.jsx(Ie, {
                    variant: "rounded",
                    width: 75
                })
            })]
        }), v.jsx(br, {
            sx: a ? hze : pze,
            color: e ? "inherit" : "disabled"
        })]
    })
}
))
  , cze = {
    maxWidth: "calc(50vw - 350px)"
}
  , dze = {
    height: 15,
    alignSelf: "center",
    ml: -1
}
  , uze = {
    md: 90
}
  , pze = {
    fontSize: 28
}
  , hze = {
    fontSize: 36
}
  , mze = {
    py: .75,
    px: 1
}
  , gze = y.memo(( ({label: e, onClick: t, Icon: n, disabled: r=!1}) => {
    const a = D();
    return v.jsx(te, {
        disabled: r,
        onClick: t,
        sx: e => ({
            borderBottom: `1px solid ${e.palette.background.borderMain}`,
            ":last-child": {
                borderBottom: "none"
            }
        }),
        children: v.jsxs(S, {
            width: "100%",
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            sx: {
                gap: 2,
                my: 1
            },
            children: [v.jsx(k, {
                variant: "labelRegular",
                children: e
            }), v.jsx(n, {
                size: xze,
                color: a.palette.text.label
            })]
        })
    })
}
))
  , xze = 16
  , bze = y.memo(( ({wallet: e, onWithdraw: t, onDeposit: n, onExport: r, isDesktop: a, hasWithdrawalWallets: s, chain: l, nativeBalance: i}) => {
    var c;
    const {t: d} = we()
      , u = D()
      , p = (null == (c = VK().user) ? void 0 : c.uid) ?? null
      , {hasLimitRawSigningPolicy: h, createLimitRawSigningPolicy: m} = UD((e => e))
      , [g,x] = y.useState(!1)
      , b = pK()
      , {openEditForm: f} = nWe()
      , {openAddWalletModal: C} = zHe()
      , {buttonProps: A, popoverProps: w} = Fw({
        id: `wallet-management-popover-${e.walletId}`
    })
      , j = y.useCallback(( () => {
        f(e),
        w.onClose()
    }
    ), [f, e, w])
      , [T,I] = y.useState(!1)
      , E = y.useCallback(( () => {
        I(!1)
    }
    ), [])
      , M = y.useCallback(( () => {
        p && (am.setWalletVisibility({
            isHidden: !0,
            uid: p,
            walletId: e.walletId,
            walletType: e.walletType
        }).then(( () => {
            b({
                message: pu.walletArchived,
                type: "success"
            }, "wallet-archived")
        }
        )).catch((e => {
            o(e),
            b({
                message: uu.unableToArchiveWallet,
                snackName: pu.somethingWentWrong,
                type: "warning"
            }, "unable-to-archive-wallet")
        }
        )),
        w.onClose())
    }
    ), [p, e.walletId, e.walletType, w, b])
      , N = y.useCallback(( () => {
        i && i >= Sze ? I(!0) : M()
    }
    ), [M, i])
      , P = y.useCallback((t => {
        t.stopPropagation(),
        n(e),
        w.onClose()
    }
    ), [n, e, w])
      , O = y.useCallback((n => {
        n.stopPropagation(),
        s ? t(e, l) : C(e.walletType),
        w.onClose()
    }
    ), [t, C, e, w, l, s])
      , L = y.useCallback(( () => {
        r(e),
        w.onClose()
    }
    ), [r, e, w])
      , R = y.useCallback((e => {
        A.onClick(),
        e.stopPropagation()
    }
    ), [A])
      , B = y.useCallback((async () => {
        if (!h && p)
            try {
                x(!0),
                await m(p)
            } catch (fNe) {
                o(fNe)
            } finally {
                x(!1)
            }
    }
    ), [m, h, p]);
    return v.jsxs(v.Fragment, {
        children: [a && v.jsxs(v.Fragment, {
            children: [v.jsx(V, {
                variant: "tertiary",
                onClick: h ? O : B,
                startIcon: v.jsx(Gy, {
                    color: u.palette.text.meta
                }),
                sx: vze,
                disabled: g,
                children: v.jsx(k, {
                    variant: "labelLarge",
                    sx: {
                        mt: .25
                    },
                    children: d(h ? "Withdraw" : "Enable Withdrawals")
                })
            }), v.jsx(V, {
                variant: "tertiary",
                onClick: P,
                startIcon: v.jsx(xS, {}),
                sx: vze,
                children: d("Deposit")
            })]
        }), a ? v.jsx(V, {
            ...A,
            variant: "tertiary",
            onClick: R,
            sx: e => ({
                px: 1,
                border: `1px solid ${e.palette.background.borderSubtle}`
            }),
            children: v.jsx(SS, {
                size: fze
            })
        }) : v.jsx(F, {
            ...A,
            onClick: R,
            sx: {
                p: .25
            },
            children: v.jsx(SS, {
                size: fze
            })
        }), v.jsx(ae, {
            ...w,
            disablePortal: !0,
            onClick: Ww,
            anchorOrigin: Cze,
            transformOrigin: Aze,
            children: v.jsx(ee, {
                elevation: 1,
                sx: wze,
                className: "padre-no-scroll",
                children: v.jsxs(S, {
                    children: [!a && v.jsxs(v.Fragment, {
                        children: [v.jsx(gze, {
                            label: d("Deposit"),
                            onClick: P,
                            Icon: xS
                        }), v.jsx(gze, {
                            label: d(h ? "Withdraw" : "Enable Withdrawals"),
                            onClick: h ? O : B,
                            Icon: Gy,
                            disabled: g
                        })]
                    }), v.jsx(gze, {
                        label: d("Export Private Key"),
                        onClick: L,
                        Icon: fS
                    }), v.jsx(gze, {
                        label: d("Edit name"),
                        onClick: j,
                        Icon: Ky
                    }), v.jsx(gze, {
                        label: d("Archive"),
                        onClick: N,
                        Icon: qv
                    })]
                })
            })
        }), T && null !== i && v.jsx(Sw, {
            open: T,
            onClose: E,
            children: v.jsxs(S, {
                gap: 2,
                children: [v.jsxs(k, {
                    variant: "h2",
                    textAlign: "center",
                    sx: kze,
                    children: [d("Confirm archiving wallet with balance of "), v.jsx("span", {
                        className: yze,
                        children: `${i.toFixed(2)}$`
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 1,
                    children: [v.jsx(V, {
                        onClick: E,
                        fullWidth: !0,
                        variant: "tertiary",
                        children: d("Cancel")
                    }), v.jsx(V, {
                        onClick: M,
                        fullWidth: !0,
                        color: "error",
                        variant: "secondary",
                        children: d("Archive wallet")
                    })]
                })]
            })
        })]
    })
}
))
  , fze = 16
  , vze = e => ({
    border: `1px solid ${e.palette.background.borderSubtle}`,
    px: 1.5,
    backgroundColor: e.palette.background.tertiary
})
  , Sze = 2
  , yze = "archive-warning-balance"
  , kze = e => ({
    color: e.palette.text.value,
    fontWeight: 500,
    [`.${yze}`]: {
        color: e.palette.warning.main,
        fontWeight: 600
    }
})
  , Cze = {
    vertical: "bottom",
    horizontal: "center"
}
  , Aze = {
    vertical: "top",
    horizontal: "center"
}
  , wze = e => ({
    background: e.palette.background.tertiary,
    overflow: "auto",
    border: `1px solid ${e.palette.background.borderMain}`
})
  , jze = y.memo(( ({item: e, isHidden: t, chain: n, walletAddress: r, walletType: a, showValuesInNative: s}) => {
    const o = D()
      , l = pK()
      , {showPair: i, hidePair: c} = SX()
      , d = yT()
      , {openSplitModal: u} = _ke()
      , p = VV(n === Pd.SOLANA ? n : null)
      , h = y.useMemo(( () => lze({
        chain: n,
        showValuesInNative: s,
        usdAmount: (null == e ? void 0 : e.usdBalance) ?? null,
        nativePrice: p
    })), [n, null == e ? void 0 : e.usdBalance, p, s])
      , m = y.useCallback(( () => {
        if (!e || !e.tokenAddress)
            return;
        const t = ng(e.tokenAddress);
        ru(t) || t === Fd ? l({
            message: uu.nativeMarketClick,
            type: "default"
        }, "wallets-native-token-click") : d({
            tokenAddress: e.tokenAddress,
            chain: n,
            tradePageOrigin: nT.WALLETS_LIST
        })
    }
    ), [e, d, n, l])
      , g = y.useCallback(( () => {
        e && e.tokenAddress && ST({
            query: bg(n, e.tokenAddress),
            withDeepCacheWarm: !1
        })
    }
    ), [e, n])
      , x = y.useCallback((r => {
        r.stopPropagation(),
        e && (t ? i(e.tokenAddress, n) : c(e.tokenAddress, n))
    }
    ), [i, c, t, e, n])
      , b = y.useCallback((t => {
        t.stopPropagation(),
        e && a === pc.SOL && u({
            initialTokenAddress: e.tokenAddress,
            intialWalletAddress: r
        })
    }
    ), [e, u, r, a])
      , f = y.useMemo(( () => {
        if (!e)
            return !1;
        if (t)
            return !0;
        const n = ng(e.tokenAddress);
        return !(ru(n) || n === Fd)
    }
    ), [t, e])
      , C = y.useMemo(( () => t => ({
        gap: 1,
        px: 2,
        "&:nth-of-type(odd)": {
            backgroundColor: t.palette.background.secondary
        },
        borderBottom: `1px solid ${t.palette.background.borderSubtle}`,
        ...e && e.tokenAddress ? {
            ":hover": {
                background: t.palette.background.buttonDefault,
                cursor: "pointer"
            }
        } : {},
        ":last-of-type": {
            borderBottom: "none"
        }
    })), [e]);
    return e ? v.jsxs(S, {
        direction: "row",
        justifyContent: "space-between",
        alignItems: "center",
        minHeight: 39,
        onClick: m,
        onMouseEnter: g,
        sx: C,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1,
            children: [ru(e.tokenAddress) ? v.jsx(Sz, {
                size: Ize,
                chain: n
            }) : v.jsx(b_, {
                url: IE(n, e.tokenAddress),
                padreAvatarUrl: null,
                name: e.tokenName ?? e.tokenSymbol ?? "?",
                size: Ize,
                markerIcon: v.jsx(Sz, {
                    chain: n,
                    size: Tze
                }),
                markerSize: Tze,
                chain: n,
                protocolInfo: null,
                hideHoverAvatar: !0
            }), v.jsx(k, {
                sx: Pze,
                variant: "paragraph3",
                ...Nu,
                children: e.tokenSymbol
            })]
        }), v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            gap: 1.5,
            children: [h ?? v.jsx(k, {
                variant: "paragraph3",
                color: "text.value",
                mt: .25,
                ...Nu,
                children: Ud
            }), v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "flex-end",
                width: Eze + (a === pc.SOL ? Eze + 8 * Mze : 0),
                gap: Mze,
                children: [f && v.jsx(F, {
                    onClick: x,
                    sx: Nze,
                    children: t ? v.jsx(Ek, {
                        size: 14,
                        color: o.palette.text.label
                    }) : v.jsx(Tk, {
                        size: 14,
                        color: o.palette.text.label
                    })
                }), a === pc.SOL && v.jsx(F, {
                    onClick: b,
                    sx: Nze,
                    children: v.jsx(Dv, {
                        size: 14,
                        color: o.palette.text.label
                    })
                })]
            })]
        })]
    }) : null
}
))
  , Tze = 10
  , Ize = 22
  , Eze = 24
  , Mze = .25
  , Nze = e => ({
    p: .25,
    width: Eze,
    height: Eze,
    "&:hover": {
        background: e.palette.background.buttonHover
    }
})
  , Pze = {
    textOverflow: "ellipsis",
    overflow: "hidden",
    whiteSpace: "nowrap"
}
  , Oze = y.memo(( ({items: e, chain: t, walletAddress: n, walletType: r, showValuesInNative: a, isHidden: s=!1}) => {
    const o = bw();
    return v.jsx(S, {
        height: (l = (null == e ? void 0 : e.length) || 0,
        i = !o,
        Math.min(40 * l, i ? 170 : 210)),
        sx: {
            overflowY: "scroll",
            overflowX: "auto"
        },
        className: "padre-no-scroll",
        children: (e || []).sort(( (e, t) => (t.usdBalance || 0) - (e.usdBalance || 0))).map(( (e, o) => v.jsx(jze, {
            item: e,
            isHidden: s,
            chain: t,
            walletAddress: n,
            walletType: r,
            showValuesInNative: a
        }, o)))
    });
    var l, i
}
))
  , Lze = y.memo(( ({walletData: e, chain: t, onWithdraw: n, onDeposit: r, onExport: a, hasWithdrawalWallets: s, showValuesInNative: o}) => {
    var l;
    const i = bw()
      , [d,u] = y.useState(!1)
      , [p,h] = y.useState(!1)
      , m = y.useMemo(( () => e.holdings ? c.reduce(e.holdings, ( (e, t) => (ru(t.tokenAddress) && (e.nativeHolding = t),
    t.isHidden ? e.hiddenHoldings.push(t) : e.shownHoldings.push(t),
    e)), {
        shownHoldings: [],
        hiddenHoldings: [],
        nativeHolding: null
    }) : null), [e])
      , g = y.useMemo(( () => p && !!m && !!m.hiddenHoldings.length), [p, m])
      , x = VV(t === Pd.SOLANA ? t : null)
      , b = y.useMemo(( () => lze({
        chain: t,
        showValuesInNative: o,
        usdAmount: e.usdAmount,
        nativePrice: x
    })), [t, x, o, e.usdAmount]);
    return v.jsxs(Un, {
        slotProps: {
            transition: {
                unmountOnExit: !0
            }
        },
        expanded: d,
        onChange: (e, t) => {
            u(t),
            t || h(!1)
        }
        ,
        ...XHe,
        children: [v.jsx(Wn, {
            sx: e => {
                const t = i ? Dze : Rze;
                return {
                    minHeight: t,
                    height: t,
                    backgroundColor: "transparent",
                    borderBottom: d ? `1px solid ${e.palette.background.borderSubtle}` : "1px solid transparent",
                    transition: "border-color 0.3s ease"
                }
            }
            ,
            children: v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                justifyContent: "space-between",
                width: "100%",
                children: [v.jsxs(S, {
                    gap: .5,
                    mb: -.5,
                    children: [i && v.jsx(k, {
                        variant: "labelLarge",
                        color: "text.value",
                        noWrap: !0,
                        sx: {
                            maxWidth: `calc(50vw - ${_ze}px)`
                        },
                        ...Nu,
                        children: e.wallet.walletName
                    }), v.jsxs(S, {
                        direction: "row",
                        gap: 1,
                        alignItems: "center",
                        ml: -1,
                        children: [v.jsx(cA, {
                            customName: i ? void 0 : e.wallet.walletName,
                            address: e.wallet.publicAddress,
                            labelVariant: "labelRegular",
                            maxWidth: "calc(100vw - 244px)",
                            isInTooltip: !0,
                            stopPropagation: !0,
                            omitAriaLabel: !0,
                            containerSx: i ? {
                                py: .75,
                                px: 1
                            } : void 0
                        }), i && v.jsx(Ee, {
                            flexItem: !0,
                            orientation: "vertical",
                            sx: {
                                height: Wze,
                                alignSelf: "center",
                                ml: -1
                            }
                        }), i && v.jsxs(S, {
                            direction: "row",
                            gap: 1,
                            alignItems: "center",
                            children: [(!o || t !== Pd.SOLANA) && v.jsx(C, {
                                display: "flex",
                                mt: .25,
                                children: v.jsx(Iae, {
                                    walletType: e.wallet.walletType
                                })
                            }), (!o || t !== Pd.SOLANA) && v.jsx(Ee, {
                                flexItem: !0,
                                orientation: "vertical"
                            }), b ?? v.jsx(Ie, {
                                variant: "rounded",
                                width: 75
                            })]
                        })]
                    })]
                }), v.jsxs(S, {
                    direction: "row",
                    gap: 1.5,
                    minWidth: {
                        md: Uze
                    },
                    alignItems: "center",
                    justifyContent: "flex-end",
                    children: [i ? null : null === e.usdAmount ? v.jsx(Ie, {
                        variant: "rounded",
                        width: 75
                    }) : v.jsx(k, {
                        variant: "labelRegular",
                        ...Nu,
                        children: LI(e.usdAmount, {
                            collapseExponent: !0,
                            symbol: "$",
                            symbolPosition: yI.START,
                            padSymbol: !1,
                            maxPrecision: 2
                        })
                    }), v.jsx(bze, {
                        wallet: e.wallet,
                        onWithdraw: n,
                        onDeposit: r,
                        onExport: a,
                        isDesktop: i,
                        hasWithdrawalWallets: s,
                        chain: t,
                        nativeBalance: (null == (l = null == m ? void 0 : m.nativeHolding) ? void 0 : l.usdBalance) ?? null
                    }), v.jsx(V, {
                        variant: "tertiary",
                        sx: {
                            width: i ? Vze : Fze,
                            minWidth: i ? Vze : Fze,
                            height: i ? Vze : Fze,
                            p: 0
                        },
                        children: d ? v.jsx(yy, {}) : v.jsx(Sy, {})
                    })]
                })]
            })
        }), v.jsxs(Fn, {
            sx: {
                p: 0,
                backgroundColor: "transparent"
            },
            children: [null === m ? v.jsx(S, {
                width: "100%",
                height: 120,
                children: v.jsx(Km, {})
            }) : m.shownHoldings.length ? v.jsx(Oze, {
                items: m ? m.shownHoldings : null,
                chain: t,
                walletAddress: e.wallet.publicAddress,
                walletType: e.wallet.walletType,
                showValuesInNative: o
            }) : v.jsx(S, {
                width: "100%",
                alignItems: "center",
                justifyContent: "center",
                height: 120,
                children: v.jsx(k, {
                    variant: "labelRegular",
                    color: "text.disabled",
                    textAlign: "center",
                    children: m.hiddenHoldings.length ? "All tokens on this wallet are hidden" : "You don't have tokens on this wallet"
                })
            }), m && m.hiddenHoldings.length ? v.jsxs(Un, {
                slotProps: {
                    transition: {
                        unmountOnExit: !0
                    }
                },
                expanded: g,
                onChange: (e, t) => {
                    h(t)
                }
                ,
                ...XHe,
                sx: e => ({
                    "&.MuiAccordion-root": {
                        backgroundColor: e.palette.background.default
                    },
                    borderTop: `1px solid ${e.palette.background.borderMain}`,
                    boxShadow: "none",
                    "&:before": {
                        display: "none"
                    }
                }),
                children: [v.jsx(Wn, {
                    sx: e => ({
                        minHeight: Bze - (g ? 0 : 1),
                        height: Bze - (g ? 0 : 1),
                        borderBottom: g ? `1px solid ${e.palette.background.borderSubtle}` : "1px solid transparent",
                        transition: "border-color 0.3s ease"
                    }),
                    children: v.jsxs(k, {
                        textAlign: "center",
                        variant: "paragraph3",
                        color: "text.label",
                        sx: {
                            display: "flex",
                            alignItems: "center",
                            alignSelf: "center",
                            justifyContent: "center",
                            width: "100%",
                            gap: .5
                        },
                        children: [`${g ? "Hide" : "Show"} ${m && m.hiddenHoldings.length ? `${m.hiddenHoldings.length} ` : ""}tokens`, v.jsx(S, {
                            mt: g ? -.25 : 0,
                            children: g ? v.jsx(yy, {}) : v.jsx(Sy, {})
                        })]
                    })
                }), v.jsx(Fn, {
                    sx: e => ({
                        backgroundColor: e.palette.background.default,
                        p: 0
                    }),
                    children: v.jsx(Oze, {
                        items: m ? m.hiddenHoldings : null,
                        chain: t,
                        walletAddress: e.wallet.publicAddress,
                        walletType: e.wallet.walletType,
                        showValuesInNative: o,
                        isHidden: !0
                    })
                })]
            }) : null]
        })]
    })
}
))
  , Rze = 44
  , Dze = 79
  , Bze = 32
  , _ze = 350
  , Uze = 90
  , Wze = 15
  , Fze = 30
  , Vze = 40
  , Hze = y.memo(( ({walletsData: e, archivedWalletsData: t, isLoading: n, chain: r, credentialIds: a, editCustomOrder: s, showValuesInNative: o}) => {
    const i = D()
      , c = bw()
      , {evmWalletsOrder: d, setEvmWalletsOrder: u, solWalletsOrder: p, setSolWalletsOrder: h} = rQ()
      , [m,g] = y.useState(null);
    y.useEffect(( () => {
        l(( () => import("./assets/vendor.js-DHDwnJDe.js").then((e => e.cZ))), __vite__mapDeps([1, 2])).then((e => {
            g(e)
        }
        )).catch((e => {
            g(null)
        }
        ))
    }
    ), []);
    const x = y.useMemo(( () => ED(r)), [r])
      , [b,f] = y.useState(null)
      , {withdrawalWallets: k, openWithdrawModal: C} = zHe()
      , A = y.useCallback(( () => {
        f(null)
    }
    ), [])
      , [w,j] = y.useState(null)
      , T = y.useCallback(( () => {
        j(null)
    }
    ), [])
      , I = y.useMemo(( () => {
        if (!e)
            return null;
        const t = x === pc.ETH ? d : p;
        return t.length ? $J(e, Yze, t) : e
    }
    ), [e, x, d, p])
      , E = y.useCallback((e => {
        if (!e.destination || !I)
            return;
        const t = [...I.map(Yze)]
          , [n] = t.splice(e.source.index, 1);
        t.splice(e.destination.index, 0, n),
        x === pc.ETH ? u(t) : h(t)
    }
    ), [I, u, h, x]);
    return !m && s ? v.jsx(S, {
        height: "100%",
        alignItems: "center",
        children: v.jsx(Km, {})
    }) : v.jsxs(v.Fragment, {
        children: [v.jsx(S, {
            height: "100%",
            minWidth: Gze,
            children: n || !I ? v.jsx(S, {
                height: "100%",
                alignItems: "center",
                children: v.jsx(Km, {})
            }) : v.jsxs(v.Fragment, {
                children: [I.length ? s && m ? v.jsx(m.DragDropContext, {
                    onDragEnd: E,
                    children: v.jsx(m.Droppable, {
                        droppableId: "sidebar-order-settings-droppable",
                        children: (e, t) => v.jsxs("div", {
                            ...e.droppableProps,
                            ref: e.innerRef,
                            style: {
                                backgroundColor: t.isDraggingOver ? i.palette.background.tertiary : i.palette.background.secondary
                            },
                            children: [I.map(( (e, t) => v.jsx(m.Draggable, {
                                draggableId: e.wallet.walletId,
                                index: t,
                                children: (t, n) => v.jsx(S, {
                                    ref: t.innerRef,
                                    ...t.draggableProps,
                                    ...t.dragHandleProps,
                                    sx: {
                                        height: (c ? Kze : qze) + 1,
                                        backgroundColor: n.isDragging ? i.palette.background.secondary : i.palette.background.default,
                                        borderBottom: n.isDragging ? "1px solid transparent" : `1px solid ${i.palette.background.borderMain}`
                                    },
                                    children: v.jsx(ize, {
                                        isDragging: n.isDragging,
                                        walletData: e,
                                        showValuesInNative: o,
                                        chain: r
                                    })
                                })
                            }, e.wallet.walletId))), e.placeholder]
                        })
                    })
                }) : I.map((e => {
                    const t = k ? !!k.filter((t => t.walletType === e.wallet.walletType && ng(t.walletAddress) !== ng(e.wallet.publicAddress))).length : null;
                    return v.jsx(Lze, {
                        walletData: e,
                        chain: r,
                        onWithdraw: C,
                        onDeposit: f,
                        onExport: j,
                        hasWithdrawalWallets: t,
                        showValuesInNative: o
                    }, e.wallet.walletId)
                }
                )) : v.jsx(S, {
                    width: "100%",
                    height: zze,
                    minHeight: zze,
                    alignItems: "center",
                    sx: $ze,
                    children: v.jsx(pQ, {
                        message: "You don't have wallets on this chain"
                    })
                }), v.jsx(rze, {
                    walletItems: t
                })]
            })
        }), v.jsx(qHe, {
            close: A,
            isOpen: !!b,
            walletType: x,
            publicAddress: (null == b ? void 0 : b.publicAddress) || ""
        }), v.jsx(YHe, {
            close: T,
            isOpen: !!w,
            walletType: x,
            walletToExport: w,
            credentialIds: a
        })]
    })
}
))
  , zze = 200
  , $ze = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , Gze = {
    md: 625
}
  , qze = 44
  , Kze = 79
  , Yze = e => e.wallet.walletId
  , Xze = ({walletData: e, selectAirdropWalletMode: t, assignAirdropWallet: n, assigningAirdropWallet: r}) => {
    const a = D()
      , s = bw()
      , {settings: o, updateAirdropWallet: l} = rf()
      , [i,c] = y.useState(!1)
      , [d,u] = y.useState(!1)
      , p = pK()
      , h = y.useCallback((async () => {
        u(!0);
        try {
            await am.removeWithdrawalWallet({
                uid: e.uid,
                walletAddress: e.walletAddress
            }),
            p({
                message: uu.withdrawalWalletDeleteSuccess,
                snackName: pu.deleteSuccess,
                type: "success"
            }, "withdrawal-delete-success")
        } catch (fNe) {
            u(!1),
            p({
                message: uu.withdrawalWalletDeleteFail,
                snackName: pu.deleteFailed,
                type: "error"
            }, "withdrawal-delete-failed")
        }
    }
    ), [e.uid, e.walletAddress, p])
      , m = y.useCallback((async () => {
        if (e.walletType !== pc.SOL)
            try {
                c(!0),
                await n(ng(e.walletAddress))
            } catch (fNe) {} finally {
                await Hu(300),
                c(!1)
            }
    }
    ), [n, e.walletAddress, e.walletType])
      , g = y.useCallback((async () => {
        try {
            c(!0),
            await l(null)
        } catch (fNe) {} finally {
            c(!1)
        }
    }
    ), [l])
      , x = y.useMemo(( () => !!(null == o ? void 0 : o.airdropWalletAddress) && ng(e.walletAddress) === ng(o.airdropWalletAddress)), [null == o ? void 0 : o.airdropWalletAddress, e.walletAddress]);
    return v.jsxs(S, {
        direction: "row",
        justifyContent: "space-between",
        minHeight: {
            xs: 60,
            md: 80
        },
        height: {
            xs: 60,
            md: 80
        },
        alignItems: "center",
        sx: e => ({
            borderBottom: `1px solid ${e.palette.background.borderMain}`,
            backgroundColor: "transparent",
            px: 2,
            width: "100%"
        }),
        children: [v.jsxs(S, {
            gap: {
                md: .5
            },
            mb: -.5,
            children: [v.jsx(k, {
                variant: "paragraph1",
                color: "text.value",
                noWrap: !0,
                overflow: "hidden",
                sx: {
                    maxWidth: {
                        xs: `calc(100vw - ${Zze}px)`,
                        md: `calc(50vw - ${Qze}px)`
                    }
                },
                ...Nu,
                children: e.name
            }), v.jsxs(S, {
                direction: "row",
                gap: 1,
                alignItems: "center",
                ml: -1,
                children: [v.jsx(cA, {
                    address: e.walletAddress,
                    labelVariant: "labelRegular",
                    isInTooltip: !0,
                    stopPropagation: !0,
                    omitAriaLabel: !0,
                    labelSx: {
                        color: "text.label"
                    },
                    containerSx: e => ({
                        backgroundColor: e.palette.background.tertiary,
                        py: .75,
                        px: 1
                    })
                }), v.jsx(Ee, {
                    flexItem: !0,
                    orientation: "vertical",
                    sx: {
                        height: Jze,
                        alignSelf: "center",
                        ml: -1
                    }
                }), v.jsx(Iae, {
                    walletType: e.walletType
                })]
            })]
        }), v.jsxs(S, {
            direction: "row",
            gap: 1,
            children: [x && !t && !i && v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                justifyContent: "center",
                sx: e => ({
                    bgcolor: "transparent",
                    border: `1px solid ${e.palette.background.borderMain}`,
                    p: 1,
                    borderRadius: 1,
                    gap: .5,
                    height: s ? t$e : e$e,
                    color: "success.main",
                    minWidth: s ? r$e : n$e
                }),
                children: [v.jsx(k, {
                    variant: s ? "paragraph1" : "paragraph3",
                    color: "inherit",
                    children: "Airdrop wallet"
                }), v.jsx(Fv, {
                    color: "inherit"
                })]
            }), (t || i) && v.jsxs(V, {
                disabled: i || r,
                onClick: x ? g : m,
                variant: x ? "tertiary" : "primary",
                sx: {
                    height: s ? t$e : e$e,
                    px: 1,
                    gap: .5,
                    minWidth: s ? r$e : n$e
                },
                children: [v.jsx(k, {
                    variant: s ? "paragraph1" : "paragraph3",
                    color: x ? "error.main" : "inherit",
                    children: x ? "Unassign wallet" : "Assign as airdrop"
                }), i && r ? v.jsx($_e, {}) : null]
            }), v.jsx(V, {
                disabled: d,
                onClick: h,
                variant: "tertiary",
                sx: {
                    width: s ? t$e : e$e,
                    minWidth: s ? t$e : e$e,
                    height: s ? t$e : e$e,
                    p: 0
                },
                children: d ? v.jsx($_e, {}) : v.jsx(wS, {
                    color: a.palette.text.label
                })
            })]
        })]
    })
}
  , Qze = 190
  , Zze = 160
  , Jze = 15
  , e$e = 30
  , t$e = 40
  , n$e = 117
  , r$e = 124
  , a$e = y.memo(( ({walletType: e, selectAirdropWalletMode: t, assignAirdropWallet: n, assigningAirdropWallet: r}) => {
    const {withdrawalWallets: a} = zHe()
      , s = y.useMemo(( () => a ? a.filter((t => t.walletType === e)).sort(( (e, t) => t.addedAt - e.addedAt)) : null), [e, a]);
    return v.jsx(S, {
        height: "100%",
        children: s ? s.length ? s.map((e => v.jsx(Xze, {
            walletData: e,
            selectAirdropWalletMode: t,
            assignAirdropWallet: n,
            assigningAirdropWallet: r
        }, `${e.walletAddress}-${e.walletType}`))) : v.jsx(pQ, {
            message: `You don't have ${e} withdrawal wallets`
        }) : v.jsx(S, {
            height: "100%",
            alignItems: "center",
            children: v.jsx(Km, {})
        })
    })
}
))
  , s$e = ({walletType: e, selectAirdropWalletMode: t, assignAirdropWallet: n, assigningAirdropWallet: r}) => {
    const {t: a} = we()
      , {withdrawalWallets: s, openAddWalletModal: o} = zHe()
      , l = y.useMemo(( () => s ? s.filter((t => t.walletType === e)).length : null), [s, e])
      , i = y.useCallback(( () => {
        o(e)
    }
    ), [o, e]);
    return v.jsxs(S, {
        flex: 1,
        children: [v.jsxs(S, {
            direction: "row",
            alignItems: "center",
            justifyContent: "space-between",
            py: 2.75,
            px: 2,
            sx: e => ({
                borderBottom: `1px solid ${e.palette.background.borderMain}`
            }),
            children: [v.jsxs(S, {
                direction: "row",
                alignItems: "center",
                gap: 1.5,
                children: [v.jsx(k, {
                    variant: "h1",
                    color: "text.main",
                    children: a("Withdrawal Wallets")
                }), v.jsx(Khe, {
                    label: (l || 0).toString(),
                    grayOut: !0
                })]
            }), v.jsx(S, {
                direction: "row",
                gap: 1.5,
                children: v.jsx(V, {
                    onClick: i,
                    disabled: !s,
                    startIcon: v.jsx(XS, {
                        color: "inherit"
                    }),
                    sx: o$e,
                    children: a("Add")
                })
            })]
        }), v.jsx(S, {
            className: "padre-no-scroll",
            width: "100%",
            height: "100%",
            sx: {
                overflowY: "auto",
                overflowX: "hidden"
            },
            children: v.jsx(a$e, {
                walletType: e,
                selectAirdropWalletMode: t,
                assignAirdropWallet: n,
                assigningAirdropWallet: r
            })
        })]
    })
}
  , o$e = {
    px: 2,
    borderRadius: "24px",
    fontWeight: 600
};
var l$e = (e => (e.TRADING_WALLETS = "Trading Wallets",
e.WITHDRAWAL_WALLETS = "Withdrawal wallets",
e))(l$e || {});
const i$e = l$e.TRADING_WALLETS
  , c$e = (e, t, n) => {
    const r = c.reduce(e, ( (e, r) => {
        var a;
        const s = t ? Object.values((null == (a = t[ng(r.publicAddress)]) ? void 0 : a.perTokenId) || {}) : null
          , o = n && s ? ( (e, t) => c.reduce(e, ( (e, n) => {
            const {chain: r, tokenAddress: a, tokenInfo: s, currentValueInUsdUi: o} = n;
            if (!TD(r))
                return e;
            if (!s)
                return e;
            const l = ng(a)
              , i = t.has(kX(l, r));
            return e[r].push({
                tokenAddress: l,
                tokenName: s.name || null,
                tokenSymbol: s.symbol || null,
                usdBalance: o,
                isHidden: i
            }),
            e
        }
        ), {
            [Pd.ETH_MAINNET]: [],
            [Pd.BASE]: [],
            [Pd.BSC]: [],
            [Pd.SOLANA]: []
        }))(s, n) : null;
        return o ? (c.forEach(Object.entries(o), ( ([t,n]) => {
            if (!TD(t))
                return;
            const a = t;
            if (a !== Pd.SOLANA && r.walletType === pc.SOL || a === Pd.SOLANA && r.walletType !== pc.SOL)
                return e;
            const {usdAmount: s, sortAmount: o} = c.reduce(n || [], ( (e, t) => (null === t.usdBalance || (e.sortAmount += t.usdBalance,
            t.isHidden || (e.usdAmount += t.usdBalance)),
            e)), {
                usdAmount: 0,
                sortAmount: 0
            });
            e[a].push({
                wallet: r,
                usdAmount: s,
                sortAmount: o,
                holdings: n
            })
        }
        )),
        e) : e
    }
    ), {
        [Pd.ETH_MAINNET]: [],
        [Pd.BASE]: [],
        [Pd.BSC]: [],
        [Pd.SOLANA]: []
    });
    return {
        [Pd.ETH_MAINNET]: r.ETH_MAINNET.sort(( (e, t) => (t.sortAmount || -1) - (e.sortAmount || -1))),
        [Pd.BASE]: r.BASE.sort(( (e, t) => (t.sortAmount || -1) - (e.sortAmount || -1))),
        [Pd.BSC]: r.BSC.sort(( (e, t) => (t.sortAmount || -1) - (e.sortAmount || -1))),
        [Pd.SOLANA]: r.SOLANA.sort(( (e, t) => (t.sortAmount || -1) - (e.sortAmount || -1)))
    }
}
  , d$e = e => c.reduce(e, ( (e, t) => (t.walletType === pc.SOL && e[Pd.SOLANA].push({
    wallet: t
}),
t.walletType === pc.ETH && (e[Pd.ETH_MAINNET].push({
    wallet: t
}),
e[Pd.BASE].push({
    wallet: t
}),
e[Pd.BSC].push({
    wallet: t
})),
e)), {
    [Pd.ETH_MAINNET]: [],
    [Pd.BASE]: [],
    [Pd.BSC]: [],
    [Pd.SOLANA]: []
})
  , u$e = y.memo(( () => {
    const {t: e} = we()
      , t = bw()
      , [n,r] = y.useState(!1)
      , a = y.useCallback(( () => {
        r((e => !e))
    }
    ), [])
      , [s,o] = Mx("padreV2-walletsPageShowNativeValues", !1)
      , l = y.useCallback(( () => {
        o((e => !e))
    }
    ), [o])
      , i = pK()
      , [c,d] = Mx("padreV2-walletsPageMode", i$e)
      , {updateAirdropWallet: u} = rf()
      , {withdrawalWallets: p, openAddWalletModal: h} = zHe()
      , m = y.useCallback(( (e, t) => {
        d(t)
    }
    ), [d])
      , [g,x] = y.useState(!1)
      , b = y.useCallback(( () => {
        x((e => !e))
    }
    ), [])
      , [f,C] = y.useState(!1)
      , A = y.useCallback((async e => {
        if (!f)
            try {
                C(!0),
                await u(e),
                x(!1)
            } catch (fNe) {} finally {
                C(!1)
            }
    }
    ), [f, u])
      , {state: w, wallets: j, hiddenWallets: T, credentialIds: I} = UD((e => e))
      , {portfolioData: E} = zce()
      , {hiddenPairs: M} = SX()
      , {lastViewedChain: N, setLastViewedChain: P} = _H()
      , O = y.useMemo(( () => ED(N)), [N]);
    y.useEffect(( () => {
        O === pc.SOL && x(!1)
    }
    ), [O]);
    const L = y.useCallback(( () => {
        h(O)
    }
    ), [h, O])
      , {openCreateForm: R, openImportForm: D, isImportAvailablePerType: B} = nWe()
      , _ = y.useCallback(( () => {
        R(O)
    }
    ), [O, R])
      , U = y.useCallback(( () => {
        D(O)
    }
    ), [O, D])
      , W = y.useMemo(( () => ({
        onClick: _,
        disabled: w !== BD.READY,
        startIcon: v.jsx(XS, {
            color: "inherit"
        }),
        children: e("Create")
    })), [_, w, e])
      , H = y.useMemo(( () => ({
        onClick: U,
        disabled: w !== BD.READY || !B[O],
        startIcon: v.jsx(Pk, {
            color: "inherit"
        }),
        children: e("Import")
    })), [U, w, O, B, e])
      , z = y.useMemo(( () => ({
        onClick: L,
        disabled: w !== BD.READY || !p,
        startIcon: v.jsx(XS, {
            color: "inherit"
        }),
        sx: {
            px: 2
        },
        children: e("Add")
    })), [L, w, p, e])
      , [$,G,q] = y.useMemo(( () => {
        if (!j || !M)
            return [{
                [Pd.ETH_MAINNET]: null,
                [Pd.BASE]: null,
                [Pd.BSC]: null,
                [Pd.SOLANA]: null
            }, {
                [Pd.ETH_MAINNET]: null,
                [Pd.BASE]: null,
                [Pd.BSC]: null,
                [Pd.SOLANA]: null
            }, !0];
        const e = new Set(Object.keys(M));
        return [c$e(j, E, e), T ? d$e(T) : {
            [Pd.ETH_MAINNET]: null,
            [Pd.BASE]: null,
            [Pd.BSC]: null,
            [Pd.SOLANA]: null
        }, !1]
    }
    ), [j, M, E, T])
      , K = y.useMemo(( () => Object.keys($[N] || {}).length), [N, $])
      , Y = y.useMemo(( () => p ? p.filter((e => e.walletType === O)).length : null), [p, O])
      , X = y.useCallback(( () => {
        if (!QC)
            return;
        const e = $[N];
        (null == e ? void 0 : e.length) && (ZC(e.map((e => ng(e.wallet.publicAddress))).join("\n")),
        i({
            message: uu.clipboardWalletsSaved,
            type: "success"
        }, "clipboard-wallets-save-success"))
    }
    ), [N, i, $]);
    return v.jsx(vt, {
        sx: p$e,
        style: {
            paddingLeft: 0,
            paddingRight: 0
        },
        children: v.jsxs(S, {
            height: "100%",
            children: [v.jsxs(S, {
                width: "100%",
                direction: {
                    xs: "column",
                    sm: "row"
                },
                alignItems: {
                    sm: "center"
                },
                gap: {
                    xs: 2,
                    sm: 4
                },
                px: 2,
                mb: {
                    xs: 0,
                    md: .5
                },
                children: [v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 1,
                    width: "100%",
                    justifyContent: "space-between",
                    children: [v.jsx(pHe, {}), v.jsxs(S, {
                        direction: "row",
                        gap: 1.5,
                        alignItems: "center",
                        flexGrow: 1,
                        justifyContent: "flex-end",
                        children: [!t && v.jsx(S, {
                            mr: "auto",
                            width: "100%",
                            children: v.jsx(SUe, {
                                walletsData: $,
                                chain: N,
                                setChain: P
                            })
                        }), t && v.jsx(SUe, {
                            walletsData: $,
                            chain: N,
                            setChain: P,
                            minWidth: 300
                        })]
                    })]
                }), !t && v.jsxs(S, {
                    direction: "row",
                    alignItems: "center",
                    gap: 2,
                    children: [v.jsx(WR, {
                        label: e("Edit order"),
                        isChecked: n,
                        onClick: a
                    }), N === Pd.SOLANA && v.jsx(WR, {
                        label: e("Values in {{currency}}", {
                            currency: "SOL"
                        }),
                        isChecked: s,
                        onClick: l
                    })]
                }), !t && v.jsxs(ot, {
                    value: c,
                    onChange: m,
                    sx: h$e,
                    children: [v.jsx(lt, {
                        value: l$e.TRADING_WALLETS,
                        label: `${e("Trading Wallets")}${$[N] ? ` (${K})` : ""}`
                    }), v.jsx(lt, {
                        value: l$e.WITHDRAWAL_WALLETS,
                        label: `${e("Withdrawal Wallets")}${null !== Y ? ` (${Y})` : ""}`
                    })]
                })]
            }), t ? v.jsxs(S, {
                direction: "row",
                width: "100%",
                sx: b$e,
                children: [v.jsxs(S, {
                    flex: 1,
                    children: [v.jsxs(S, {
                        justifyContent: "space-between",
                        alignItems: "center",
                        direction: "row",
                        py: 2.75,
                        px: 2,
                        sx: f$e,
                        children: [v.jsxs(S, {
                            mb: -2,
                            children: [v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 1.5,
                                children: [v.jsx(k, {
                                    variant: "h1",
                                    color: "text.main",
                                    children: e("Trading Wallets")
                                }), v.jsxs(S, {
                                    direction: "row",
                                    alignItems: "center",
                                    gap: .5,
                                    children: [v.jsx(Khe, {
                                        label: K.toString(),
                                        grayOut: !0
                                    }), QC && v.jsx(GC, {
                                        title: e("Copy all wallet addresses"),
                                        children: v.jsx(F, {
                                            sx: m$e,
                                            onClick: X,
                                            children: v.jsx(gk, {})
                                        })
                                    })]
                                })]
                            }), v.jsxs(S, {
                                direction: "row",
                                alignItems: "center",
                                gap: 2,
                                children: [v.jsx(WR, {
                                    label: e("Edit order"),
                                    isChecked: n,
                                    onClick: a
                                }), N === Pd.SOLANA && v.jsx(WR, {
                                    label: e("Values in {{currency}}", {
                                        currency: "SOL"
                                    }),
                                    isChecked: s,
                                    onClick: l
                                })]
                            })]
                        }), t && v.jsxs(S, {
                            direction: "row",
                            gap: 1.5,
                            children: [v.jsx(V, {
                                ...W,
                                sx: g$e
                            }), v.jsx(V, {
                                ...H,
                                sx: g$e
                            })]
                        })]
                    }), v.jsx(S, {
                        className: "padre-no-scroll",
                        width: "100%",
                        height: "100%",
                        sx: v$e,
                        children: v.jsx(Hze, {
                            walletsData: $[N],
                            archivedWalletsData: G[N],
                            isLoading: q,
                            chain: N,
                            credentialIds: I,
                            editCustomOrder: n,
                            showValuesInNative: s
                        })
                    })]
                }), v.jsx(Ee, {
                    orientation: "vertical",
                    flexItem: !0
                }), v.jsx(s$e, {
                    walletType: O,
                    selectAirdropWalletMode: g && O !== pc.SOL,
                    toggleSelectAirdropWalletMode: b,
                    assignAirdropWallet: A,
                    assigningAirdropWallet: f
                })]
            }) : v.jsx(S, {
                sx: x$e,
                className: "padre-no-scroll",
                height: "100%",
                children: c === l$e.TRADING_WALLETS ? v.jsx(Hze, {
                    walletsData: $[N],
                    archivedWalletsData: G[N],
                    isLoading: q,
                    chain: N,
                    credentialIds: I,
                    editCustomOrder: n,
                    showValuesInNative: s
                }) : v.jsx(a$e, {
                    walletType: O,
                    selectAirdropWalletMode: g && O !== pc.SOL,
                    assignAirdropWallet: A,
                    assigningAirdropWallet: f
                })
            }), !t && v.jsxs(v.Fragment, {
                children: [v.jsx(Ee, {
                    sx: {
                        mx: -2
                    }
                }), v.jsx(S, {
                    direction: "row",
                    gap: 1.5,
                    py: .5,
                    px: .75,
                    children: c === l$e.TRADING_WALLETS ? v.jsxs(v.Fragment, {
                        children: [v.jsx(V, {
                            fullWidth: !0,
                            size: "large",
                            ...W
                        }), v.jsx(V, {
                            fullWidth: !0,
                            size: "large",
                            ...H
                        })]
                    }) : v.jsx(v.Fragment, {
                        children: v.jsx(V, {
                            fullWidth: !0,
                            size: "large",
                            ...z
                        })
                    })
                })]
            })]
        })
    })
}
))
  , p$e = {
    flexGrow: 1,
    pt: {
        xs: 1.5,
        md: 1.25
    },
    overflow: "hidden"
}
  , h$e = e => ({
    minWidth: 320,
    borderBottom: `1px solid ${e.palette.background.borderMain}`,
    mb: 1,
    mx: -2,
    "& .MuiTabs-scrollButtons": {
        width: 24
    }
})
  , m$e = {
    p: .75
}
  , g$e = {
    px: 2,
    borderRadius: "24px",
    fontWeight: 600
}
  , x$e = {
    flex: {
        xs: "1 1 1px",
        md: "initial"
    },
    overflowY: "auto",
    overflowX: "hidden"
}
  , b$e = e => ({
    height: "calc(100% - 58px)",
    mt: 1,
    borderTop: `1px solid ${e.palette.background.borderMain}`
})
  , f$e = e => ({
    borderBottom: `1px solid ${e.palette.background.borderMain}`
})
  , v$e = {
    overflowY: "auto",
    overflowX: "hidden"
}
  , S$e = () => v.jsx(Bke, {
    children: v.jsx(HHe, {
        children: v.jsx(u$e, {})
    })
})
  , y$e = y.memo(( () => {
    const {history: e} = fz()
      , t = pT()
      , n = me()
      , [r] = xe()
      , a = YT()
      , {user: s, loading: o} = VK();
    return y.useEffect(( () => {
        o || a.isContextLoading || (s && a.apiStamper ? e.length ? t({
            marketId: e[0].marketId,
            keepSearchParams: !0,
            tradePageOrigin: null
        }) : t({
            marketId: `${eg(Pd.ETH_MAINNET)}-0x3b8f9be1c9d951e2caf224e8a698b61b64db0796`,
            keepSearchParams: !0,
            tradePageOrigin: null
        }) : n({
            pathname: `${tT.SIGN_IN}`,
            search: r.toString()
        }))
    }
    ), [t, e, o, s, n, r, a.isContextLoading, a.apiStamper]),
    v.jsx(Km, {})
}
));
var k$e = (e => (e.CHAIN = "chain",
e.MARKET_ADDRESS = "marketAddress",
e.REF_CODE = "refCode",
e))(k$e || {});
const C$e = y.memo(( () => {
    const {history: e} = fz()
      , t = me()
      , [n] = xe()
      , r = Cbe(Nn()[k$e.REF_CODE])
      , {user: a, loading: s} = VK();
    return y.useEffect(( () => {
        if (s)
            return;
        if (a)
            return;
        if (!r)
            return;
        const e = new URLSearchParams(n);
        e.append(Sbe, r),
        t({
            pathname: `${tT.SIGN_IN}`,
            search: e.toString()
        })
    }
    ), [e, s, a, t, n, r]),
    !r || a ? v.jsx(y$e, {}) : v.jsx(Km, {})
}
))
  , A$e = v.jsx(y$e, {})
  , w$e = [{
    index: !0,
    element: A$e
}, {
    path: `${tT.RK}/:${k$e.REF_CODE}`,
    element: v.jsx(C$e, {}),
    hideBottomBar: !0,
    hideHeader: !0
}, {
    path: tT.TRADE,
    element: v.jsx(uve, {}),
    children: [{
        index: !0,
        element: v.jsx(k_e, {})
    }, {
        path: `${tT.TRADE}/:${k$e.CHAIN}/:${k$e.MARKET_ADDRESS}`,
        element: v.jsx(y_e, {})
    }],
    requiresAccountReady: !0
}, {
    path: tT.SIGN_IN,
    element: v.jsx(AWe, {
        children: v.jsx(xK, {
            children: v.jsx(kWe, {})
        })
    }),
    hideBottomBar: !0,
    hideHeader: !0
}, {
    path: tT.TRENDING,
    element: v.jsx(iHe, {}),
    requiresAccountReady: !0
}, {
    path: tT.PORTFOLIO,
    element: v.jsx(w_e, {}),
    requiresAccountReady: !0
}, {
    path: tT.WALLETS,
    element: v.jsx(S$e, {}),
    requiresAccountReady: !0
}, {
    path: tT.TRENCHES,
    element: v.jsx(kVe, {}),
    requiresAccountReady: !0
}, {
    path: tT.TRACKER,
    element: v.jsx(RFe, {})
}, {
    path: tT.REWARDS,
    element: v.jsx(I_e, {}),
    requiresAccountReady: !0
}, {
    path: "*",
    element: A$e
}]
  , j$e = fr([{
    path: tT.HOME,
    element: v.jsx(Rbe, {}),
    children: w$e.map((e => e)),
    errorElement: v.jsx(pve, {})
}])
  , T$e = y.memo(( ({path: e}) => {
    const t = me();
    return y.useEffect(( () => {
        t(e)
    }
    ), [e, t]),
    null
}
))
  , I$e = ({children: e}) => {
    const t = xw()
      , [n,r] = y.useState(null)
      , [a,s] = Mx("padreV2-desktopSnacksAnchor", Ihe)
      , [o,l] = Mx("padreV2-mobileSnacksBelowHeader", !0)
      , i = y.useCallback(( () => {
        l((e => !e))
    }
    ), [l])
      , [c,d] = Mx("padreV2-mobileSnacksBelowTokenInfo", !1)
      , u = y.useCallback(( () => {
        d((e => !e))
    }
    ), [d])
      , p = y.useMemo(( () => ({
        containerAnchorOriginTopCenter: (n && n.startsWith(tT.TRADE) && c ? "padre-mobileSnackbarTokenInfoOffset" : o ? "padre-mobileSnackbarHeaderOffset" : "padre-mobileSnackbarDefaultOffset") + " padre-snackFixMobileAlignCenter"
    })), [o, c, n])
      , h = y.useMemo(( () => ({
        desktopAnchor: a,
        setDesktopAnchor: s,
        mobileBelowHeader: o,
        toggleMobileBelowHeader: i,
        mobileBelowTokenInfo: c,
        toggleMobileBelowTokenInfo: u,
        setCurrentPathname: r
    })), [a, o, c, s, i, u, r]);
    return v.jsx(Mhe.Provider, {
        value: h,
        children: v.jsx(vr, {
            maxSnack: 5,
            disableWindowBlurListener: !0,
            anchorOrigin: t ? a : Ehe,
            ...t ? {} : {
                classes: p
            },
            transitionDuration: 50,
            dense: !0,
            children: e
        })
    })
}
  , E$e = async (e, t) => {
    const n = FT(e.credentialIds, !0, e.apiStamper);
    return await n.stampCreateApiKeys({
        type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
        organizationId: e.subOrgId,
        timestampMs: String(+(await kg())),
        parameters: {
            userId: e.turnkeyUserId,
            apiKeys: [{
                apiKeyName: "End User Key",
                publicKey: t.publicKey,
                curveType: "API_KEY_CURVE_P256"
            }]
        }
    })
}
  , M$e = y.memo(( ({children: e}) => {
    const t = Ax()
      , {apiStamper: n, injectVelvetBundle: r, isContextLoading: a, _passwordHash: s, _localStoragePassphrase: l, _velvetBundleVersion: i} = YT()
      , {credentialIds: c, ethEndUserId: d, ethSubOrgId: u, solSubOrgId: p, solEndUserId: h} = UD((e => e))
      , m = y.useCallback((async () => {
        if (!t || !s || !l || !n || !u || !p || !d || !h || a)
            return;
        const [e,i] = await Promise.all([GT(), Em.getVelvetBundles(t)])
          , m = i.bundles.find((e => "2" === e.version));
        if (m)
            return void r(m);
        const g = ( ({uid: e, passwordHash: t, localStoragePassphrase: n}, r) => {
            const a = () => {
                const a = {
                    uid: e,
                    publicKey: r.publicKey,
                    encryptedPrivateKey: VT(r.privateKey, t),
                    localStoragePassphrase: n,
                    version: "2"
                };
                return HT(a, t) ? a : null
            }
            ;
            for (let s = 0; s < 100; s++) {
                const e = a();
                if (e)
                    return e
            }
            return o(new Error("Failed to generate velvet bundle after 100")),
            null
        }
        )({
            uid: t,
            passwordHash: s,
            localStoragePassphrase: l
        }, e);
        try {
            if (!g)
                throw new Error("Failed to create velvet bundle");
            const a = {
                bundle: g,
                ethRequest: await E$e({
                    credentialIds: c,
                    apiStamper: n,
                    subOrgId: u,
                    turnkeyUserId: d
                }, e),
                solRequest: await E$e({
                    credentialIds: c,
                    apiStamper: n,
                    subOrgId: p,
                    turnkeyUserId: h
                }, e)
            };
            np.info("[Velvet] createAndEnableVelvetBundle called", {
                uid: t
            });
            const s = await Em.createAndEnableVelvetBundle(t, a);
            r(s.bundle)
        } catch (fNe) {
            o(new PT(fNe), {
                extra: {
                    name: "VelvetContextProvider.migrateToNewVelvetBundle"
                }
            })
        }
    }
    ), [t, s, l, r, n, d, u, h, p, c, a])
      , g = y.useRef(!1);
    return y.useEffect(( () => {
        n && !a && (async () => {
            try {
                i || g.current || (g.current = !0,
                await m())
            } catch (W$e) {
                o(new PT(W$e)),
                await Hu(1e4)
            } finally {
                g.current = !1
            }
        }
        )()
    }
    ), [n, a, i, m]),
    v.jsx(v.Fragment, {
        children: e
    })
}
))
  , N$e = () => {
    const e = [];
    setInterval(( () => {
        if ("visible" !== document.visibilityState)
            return;
        const t = performance.now();
        nm.ping().then(( () => {
            (t => {
                if (e.push(t),
                e.length < 5)
                    return;
                const n = Math.min(...e)
                  , r = Math.max(...e)
                  , a = e.reduce(( (e, t) => e + t), 0) / e.length;
                e.sort();
                const s = e.slice(1, -1)
                  , o = s.reduce(( (e, t) => e + t), 0) / s.length;
                np.info("Ping", {
                    min: n,
                    max: r,
                    mean: a,
                    tMean: o
                }),
                e.length = 0
            }
            )(performance.now() - t)
        }
        )).catch(( () => {}
        ))
    }
    ), 1e4)
}
  , P$e = [];
let O$e = performance.now();
const L$e = () => {
    setInterval(( () => {
        if ("visible" !== document.visibilityState)
            return;
        const e = performance.now()
          , t = e - O$e;
        O$e = e;
        const n = t - 20;
        n < 5 || n > 5e3 || P$e.push(n)
    }
    ), 20),
    setInterval(( () => {
        if (!P$e.length)
            return;
        let e = 0
          , t = 0;
        for (const n of P$e)
            e += n,
            n > t && (t = n);
        np.info("Event loop delay", {
            avgDelay: e / P$e.length,
            maxDelay: t,
            count: P$e.length,
            url: window.location.href
        }),
        P$e.length = 0
    }
    ), 1e4)
}
  , R$e = []
  , D$e = () => {
    let e = performance.now()
      , t = 0;
    const n = () => {
        const r = performance.now();
        t++;
        const a = r - e;
        if (a >= 1e3 && "visible" === document.visibilityState) {
            const n = 1e3 * t / a;
            R$e.push(n),
            t = 0,
            e = r
        }
        requestAnimationFrame(n)
    }
    ;
    requestAnimationFrame(n)
}
  , B$e = () => {
    setInterval(( () => {
        if (!R$e.length)
            return;
        let e = 1 / 0
          , t = -1 / 0
          , n = 0;
        for (const r of R$e)
            n += r,
            r < e && (e = r),
            r > t && (t = r);
        np.info("FPS metrics", {
            minFps: e,
            maxFps: t,
            avgFps: n / R$e.length,
            count: R$e.length,
            url: window.location.href
        }),
        R$e.length = 0
    }
    ), 1e4)
}
;
globalThis.Buffer = Sr.Buffer,
N$e(),
L$e(),
D$e(),
B$e();
const _$e = y.memo(( () => {
    y.useEffect(( () => {
        ( () => {
            if (window.location.search && new URLSearchParams(window.location.search).forEach(( (e, t) => {
                t === Sbe && e && localStorage.setItem(kbe, Cbe(e))
            }
            )),
            window.location.pathname && window.location.pathname.includes("/rk")) {
                const e = window.location.pathname.split("/");
                if (2 === e.length && "rk" === e[0] && e[1])
                    localStorage.setItem(kbe, Cbe(e[1]))
            }
        }
        )()
    }
    ), []);
    const {colorSkin: e, customStyleConfig: t, customStyleConfig2: n, font: r} = y.useContext(Wb)
      , a = y.useMemo(( () => rX(e, t, n, r)), [e, t, n, r])
      , s = y.useMemo(( () => ({
        ...oY(a)
    })), [a]);
    return v.jsxs(xr, {
        theme: a,
        children: [v.jsx(yr, {}), v.jsx(tr, {
            styles: s
        }), v.jsx(I$e, {
            children: v.jsx(pf, {
                children: v.jsx(WK, {
                    children: v.jsx(KT, {
                        children: v.jsx(n_, {
                            children: v.jsx(dX, {
                                children: v.jsx(_D, {
                                    children: v.jsx(fX, {
                                        children: v.jsx(ZK, {
                                            children: v.jsx(tWe, {
                                                children: v.jsx(bz, {
                                                    children: v.jsx(u$, {
                                                        children: v.jsx(Xb, {
                                                            children: v.jsx(nQ, {
                                                                children: v.jsx(sX, {
                                                                    children: v.jsx(eQ, {
                                                                        children: v.jsx(fA, {
                                                                            children: v.jsx(BX, {
                                                                                children: v.jsx(iX, {
                                                                                    children: v.jsx(jX, {
                                                                                        children: v.jsx(MX, {
                                                                                            children: v.jsx(BH, {
                                                                                                children: v.jsx(lH, {
                                                                                                    children: v.jsx(PD, {
                                                                                                        children: v.jsx(WV, {
                                                                                                            children: v.jsx(LA, {
                                                                                                                children: v.jsx(Q3, {
                                                                                                                    children: v.jsx(FX, {
                                                                                                                        children: v.jsx(M$e, {
                                                                                                                            children: v.jsx(kr, {
                                                                                                                                router: j$e
                                                                                                                            })
                                                                                                                        })
                                                                                                                    })
                                                                                                                })
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })]
    })
}
))
  , U$e = y.memo(( () => v.jsx(Fb, {
    children: v.jsx(_$e, {})
})));
Cr.registerModules([Ar]),
wr({
    theme: "legacy"
}),
jr({
    dsn: "https://73523c7d9410a6f0ae12f18ac89a8e4c@sentry2.padre.gg/4507265060241408",
    enabled: !0,
    environment: Du.NODE_ENV,
    release: Du.SENTRY_RELEASE_HASH,
    enableTracing: !1,
    tracesSampleRate: 0,
    profilesSampleRate: 0,
    replaysSessionSampleRate: 0,
    replaysOnErrorSampleRate: 0
}),
Tr.createRoot(document.getElementById("root")).render(v.jsx(E.StrictMode, {
    children: v.jsx(U$e, {})
}));
export {ox as $, kf as A, xu as B, RZ as C, GC as D, uZ as E, xk as F, pc as G, sk as H, nk as I, ak as J, dk as K, Km as L, URe as M, OI as N, _Re as O, E4 as P, ng as Q, P4 as R, gS as S, UR as T, pK as U, SX as V, zce as W, UD as X, Mx as Y, JC as Z, rge as _, yf as a, Gw as a$, nDe as a0, WRe as a1, mSe as a2, rf as a3, VV as a4, $Re as a5, qh as a6, Gh as a7, FRe as a8, uu as a9, yge as aA, wAe as aB, bge as aC, xge as aD, uge as aE, pge as aF, hge as aG, mge as aH, sge as aI, gge as aJ, vge as aK, fge as aL, WD as aM, mE as aN, Ax as aO, tc as aP, km as aQ, yx as aR, sB as aS, Jd as aT, tU as aU, AA as aV, tE as aW, gy as aX, Sw as aY, _R as aZ, jR as a_, dge as aa, ST as ab, bg as ac, oZ as ad, gU as ae, Ode as af, YA as ag, sc as ah, wRe as ai, r_ as aj, qRe as ak, UAe as al, u4 as am, R4 as an, YRe as ao, eDe as ap, l_ as aq, sm as ar, pu as as, rDe as at, BD as au, pHe as av, fu as aw, GRe as ax, yQ as ay, Sge as az, Fw as b, Hh as b$, kx as b0, vy as b1, by as b2, cA as b3, VK as b4, tT as b5, XS as b6, lK as b7, NI as b8, Jv as b9, qw as bA, rX as bB, y3 as bC, Vb as bD, rg as bE, Db as bF, Bb as bG, rx as bH, ax as bI, QC as bJ, ZC as bK, WR as bL, IH as bM, ku as bN, wb as bO, hb as bP, gb as bQ, cb as bR, ub as bS, vb as bT, Cb as bU, bb as bV, yb as bW, NX as bX, LR as bY, RR as bZ, pZ as b_, my as ba, _k as bb, Gwe as bc, Uu as bd, fy as be, UA as bf, xw as bg, Lv as bh, $C as bi, _S as bj, xme as bk, sH as bl, Xh as bm, pb as bn, mb as bo, ib as bp, db as bq, fb as br, kb as bs, xb as bt, Sb as bu, Ab as bv, lx as bw, Lb as bx, Ob as by, kS as bz, q9 as c, DR as c0, BR as c1, _X as c2, bu as c3, zI as c4, QS as c5, US as c6, wS as c7, Wx as c8, Fx as c9, Bx as cA, EB as cB, yH as cC, Od as cD, Ld as cE, rk as cF, Bd as cG, xc as cH, zh as cI, y$ as cJ, Yh as cK, Ox as cL, mM as cM, Gb as cN, _x as cO, z6 as cP, nLe as cQ, l6 as cR, Kh as ca, ay as cb, sy as cc, Mk as cd, ny as ce, MS as cf, Nhe as cg, $V as ch, Aue as ci, Vh as cj, Xce as ck, NA as cl, QR as cm, XR as cn, Ux as co, S$ as cp, Vx as cq, Hx as cr, zx as cs, $x as ct, Fh as cu, ou as cv, ID as cw, wD as cx, xUe as cy, _H as cz, Ud as d, yI as e, age as f, Cu as g, Sz as h, ru as i, b_ as j, IE as k, LI as l, Pd as m, Nu as n, KRe as o, jI as p, dx as q, RRe as r, DRe as s, iu as t, bw as u, BRe as v, L4 as w, Oc as x, oA as y, wae as z};
//# sourceMappingURL=index-YEwmvHSQ.js.map

          